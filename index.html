<body>
</body>
<head>
<script>
    var $textures$=
[
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAgACAYAAAAbs3KBAAAAAXNSR0IArs4c6QAAIABJREFUeF7tXWeAFUW2rjKAKEEZmCEIQ5YsoCJKUsBAXlBxF8Q1LGbX9EwIuxgAw1PUVRQEA4gBFFdUdA2sYkBRBEGJEgZkYIABGRB0VPq979Scmuq+1VUXrsO43K0/3VX11Tnf+c6p7puvzL+2cnBIViWB9kvedjpu2SxFlaoBncvto+uqs6IGEADcEgAbvy7Qk7AibS5MNwSI+jVdymWDMjQHJmaSJgsmKYCsAF5tmqcwmQNWJaWDGaZVqAQA68DmmQPLrTmY5Ew+v5EO0djRZzexOgBE2TTrIVoLWknWHgNJ6cDJ0wUTJRnSwUx3tB40B9OkyQekrVJbdYjy0Mn6bXSIMx+Kwiza2LJPTQdzyye4sBVMqGjNFdFtaN3+oQsIbz3TTegSxOlOSgdYqda8YohzwsYx6yG0/Z06mDVovYD8NjrEuQld5aJa6Ko2pd03HcyNY+6J0O6OXsT07cC82mPQvEZYLyB85ddXGNulOHQ7sG3/0OY17xfReiChogDzfmG9gMTqwCFyFPq++dvoEL01m2727r6Zmg6x982dIgg9PCgvih8akJL7ASCECHHYGe4So5IG3P7H04MK5Q+jOt2x88eES6Z84C99QhyiID/A6wKAqGOTk4wCeFJv3r0GYGXIxTVntAsyq6jL76YtBWLrzt2icvlympYcOUiRXLomTzSuk0Wg0O5mAA8ygC1JuEDHXG26IUBUB5NTCMCWeAF4ycHtjw1M1rxaC2W6YN8hF5c+0zs4rEIZ8eOOwoRaoH1xzfSzNEkbSHotAGC1XTRIFqIAk1MCAJPcwGnvLUTdyWWfPekmCUCFqhl64Y7N+eF6yF31aoIFEyRtgFBFJQUwTZp8KFm2KEyQP8xnpr3h1gGAalmVifjGvK2JF5A4ABZhgUzKhbNg2IXp3+RkdeEFhHLxwgsvBLM//FjUqZMt1qzJSTjKK668OohOdurYXvAiee99/xtgpTloWrJaYItYpC2YgyYnshBnHosSLEQthTjYLMnczZvd9ZAmgGEDT3TrAED1apXEho3qxQmco3FfJgVwln1SHGy+mRdxSAoQx0N2apzp1gGAzMqHi01bd5ERnKNxnyx4AU4dkuJg881udRRRcgmAWB3O7XuGWwcAsrOPFjk535ERnKNxXyYFcOqQFAebb+ZFHJICxOpwgq8eAKhepYLYsGWH2hdVKqh9UdSXSQGcOiTFweabeRGHpACxOuTlfuquBwb07nVRyMhrrz9JfZk0YN85tG3TlEiyT7bEnKQX4A1zcPcstw42QGZ19WRs04ZASADMgWi4yQGiqxJceAFeDs6afGXMOW4dUgdMuKVHSbvwkvRymPP6CDfJ1AHTx15Z0i68JL0cpl/Y2k0ydcCjPRuVtAsvSS+HKcMGuEmmDhhzsefWnLoLrwUvh6GDjnfrkDrgwq7HlLQLL0kvh37HV3eTTB3QsaF62y72vpm6C68FLwdcafPzfhAZWUdonmZf7hWAV5rHkIUSBDB9WzTEwQnAlXbD2s2ieu2qWgezL/cKwCvNY8hCCQKYvi0a4uAE4Er7Xd5OcXRWea2D2Zd7BeCV5jFkoQQBTN8WDXFwAnClzV+/VWTUVC85oZl9uVcAXmkeQxZKEGBjz9EQBycAV9r8/F0iI0M9naaVRl/uFYBXmseQhRIE2NhzNMTBCcCVdsv2n0SVSmW1DmZf7hWAV5rHkIUSBDB9WzTEwQl4+IEHNGDrVvUybOXKao+gL03A6tWrRaVKlfwALSmekI4YNizYvl29mlW3bl09x+4IwKPsG312pzlghReAlewO5yAccmGS4/NQmE7AURnqtftt+ZHX7VmoKID7sS68gBDJOP8AkYs4/yBs5WAu8AuFZNVv2NCmkVi5YoWS+j8CYA2haFDO/fh9qsnmrVqFcF8vWEB9Aqz6dhV1+pzdn44zXppOx3oN6gm564fvA3MAE+YCAmCQTbIfdpkcwOnCS9IbJpOMEys2TGiAcK0AtqYBUQ2cAFYxwQUGTJlDAK8LVtK6/UfcdY/7wT8AmVXVhXPTZsv7WTYL5gKZlAtn0e4HDpOefc6tAwBzPptHPLOyMumYl7eJznGUNgBHpQGr1qyzRmoFYJDdhVyY/hMATheXX32DJ91/ODXIrpllJZmzPk/Ip678I1mo2qSl2LxkYQJQA6IzvCAEgEk002VygDj/sGblYC6QI3xhvjf6KrdQAHz42Tch9ogGkZBQNgBrogFrv9sSLzUsmABTrJALVs8KcLqADs6tZ77nzm+t8zvm6Ifetd/w9TJRPquK8AJMl/Se+848pUP15sfoOXYXelPefLee3WkOWOEFwD67wzkI+9/3L9j1erA5J4fIVc3OTiz7lUseDSkZBUkvwOsCgKhjk5OMAniSF+09ACtDLsyHzWz2ycnP0ulFg89Tj8TMAUxw/9QO7cMADPBDZzwqps3LLnjAfGwdAtj8E6BV6zYkFAhF/cOaBtj8EwAc4vxbOWCwT2f1JGDGB6uVBXPABDz09KwwAAOp6xB1J9fMe4V0AKGofwqTATb/+67DJZ2eIHfjZw9RYZoDmOD+rc90CwMwkLoOUXfyxy+akA4gFPVPYTLA5n/fdXj6nZ/J3QWnHarCNAcwwf3ODb4LAzCQug5Rd7JNd/VgD4Si/ilMBtj877sOU89fT+4GTKqpwjQHMMH9E24vDAMwkLoOUXeywxb1KAiEov4pTAbY/O+7Di9f2J7cnfXUxypMcwAT3G/zt2fDAAykrkPUney87TPSAYSi/ilMBtj8J6dDRkbxV37IR6TJNAEs/mqu+4EWAI2aNLdpJJYv+VrI/xiANYSiQbljagO3DgCUP2cF4X/NPy5kbPesAkEWAIhOAqkB5bqEvznCZlIDHJwxT+yc1lBxiLrAJJoGOHWoN2i6WwcAqtdXzzOjbcPK/3+++R8DcOpwxMeez4EAMOj4E61GpnzxmZAMQMdsWJQAYEuY2DeA04WNpebg1KGwsJDqIW+Levk1q4p6OZb7cl3uBgJEJ7gvDwwLv4xUX1PduWUbxV++ylFqVxX15ffXHUmA6AT35YFh4fMe71GY23arr1UcVU5d0Lgv3z5VPbaPTnBfHhgW2s/OpTB/2aLeaDmkStF3nIv68sTpSwgQneC+PDAsBItOoTB/+l69gFj2yFp05L788cP6BIhOcF8eGBZGza1FYW7Yop5bVa+inspwX149sxoBohPclweGhT1PvKuuk/nqhbPyGVXUdbKoLwvufkFdJyMT3JcHhoXufdXXr3buUB+fLl9BfXya+7JjF/U9tegE9+WBYWH8ePXy4/YCdd+sVFHdN7kv7/vfuwgQneC+PDAsVB83Xt0vtv5A8R9SWX1ejPuy6ugx6n4RmeC+PDAs3N3iTQpza6G6b1Yuo+6b3Jc3HaOuD9EJ7ssDw8LJ3dT7eoUFOyn+MhXV58W4L49vqwomOsF9eWBYGN6vOYVZsFPdNyuWV/dN7strTlOfho1OcF8eGBb+fHMdCnPHjl8o/goVDqEj92X/K44mQHSC+/LAsPDP5g0pzM0/Kh2qHqZ04L58ooF6Ihad4L48MCzUylavR/2wUz1+OKK8evzAfVk5Q31hJzrBfXlgWBg7uCuFGddkmgAWvvqMW4c0AUw6y/NlmTQBPHqu53MgaQK49qp73fsiTQBvj/S8f5EmgEtvPMFdD2kCmNSnr1uHNAGc3NSzL9IEMPrKi9z1kCaAcwYOdOuQJoCbTvd8nzdNAN3bD3LXQ5oAerdRb9PEPs9KE0DP/o3dOqQJ4IGOx7p1SBNAg6qV3DqkCeDEkzu5dUgTwPDhni+qpAmg3BHq4y6x94s0AbQ49kG3DmkCuLCDev8ith7SBFD15tFuHdIE0PBez++qpQngz1M9v5OTJoAXWz3l3hdpAsi5MPLj4ZELpkwTwOIh6uMusfeLNAEMqTPRrUOaAMbUDf8NULQuZJoAFixWHxuO3RdpAug+yPO6fZoACv5Z9EdZMQUh0wSQ2aQ87YtKNQ4T23OL//+C+5IBcSACxK3GItmwa5XAZpqV1y5Kk0ObEeoXj8vklROFWbt1VXBfMiAORIC41aRDu8uzA5tprcPvgQNIglDuvF9EjePUZ8TMPkURHTT7BIhbTTrUblszsJnWOvweOLR4rAKFufWjQlG5Q/Hfa3BfMiAORIC41aRDzUFlA5tprcPvgcPDXQ4N2jSqKL5cXiBwRONzHCUA/c6sJl55a6PAEY3PcSTAFa/cRhMbxk2kY/VLL6bj2H4jkwTslQs2H3IBC9EJ8NIcnGE+81Kt4N2cg0W37F8Fjmh8jqP8L4D0kIPvrxPgBM0UivsklL6sWE7IAsv7+Gz1sf7LOh2hrfkBSbnwknSm+5Pc9e4oADipeg0hpQz/s9b//67apEVfBRKAk2vUTJhEuKUNCIIgmPz1QiFBxJmsrBqe1ycB2Lh+tVUH/L+XBCAvd41Vh9IGQAfkL+GfyKKayCGj5nueb46aH4y/tZVVhzNuWByQhSeGtrbqUNoA6HDm/ywREkSc9TD+Js/7/gAMuedZqw73DukeSAAuuXeKVYfSBkCH+y7pISSIOHXIfuhZP2DNXwdZdcBr2RIWcq45z6pDaQOgQ+YtdwvpfdV9wMDBbh0AeHHKJKsOZ/buH0gApj432apDaQOgQ/c+ZwkJIs56eO3Nd/yAXmd2s+ow/unnAwkLvbufZtWhtAHQ4YlnXhASRJw6XD7c8343AGPv+MCqw4ArmgcSgMfunG3VobQB0OHcK1sICSJOHUa/U+AH3NKtglWHIdN2BhIWbj2tolWH0gZAh0te+kFIEHHq8O7ax/2ArrUuterw7Mq/BhIWutW+zKpDaQOgw5RV1wgJIk4dPuiuvr8Z1yQAnWaeadUB7/EQoPOb3a06lDYAOkxt/bSQ3nejCh7zXEgBqHDZy1Yddt3RNJAAVLx8ulWH0gZAh913NhMSRJzpLpiovu8fWw8AVLioq1WH7SOmBhKAihd3s+pQ2gDoUHD7NCFBxBnm3zon/ououUACcPv7fezXyToTAwLc8UFf+3WylAF0naz7pJDed6Nmtkv8b9yQDgB0nzPHqgPe45EA9Pj0U6sOpQ2ADg/Wqyf870b9sGuXu2AAOLxcOasOm/O3BhKAIw4/3KpDaQOgw5at24QEEee++HGx5/MwAJRtcotVh8K5gwIJwGFNb7XqUNoA6PDz5+cJCSJOHcaNGzfZC2jRosWHAC1atCiK7ShhAQDLJMAKIIQgC5aWAqBFixbgZLeAySLSGhB/O2h3dFm3UABMH96VLPS/8z06mn3JAEx++OrdBOjY9xYCYYwAGORJJgMQWnIANhfrwkvSme6kdGhTW/1IyJdr1auLZp+iwAAmzQke02HyJPNha8kBvC68JJ06uCYpWWkCmDRqeJA/d3b8xvltAM5cjPlD59DezGjbSZicZOoAROHkcN3VVwfRH9Y2F8jfBuDkEP0tcfzgtskp4V9d9h6AKJwcOtauExx1uPptHFuTqQOaV/V8tKBP4/B3QLbt2i5MTjJ1gJfDje2O00LlFf1WTlbRb+WgL03Asg1bxJFHHCa8gFBFnd/0mOD7H9RHCo6prn6uDI3dSQB4kE2jz+40B6zwArCS3eEchEMurOn++cdt7oJJE0D++mVuHQComGH/fdqC/E1CMgAds2GRBvAEWzLBZMELYHOxLrwkvddJLyDuQorrlb6Q8t8JsDUsSgCYP/K9bwCTbIIFWySaQ9Jh5uz+SGOzy3Wgcx0mT/IEI5O7oTg52O4XB1VTvy1PHG4Y2T9gv+CxZ2NNuqEwJ31D4QEGhEgmrQMDzdtSQpgJ96ykbqx7rYNZOPrfK6LVpMM0/2KDiyR05/XeN83/hbFeSP8LUDW5aNY/3BdSCJW/Zi2hM+rUpqPZp3+38QI4B1EgcTBzYQUkRdJZk6Pm73klKcCtraQYvSBREgkLcZMURdIu4njsuwXm5beQUd7++YfMCkeremAAD2za8Z3gcw0wB0wAzsmCuToarnZhTpgLEixE3ckm1TvoDEX9E0kGYNK6/ee8UCdY++1PonaDssJ2lF7AS71aujeO14IXsB9cfPlpl2Dpl+o3ehu3KX7Qqy/Fz40NhwmQuUB6AV4XAESTFHIRtcCTmmRSAKcLvILnvD7QW8ard1kxQ+oeLiQDGmepX67ktjTvZ5EAqFHuIJrP3b1H7BvA6cLGUnNwhjl2SPHvJp0zuJeYNvn1EF6aAJ65bPTDdPr4rX8VBDAHMOEFmD6sLhgATgmAqDu5Z8scyiYIRf3T9SEKiGoi1+QEwVtfLBdnHt9I2I5+QOHPnooCoHGjemLp8lUCRzQ+x1EmBXBmM/UoYMHrokYNIZ6csVxc1KcRYfk8N1cILZTNCtQlgNeCF4AkpebCGWbLlscGGzZsENWrVxe2o6xaNTOIm8S4PDAs9O3Z010PALRu3doq5vz584VkADofz5lDwPYnnSSwKAR4ZOzYkJWrrriiGHD2gAFWFy9NnapcAICO6YLHNOC6664LWRkzZgwtIoCzHpICJKWDzU1IBycgKR1sFkJCOQH/ETrsB6mdOvylcwt3wQDQ8w+NxTcLN4pmLdX3Dvj8jX8uFRKAOvWOtHpZs+p7BYAFW9MWvICkXDhJ7kcdTKHgtgR0cLrYdx0aTvvAXQ8ALD+7E4l5yvdzQ6LmvvujkAyITgKpATW6HWZNR2qA949sKxq9NFtxiLrAJJoGOOvhuJbqd7zjmgTg+i7q0XC0PTBrjyAAT9w+agyd/n1o8XU7OQteF6kDvGF6AV4OqVvwukgd4CXpBaTO4fdgwRmm7X+KzQX0GumSxYtFk6ZNBY5ofI6jfq0Yk1k11R+F5q1fTyA0bQGT/762Bw2e+uBMDUoOgFVeF16Ssdu/38PN3NcHAG49rY94cfmrCUZW5UghAahX/B3PEMgJOLdRXzH6nRkpWICvBBcwa5LVAGc9DOsTE0LRKglAn3sGirn3J76OuXHTbkGAapnlrF6cgLY39BMzbn4uBQvwmeACZk2yGuDUobBgnbseUgdsXrOopF14SXo5fDXc88f3qQNmX1P8IqotJzJ1F14LXg4T+vzNnazUAWNOv7akXXhJejmcM+FlN8nUAaeP8PwUT+ouvBa8HFbM7OfWIXXAnOfPLGkXXpJeDuNf9vwvbeqAeyd4XgNJ3YXXgpfDR0PV/8rFPsBIHfDGtXeXtAsvSS+H/n08RZs64LRTPfeL1F14LXg5jPuH539AUgeMHHGzux5Sd+G14OVw6bRpbpKpAwZPmFDSLrwkvRwevc6jQ+qAuwZ7dEjdhdeCl8M55/seP6QM6Nnbo8PvgcMd53seV6cOuPEPJ7n3ReouvBa8HC69sb1n86YMGHBJm5J24Y3Cy2Hamd3cJFMHTOjUsaRdeEl6OTRp5PndxdQBVSp7fio8dRdeC14OSb2Pc3THvuKQ9R+IX2p2psedfP7dh68m+T4OLNiatuAFeN/H8ZJ0PmxOSgfmYOoAq/ptGgB4kt1BLA3whukFeF14STp12POt+n+cn+u/IA5d+Uc6nvr6tyJvcb5YfNOJQgLAkwxseu9nNEkvw/4U7Al4pekKYwQwXcA02r97NdDuyAKvNAFwk9U0Q8iTX1seMCEGYhKNAPXvmROAEPts+LJ6/yREEgNmiMwDlogD+zPJ6SiYJMfOE6xNKMyoDgCFhIrqQEKZYZoAtqYBZmg410KZJDGx4iz1fhL8U5gslC0PxMEL8LrgKGJJesM0K8oqlFlRsVKzMGZd6GQlne7YgvGWnLdovWWf1Mbxbj3n5vVu/59G1Apq1R8l1h30CClda89VYt15g0T9OZ+q3Z05eTJtXhPw+azBOi3ypyknEmDju5+Jatm1xMacdfrYfsgnQgPEilwh/p4jNl5U/G7pCV0mF7tgs9We3CPEcycJLKh/+otqZ2GVNt9NXZtq7R4iyuC9pKM/+ST4+ImTNSkAax39d5osXLy4GABChStXijL16xMYk+vKPaEAGFh5UjtR69kpYT1WDhWh3zMHa1MPEoo5RDWoVkSWlDSVozBvzxaiYQ0lNSysfPtcNTBwjhYK7jSAGSdI/uQeITMnTAg45nXf3U654KZzwapR/EVaQLzkAF4XiMJJ0htmUkKBcazU5o/PxybLmW7OprNgnCXnLVreWfFlX7SzYjeOd+v5N69v+6+8bHmwKXedyKxRS2T13k7FtGhcAfUxLhnQ4tKK4o3bviZAz5HNRd5rlYoBWInJOvXqEmDNqtUEgiW5843PA15pAtgSAbiKv5movkLe7GL1lXLaFyYHExDiALYg6QVou3hD2oyCJ1gHTGoOc/q8p0myFhwikTSjwEBULAIwOZMDi5UcwFxpuiCpIZQZBQCcLCIZjYLTHQrTrAWe4JogCwwwpU4e4E23t2DAgXMQLTkkLUQyKhLIawAXDcLkWtAAjh2uEoRiqbn0TZm11NFNYyZP7wuOwJxE+fsB4MD+eTeFXHC6bQWrd5az7PEwqczkWaLB/erZwLc3vCBaPjRQTOqSLc5+e7V6wIkJBgEA8Eunq0tBCHDwQYeLeV9dQxN4PNu0VaaQvf+1Mli8YJMoN+XThEmMyybNRwamSX7qgNXkAgCcLFh0K5kl80WTBOCHaq1ajA6RwyRFAQ5gDACa6Y4s2AAgpzdO1IU5CW1CJLHquGMfEr/uUV/YgDsdJlbyEx+A6t7XR4XJHDhEBjFpHSZCYv8AoX/4IQcV64ABbqY7shCdhJLQhoQyH/RiAOlm6UNKsnkGITc6CtM3zkFSR4EwabBIXg6TLVFFgVRUqN2D2oUrylQRUhcO7qI4cBRsEvojEg1gqc+flSMWXvNcqPwB0rlgqc1yg1jaBZc5h6z3xbnvrQ52/bKHpDWLVgPMquYNw2JpqTGw+sYZCRsH0RBJTpC59bTUcMEx86bBAp0s3t3mZCjde5Z2DGSVC3Q1BVueFuhvm3WtmPlFZyGDLRODHR+pX7RBq9DhboF++caNxc6lS4sBPIEjN7IWZ4EXyCiHKfe+Igbd1I+M4FxbMF1ggpvcOrVCcGTLVsScGwB9Tv5MzPjkRCGfvalXgA6zxiC3Hsd/oAA4OarLg4I1CEWB/7/g1czD1CQhCohkEqZ/0DAHoqoSBzNuPocb4gQA+8RkggsOE+FFV3+/cIEgoZBWblFN/ACvi6RIOsP0ChUtGKvUzmR50+0tGG/JcdnHFm3SZR/denrj2FwktfX05vVuf+Tiqp/U7/ub7efdgXiu1yghz3+xGtVkr1N6J4DOObidAmDy9fdfE8c0Kv784Ndf7Sq2AMCK3HfF1Tk7adMMfH0oTSKz2gIAQ2sNEyPWDBMj6txFk//ILh8GsFlYaH7s4aJhjW5C/unprKBf9z7ilTdnaLNYiUlYpSsM02ezPAlOBIDJQ8sl/lLUI2V/VYBpv6oXZcyGsNG0BZDitmz5bhIOIH19MGNnkgQYOb9uwAKxBqPW3UVREGBq3pAA4dg00BbMsFhq1oY4mMKwO32l9QJA0ukiKZLOMPn6ECsUJytW6qST5Uy3s2C8Jcf7Ii5he1f2zo3j3HrOzevd/m+9qd7377CntggWrxayqXrasP7dearsAcAkBmp2O44GGYgxepbEkzyBI61uWlfIHfdNDdis6ULXJCxEV/JqGjcB5t5kt3LZdY8HIGf65cmPDlorCICV0QgwSa6SAjhdeEl6w0xKKKfU3mQlle69qoeo5KF6MJPFGdb1wCtDqUbBRF/JMYsmVA/RldZ6MCsaCSyBerC64HTHkvSGyfXgFMrclyy3ljpaDwnJ8tZD25PUhxMu/csFYtyEp8nDUZlVRZVa2WLFvC+EPKNv/6B/jzPE9Jn/Ets2baZJNAAo9HHjxgWYRAOAG4DokwVGd2ndXMya/zWZ1gDm0PC44wUAaMwFvOSgq64jklgFENqWdTliQJ+eYuqMNxQAA8w6ainEAVYuvuA8MfHpZ4s5mCSZnBm21QVcAgRLsSRBFkSlK0yt5OxFSym8WKEgCGKOSk0WEAV8sYIJyWIOmACQZYZglG4AODEskik5AcABjTMJAMuvOYAkp91MnJw4cWJgpte0RFGYHDiTcMVpDwHMcsM58qFzAVJcl4iKM0oWmDUraW4BDQBztKjsVhesC9UkcmHbEyy7M8xOLRoXFwz7TxAKSsIXmlVqhIksYn+ae0Mni6U2Sz2U7i8WLAwemTRFnHRMPTFn2SpyxedXnT9IyAuuV5+GRQetxxfqu6w9Fq+go4QFnMz7TH3X/7gTT6Lz4QcfLO789ddiC2wFkwDBEqzQu3KcZgzAFYPAjS5BvIJ9gyS7Ig5Rs7CC1UQSLmYe31YTYzcAUJhegNeFl6Q3TJY6VqikpXYmy5lurgdWb2bThpRFlj9UD7AEACsLkE4W8oGKAgCNQWQhmmIGUbIAiJrlTBIAUnN5cQ1w6WkL5NPwjb6uB2/ZewGcrFgXSZF0hukVikvOKTVXkzVZ3nTjArK6U0/RZulcMfL2EeK2v48QXzZuS/35vXuojROsUD8whUFMcqs7+43inXXF5VcKWELDxNjHHhXdn59ZfAGxAeCOrrSmWTbPnGTVm4u/wQHTaHD15p96EGG6FLNvzQ6V1LCKAHmKovVrM3VoCJWvdHUmPqMAODG1CAGiJOEbDSFSTZokWQMmikh0mIjAJKvDRLJgLgpg6UO5iLrQl0HeixAGYTJJ4hCXbrhcc/GfFQAnppVQPSBMltWUmvlQmPDLkbAGDKaLOZdZ1IIWChZsBaOlhv42AJKWUA9m4YK8tR6Yk67qaD2EAFwPXAcsNxeNrgezYLUG4GAre049rFqFYkBCRUVlDtVktFh1RcWlW9fDPW3eCqrXayzuXdpf52pwmVFicuFQ0XbHJUJOOntNsGHVUgEQGoAMwFE2b94muKnxdAEQrzomow6Bl+WvKQZgJYA4wjQagGQBHQzOrTBjQQ6aAAAGWUlEQVSeJkIAkGR2MMkrtdxsAYRMAM7JxUXZjwc44YFoXRIAvjk0BnBkEhwQHgMwgcbaaBccN1tjdckCk8Mka8HHBEBUEwI4dWAXHCoLBeJUMKYF0xIvSA7AKppSW11YkxXVwRqmUyjOplNqb7Kc6fYWjLfkvMnylj3vLOfGcW497+b1bv/6tbtSyZU7spfY/b36rUE+/+XPQ4XMHv5ecMgzo0IAE6QBQJuNFxEAExVeXRgC7OjbUgAUAmCQwXwumSRcsBVM8rls3nJMwOyZB0zrCwgsmGFFiZILJyApFzAbS9LUgdmzBrR5kwIgrKiLkNTcYfXM5GklESr7DqUbOsRlEgprCxwqjiw1LFEuMGgmyBmmNd1miJwsXQ+cCxtRKlozm7zaW9XmFkgoe+bDVWYtGNQjAMTBJGkWLScwoarNmqB6iJZ9AsArNVuITZY33fMeGhbM/HCmqFuvhli9Klf06NhDnJlbXrxVYycd5Z1nq5u7CViyfoG4oWJPMbPC+vCb8gCylaGzFov5LTuGLZgAdivBARMYiLrCGD1UGxN8JJrUbEUABoJsjx01BVnASavP3xEdDl1DUaAhgr+unKoscEiwBJIP1x9AkziGAABGNdEu7i94g3iYAMomXOBR36guTfWkeRmiTy+wOLya9SALkBrMo6Y5Gk3SjB8rkY/rZAdlAeEgAhbqo5/riAUnnKaSBZKI+ZFWQ8RVC56grF5ftqt4s0q+SjcDWBwAYDpUD04XWXc9FsCXk6QzTK9QmcPHBK0XfhgvNdeDM1kckjXdXDDdt2SIB356jwqGRaOCSark4oqWpPaWvbn1rBvH/KhJdOvhSaF/83q3//3P/ynoeuzfxK0je4vRt71Gx269TqDqwrhcsHgJbV4GPPBcZ1Elu6LYklMgjm3WVcjugxoQ4M4bp4vh9/UXVesWEGDJ+2p3hCxgoMkpgiZxJAAsYBUam968uqIGSpBcv/NzArBZXg0eBPjqm/cEr+J9CTAsE4f3vrpDvPv659osu6QoGICVALEWOGKhdsEErx/4gdZER8HhgRS4sCYEuP4JJRTHzpHAhbbA4rCKsIQGa/L8YZkB/Nt0qFn+BAWI04DCZKHYJLtDyindXoDXhZck0u0MMymhnFJzFLHJ8qbbWzDekvMWrbfsza0Xu3GS3noos4TN693+/2zZKFhVUMgbio71KpYRtWvVFmvXrRWSARjkhgWnNGugqvqBOuofE3gA5+9/820xABbYHCZxDgA3csGA6BGuCMArcQQxE0iX4nUTp2qTmOQWnN5OWah18QAh3y7+hBOsYAwLNcC0At8cdsgFmw9F8WXPboFJjAljjKIwAdEoNIAnouFqHczQTP8gSiQRInyimYmiZJk68GpOnE43ixJVkYRiFywvu0KfFI7qwFYYSAVjllg05bqiuKp4pa5JuIiWGfcpTBMQLVwSyiw5W/lrgGkWQqGaSAd2wQB2A5K65EzT5v4gqU0dbGm3CmUWTgLALDnwSFDSdEPJ4p1lljpnksJs3bpdcNl29T2DxytlisLCn8Q338ynfuvW7YQcV69egAmAcJw//1Mxrp76tf5LV61SAF4NEAZDALgAgC0wCGMAymbNWgfsk1dy+cElPtEYmCb5HJNUDzYAT4IwhYkT9mlOUpgmoFmz1qJMmbJEmCNLcIFVZkSxHNgKCQVxTA5sgaIwc8Hx8wJwIgAryfqHpIYOIMYgay6gQxSk0806xAKScuEk6Q3TK1RcurXUUUBCsrzp9haMt+S8Reste+/G8W497+b1bv9XbusfrF+fz+UoatbMEGZfmgBMojEA/d8YAPNWDlG/Zp84pAaY+JdqQZPmR4klX28TtqPcjwCdjMiJ5pAaIG41XaM+ebBJEKcBxvcXII6k5pAaANl06vBfgLrz/l7qobRr0vw9809XqxcE2tVVXzlBP/Rfye/PnyZaZncVlStXdgMwu3z7x0rqgVefGvz4vfp/3lNan6PLk90RoFGl9jTBpnHO7jSHrVu3+gFYuTBH/fE8GgjLEcOGBUwIg+wOYziXz1c92r1xGNCihrpXcFuUq24yZCE6aYL2FwA+nSRD9COd/a0D1Hvgtkzx1FO/EhP0tVA8yRwBCgF4hdXCftIhTs2QkpwPLhZdMEwSE1GQtoAJXmmeJ+8iKZI20P8BHyGgq/ibluEAAAAASUVORK5CYII=",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAgACAYAAAAbs3KBAAAAAXNSR0IArs4c6QAAIABJREFUeF7tnXmcFcW596skIrtswyLLDMOAQEBBUBFRBEkEFQm4oPG9F4kaRcXI9YqaiIC7JErUgAJR1ESNG2pMAlE0LhgBRTFyQRZhBtmHzWEVhb7v7+l56lR1V1f1LByHz03/011V32et6j6nq6vPkQ8/+GAgItt554+mmj+/PElIAHoFGrj80G+uNwFUtGnThqRXr15Ne9KgVzDAVhXAFVFzsrAoIA1wKGof2hRgs08AfGCHovbJye7HtYvlQU8LAS+/vjyaKyqfP6i9qeHDhSF4Svf2SiCdBq+JigPWEEorKzkPNlP/l/JQ8c7KggbneHjs5WXu8wLAVUPDYV60xtQ1++PlQjIQbQSqgAE9MieKrqNiQG5rIabOLPUhagKN2BTgzMP6K+oHDQpqiOufrE/chN4baT9ubjPay733NQu4kQFuJODKDh1UJh++bIfSxLAC0Lh95T6lmk1J+KDbRIPuEwG6zagZwwdIR2EFRMNjn+SVfZu7xwOAjdW3iWb7G6qE5jQ+UhRv+TZMFGtIgtKZcHYWm9DtQoBNkomkRsPJJDNy/arX3Hn4/O1H3IBXQxaAijv50fUFKszd2/ZTvmo3rE57lKUObFi1S9SrX90P6GmX7/y/1kHJjlB18/w6qo3NEcC1bBtlNqd8gIQXgCSbwzEcNkzYxoQR5r+B5LNTvnFJK/d5oQ+Y7cXfkKoGOUcplZRqbogaAmj0RaIGlrQCZXKyfN2dBRN6Jr8vJ2+d9Yzq7m2bN5EbDZs0pT3KUge+XLxINGjS3A8Y14ernnow2L55A9W17dxVtbE5CYBr2TbKbE75AAkvAEk2R2OzSXNhmLCm+uyHxrmHPYDm7TqLDSsWC+zpAlZ6jL1MDbAkXS81TUqDF6iYD8knvxDy1Duupjzs3LBD1G0efpfSj/3AcSMvdmfysDCBT95GeaVfQS0Zk5UDOPsi+gVja+EaofsU+5JTdsD7BWPBB+8EnbtmTlrd4cWLFgm5Z/cO1d2owKYLKACN3KAfE8AVugauSwfArtMEe2510humC4BmWTmAczzoqY6GSz5UHEAUTh9GjrrRDzRt2kRs2rRZYI+Nj7GXugYdYLMERBv0cjqA1TlNpHLS+nmhO3kIAWdfjL/rfqMv9GhoPFQc8Hb3jGvDq33Ruk0it0X4vUE/ll5g/E/6ukeUV4MXyJIJjt86HuBDxQHneOA8MKT3A42HigPeTK4vLg6eXNso0U9ZOYAzD/d8etAYUZe13Cp0n2TFAUTh9KHXDScQsHH5FtGsfWPFclkykAQRkCRNvZl/duvAplpdSKuCD+3ObEx5+Hr9PnH0MTVUHrgsGUiCCEiSpjw06VgnsKlWeagKPlw883TKQ+GyIpF3bK7KA5clA0kQAUnSlIee9+YGNtUqD1XBh0sv7Ow+cWxAowY1KYit2/cKCUCviJ6G6YCoVMyEF/D64Lw+LJk60J2HigNzf93vUJvwOun1IdUcCM8kIqP6/CANe312kVOuQ/65QZsGvfNIg65S94d8sEWhQ/7pR0w36bNosVFdOYBzTEajwNRbbGZP11B2wDurNuHiHwd164SfEzt37RM7co4V9YuXKavywSvOo1H9Vc1c0WpvEUFGZzHAlQywJgkTKOjSuhkCoonSfTIA1sQC8EuOHjUq0L1maXUp1k2wbcPEx7fkkg8LN1QT3ZsfUO5wWU4dnh9wgw2S0JAkTYOWTbDuKKyA79MHb5heIFUeKidR5c+kt7tfmXSh+2J+WAC/v+VsdxRe4JeX9nBrOCyAEWce647CC8wc0c2t4bAAJp/T3h2FFxjSw/O8+7AATmvX0J0HL/DhX8a7NRwWwMwp13pGtQ945raL3BoOC2DS5We5o/AC3m/mhwXgvX3wAmX6Lsef34lf9gA4v8tlCdDN4Put/yvrVU8Nio2oGnWri307w4UbsswApHmDlpgGLwDpivkQu0uyRWHcHYy/7TaVh4YNM0ugsPj06KOPFtIL8HLZbdu2CauGMgFw7uuvv1Y+kg+6BiugO2m7pTOisAK2dcVGolIBDRqFM73bt26NWaEoygzoAlYNMSBquGwAMtm2XTtbjsSXK1aE4+GwAKwhlFb6xwPuWLHwGueBvkKc6+iWNjWg+2LV4ARskcAv5YMTcOYBUTiB6LDX80HXycMC8IbpBX46qm/Q/uhTKVf6Ve6dT18Ux+WeKaQXSLoMKg1lAuDHv4reUn1HPkSvkzEAJ+/yrz9QUhwR6nBM54UTsHX3Ec3WKY3W8WAAN949NMit2ZskivbOFQc3tqAzDMc0orwA+8ASrIGdUD4kAt7u9gLRR8nRkyj2rNkKNMkJP3E3F2+Lf17AhBeIiukCVh+8gPGp5w3z6T8+G6wq/EoJ4Zk7Nl7yIFMBH85faCyOiGnwAroPegS0xCLqQwzwPtZPBWRhkQZ7Xv5VHKnXotg+FozFKlag4kssqoKGVN3t/NzkpUe8uophXvFlLAPTNRnAn1+aSW35Bfm0X7VyFe3Pu2BouLrJCWDxki4BSV2A1mh5AUhFV7xxVKTBCfBiNg6RzSEiHKvFbE4AXkdzYGjwAtF+0M3FfND7QznJmbMOe70vEoEsLeor/6o/79rFCi0LjC2PRKJ0Z1GuhDV7FV/159XgXRboBfSlR1iXhE1fDmWsTUoEcjoeJ4qX/st6JSINXiAqqgvE1kcBNgDXIi44Lb3AW/deF6xZu0W5oYdKGlIB78//H2O1HWdTafACug96Tqw+xADvMjAv4F2z5wW8JryA10QWAU7xIVizV/FVf14N3lR7gWXzn1A35nVzMusHNyxeJuo0bSykF+DV8juLtwqrhjIB6I9dmzLnKfmga7ACupPWj0UvoK/5x3J+bIlr/g8R4H0pwAtk4dXILJjwhukFKt/Jsr/ikYW3SLwmvInyAt53SL0Ar25K9ZJp+d5C1U3gxC37a6repWip3r7kS0/5Xq70mvAu4vICqVb9Wb/llVb6F9RlwYQ3TC9Q+U6WfUleFlb9eU14E+UFJv2kjzGx3+ik08XWBe+pMSQPC+Dpe8a6H094gYq/2lAVNHhfr/ACk+pP8qygKAUKGhcYF5qVW1ZSWUJDtJFJQNkCYNPppPM6+T3kYe2er0TLWq3IrVii0PjEmN9T4+2/mxAH0HDHdeOo0dCQpTwkZZO6mxu5P3iwqAHDTkZzYAVQiUQZQy6ViVROWm9AbrrYs/KQgdyc2oaCouLd4XkBINrIJKBsAbDpdNJ5XlRuHt5atFmc2TV82RVbYh4YLF+idDNKQ8XyMPpCz++qlQlo26wuxf/lxp0qF5I1oBENUSgGQJRhGnK6D04TieeFN4oRI0Z4VuSOGBE0btxYbNkSTgrgGBuXJTR4AeeYTOWDzTabJR9SAYmJeuD6y915qDgw6lzPC78VN+HV4PWhZN9mysMXG98VHZr1UfnismQgCSIgSZpG9YLCFwObaralTHyfPngzeVgA3u72AvuWDnCfFwwc1SHzC1joyW++2BV+bgKINnJXA8oWAJtOJ53XqO8hD0gOOxxLFCreayDJ5x81rU3pjmXyzU27qZH7g4As5SHxSqtnUg9Pnf66k9EcqBHFUfAwgyZjyLE6p4lUTtogedNNN6nzwvbRaAALFy4Uubm5xmenFdBN0YdaUVER1XXv3l21GZ+8XMsfyyizOWUCEl4AkmwOx3BYfbAmJuraazNvLljzoANLly4ltbVq1SKFEJA2gM3t2bNHyGHDhgXFxcVU17FjR+UKGhXAKnkPCuZycnIyJkB7gWgeSAN8cF4fdICdNXpTB1auXEmLrqEaGwQME1EAZdmvX78gumQa0lxHgG6T1SsTAHSbOqBMcCUqCgoykwQK0G0iCt0nOWhQZr39+vXrKUwAxxxzDLlmBdBQu3Z4nVIApHmDFjYru3fvrsJktWyKNHAedLu6NtKgq2QzMSd37w5v/nRNMSejIRLQv39/5eTGjRtFvXr1RElJCe0xBBWAMYmGZs2a0WjmjQBu5EqGICA7d878pAAasMEUQ7JXr14BbHElA8oENLBDgHhTTkIDV7ImblRhspMcIvtCwOmnh7//sHfvXrFr1y5Rp074NYGPrQAalZMnnngiadAroUVp6Nixo3ISPmBDgtiU1DXogGGC1UXNUBS6Cd12zZrhDzSQCVt4Cnj30ZvdF5D/I8Ca07q68wCg9ovTKK27L/y5Ggeqs1IBMTGtQqbyIapB98mqwQvoGuXnn8x15+GDOa8aQL2GmR/ToSEXBaIOx0yUbMs81icNVcGHYIIItr7dzdpfjfp9KuSWPt0CHGA72OoH4oivvlMwBBWwY0UPQ0v9dh+LGFCvX/hLfSVvdxUG0GD451SJDZAVgG34ENOgR1GtVTUCoB6b4YPuIYdNYYp/BEG3OWYHMfxp/8ZCdvtVcYADbEc2PiC+3RKawQZBBfT4wlxj/nGHhnHgs97hB+rxc78WBrD44gZUiQ2QFYBt+BDToEdRreURBEB9zEk9Dxw2hflwvyODE9rXE58sLxHYY+Nj7AkYMqCZeGX2RoE9Nj7G/vABKhbmVxNbBYgXm54HLlMe9DRHjyU0cPZGTAzvL2aMWai0+YFUJrxOenuzYomCk++vDH/k/cHrwscz//W78E2G0wqODAeMF/A6CYDVcqphzhiTTsAZZsneF4Nq6y4UB1q8KLDHxsfYy38DlA+5e6UIcIBNTxSXKVHO8wIaOL3LF95ObPvudyhtZMIJpDLhddLZ3d/t3xMsX7pYtO/YWWBPTpYeYy//DVA+5JLPFgQ4wKYnisuUKOd4gAZO76y//oXYgeecq7SRCSeQyoTXSWd3//+//IAP4YRgeIxNlfnA2qjITj3DGYQl894mAb0sB172X9Q468kHqTFaJiCpEW3KhyQzid5zNABioemhyrNuXBIsm/ekOP9nd4rFS76kts6d2oqXnxgrju15mZB5p44JCj+YKG98/JvggcuPIpN8jDZq4PGgA1xHJv7+QCc9o2r8oM0PeE14nfSGedvQzCSJbXRLAHfNXCgnXjkwGDN9FkXDx6PPOjYgoF6jJoIbWQugDWtWCaXBpl5pgAknkMpEopOw4zx5c26+NxjUuxcxTwzqQ7787PV3Sej1uf8UEoVog172A14TXiALPlz00/8IXnj2D5L3iH/AoKHB7NdnUp1qSAVwykt27haGBm6AqUQTbBcAzKkzi20D4Mp6dWsLdlw5GdWQHpj25HNBQX74O6T9Tu9FTr793j/J3MpVRUIC+PlllxgNDKKNANZw4Jvq9FcB1Y7av6N8GsrvA0+YXnrheeTsMy/+maLAnKURBTcwSFGMHBvOyyVt1pNWhw1g9b/aBG2OW23UqQI3RiGDhj+P3vke1X3w447BqW8slVRYMaN20G7EbuUwIIYJuOiazsELUxarStQpAI3OMF9aHAQrNoSrNm79UT3SeO+bJSTUrnldIVGINuhlBUDTBZ1Dp/kYwkolS7E/rNkPMJlowuukN0w4NfbDk4M+LUaI5Xv/QT62r9lXvLtuhrjzlPlSorF5wzyq7N/6anJ6zprHAsAbthUKOWVZ+IjEBqBegmZJaEMlVLMmP+A14XXSG+Z9J08ITml4EsX/4bYFtNfL8t2Bs4K8044Vz732B3HL/HHkPYQuGfwfovD9ZYIASHIjdzdrljiINuoQAVyhm+C6dD44nWRn4KgeHo5RJ18afFTw4wHniG1ffCCalP7azeatW0XDDqeKN2b/VciSR8NrNIC8hzZRHgp/0TQAQN2NAg64kb3nernnjk5BrduXWK80aPMDXhNeJ71h7l+4Ktj13PviBx1bGNeR75auE3UuOU1IAGip3j3fiITrZcnjc4J6l/e3hom2SgJqdM23+rBv0SpBJpwAewta3yBEvXl7H8//yoGaNmJ+8PMZJ8dCRb10NUKIpGDmjncHxzSgnnxIakQ9SQ1tcmcwc/PYmAbUS1cjhAgwEhApyElt2hDQr3t3cfxLL5GZzy64IHh74cIwUTqwbu1aJb9sU/jyrwSNhhYtWxoa1NmNg7/17BmcPW+eEQXXUaUTgAlWpzvJZpWTxzYN/7kCG/yxRmENMwjCv75N2iQDUkr7MQBuxB6ajLqNm7cETXMaCW5kU4A2FW8VEkCzJo2tZxba0gFOE2zLFiYJ7ltyrzsPAGp0utXq5P4FlwakAYAO8rEB2HwwABSqn/QMmeLjmAZUANBBw3bUDGlgqcTu9v4M7xV9O5Hd/rXDJw9zdmd+/I3OCwDNr2opfvjH8NsYgKLhZ9Bx7lPvCHnifz8bDOjxpALqDv1O/PaIEwnYsbh3VgDv7/SmzkNiJjlRVRqoCnnAeDh+4V3Jl6AsAFnKA86LDVMzHyZ6zOq8+D6BystDma4P1jzoF5BsA1UxD7hOvvKHcCETXWltF9JKBr6nPKT+vPB+oFQS4M3DFX26uL8/AMjLD/+QMroVrtohJAN1Ck432netfE8YgFfDIQYSL9T06V9peTjEUaTqC6cPWcpDqvEw/JbLyZ2n7nuc9tkcMM48pPoZ3qVLloiOnToJ7LHxMfbqxyHR2LRFePe+ad06gugyCBPc+MvbxlPlPXeNV1A6AFJeE14nk3Ihlw3zvJcE4PMVn4ou7boJ7LHxMfZKA0MA9GMCuKLt5FDDl9eG2pQGLxBVm2jC6WRiHvCz7dtKvhEN62X+cVsvyzIBLKnvDQ2HEOAQbdGQD04Arx0Vrlol8vLDiZnwpM2UZZkAltT3hoZDCNi852jIByew84WC4Nu88EyObkcWLhFy24Lw/5IOtAmvbNj2vJgv6vboS8cEoFGv1MtKA0uzJhYwgKgmZSJpRMcAqwZvmJfccUaw4tPMW6e6uXbd6grZY0j3AAfYWresJtaszfypEgQVsHlt+Iv4vDVpWV3EgB49wwXPH8/bKwzgzEH1qRIbICsA2/AhpkGP4uic8AyHemyGD7qDHDaFefeZPYOP9maWsOvgiTWbCfmTXnkBDrA1E7XFRpH5RgxBBaw9YGazZbW6Igb0qBZq+vjARmEAg2q2pUrKQ7VmdgC24UNMgx5F8+ohAPXYDB/08DhsCrPvoAeD79Z+bvQkF37QsouQp3UbEeAAW/WcRmJ/ceYn7CGogP1bwglL3qo3bipiQJ2O4Sm4a+kSYQC1up1BldgAWQHYhg8xDXoUB2uE75dDPTbDB91BDpvCPCn/OPf3agYa1DLf99++p/R9/9SANde4wnh9OKvzKeQk22RN7JP0Al4Tm955M/h683ZxdJMGyk+9LMsEsKS+NzQcQoDdt0VDPqQGbB1maCgfsPyFF9xDTneyfCa8Grw+fPNeETm5q7BY1MkLXz/Ty5KBJIiAJGkIya1PfxzYVLMpZeL79EF30uaHEYUV8OYhFaCPg6gZoy9s/ZE+k4mp9o6owwLwDnsvsPakX7tPXgZaHH+cce6u+yz8WV4JINrIJKBsAbDpdDLp80pFkQqonDwgMSfd+qlY97fhZNWaKB1KzCRDC+7tFqY6S3lI/PTXRxQniweLkWo0oiEKGVGwJMOxznKaSOWk9SNpYf+FwebS/3qIAk2aNhFyVpdZAQ6w1apZS+zZm3mHFYIK0F+sBIz3KGNAk5xQ0+bizSaQl5dHldgAWQHYhg8xDXoUtWqHAL8eavigh8hhU5gH1nQPtm9dJRo0yhfYY+Nj7OWWTxuoC0jj12g1oNgyODNvqzQ0eapEHKx/kIAjdhwhNg+vR5pIAyRRqQM4hiZ5xA3VAhRsAOqyAZQpD9YRVSYN+1tMJSXV112llBmptgJlMlE+J719IcZLGg+2zqKTFxqSzksCdA2LrgrfQ+k69Q41NvxAmUxEh5xy0jnkzrj/4CvOKBi4tasU9y6KRywBJDWSD6lNJPlRfg3sl19Dyas57t70AoVFnhU1APqdkS/efmeVwB4bH2MvUwHOzvI6mUVgW7fwas9bw0/DjwbJPgDQ81A+wGkicUR587BoyVL3ePACVWE8eJ3MIlC/dgejO3bs/iIcD+wDAH08lA/QbcQ0JI4Hbx54WWCiBi9QFcaD18ksAkPeMZeqvlJ6SVSLGwHo46F8gN5hMQ3l780r8x53Xx+8QFUYD14nswj86t2fGd1xd58nwusD+wBAHw/lA3QbMQ2J48GbhyVXen632QtUhfHgdTKLQK3bbjC6Y89dvw3HA/sAQB8P5QN0GzENiePBm4eiEepFV6sS6QWqwnjwOplFIBhvXnDl+HBNtsokAH08lA/QeyumIXE8ePPwfNcZ7s8LL1AVxoPXySwCJ792mdEd8wc/GY4H9gGAPh7KB+g2YhoSx4M3D8NfaO4eD16gKowHr5NZBCacnPm9QfTLuPmlv1jIPgDQx0P5AL3LYxoSx4M3D2PH3ugeD16gKowHr5NZBC6/4jdGdzz++/8Orw/sAwB9PJQP0G3ENCSOB28e2k2c5x4PXqAqjAevk1kE3hx2stEdP3p+fjge2AcA+ngoH6DbiGlIHA/tJs7L/CyehZIDLy1wjwcvUBXGg9fJLAKP3rPCSPTIX7YLxwP7AEAfD+UDdBsxDYnjYeClBe7xcHIvz+8/eIGqMB68TmYReP65d43uGHZJ+O8Jkn0AoI+H8gG6jZiGxPHgzQN+oyZJmqLwAlVhPHidzCLw0TW3GAk9ccp94XhgHwDo46F8gG4jpiFxPHjzMKJ3nns8eIGqMB68TmYRGPfMaqM7JlzaJhwP7AMAfTyUD9BtxDQkjgdvHroc/1v3ePACVWE8eJ3MIvD6n39hdMeg8x4KxwP7AEAfD+UDdBsxDYnjwZuHmrXru8eDF6gK48HrZBaBpUu2G93RsVO4YluyDwD08VA+QLcR05A4Hrx5wAPxum1/SAp2fvk/tNfLMvj8DBowaORH+7klfakMkACWrPeT8O8+Sl4NVygTABOQzMuVIvj8DJIEWFgUCDz7NwCWNADdBzbBmmI+sJO8rED54AwTD4I7FbQlr5esDH9/Ui/L/fv3Ux7QyI+0j2n+LZUBEsCSXTuFf3eyaMlSpYmed0MSedi/fz9JAkQe8MTaAFjSAHQf2ARrivnATvLDcAK8YeJBcJva4U+lr94d3ovoZflq5/AP+NDIj3IXndOeygAJYMnRq8PPzkltws9MAmACksjDq53bkSRA5AFPag2AJQ1A94FNsKaYD+wkPwRWPjjDxIO/tnXDmcQvd4YzjHpZ3tdlFuUBjfwI80/nzqYyQAJYcnph+LrulXnhS20EwAQkkYf7uswiSYDIA55QGgBLGoDuA5tgTTEf2El++Kl8cIaJB14dTgpfO/piQfh+kl6WB6fPoTygkR/dtX7jLSoDJIAlO00fHZ5hV05Smui5HiSRh4PT55AkQOQBT+YMgCUNQPeBTbCmmA/sJD/0I8AbJh70tCgIR/G6leGo1svyu7vDH5hCIz+yavnHfCoDJIAlc2eQAlE0ItwTABOQRB6+u7sNSQJEHvBEygBY0gB0H9gEa4r5wE7ywy7lgzNMPODIP6Y1eb1q/Rra62X50dlvUR7QyI9qike+TWWABLDksEVhAp7vGiaEAJiAJPLw0dlvkSRA5AFPYgyAJQ1A94FNsKaYD+wkP+RRPjjDxMT+sXnhdXJZYXid1MvyngXhr/SjkR9RPLupNZUBEsCST120gTQMf6G50iRhApLIwz0LWpEkQOQBTyAMgCUNQPeBTbCmmA/sJD/cIMAbJia0W7UKFzV+9VW4skcvy2nTJlMe0MhT82/8fQqVARLAknfe+QBpGDv2RqWJ5u0hiTxMmzaZJAEiD5h5NwCWNADdBzbBmmI+sJM8qU+AN0xMJjfpGZ4Xm+eF54Velqe+t57ygEaekr60aAOVARLAkivG9CQN7SbOU5povhqSyMOp760nSYDIA2acDYAlDUD3gU2wppgP7CRPZhPgDROTqE1ahufD5rXh+aGX5fCbwwkKNPJU7LgpbagMkACWnPVM+OfmAy8N/8+MAJiAJPIw/OY8kgSIPGCm1QBY0gB0H9gEa4r5wE7yJK7ywRkmJu4alv5N3LbSP8HTy3Lg4PMpD2jkKciR119AZYAEsOT8f75H8Z/cK/ytGAJgApLIw8DB55MkQOQBM4wGwJIGoPvAJlhTzAd2kicvlQ/OMDFh9YP88FXh71aFryzrZdl86jTKAxp56u2U2dOpDJAAliy+/1bSkHPzvUoTzctBEnloPnUaSQJEHjCzZgAsaQC6D2yCNcV8YCd50o4Ab5iYqGmZE/6H2tri8G/S9LIcOyT8xWM08pTT4zd0oTJAAlhyxtxC0jCid57SRPNRkEQexg7pTJIAkQfMKBkASxqA7gObYE0xH9hJnqwiwBsmJijqlr4stLP0vSC9LHv1fza83yzeLHiq5aeXP0dlgASw5OefhWvFuhwfrhEjACYgiTz06v8sSQJEHjCTYgAsaQC6D2yCNcV8YCd5kkb54AwTN+bRv+TWy7JVbvjgD/+1yVMMp53ejsoACeB/7ty7O3xxqWbt8MUlAmACkshDq9wCkgSIPGAGwQBY0gB0H9gEa4r5wE7y5ITywRmmd0E+T1DwFAPFVzq1gDr1WgHf3jPAAgrghuieAOfkQGofnCaSGlGvFsMnauA7d55iYBC39ahTGnjWggEWSG8CktY5kNQ+OKNw5iHVQnTcufMUA2vjOrWMnG/vGWABBSQ66Z0DYcDrg9OEMw/ehcc8QcFTDKwNd/OoU8un+faeARZQQKKT3jmQ1D44TTjz4F1wy3fuPMXA2nBbjzq1bJhnLRhgAQUkOumdHEjtg9OEMw/ehaY8QcFTDKwNd/OoU8tl+faeARbwr0z2zoGk9iExD94wvQsseYKCpxjYFO7mUaeWifLtPQMsoIBEJ71zIKl9cJpwjgfvwkK+c+cpBtaG23rU0a09KnnWggEWUECik97JgdQ+OE048+BdUMd37jzFwNpwW486tSyQZy0YYAEFJDrpnRxI7YPThDPFlujEAAAISklEQVQPqRbU4RaepxhYG9ep5XA8a8EACygg0Unv5AADXh+cJpx5SLWQDHfuPMWg8lBap5aB8e29ykPpbEa6JXnOyQGeJPH6kJgHb5jehUM8QcFTDGwKd/OoU8uf+PaeARZQQKKT3jmQ1D44TTjHg3fBDN+58xQDa8NtPerUsh+etWCABfwrrLyTA6l9SMyDN0zvQhG+c+cpBjaF23rUqeUuPGvBAAsoINFJ7+RAah+cJpzjwbtAgicoeIqBteFuHnVqmQff3jPAAgpIdNI7B5LaB6cJZx68CwN4goKnGFgb7uZRp5Y38O09AyyggEQnvXMgqX1wmnDmIdX8A2vY3vp3osGa6wTvUU+zB3rD1uL1olHOMQQaADfo+4K992Q0OAGoWlnzl6QaICRRVhoY0BvYcf8ciPdFeB1osO9fYnuN4wTvKUwAegNHA9AAbGEe0WpARoMTgKqDX81WeYAkykoDA3qDyoM3zFTzD6xu6Mv3iZnn3yJ4T2FCg97A0QA0AFuY7179cEaDE4CqPo9dr/IASZSVBgb0BpUHb5ip5h9Y3W0z64i7hu4SvKcwoUFv4GgAGoAtzEevqpfR4ASgauTUEpUHSKKsNDCgN6g8eMNMNf/A6mqPPEbsfnS94D2FCQ16A0cD0ABsYdZ4SdPgBKBq3wVC5QGSKCsNDOgNKg/eML035gYw6nkhHhkmBO/V67paA0dDoA7Ywmz0p9GlMxijnqfLH18G1V4BQoitF0/KAH8aHZZjgNag8uANM9X8A6vr+UQtMe9newTvKUxo0Bs4GoAGYAtzxc31MxqcAFS1u3+HygMkUVYaGNAbVB68Yaaaf2B1dxT8Vty+8gbBewoTGvQGjgagAdjCfOjriRkNTgCqfnH0GJUHSKKsNDCgN6g8eMNMNf/A6q4YcpL4/SsLBO8pTGjQGzgagAZgC/OVuWszGpwAVA3p3VLlAZIoKw0M6A0qD94wU80/sLo5/YtE/zm5gvcUJjToDRwNQAOwhTnss1MyGpwAVD1//IcqD5BEWWlgQG9QefCG6b0x14HHbrxbXP3ArwTvKUwAegNHA9AAbGH+6unJGQ1OAKru/s9rVR4gibLSwIDeoPLgDTPV/AOre+F314qLrpsseE9hQoPewNEANABbmCMnvJLR4ASg6tFxQ1QeIImy0sCA3qDy4A3Te2OuAx8Pyxc9nl8leE9hAtAbOBqABmAL86y392U0OAGo+nu/GioPkERZaWBAb1B58IaZav6B1Y1/+H4x/vqbBe8pTGjQGzgagAZgC/OROx/KaHACUDVq7C9UHiCJstLAgN6g8uANM9X8A6v7y4zm4twRGwTvKUxo0Bs4GoAGYAtz+BiZ0eAEoOqpiYHKAyRRVhoY0BtUHrxhppp/YHVfvD9VdDjtKsF7ChMa9AaOBqAB2MI8deiEjAYnAFUfzByn8gBJlJUGBvQGlQdvmG/Vrh+02B3+/0Z0W1e7ppBe4AtxVAAyqoXrZFUBEJ7uqH5cSWE6TSAPnOKfju0imnVrJh4c+qbKOiVKB3CsQwqIRvHAH3qTJn+qU/UmR6GPB+5dZcI2YABRJrmRpeCwGpMMoHFxzRqi89591MaQ0sAAGgHFADRYTfCQS3SSU607pmuTXz1xRbgcrjB8o4i3lqX/fUDAlRP+Yj1xpo87V8gPbx8cTHhqvnjkH58Y0Ki+J4hxw082ga1jrhM/rFNLbLx9orACG56/WMydU01cOP0ZO6DbUBq8TnrDbDBvdLB3ylxrmDWv6S1kjf88McABtmr5DcWBVdsUDEEF7H8j/N1N3qr/uIOIATWv7kXtex/7pzCAOr85jyqxAbICsA0fYhr0KKoVNCYA6gnUndQd5LApTH4FzJoIfBwYQL3wFX5Rknm1PwNwI6sqhUIg2qhBZTABKacPqQBLrGXMA5ux5oHVRxxNmYfUibKEGo8C2pxORnJRxjxUvC8SNaTKg3PIJfQDqssYpnfARNJsmrCEmAG8YXqBhCEfD9PpZML5rxI17el3xM+vGZPBdpXOouDsjjUytmuBkFNvCn+5EdLTpkw0taAvdMDmhgKijeyPAbAZNqnyACetGuAkX+V0iNRzmPyKaOJ1Ugc++ST8aDzhhBMUr1505UZuYYiAaKMOKQ2odJqoHMDaF2XKA/thzQOrj0aSLg+pE2XLhZHJVE5GcxHT4AQOYWelyoNzyCX1A504Ze5ubx70sWCYsCVJAd4wvUDSORELE5oSnfSe/tOnTxfXXHON4r799ls6pkxGG5kCJCdPDl/og/SUKVMMLaRBB6znJgPRRvZHadDN8LHhpE0DOcnjAZHwBvUqTH6FPDFROjD4/POJe+3llxWvXoTnRm5hiIBoow4pDah0mqgcwNoXZcoD+2HNA6uPRpIuD6kTZcuFkclUTkZzEdPgBA5hZ6XKg3PIJfUDnThl7m5vHvSxYJiwJUkB3jC9QNI5EQsTmhKd9J7+f1+2Qjww6lrFvfHGG3RMmYw2MgVIjjwy/D4J6RsfmWxoIQ06YD03GYg2sj9Kg26Gjw0nbRrISR4PiIQ3qFdh8k9MJCZKB84ZMoC4v74yW/HqhzK4kVsYIiDaqENKAyqdJioHsPZFmfLAfljzwOqjkaTLQ+pE2XJhZDKVk9FcxDQ4gUPYWany4BxySf1AJ06Zu9ubB30sGCZsSVKAN0wvkHROxMKEpkQnvaf/O5//Tdx308OKmz07vARQJqONTAGSA8Qouk5C+pZfX29oIQ06YD03GYg2sj9Kg26Gjw0nbRrISR4PiIQ3qFdh8k/QJCZKB2Sb8C+xgtWZv8pSP6TDjayJIQKijTqkNFBILhOVA9hC/V87nJkOLRe34wAAAABJRU5ErkJggg==",
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAARACAYAAADTSxKZAAAAAXNSR0IArs4c6QAAFDNJREFUeF7tXX+wVdV13lunTowOg1qMWBBBXshTaBQjUUjBGUhEHi0pBJIqqU2USmeMMzpjUZCESYSkcZKZptMRQfJjok7zXsEfBaMWiIBPCfgjVCMa5IeV+jBUZdCMKVM9nbXO/fZde5/96/DuFTPT84dv37O+861vfXuvfXn3nXPV769cX6jIoV2AHn66Kvb+1lziBVAUIAbQVb6DQHkAeTXYrBQuICrS1VKpIgpw8xPYYjh6QNIozuW46fUhqcE3H/V9kDZbPvjyG0CyzCRA+hDUAFAUEPVhxYoV6tpv3WIwxatv8JiNcoNAEUgvv2gOdxZdfefib1sszCABXg0AuEHoMQwyDcaWSB8Di0R3UyU4iN6U+b9Lh8f3Bwk4vnMak7y386Hm/gAAgogApAngBiWIATgRTUGg/gO8c1HLB+jw+hCqJM+HbKN8XlhOZol0vagwRAH9n4sgQ5YP0SWXvaL6vx5Ih1wL3JtuX3gByTKTgFBPWBp8a6ECiPqw8rG9av7Vf2Mw7+3exGMu0w2a7t69Sek7Pqu4u+nq5at+bLEwgwR4NQDgBqHHMMg0GFsifQxUiZksqgQH0Zsyt0/bEN8nJeBTU8cxyVMPbzNsGgAEEQGIAW5QggwDnYymaA3AOxe1fIAOrw+gdyvJ8yHbKJ8XlpNZIl0vKgxRQBsnK8uH6JILzQM3Tu3pTvog14KVwmeSASTLTAJCPVEpk5iCIn09YTGseeg+tez2ZQb31C+285iddIOmu3+xXelb1HW8w9DVC29aaLEwgwR4exMANwg9hkGmwdgS6WOgSsx6oEpwEL0pc9m2ofF9UgImXfR5Jtm0/X7DpgFAEBGAGOAGJcgw0MloitYAvHNRywfo8PoAereSPB+yjfJ5YTmZJdL1osIQBbRxsrJ8iC650Dxw49Se7qQPci1YKXwmGUCyzCQg1BOVMokpKNLXExbDlvteVTcvu9rgerc/ymN20g0CRSB9+S3lvyfp6u8sXGWxMIMEeHsTADcIPYZBpsHYEuljYJFYD1QJDqI3Za5Y8c/xfVICpk//cyZZu/bfDJsGAEFEAGKAG5Qgw0AnoylaA/DORS0foMPrA+jdSvJ8yDbK54XlZJZI14sKQxTQxsnK8iG65ELzwI1Te7qTPsi1YKXwmWQAyTKTgFBPVMokpqBIX09YDJs3b1aLFi0yuC1btvCYnXSDQBFIz537Rd5h6OqlS5daLMwgAd7eBMANQo9hkGkwtkT6GFgk1gNVgoPoTZkTNr8W3ycl4LMjBjPJv+/pM2waAAQRAYgBblCCDAOdjKZoDcA7F7V8gA6vD6B3K8nzIdsonxeWk1kiXS8qDFFAGycry4fokgvNAzdO7elO+iDXgpXCZ5IBJMtMAkI9USmTmIIifT1hMfR2360W/P1NBvf4vnILYCfdIFAE0uq67/IOQ1f/w3dvt1iYQQK8vQmAG4QewyDTYGyJ9DGwSKwHqgQH0Zsyr1pwdnyflIAJEyYwSW9vr2HTACCICEAMcIMSZBjoZDRFawDeuajlA3R4fQC9W0meD9lG+bywnMwS6XpRYYgC2jhZWT5El1xoHrhxak930ge5FqwUPpMMIFlmEhDqiUqZxBQU6esJi+H5X+1TV141w+B27NjBY3bSDQJFIH3hZeXv3XT1PT95wGJhBgnw9iYAbhB6DINMg7El0sfAIrEeqBIcRG/KvHzGrPg+KQGdnZ1MsnPnTsOmAUAQEYAY4AYlyDDQyWiK1gC8c1HLB+jw+gB6t5I8H7KN8nlhOZkl0vWiwhAFtHGysnyILrnQPHDj1J7upA9yLVgpfCYZQLLMJCDUE5UyiSko0tcTFsOePXvU5MmTDW7v3vIPw+ykGwSKQHrUmAt4h6GrN2zYYLEwgwR4exMANwg9hkGmwdgS6WNgkVgPVAkOojdlDr5zRXyflIDp06czydq1aw2bBgBBRABigBuUIMNAJ6MpWgPwzkUtH6DD6wPo3UryfMg2yueF5WSWSNeLCkMU0MbJyvIhuuRC88CNU3u6kz7ItWCl8JlkAMkyk4BQT1TKJKagSF9PWAx9mzerOb7PJ8lJNwg2/uhPXTmXdxi6unvpUouFU0iAtzcBcIPQYxhkGoxNFSTSx8AisR4kiOjN55OL/3J0fJ+UgIkTJ3Im+WmnBgBBaAGIAW5QggwDnYymaA3AOxe1fIAOrw+gdyvJ8yHbKJ8XlpNZIivtX8uHNk5Wlg/RJReaB26cWmUmFwzpkGvBSuEzyQCSZSYBoZ6olBkVGdwnYdTTO55X13zlywb37DPP8piddINAEUhPG1H+3k1X3/Wjn1oszCABXqsBcIPQYxhkGowtkT4GFinLBIjoTZnjp9wb3yclYNasWUyyevVqk1EDgCAiADHADUqQYaCT0RStAXjnopYP0OH1AfRuJXk+ZBvl88JyMkuk60WFIQpo42Rl+RBdcqF54MapPd1JH+RasFL4TDKAZJlJQKgnKmUSU1Ckrycshid6N6hbFy81uI0bN/KYnXSDQBFIqxOv5h2Grr7tW4ssFmaQAG9vAuAGoccwyDQYWyJ9DCwS64EqwUH0psyhw0bG90kJGDlyJJO8/PLLhk0DgCAiADHADUqQYaCT0RStAXjnopYP0OH1AfRuJXk+ZBvl88JyMkuk60WFIQpo42Rl+RBdcqF54MapPd1JH+RasFL4TDKAZJlJQKgnKmUSU1CkrycshqlTp6rLLrvM4G644QYes5NuECgC6XnXlveZ09WPPPKIxcIMEuDtTQDcIPQYBpkGY0ukj4FFYj1QJTiI3pQ58bU/ie+TAGwavJ8JJvUNsbJpF+CCvAAJsgAuPZcpU/QPEFwP2T5EGWCSCyLRpgoEJTgKQMleBulHBVDp7taU6dJSJUGRBD46gOumN4XrorVgXKujImVVLXZS1o80lb7wdpavPIuh1pKrvx7oCwpCS56ttgBFA6vpdHk0AQiaSAkqAW5QgGqkoKuiGrIAnnptDVkA0uH1AVc7QjN9yDbKU2q1iqRIp9SaPvR/LoIMWT5El1xgHqqrOmu6o0Y5Nvv7QiyWGn1RywdvCulDFNA/H6QHYmzvD5R/yZJmoiVLnA0EAqMMWPoNcJnCoeV9wgI4V/kBgb1Q3z+6w+yTMxofuz0gP3YDAEEQAcQMFJRXEQjndPGNmzkFAWQKjNOAZIoskVAeLfPzz+8yVt0/usOMuUwKdnR0qEEfK+8zf+LxzQogAxj/mfKPPHQcfL1P7dq1i0E8m/JqOSXEZAAIIA1SWQAZRJoKA5iMBlThLgerisBa4dPWgqETMKzCgMALu/eojuFnqz867rimD3QlAjIdgbgKN/jgQw8zbtb0aU0Andi580VDQEEjkvITCwEQCIqUU80Mrfs42v0sDJ+P6e/d8T/cFwSQH95hnAbgE+9giqzPzGFf9FPWJ9ZfYWweP+XeZl/w53Lrr6j0BUDlB3frr1C+viDQse4L1gCR7tK3qoj2hftJLwyrMCAg+8L40Oa+QJluXwRFyqnmvmjd49vus6N4nlT3Fl/jviCAfNgV4zQAT4gHU2Q9Y47pjj6VvHBc8wHPZduGNvuCUlDQfb8AiJ0kgK8vCHSs+4I1QKS79K0qon3hPhkNwyoMCMi+MD60uS9QptsXQZFyqrkviucubf6+OWBSacnh8jtybACCiDRAJQMFxVWMaZzTxSvfKFMQQKZojDMAyRSoIioSymNl6jGPmdqL5y61faCg2xcAsQ8E8PUFgY51X7AGiHSXvlVFtC+sBUMrqGFYhQEB2RfGhzb3Bcp0+yIoUk41L/vW3Sbq3qOG+9b0vP8qHxElgLypDuM0AHeiBlNk3cuK6Y7e/dh37d+aZTH4zuaX8rFRFHT7AiAD8PUFgY51X7AGVOEufauKaF+4d2DCsAoDArIvjA9t7guU6fZFUKScau6LI0eOmPeLZ555hi0ZO3Zsc58EAEFEAGIGCsqrCIRzeuvWrZyCADIFxmlAMkWWSCiPlnnCCSeY2o8cOWL7QEG3LwBiHwjg6wsCHeu+YA0Q6S59q4poX8gFQ0AYVmFAQPaF8aHNfYEy3b4IipRTzX0hv444+g230e/Idb/EmKkbX2ysi/X/wX3B303c+KZdOU4D8I3Hla+dRQpU0f8v8j1u3hSzLN5fub7ZF5SCgm5fAMROEsDXFwQ61n3BGiDSXfpWFdG+cL+/GoZVGBCQfWF8aHNfoEy3L4Ii5VTz4m3dY4nuM1F4TkrfePOt3BcEkA9xYZwG4MnHYIqsZycx3dGn7X7+QPPW0MtnlLeLGqMo6PYFQOwkAXx9QaBj3ResASLdpW9VEe0L94k/GFZhQED2hfGhzX2BMt2+CIqUU83TPWbMmPjfeSWg9+u/Z88mfPMjzQUDAIKIAMQp3KAEWRqiKeiq/gN8017PB+jw+gB6V2ieD9lG+byoVEFsUZGuF/V86P9cBBmyfIguudA81F/2yQXj2myl8JVoAMkyk4BQT1TKjIoMbYUtXA8yvxybFFFA0oc2A0aPHlPQW5u5waUoVMGvNd96oocOG1aYe2ZoSzV/Ui/3Vz3krLOKbfdMU7pQ6qQDGxo3wBCpVp03HVH6cPfIYsCc3d6peLv7HAJ0FHtHPch/oD7//HMZuGPHC6ooCnXOrhlKv90zsjj5C79hGfq44xlQFO/zn8Hf7hml9OGejmLA7ObNzjIXp3i7e2RBZQ2Ybes43HNOyXruws3x9wsJ2HpB+QWVFz+7qvl+AQCCiADEKdygBFkaoinoqv4DvO1fywfo8PoAeldong/ZRvm8qMwmsUVFVt4vavnQ/7kIMmT5EF1yoXng5q1VZnLBuDZbKXwlGkCyzCQg1BOVMqMig+8X5y3aEt8fJODJ87/KRJf86ofN/QEACiIgxzoLAGpXKDEyQ7sBtE/SWwC9T/C7QeOdA+8bI25YRxtteZclvYFo3Rjzn8OU7tvyd7SxM+Tk18vHXTSz0TtGofSUPx1SLJoxmbd/zlRC+L/ffmCj0hsX/3Ux/uur1Jtbv6ZefPRdvmrU5z6qTvv0P6neb16j9O67FhRDrrpNjRk9Rv38pvJLjS6//UH13PM71P6fLC4BoanmZElAR88mw3DmlPLXhtfWl79GMAMACCIAEAMoKK8iEM7pSW/9klMQQKbAOA1IpsgSCeXRMoONgxS7Zjf++NlAdvQ0/kchBKDgpLd+qe4dUL77X3H4BbXplE8rAvFikkGkAqj8xbxnk3ps5lh16ZryM3OMiZmtRgrYTdWYFFIkpaIDQWs26QUqQQUMWL76JbMerp35cWa4c81vmusBAAQRAYgZKCivIhDO6aLRNgSQKTBOA5IpskRCebTM+bNGWUti+eqXyr6gFBTc90qhhp1VYl75T6XOHqYVgXg2ZRA0ADGgYYUxy3ig+R+uGYBoiqRIGBUs8wff/75ZDz/8afnljF/98tzmegAAQUQA0gT4i0nD1YObmv/rGQKt/soENetHvUrve/o+TuEDsNVJQDJFlkgoj5ZJILcausBbJgUsH0JXE4jLlB7Iq9kHdy7kPJCbDHCvgs0WQwikz79gbOHS0iThML1pTrh3Jpsl3UCYN1a87j/AffYBTWQ0fQCACy8sb+IKHZoAp512pnrjjdcsDM4xgCISJMcGABD9lGz5gGiKLJHRMpM+yAoARiV5RkEk/YQPlpPZACnWOxcSYImMlrngzDOLi844w2C2Hzig8JrG+l/Hji3kSULSazoIaABuGrBopHCpDYBSgFbmprHRIPPKVBUNvmqMBjcNXvN7VldXl1q3bp2in3RgTD91V1dXIU8QQF7QAoYPIEWyzLHDFhSDB37KONx36CmF1zTWXZ/sKdyTQBPQAhCQDsmoKYW8gsaSkRnck2Ci8wYAEFKAxWgIpWENsiy3ZL1v/974Pvn/ADbXGLV7f/MBDQqcM6R8SIMBbhDzQqAPCkA5oyKj++RnZs3j9XCwr3lfMb0eNLi8t1gTYOAXD6m1c3r09O7Z5Z1vjfGhnw1UetT4qcVLTzxsPuiV6Sj2QQCSIrPKTPrw+OqVeuq8RcXDK5dyuRgTO5c5/LwLvW7v/fXTTaN8DJZRUUA0BQmJimyND3Nf3aHmb9uml48bx+sB47uHfvLDsx6iIlvjw5wJner6G280vwhg3N2788PjQ1Rk0gf5O87kmXN4dW9Y080/6bX1S9Cwz01Tz/7L3erUU0+NAyg6+5r55Q7z6337i5ffeYdfvPJo8//0jHQM6LlrOQNATWOkMxrefPPNNICuvOBLzd+YSbBecuutBQQRAOnoHI3TGlorMlmmtwpMFvlwdGUmfVi/a1f83w8E+N2773L+k048sbId6iwG9zLJeHQMktEwhISmU8i+2Nf4UuOzR4wwWay+wHzIWWXAQ+vWqXM7O9WAgQP5ysOHDqkXdu5U07q6yjW59cknOUAn6KAL6Lj4kkuUvvG68ptV6GpQUypi4c6CSFwFdWBLA0gDrgItxHKKiZ2zir0zz1DD1xxQZxx/UB14b5B68eKPqE9s/T2/1nNGTyzck/J1GkApfNTEQqlZQxTQGg3RMset+sfid31vqZMGn2LWgHytawFwpfxpMbQRAPm+alhDNqDS+7RgJMPRAc67bUl8C+p/iiRDUsPp37mdRZ74x4PUu/990FSK1xqAEIgBoau59Ybd9ePCR41cJsWx1JB08g8CkJzuJOCv7phfWbSnnDxQvfVOY692ARTEQSBdm8HtLi+D9baIFFJYBeAKq8/gCov6QOD+GdUaJ5MivT74djhu3hXX/1lx8Levq0Gnf0zRTzowpp966Zc+Ht/lCCCvIAbJyClC+f/wNFCp8oBpVpnSSbMNSqMkA8xjq+U8AGQA0slgCsxgUGR0upO/iBHg+pl9as6Va3X3PdN5ZjH+wZrBH57fN6MiU2X+H3Aj9NeOyt9VAAAAAElFTkSuQmCC"
];
( () => {
    var e = {
        80: (e, t, i) => {
            e.exports = i(4312)
        }
        ,
        204: e => {
            "use strict";
            e.exports = function(e, s) {
                s <= 4 * t ? i(0, s - 1, e) : l(0, s - 1, e)
            }
            ;
            var t = 32;
            function i(e, t, i) {
                for (var s = 2 * (e + 1), r = e + 1; r <= t; ++r) {
                    for (var n = i[s++], a = i[s++], o = r, h = s - 2; o-- > e; ) {
                        var l = i[h - 2]
                          , c = i[h - 1];
                        if (l < n)
                            break;
                        if (l === n && c < a)
                            break;
                        i[h] = l,
                        i[h + 1] = c,
                        h -= 2
                    }
                    i[h] = n,
                    i[h + 1] = a
                }
            }
            function s(e, t, i) {
                t *= 2;
                var s = i[e *= 2]
                  , r = i[e + 1];
                i[e] = i[t],
                i[e + 1] = i[t + 1],
                i[t] = s,
                i[t + 1] = r
            }
            function r(e, t, i) {
                t *= 2,
                i[e *= 2] = i[t],
                i[e + 1] = i[t + 1]
            }
            function n(e, t, i, s) {
                t *= 2,
                i *= 2;
                var r = s[e *= 2]
                  , n = s[e + 1];
                s[e] = s[t],
                s[e + 1] = s[t + 1],
                s[t] = s[i],
                s[t + 1] = s[i + 1],
                s[i] = r,
                s[i + 1] = n
            }
            function a(e, t, i, s, r) {
                t *= 2,
                r[e *= 2] = r[t],
                r[t] = i,
                r[e + 1] = r[t + 1],
                r[t + 1] = s
            }
            function o(e, t, i) {
                t *= 2;
                var s = i[e *= 2]
                  , r = i[t];
                return !(s < r) && (s !== r || i[e + 1] > i[t + 1])
            }
            function h(e, t, i, s) {
                var r = s[e *= 2];
                return r < t || r === t && s[e + 1] < i
            }
            function l(e, c, u) {
                var d = (c - e + 1) / 6 | 0
                  , f = e + d
                  , _ = c - d
                  , p = e + c >> 1
                  , m = p - d
                  , g = p + d
                  , v = f
                  , y = m
                  , b = p
                  , x = g
                  , T = _
                  , E = e + 1
                  , M = c - 1
                  , S = 0;
                o(v, y, u) && (S = v,
                v = y,
                y = S),
                o(x, T, u) && (S = x,
                x = T,
                T = S),
                o(v, b, u) && (S = v,
                v = b,
                b = S),
                o(y, b, u) && (S = y,
                y = b,
                b = S),
                o(v, x, u) && (S = v,
                v = x,
                x = S),
                o(b, x, u) && (S = b,
                b = x,
                x = S),
                o(y, T, u) && (S = y,
                y = T,
                T = S),
                o(y, b, u) && (S = y,
                y = b,
                b = S),
                o(x, T, u) && (S = x,
                x = T,
                T = S);
                for (var A = u[2 * y], I = u[2 * y + 1], R = u[2 * x], C = u[2 * x + 1], P = 2 * v, D = 2 * b, w = 2 * T, F = 2 * f, O = 2 * p, L = 2 * _, B = 0; B < 2; ++B) {
                    var N = u[P + B]
                      , U = u[D + B]
                      , k = u[w + B];
                    u[F + B] = N,
                    u[O + B] = U,
                    u[L + B] = k
                }
                r(m, e, u),
                r(g, c, u);
                for (var V = E; V <= M; ++V)
                    if (h(V, A, I, u))
                        V !== E && s(V, E, u),
                        ++E;
                    else if (!h(V, R, C, u))
                        for (; ; ) {
                            if (h(M, R, C, u)) {
                                h(M, A, I, u) ? (n(V, E, M, u),
                                ++E,
                                --M) : (s(V, M, u),
                                --M);
                                break
                            }
                            if (--M < V)
                                break
                        }
                a(e, E - 1, A, I, u),
                a(c, M + 1, R, C, u),
                E - 2 - e <= t ? i(e, E - 2, u) : l(e, E - 2, u),
                c - (M + 2) <= t ? i(M + 2, c, u) : l(M + 2, c, u),
                M - E <= t ? i(E, M, u) : l(E, M, u)
            }
        }
        ,
        220: e => {
            e.exports = function(e, t, i) {
                return e[0] = t[0] - i[0],
                e[1] = t[1] - i[1],
                e[2] = t[2] - i[2],
                e
            }
        }
        ,
        409: e => {
            e.exports = function(e, t) {
                return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
            }
        }
        ,
        482: (e, t) => {
            "use strict";
            var i = ["d", "ax", "vv", "rs", "re", "rb", "ri", "bs", "be", "bb", "bi"];
            function s(e) {
                var t = "bruteForce" + (e ? "Full" : "Partial")
                  , s = []
                  , r = i.slice();
                e || r.splice(3, 0, "fp");
                var n = ["function " + t + "(" + r.join() + "){"];
                function a(t, r) {
                    var a = function(e, t, s) {
                        var r = "bruteForce" + (e ? "Red" : "Blue") + (t ? "Flip" : "") + (s ? "Full" : "")
                          , n = ["function ", r, "(", i.join(), "){", "var ", "es", "=2*", "d", ";"]
                          , a = "for(var i=rs,rp=es*rs;i<re;++i,rp+=es){var x0=rb[ax+rp],x1=rb[ax+rp+d],xi=ri[i];"
                          , o = "for(var j=bs,bp=es*bs;j<be;++j,bp+=es){var y0=bb[ax+bp]," + (s ? "y1=bb[ax+bp+d]," : "") + "yi=bi[j];";
                        return e ? n.push(a, "Q", ":", o) : n.push(o, "Q", ":", a),
                        s ? n.push("if(y1<x0||x1<y0)continue;") : t ? n.push("if(y0<=x0||x1<y0)continue;") : n.push("if(y0<x0||x1<y0)continue;"),
                        n.push("for(var k=ax+1;k<d;++k){var r0=rb[k+rp],r1=rb[k+d+rp],b0=bb[k+bp],b1=bb[k+d+bp];if(r1<b0||b1<r0)continue Q;}var rv=vv("),
                        t ? n.push("yi,xi") : n.push("xi,yi"),
                        n.push(");if(rv!==void 0)return rv;}}}"),
                        {
                            name: r,
                            code: n.join("")
                        }
                    }(t, r, e);
                    s.push(a.code),
                    n.push("return " + a.name + "(" + i.join() + ");")
                }
                n.push("if(re-rs>be-bs){"),
                e ? (a(!0, !1),
                n.push("}else{"),
                a(!1, !1)) : (n.push("if(fp){"),
                a(!0, !0),
                n.push("}else{"),
                a(!0, !1),
                n.push("}}else{if(fp){"),
                a(!1, !0),
                n.push("}else{"),
                a(!1, !1),
                n.push("}")),
                n.push("}}return " + t);
                var o = s.join("") + n.join("");
                return new Function(o)()
            }
            t.partial = s(!1),
            t.full = s(!0)
        }
        ,
        728: (e, t, i) => {
            e.exports = i(6936)
        }
        ,
        973: (e, t) => {
            "use strict";
            function i(e) {
                var t = 32;
                return (e &= -e) && t--,
                65535 & e && (t -= 16),
                16711935 & e && (t -= 8),
                252645135 & e && (t -= 4),
                858993459 & e && (t -= 2),
                1431655765 & e && (t -= 1),
                t
            }
            t.INT_BITS = 32,
            t.INT_MAX = 2147483647,
            t.INT_MIN = -1 << 31,
            t.sign = function(e) {
                return (e > 0) - (e < 0)
            }
            ,
            t.abs = function(e) {
                var t = e >> 31;
                return (e ^ t) - t
            }
            ,
            t.min = function(e, t) {
                return t ^ (e ^ t) & -(e < t)
            }
            ,
            t.max = function(e, t) {
                return e ^ (e ^ t) & -(e < t)
            }
            ,
            t.isPow2 = function(e) {
                return !(e & e - 1 || !e)
            }
            ,
            t.log2 = function(e) {
                var t, i;
                return t = (e > 65535) << 4,
                t |= i = ((e >>>= t) > 255) << 3,
                t |= i = ((e >>>= i) > 15) << 2,
                (t |= i = ((e >>>= i) > 3) << 1) | (e >>>= i) >> 1
            }
            ,
            t.log10 = function(e) {
                return e >= 1e9 ? 9 : e >= 1e8 ? 8 : e >= 1e7 ? 7 : e >= 1e6 ? 6 : e >= 1e5 ? 5 : e >= 1e4 ? 4 : e >= 1e3 ? 3 : e >= 100 ? 2 : e >= 10 ? 1 : 0
            }
            ,
            t.popCount = function(e) {
                return 16843009 * ((e = (858993459 & (e -= e >>> 1 & 1431655765)) + (e >>> 2 & 858993459)) + (e >>> 4) & 252645135) >>> 24
            }
            ,
            t.countTrailingZeros = i,
            t.nextPow2 = function(e) {
                return e += 0 === e,
                --e,
                e |= e >>> 1,
                e |= e >>> 2,
                e |= e >>> 4,
                e |= e >>> 8,
                1 + (e |= e >>> 16)
            }
            ,
            t.prevPow2 = function(e) {
                return e |= e >>> 1,
                e |= e >>> 2,
                e |= e >>> 4,
                e |= e >>> 8,
                (e |= e >>> 16) - (e >>> 1)
            }
            ,
            t.parity = function(e) {
                return e ^= e >>> 16,
                e ^= e >>> 8,
                e ^= e >>> 4,
                27030 >>> (e &= 15) & 1
            }
            ;
            var s = new Array(256);
            !function(e) {
                for (var t = 0; t < 256; ++t) {
                    var i = t
                      , s = t
                      , r = 7;
                    for (i >>>= 1; i; i >>>= 1)
                        s <<= 1,
                        s |= 1 & i,
                        --r;
                    e[t] = s << r & 255
                }
            }(s),
            t.reverse = function(e) {
                return s[255 & e] << 24 | s[e >>> 8 & 255] << 16 | s[e >>> 16 & 255] << 8 | s[e >>> 24 & 255]
            }
            ,
            t.interleave2 = function(e, t) {
                return (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e &= 65535) | e << 8)) | e << 4)) | e << 2)) | e << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t &= 65535) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
            }
            ,
            t.deinterleave2 = function(e, t) {
                return (e = 65535 & ((e = 16711935 & ((e = 252645135 & ((e = 858993459 & ((e = e >>> t & 1431655765) | e >>> 1)) | e >>> 2)) | e >>> 4)) | e >>> 16)) << 16 >> 16
            }
            ,
            t.interleave3 = function(e, t, i) {
                return e = 1227133513 & ((e = 3272356035 & ((e = 251719695 & ((e = 4278190335 & ((e &= 1023) | e << 16)) | e << 8)) | e << 4)) | e << 2),
                (e |= (t = 1227133513 & ((t = 3272356035 & ((t = 251719695 & ((t = 4278190335 & ((t &= 1023) | t << 16)) | t << 8)) | t << 4)) | t << 2)) << 1) | (i = 1227133513 & ((i = 3272356035 & ((i = 251719695 & ((i = 4278190335 & ((i &= 1023) | i << 16)) | i << 8)) | i << 4)) | i << 2)) << 2
            }
            ,
            t.deinterleave3 = function(e, t) {
                return (e = 1023 & ((e = 4278190335 & ((e = 251719695 & ((e = 3272356035 & ((e = e >>> t & 1227133513) | e >>> 2)) | e >>> 4)) | e >>> 8)) | e >>> 16)) << 22 >> 22
            }
            ,
            t.nextCombination = function(e) {
                var t = e | e - 1;
                return t + 1 | (~t & -~t) - 1 >>> i(e) + 1
            }
        }
        ,
        1144: (e, t, i) => {
            e.exports = i(8051)
        }
        ,
        1216: e => {
            e.exports = function() {
                var e = new Float32Array(3);
                return e[0] = 0,
                e[1] = 0,
                e[2] = 0,
                e
            }
        }
        ,
        1229: e => {
            e.exports = function(e, t, i, s) {
                var r = t[0]
                  , n = t[1]
                  , a = t[2];
                return e[0] = r + s * (i[0] - r),
                e[1] = n + s * (i[1] - n),
                e[2] = a + s * (i[2] - a),
                e
            }
        }
        ,
        1263: e => {
            e.exports = function(e, t, i, s) {
                var r = i[1]
                  , n = i[2]
                  , a = t[1] - r
                  , o = t[2] - n
                  , h = Math.sin(s)
                  , l = Math.cos(s);
                return e[0] = t[0],
                e[1] = r + a * l - o * h,
                e[2] = n + a * h + o * l,
                e
            }
        }
        ,
        1374: e => {
            e.exports = function(e, t, i) {
                return e[0] = Math.min(t[0], i[0]),
                e[1] = Math.min(t[1], i[1]),
                e[2] = Math.min(t[2], i[2]),
                e
            }
        }
        ,
        1380: e => {
            e.exports = function(e, t) {
                return e[0] = Math.floor(t[0]),
                e[1] = Math.floor(t[1]),
                e[2] = Math.floor(t[2]),
                e
            }
        }
        ,
        1536: (e, t, i) => {
            e.exports = function(e, t, i, r, n, a) {
                var o, h;
                for (t || (t = 3),
                i || (i = 0),
                h = r ? Math.min(r * t + i, e.length) : e.length,
                o = i; o < h; o += t)
                    s[0] = e[o],
                    s[1] = e[o + 1],
                    s[2] = e[o + 2],
                    n(s, s, a),
                    e[o] = s[0],
                    e[o + 1] = s[1],
                    e[o + 2] = s[2];
                return e
            }
            ;
            var s = i(1216)()
        }
        ,
        1589: e => {
            e.exports = function(e, t) {
                return e[0] = t[0],
                e[1] = t[1],
                e[2] = t[2],
                e
            }
        }
        ,
        1785: e => {
            e.exports = function(e, t) {
                var i = t[0]
                  , s = t[1]
                  , r = t[2]
                  , n = i * i + s * s + r * r;
                return n > 0 && (n = 1 / Math.sqrt(n),
                e[0] = t[0] * n,
                e[1] = t[1] * n,
                e[2] = t[2] * n),
                e
            }
        }
        ,
        2219: e => {
            "use strict";
            e.exports = function(e) {
                for (var t = new Array(e), i = 0; i < e; ++i)
                    t[i] = i;
                return t
            }
        }
        ,
        2286: e => {
            e.exports = function(e, t) {
                return e[0] = 1 / t[0],
                e[1] = 1 / t[1],
                e[2] = 1 / t[2],
                e
            }
        }
        ,
        2473: (e, t, i) => {
            e.exports = i(5053)
        }
        ,
        2566: (e, t, i) => {
            "use strict";
            e.exports = function(e, t, i, a, o, h) {
                if (a <= i + 1)
                    return i;
                for (var l = i, c = a, u = a + i >>> 1, d = 2 * e, f = u, _ = o[d * u + t]; l < c; ) {
                    if (c - l < r) {
                        n(e, t, l, c, o, h),
                        _ = o[d * u + t];
                        break
                    }
                    var p = c - l
                      , m = Math.random() * p + l | 0
                      , g = o[d * m + t]
                      , v = Math.random() * p + l | 0
                      , y = o[d * v + t]
                      , b = Math.random() * p + l | 0
                      , x = o[d * b + t];
                    g <= y ? x >= y ? (f = v,
                    _ = y) : g >= x ? (f = m,
                    _ = g) : (f = b,
                    _ = x) : y >= x ? (f = v,
                    _ = y) : x >= g ? (f = m,
                    _ = g) : (f = b,
                    _ = x);
                    for (var T = d * (c - 1), E = d * f, M = 0; M < d; ++M,
                    ++T,
                    ++E) {
                        var S = o[T];
                        o[T] = o[E],
                        o[E] = S
                    }
                    var A = h[c - 1];
                    for (h[c - 1] = h[f],
                    h[f] = A,
                    T = d * (c - 1),
                    E = d * (f = s(e, t, l, c - 1, o, h, _)),
                    M = 0; M < d; ++M,
                    ++T,
                    ++E)
                        S = o[T],
                        o[T] = o[E],
                        o[E] = S;
                    if (A = h[c - 1],
                    h[c - 1] = h[f],
                    h[f] = A,
                    u < f) {
                        for (c = f - 1; l < c && o[d * (c - 1) + t] === _; )
                            c -= 1;
                        c += 1
                    } else {
                        if (!(f < u))
                            break;
                        for (l = f + 1; l < c && o[d * l + t] === _; )
                            l += 1
                    }
                }
                return s(e, t, i, u, o, h, o[d * u + t])
            }
            ;
            var s = i(8288)("lo<p0", ["p0"])
              , r = 8;
            function n(e, t, i, s, r, n) {
                for (var a = 2 * e, o = a * (i + 1) + t, h = i + 1; h < s; ++h,
                o += a)
                    for (var l = r[o], c = h, u = a * (h - 1); c > i && r[u + t] > l; --c,
                    u -= a) {
                        for (var d = u, f = u + a, _ = 0; _ < a; ++_,
                        ++d,
                        ++f) {
                            var p = r[d];
                            r[d] = r[f],
                            r[f] = p
                        }
                        var m = n[c];
                        n[c] = n[c - 1],
                        n[c - 1] = m
                    }
            }
        }
        ,
        2573: (e, t, i) => {
            e.exports = function(e, t) {
                var i = s(e[0], e[1], e[2])
                  , a = s(t[0], t[1], t[2]);
                r(i, i),
                r(a, a);
                var o = n(i, a);
                return o > 1 ? 0 : Math.acos(o)
            }
            ;
            var s = i(3198)
              , r = i(1785)
              , n = i(409)
        }
        ,
        2617: e => {
            e.exports = function(e, t, i) {
                var s = t[0]
                  , r = t[1]
                  , n = t[2]
                  , a = i[0]
                  , o = i[1]
                  , h = i[2]
                  , l = i[3]
                  , c = l * s + o * n - h * r
                  , u = l * r + h * s - a * n
                  , d = l * n + a * r - o * s
                  , f = -a * s - o * r - h * n;
                return e[0] = c * l + f * -a + u * -h - d * -o,
                e[1] = u * l + f * -o + d * -a - c * -h,
                e[2] = d * l + f * -h + c * -o - u * -a,
                e
            }
        }
        ,
        2811: e => {
            e.exports = function(e, t) {
                t = t || 1;
                var i = 2 * Math.random() * Math.PI
                  , s = 2 * Math.random() - 1
                  , r = Math.sqrt(1 - s * s) * t;
                return e[0] = Math.cos(i) * r,
                e[1] = Math.sin(i) * r,
                e[2] = s * t,
                e
            }
        }
        ,
        2864: e => {
            e.exports = 1e-6
        }
        ,
        3146: (e, t, i) => {
            "use strict";
            e.exports = {
                init: function(e) {
                    var t = r.nextPow2(e);
                    h.length < t && (s.free(h),
                    h = s.mallocInt32(t)),
                    l.length < t && (s.free(l),
                    l = s.mallocInt32(t)),
                    c.length < t && (s.free(c),
                    c = s.mallocInt32(t)),
                    u.length < t && (s.free(u),
                    u = s.mallocInt32(t)),
                    d.length < t && (s.free(d),
                    d = s.mallocInt32(t)),
                    f.length < t && (s.free(f),
                    f = s.mallocInt32(t));
                    var i = 8 * t;
                    _.length < i && (s.free(_),
                    _ = s.mallocDouble(i))
                },
                sweepBipartite: function(e, t, i, s, r, o, d, f, g, v) {
                    for (var y = 0, b = 2 * e, x = e - 1, T = b - 1, E = i; E < s; ++E) {
                        var M = o[E]
                          , S = b * E;
                        _[y++] = r[S + x],
                        _[y++] = -(M + 1),
                        _[y++] = r[S + T],
                        _[y++] = M
                    }
                    for (E = d; E < f; ++E) {
                        M = v[E] + a;
                        var A = b * E;
                        _[y++] = g[A + x],
                        _[y++] = -M,
                        _[y++] = g[A + T],
                        _[y++] = M
                    }
                    var I = y >>> 1;
                    n(_, I);
                    var R = 0
                      , C = 0;
                    for (E = 0; E < I; ++E) {
                        var P = 0 | _[2 * E + 1];
                        if (P >= a)
                            p(c, u, C--, P = P - a | 0);
                        else if (P >= 0)
                            p(h, l, R--, P);
                        else if (P <= -a) {
                            P = -P - a | 0;
                            for (var D = 0; D < R; ++D)
                                if (void 0 !== (w = t(h[D], P)))
                                    return w;
                            m(c, u, C++, P)
                        } else {
                            for (P = -P - 1 | 0,
                            D = 0; D < C; ++D) {
                                var w;
                                if (void 0 !== (w = t(P, c[D])))
                                    return w
                            }
                            m(h, l, R++, P)
                        }
                    }
                },
                sweepComplete: function(e, t, i, s, r, a, o, g, v, y) {
                    for (var b = 0, x = 2 * e, T = e - 1, E = x - 1, M = i; M < s; ++M) {
                        var S = a[M] + 1 << 1
                          , A = x * M;
                        _[b++] = r[A + T],
                        _[b++] = -S,
                        _[b++] = r[A + E],
                        _[b++] = S
                    }
                    for (M = o; M < g; ++M) {
                        S = y[M] + 1 << 1;
                        var I = x * M;
                        _[b++] = v[I + T],
                        _[b++] = 1 | -S,
                        _[b++] = v[I + E],
                        _[b++] = 1 | S
                    }
                    var R = b >>> 1;
                    n(_, R);
                    var C = 0
                      , P = 0
                      , D = 0;
                    for (M = 0; M < R; ++M) {
                        var w = 0 | _[2 * M + 1]
                          , F = 1 & w;
                        if (M < R - 1 && w >> 1 == _[2 * M + 3] >> 1 && (F = 2,
                        M += 1),
                        w < 0) {
                            for (var O = -(w >> 1) - 1, L = 0; L < D; ++L)
                                if (void 0 !== (B = t(d[L], O)))
                                    return B;
                            if (0 !== F)
                                for (L = 0; L < C; ++L)
                                    if (void 0 !== (B = t(h[L], O)))
                                        return B;
                            if (1 !== F)
                                for (L = 0; L < P; ++L) {
                                    var B;
                                    if (void 0 !== (B = t(c[L], O)))
                                        return B
                                }
                            0 === F ? m(h, l, C++, O) : 1 === F ? m(c, u, P++, O) : 2 === F && m(d, f, D++, O)
                        } else
                            O = (w >> 1) - 1,
                            0 === F ? p(h, l, C--, O) : 1 === F ? p(c, u, P--, O) : 2 === F && p(d, f, D--, O)
                    }
                },
                scanBipartite: function(e, t, i, s, r, o, c, u, d, f, g, v) {
                    var y = 0
                      , b = 2 * e
                      , x = t
                      , T = t + e
                      , E = 1
                      , M = 1;
                    s ? M = a : E = a;
                    for (var S = r; S < o; ++S) {
                        var A = S + E
                          , I = b * S;
                        _[y++] = c[I + x],
                        _[y++] = -A,
                        _[y++] = c[I + T],
                        _[y++] = A
                    }
                    for (S = d; S < f; ++S) {
                        A = S + M;
                        var R = b * S;
                        _[y++] = g[R + x],
                        _[y++] = -A
                    }
                    var C = y >>> 1;
                    n(_, C);
                    var P = 0;
                    for (S = 0; S < C; ++S) {
                        var D = 0 | _[2 * S + 1];
                        if (D < 0) {
                            var w = !1;
                            if ((A = -D) >= a ? (w = !s,
                            A -= a) : (w = !!s,
                            A -= 1),
                            w)
                                m(h, l, P++, A);
                            else {
                                var F = v[A]
                                  , O = b * A
                                  , L = g[O + t + 1]
                                  , B = g[O + t + 1 + e];
                                e: for (var N = 0; N < P; ++N) {
                                    var U = h[N]
                                      , k = b * U;
                                    if (!(B < c[k + t + 1] || c[k + t + 1 + e] < L)) {
                                        for (var V = t + 2; V < e; ++V)
                                            if (g[O + V + e] < c[k + V] || c[k + V + e] < g[O + V])
                                                continue e;
                                        var G, z = u[U];
                                        if (void 0 !== (G = s ? i(F, z) : i(z, F)))
                                            return G
                                    }
                                }
                            }
                        } else
                            p(h, l, P--, D - E)
                    }
                },
                scanComplete: function(e, t, i, s, r, o, l, c, u, d, f) {
                    for (var p = 0, m = 2 * e, g = t, v = t + e, y = s; y < r; ++y) {
                        var b = y + a
                          , x = m * y;
                        _[p++] = o[x + g],
                        _[p++] = -b,
                        _[p++] = o[x + v],
                        _[p++] = b
                    }
                    for (y = c; y < u; ++y) {
                        b = y + 1;
                        var T = m * y;
                        _[p++] = d[T + g],
                        _[p++] = -b
                    }
                    var E = p >>> 1;
                    n(_, E);
                    var M = 0;
                    for (y = 0; y < E; ++y) {
                        var S = 0 | _[2 * y + 1];
                        if (S < 0)
                            if ((b = -S) >= a)
                                h[M++] = b - a;
                            else {
                                var A = f[b -= 1]
                                  , I = m * b
                                  , R = d[I + t + 1]
                                  , C = d[I + t + 1 + e];
                                e: for (var P = 0; P < M; ++P) {
                                    var D = h[P]
                                      , w = l[D];
                                    if (w === A)
                                        break;
                                    var F = m * D;
                                    if (!(C < o[F + t + 1] || o[F + t + 1 + e] < R)) {
                                        for (var O = t + 2; O < e; ++O)
                                            if (d[I + O + e] < o[F + O] || o[F + O + e] < d[I + O])
                                                continue e;
                                        var L = i(w, A);
                                        if (void 0 !== L)
                                            return L
                                    }
                                }
                            }
                        else {
                            for (b = S - a,
                            P = M - 1; P >= 0; --P)
                                if (h[P] === b) {
                                    for (O = P + 1; O < M; ++O)
                                        h[O - 1] = h[O];
                                    break
                                }
                            --M
                        }
                    }
                }
            };
            var s = i(6325)
              , r = i(973)
              , n = i(204)
              , a = 1 << 28
              , o = 1024
              , h = s.mallocInt32(o)
              , l = s.mallocInt32(o)
              , c = s.mallocInt32(o)
              , u = s.mallocInt32(o)
              , d = s.mallocInt32(o)
              , f = s.mallocInt32(o)
              , _ = s.mallocDouble(8192);
            function p(e, t, i, s) {
                var r = t[s]
                  , n = e[i - 1];
                e[r] = n,
                t[n] = r
            }
            function m(e, t, i, s) {
                e[i] = s,
                t[s] = i
            }
        }
        ,
        3198: e => {
            e.exports = function(e, t, i) {
                var s = new Float32Array(3);
                return s[0] = e,
                s[1] = t,
                s[2] = i,
                s
            }
        }
        ,
        3401: e => {
            e.exports = function(e, t, i) {
                return e[0] = t[0] + i[0],
                e[1] = t[1] + i[1],
                e[2] = t[2] + i[2],
                e
            }
        }
        ,
        3544: e => {
            e.exports = function(e, t, i) {
                return e[0] = t[0] * i,
                e[1] = t[1] * i,
                e[2] = t[2] * i,
                e
            }
        }
        ,
        3594: e => {
            e.exports = function(e, t, i) {
                var s = t[0]
                  , r = t[1]
                  , n = t[2]
                  , a = i[0]
                  , o = i[1]
                  , h = i[2];
                return e[0] = r * h - n * o,
                e[1] = n * a - s * h,
                e[2] = s * o - r * a,
                e
            }
        }
        ,
        3618: e => {
            e.exports = function(e, t, i, s) {
                return e[0] = t,
                e[1] = i,
                e[2] = s,
                e
            }
        }
        ,
        3625: () => {
            window && !window.global && (window.global = window.globalThis || {})
        }
        ,
        3636: (e, t, i) => {
            e.exports = i(220)
        }
        ,
        3928: e => {
            e.exports = function(e, t, i) {
                var s = t[0]
                  , r = t[1]
                  , n = t[2]
                  , a = i[3] * s + i[7] * r + i[11] * n + i[15];
                return a = a || 1,
                e[0] = (i[0] * s + i[4] * r + i[8] * n + i[12]) / a,
                e[1] = (i[1] * s + i[5] * r + i[9] * n + i[13]) / a,
                e[2] = (i[2] * s + i[6] * r + i[10] * n + i[14]) / a,
                e
            }
        }
        ,
        4136: e => {
            e.exports = function(e) {
                var t = e[0]
                  , i = e[1]
                  , s = e[2];
                return Math.sqrt(t * t + i * i + s * s)
            }
        }
        ,
        4226: (e, t, i) => {
            e.exports = {
                EPSILON: i(2864),
                create: i(1216),
                clone: i(6591),
                angle: i(2573),
                fromValues: i(3198),
                copy: i(1589),
                set: i(3618),
                equals: i(8817),
                exactEquals: i(4964),
                add: i(3401),
                subtract: i(220),
                sub: i(3636),
                multiply: i(6936),
                mul: i(728),
                divide: i(5053),
                div: i(2473),
                min: i(1374),
                max: i(9200),
                floor: i(1380),
                ceil: i(5421),
                round: i(5930),
                scale: i(3544),
                scaleAndAdd: i(4252),
                distance: i(8051),
                dist: i(1144),
                squaredDistance: i(4312),
                sqrDist: i(80),
                length: i(4136),
                len: i(9765),
                squaredLength: i(9059),
                sqrLen: i(4397),
                negate: i(5178),
                inverse: i(2286),
                normalize: i(1785),
                dot: i(409),
                cross: i(3594),
                lerp: i(1229),
                random: i(2811),
                transformMat4: i(3928),
                transformMat3: i(8317),
                transformQuat: i(2617),
                rotateX: i(1263),
                rotateY: i(8104),
                rotateZ: i(9137),
                forEach: i(1536)
            }
        }
        ,
        4252: e => {
            e.exports = function(e, t, i, s) {
                return e[0] = t[0] + i[0] * s,
                e[1] = t[1] + i[1] * s,
                e[2] = t[2] + i[2] * s,
                e
            }
        }
        ,
        4312: e => {
            e.exports = function(e, t) {
                var i = t[0] - e[0]
                  , s = t[1] - e[1]
                  , r = t[2] - e[2];
                return i * i + s * s + r * r
            }
        }
        ,
        4397: (e, t, i) => {
            e.exports = i(9059)
        }
        ,
        4601: e => {
            "use strict";
            var t = []
              , i = []
              , s = []
              , r = []
              , n = []
              , a = []
              , o = []
              , h = []
              , l = []
              , c = []
              , u = []
              , d = [];
            e.exports = function(e, f, _, p, m, g) {
                for (var v = o, y = l, b = c, x = d, T = 0; T < 3; T++)
                    v[T] = +_[T],
                    b[T] = +f.max[T],
                    y[T] = +f.base[T];
                g || (g = 1e-10);
                var E = function(e, o, l, c, d, f) {
                    var _ = t
                      , p = i
                      , m = s
                      , g = r
                      , v = n
                      , y = a
                      , b = h
                      , x = Math.floor
                      , T = 0
                      , E = 0
                      , M = 0
                      , S = 0
                      , A = 0;
                    if (I(),
                    0 === M)
                        return 0;
                    for (S = P(); E <= M; ) {
                        if (R(S) && C())
                            return T;
                        S = P()
                    }
                    for (T += M,
                    A = 0; A < 3; A++)
                        c[A] += l[A],
                        d[A] += l[A];
                    return T;
                    function I() {
                        if (E = 0,
                        0 !== (M = Math.sqrt(l[0] * l[0] + l[1] * l[1] + l[2] * l[2])))
                            for (var e = 0; e < 3; e++) {
                                var t = l[e] >= 0;
                                g[e] = t ? 1 : -1;
                                var i = t ? d[e] : c[e];
                                _[e] = t ? c[e] : d[e],
                                p[e] = D(i, g[e]),
                                m[e] = w(_[e], g[e]),
                                b[e] = l[e] / M,
                                v[e] = Math.abs(1 / b[e]);
                                var s = t ? p[e] + 1 - i : i - p[e];
                                y[e] = v[e] < 1 / 0 ? v[e] * s : 1 / 0
                            }
                    }
                    function R(t) {
                        for (var i = g[0], s = 0 === t ? p[0] : m[0], r = p[0] + i, n = g[1], a = 1 === t ? p[1] : m[1], o = p[1] + n, h = g[2], l = 2 === t ? p[2] : m[2], c = p[2] + h, u = s; u != r; u += i)
                            for (var d = a; d != o; d += n)
                                for (var f = l; f != c; f += h)
                                    if (e(u, d, f))
                                        return !0;
                        return !1
                    }
                    function C() {
                        T += E;
                        var e = g[S]
                          , t = E / M
                          , i = u;
                        for (A = 0; A < 3; A++) {
                            var s = l[A] * t;
                            c[A] += s,
                            d[A] += s,
                            i[A] = l[A] - s
                        }
                        if (e > 0 ? d[S] = Math.round(d[S]) : c[S] = Math.round(c[S]),
                        o(T, S, e, i))
                            return !0;
                        for (A = 0; A < 3; A++)
                            l[A] = i[A];
                        return I(),
                        0 === M
                    }
                    function P() {
                        var e = y[0] < y[1] ? y[0] < y[2] ? 0 : 2 : y[1] < y[2] ? 1 : 2
                          , t = y[e] - E;
                        for (E = y[e],
                        p[e] += g[e],
                        y[e] += v[e],
                        A = 0; A < 3; A++)
                            _[A] += t * b[A],
                            m[A] = w(_[A], g[A]);
                        return e
                    }
                    function D(e, t) {
                        return x(e - t * f)
                    }
                    function w(e, t) {
                        return x(e + t * f)
                    }
                }(e, p, v, y, b, g);
                if (!m) {
                    for (T = 0; T < 3; T++)
                        x[T] = _[T] > 0 ? b[T] - f.max[T] : y[T] - f.base[T];
                    f.translate(x)
                }
                return E
            }
        }
        ,
        4931: (e, t, i) => {
            "use strict";
            e.exports = function(e, t, i, n, c, I, R, C, P) {
                !function(e, t) {
                    var i = 8 * r.log2(t + 1) * (e + 1) | 0
                      , n = r.nextPow2(b * i);
                    T.length < n && (s.free(T),
                    T = s.mallocInt32(n));
                    var a = r.nextPow2(x * i);
                    E.length < a && (s.free(E),
                    E = s.mallocDouble(a))
                }(e, n + R);
                var D, w = 0, F = 2 * e;
                for (M(w++, 0, 0, n, 0, R, i ? 16 : 0, -1 / 0, 1 / 0),
                i || M(w++, 0, 0, R, 0, n, 1, -1 / 0, 1 / 0); w > 0; ) {
                    var O = (w -= 1) * b
                      , L = T[O]
                      , B = T[O + 1]
                      , N = T[O + 2]
                      , U = T[O + 3]
                      , k = T[O + 4]
                      , V = T[O + 5]
                      , G = w * x
                      , z = E[G]
                      , W = E[G + 1]
                      , X = 1 & V
                      , H = !!(16 & V)
                      , K = c
                      , Y = I
                      , j = C
                      , q = P;
                    if (X && (K = C,
                    Y = P,
                    j = c,
                    q = I),
                    !(2 & V && B >= (N = m(e, L, B, N, K, Y, W)) || 4 & V && (B = g(e, L, B, N, K, Y, z)) >= N)) {
                        var Z = N - B
                          , Q = k - U;
                        if (H) {
                            if (e * Z * (Z + Q) < f) {
                                if (void 0 !== (D = h.scanComplete(e, L, t, B, N, K, Y, U, k, j, q)))
                                    return D;
                                continue
                            }
                        } else {
                            if (e * Math.min(Z, Q) < u) {
                                if (void 0 !== (D = a(e, L, t, X, B, N, K, Y, U, k, j, q)))
                                    return D;
                                continue
                            }
                            if (e * Z * Q < d) {
                                if (void 0 !== (D = h.scanBipartite(e, L, t, X, B, N, K, Y, U, k, j, q)))
                                    return D;
                                continue
                            }
                        }
                        var $ = _(e, L, B, N, K, Y, z, W);
                        if (B < $)
                            if (e * ($ - B) < u) {
                                if (void 0 !== (D = o(e, L + 1, t, B, $, K, Y, U, k, j, q)))
                                    return D
                            } else if (L === e - 2) {
                                if (void 0 !== (D = X ? h.sweepBipartite(e, t, U, k, j, q, B, $, K, Y) : h.sweepBipartite(e, t, B, $, K, Y, U, k, j, q)))
                                    return D
                            } else
                                M(w++, L + 1, B, $, U, k, X, -1 / 0, 1 / 0),
                                M(w++, L + 1, U, k, B, $, 1 ^ X, -1 / 0, 1 / 0);
                        if ($ < N) {
                            var J = l(e, L, U, k, j, q)
                              , ee = j[F * J + L]
                              , te = p(e, L, J, k, j, q, ee);
                            if (te < k && M(w++, L, $, N, te, k, (4 | X) + (H ? 16 : 0), ee, W),
                            U < J && M(w++, L, $, N, U, J, (2 | X) + (H ? 16 : 0), z, ee),
                            J + 1 === te) {
                                if (void 0 !== (D = H ? A(e, L, t, $, N, K, Y, J, j, q[J]) : S(e, L, t, X, $, N, K, Y, J, j, q[J])))
                                    return D
                            } else if (J < te) {
                                var ie;
                                if (H) {
                                    if ($ < (ie = v(e, L, $, N, K, Y, ee))) {
                                        var se = p(e, L, $, ie, K, Y, ee);
                                        if (L === e - 2) {
                                            if ($ < se && void 0 !== (D = h.sweepComplete(e, t, $, se, K, Y, J, te, j, q)))
                                                return D;
                                            if (se < ie && void 0 !== (D = h.sweepBipartite(e, t, se, ie, K, Y, J, te, j, q)))
                                                return D
                                        } else
                                            $ < se && M(w++, L + 1, $, se, J, te, 16, -1 / 0, 1 / 0),
                                            se < ie && (M(w++, L + 1, se, ie, J, te, 0, -1 / 0, 1 / 0),
                                            M(w++, L + 1, J, te, se, ie, 1, -1 / 0, 1 / 0))
                                    }
                                } else
                                    $ < (ie = X ? y(e, L, $, N, K, Y, ee) : v(e, L, $, N, K, Y, ee)) && (L === e - 2 ? D = X ? h.sweepBipartite(e, t, J, te, j, q, $, ie, K, Y) : h.sweepBipartite(e, t, $, ie, K, Y, J, te, j, q) : (M(w++, L + 1, $, ie, J, te, X, -1 / 0, 1 / 0),
                                    M(w++, L + 1, J, te, $, ie, 1 ^ X, -1 / 0, 1 / 0)))
                            }
                        }
                    }
                }
            }
            ;
            var s = i(6325)
              , r = i(973)
              , n = i(482)
              , a = n.partial
              , o = n.full
              , h = i(3146)
              , l = i(2566)
              , c = i(8288)
              , u = 128
              , d = 1 << 22
              , f = 1 << 22
              , _ = c("!(lo>=p0)&&!(p1>=hi)", ["p0", "p1"])
              , p = c("lo===p0", ["p0"])
              , m = c("lo<p0", ["p0"])
              , g = c("hi<=p0", ["p0"])
              , v = c("lo<=p0&&p0<=hi", ["p0"])
              , y = c("lo<p0&&p0<=hi", ["p0"])
              , b = 6
              , x = 2
              , T = s.mallocInt32(1024)
              , E = s.mallocDouble(1024);
            function M(e, t, i, s, r, n, a, o, h) {
                var l = b * e;
                T[l] = t,
                T[l + 1] = i,
                T[l + 2] = s,
                T[l + 3] = r,
                T[l + 4] = n,
                T[l + 5] = a;
                var c = x * e;
                E[c] = o,
                E[c + 1] = h
            }
            function S(e, t, i, s, r, n, a, o, h, l, c) {
                var u = 2 * e
                  , d = h * u
                  , f = l[d + t];
                e: for (var _ = r, p = r * u; _ < n; ++_,
                p += u) {
                    var m = a[p + t]
                      , g = a[p + t + e];
                    if (!(f < m || g < f || s && f === m)) {
                        for (var v, y = o[_], b = t + 1; b < e; ++b) {
                            m = a[p + b],
                            g = a[p + b + e];
                            var x = l[d + b]
                              , T = l[d + b + e];
                            if (g < x || T < m)
                                continue e
                        }
                        if (void 0 !== (v = s ? i(c, y) : i(y, c)))
                            return v
                    }
                }
            }
            function A(e, t, i, s, r, n, a, o, h, l) {
                var c = 2 * e
                  , u = o * c
                  , d = h[u + t];
                e: for (var f = s, _ = s * c; f < r; ++f,
                _ += c) {
                    var p = a[f];
                    if (p !== l) {
                        var m = n[_ + t]
                          , g = n[_ + t + e];
                        if (!(d < m || g < d)) {
                            for (var v = t + 1; v < e; ++v) {
                                m = n[_ + v],
                                g = n[_ + v + e];
                                var y = h[u + v]
                                  , b = h[u + v + e];
                                if (g < y || b < m)
                                    continue e
                            }
                            var x = i(p, l);
                            if (void 0 !== x)
                                return x
                        }
                    }
                }
            }
        }
        ,
        4962: (e, t, i) => {
            e.exports = function() {
                var e = this;
                this.components = {},
                this.comps = this.components;
                var t = this.components
                  , i = 1
                  , r = {}
                  , n = []
                  , a = []
                  , o = {
                    timeout: !1,
                    removals: [],
                    multiComps: []
                };
                function h(e, i) {
                    var s = t[i]
                      , n = r[i]
                      , a = n.hash[e];
                    a && (n.remove(e),
                    s.onRemove && (s.multi ? (a.forEach((t => {
                        t && s.onRemove(e, t)
                    }
                    )),
                    a.length = 0) : s.onRemove(e, a)),
                    o.removals.push(n),
                    l())
                }
                function l() {
                    o.timeout || (o.timeout = !0,
                    setTimeout(c, 1))
                }
                function c() {
                    o.timeout = !1,
                    u()
                }
                function u() {
                    o.multiComps.length && function(e) {
                        for (var t = 0; t < e.length; t++) {
                            var {entID: i, data: s} = e[t]
                              , r = s.hash[i];
                            if (r) {
                                for (var n = 0; n < r.length; n++)
                                    r[n] || (r.splice(n, 1),
                                    n--);
                                0 === r.length && (s.remove(i),
                                o.removals.push(s))
                            }
                        }
                        e.length = 0
                    }(o.multiComps),
                    o.removals.length && function(e) {
                        for (var t = 0; t < e.length; t++)
                            e[t].flush();
                        e.length = 0
                    }(o.removals)
                }
                this._storage = r,
                this._systems = n,
                this._renderSystems = a,
                this.createEntity = function(t) {
                    var s = i++;
                    return Array.isArray(t) && t.forEach((t => e.addComponent(s, t))),
                    s
                }
                ,
                this.deleteEntity = function(t) {
                    return Object.keys(r).forEach((e => {
                        r[e].hash[t] && h(t, e)
                    }
                    )),
                    e
                }
                ,
                this.createComponent = function(e) {
                    if (!e)
                        throw new Error("Missing component definition");
                    var i = e.name;
                    if (!i)
                        throw new Error("Component definition must have a name property.");
                    if ("string" != typeof i)
                        throw new Error("Component name must be a string.");
                    if ("" === i)
                        throw new Error("Component name must be a non-empty string.");
                    if (r[i])
                        throw new Error(`Component ${i} already exists.`);
                    var o = {};
                    return o.name = i,
                    o.multi = !!e.multi,
                    o.order = isNaN(e.order) ? 99 : e.order,
                    o.state = e.state || {},
                    o.onAdd = e.onAdd || null,
                    o.onRemove = e.onRemove || null,
                    o.system = e.system || null,
                    o.renderSystem = e.renderSystem || null,
                    t[i] = o,
                    r[i] = new s,
                    r[i]._pendingMultiCleanup = !1,
                    r[i]._multiCleanupIDs = o.multi ? [] : null,
                    o.system && (n.push(i),
                    n.sort(( (e, i) => t[e].order - t[i].order))),
                    o.renderSystem && (a.push(i),
                    a.sort(( (e, i) => t[e].order - t[i].order))),
                    i
                }
                ,
                this.overwriteComponent = function(e, i) {
                    var s = t[e];
                    if (!s)
                        throw new Error(`Unknown component: ${e}`);
                    if (!i)
                        throw new Error("Missing component definition");
                    if (s.name !== i.name)
                        throw new Error("Overwriting component must use the same name property.");
                    var o = {};
                    o.name = e,
                    o.multi = !!i.multi,
                    o.order = isNaN(i.order) ? 99 : i.order,
                    o.state = i.state || {},
                    o.onAdd = i.onAdd || null,
                    o.onRemove = i.onRemove || null,
                    o.system = i.system || null,
                    o.renderSystem = i.renderSystem || null,
                    t[e] = o,
                    r[e]._pendingMultiCleanup = !1,
                    r[e]._multiCleanupIDs = o.multi ? [] : null;
                    var h = n.indexOf(e);
                    o.system && h < 0 && n.push(e),
                    !o.system && h >= 0 && n.splice(h, 1),
                    n.sort(( (e, i) => t[e].order - t[i].order));
                    var l = a.indexOf(e);
                    o.renderSystem && l < 0 && a.push(e),
                    !o.renderSystem && l >= 0 && a.splice(l, 1),
                    a.sort(( (e, i) => t[e].order - t[i].order));
                    var c = o.state;
                    return this.getStatesList(e).forEach((e => {
                        for (var t in c)
                            t in e || (e[t] = c[t]);
                        o.onAdd && o.onAdd(e.__id, e)
                    }
                    )),
                    e
                }
                ,
                this.deleteComponent = function(i) {
                    var s = r[i];
                    if (!s)
                        throw new Error(`Unknown component: ${i}`);
                    s.flush(),
                    s.list.forEach((e => {
                        e && h(e.__id || e[0].__id, i)
                    }
                    ));
                    var o = n.indexOf(i)
                      , l = a.indexOf(i);
                    return o > -1 && n.splice(o, 1),
                    l > -1 && a.splice(l, 1),
                    r[i].dispose(),
                    delete r[i],
                    delete t[i],
                    e
                }
                ,
                this.addComponent = function(e, i, s) {
                    var n = t[i]
                      , a = r[i];
                    if (!a)
                        throw new Error(`Unknown component: ${i}.`);
                    if (a.hash[e] && !n.multi)
                        throw new Error(`Entity ${e} already has component: ${i}.`);
                    var o = Object.assign({}, {
                        __id: e
                    }, n.state, s);
                    if (o.__id = e,
                    n.multi) {
                        var h = a.hash[e];
                        h || (h = [],
                        a.add(e, h)),
                        h.push(o)
                    } else
                        a.add(e, o);
                    return n.onAdd && n.onAdd(e, o),
                    this
                }
                ,
                this.hasComponent = function(e, t) {
                    var i = r[t];
                    if (!i)
                        throw new Error(`Unknown component: ${t}.`);
                    return !!i.hash[e]
                }
                ,
                this.removeComponent = function(t, i) {
                    if (!r[i])
                        throw new Error(`Unknown component: ${i}.`);
                    return h(t, i),
                    e
                }
                ,
                this.getState = function(e, t) {
                    var i = r[t];
                    if (!i)
                        throw new Error(`Unknown component: ${t}.`);
                    return i.hash[e]
                }
                ,
                this.getStatesList = function(e) {
                    var t = r[e];
                    if (!t)
                        throw new Error(`Unknown component: ${e}.`);
                    return u(),
                    t.list
                }
                ,
                this.getStateAccessor = function(e) {
                    if (!r[e])
                        throw new Error(`Unknown component: ${e}.`);
                    var t = r[e].hash;
                    return e => t[e]
                }
                ,
                this.getComponentAccessor = function(e) {
                    if (!r[e])
                        throw new Error(`Unknown component: ${e}.`);
                    var t = r[e].hash;
                    return e => !!t[e]
                }
                ,
                this.tick = function(i) {
                    u();
                    for (var s = 0; s < n.length; s++) {
                        var a = n[s]
                          , o = t[a]
                          , h = r[a];
                        o.system(i, h.list),
                        u()
                    }
                    return e
                }
                ,
                this.render = function(i) {
                    u();
                    for (var s = 0; s < a.length; s++) {
                        var n = a[s]
                          , o = t[n]
                          , h = r[n];
                        o.renderSystem(i, h.list),
                        u()
                    }
                    return e
                }
                ,
                this.removeMultiComponent = function(i, s, n) {
                    var a = t[s]
                      , h = r[s];
                    if (!h)
                        throw new Error(`Unknown component: ${s}.`);
                    if (!a.multi)
                        throw new Error("removeMultiComponent called on non-multi component");
                    return function(e, t, i, s) {
                        var r = i.hash[e];
                        if (r) {
                            var n = r[s];
                            n && (r[s] = null,
                            t.onRemove && t.onRemove(e, n),
                            o.multiComps.push({
                                entID: e,
                                data: i
                            }),
                            l())
                        }
                    }(i, a, h, n),
                    e
                }
            }
            ;
            var s = i(6318)
        }
        ,
        4964: e => {
            e.exports = function(e, t) {
                return e[0] === t[0] && e[1] === t[1] && e[2] === t[2]
            }
        }
        ,
        5053: e => {
            e.exports = function(e, t, i) {
                return e[0] = t[0] / i[0],
                e[1] = t[1] / i[1],
                e[2] = t[2] / i[2],
                e
            }
        }
        ,
        5178: e => {
            e.exports = function(e, t) {
                return e[0] = -t[0],
                e[1] = -t[1],
                e[2] = -t[2],
                e
            }
        }
        ,
        5343: e => {
            "use strict";
            function t(e, i, s) {
                var r = 0 | e[s];
                if (r <= 0)
                    return [];
                var n, a = new Array(r);
                if (s === e.length - 1)
                    for (n = 0; n < r; ++n)
                        a[n] = i;
                else
                    for (n = 0; n < r; ++n)
                        a[n] = t(e, i, s + 1);
                return a
            }
            e.exports = function(e, i) {
                switch (void 0 === i && (i = 0),
                typeof e) {
                case "number":
                    if (e > 0)
                        return function(e, t) {
                            var i, s;
                            for (i = new Array(e),
                            s = 0; s < e; ++s)
                                i[s] = t;
                            return i
                        }(0 | e, i);
                    break;
                case "object":
                    if ("number" == typeof e.length)
                        return t(e, i, 0)
                }
                return []
            }
        }
        ,
        5421: e => {
            e.exports = function(e, t) {
                return e[0] = Math.ceil(t[0]),
                e[1] = Math.ceil(t[1]),
                e[2] = Math.ceil(t[2]),
                e
            }
        }
        ,
        5930: e => {
            e.exports = function(e, t) {
                return e[0] = Math.round(t[0]),
                e[1] = Math.round(t[1]),
                e[2] = Math.round(t[2]),
                e
            }
        }
        ,
        6318: e => {
            function t(e, t) {
                var i = e._map[t];
                if (delete e.hash[t],
                delete e._map[t],
                i === e.list.length - 1)
                    e.list.pop();
                else {
                    var s = e.list.pop();
                    if (e.list[i] = s,
                    null === s || null === s[0]) {
                        var r = e.list.length;
                        for (var n in e._map)
                            if (e._map[n] === r)
                                return void (e._map[n] = i)
                    } else {
                        var a = s.__id || s[0].__id;
                        e._map[a] = i
                    }
                }
            }
            e.exports = class {
                constructor() {
                    this.list = [],
                    this.hash = {},
                    this._map = {},
                    this._pendingRemovals = []
                }
                add(e, t) {
                    if ("number" == typeof this._map[e]) {
                        var i = this._map[e];
                        this.hash[e] = t,
                        this.list[i] = t
                    } else
                        this._map[e] = this.list.length,
                        this.hash[e] = t,
                        this.list.push(t)
                }
                remove(e) {
                    var t = this._map[e];
                    this.hash[e] = null,
                    this.list[t] = null,
                    this._pendingRemovals.push(e)
                }
                dispose() {
                    this.list = null,
                    this.hash = null,
                    this._map = null,
                    this._pendingRemovals.length = 0
                }
                flush() {
                    for (var e = 0; e < this._pendingRemovals.length; e++) {
                        var i = this._pendingRemovals[e];
                        null === this.hash[i] && t(this, i)
                    }
                    this._pendingRemovals.length = 0
                }
            }
        }
        ,
        6325: (e, t, i) => {
            "use strict";
            var s = i(973)
              , r = i(5343)
              , n = i(7206);
            i.g.__TYPEDARRAY_POOL || (i.g.__TYPEDARRAY_POOL = {
                UINT8: r([32, 0]),
                UINT16: r([32, 0]),
                UINT32: r([32, 0]),
                INT8: r([32, 0]),
                INT16: r([32, 0]),
                INT32: r([32, 0]),
                FLOAT: r([32, 0]),
                DOUBLE: r([32, 0]),
                DATA: r([32, 0]),
                UINT8C: r([32, 0]),
                BUFFER: r([32, 0])
            });
            var a = "undefined" != typeof Uint8ClampedArray
              , o = i.g.__TYPEDARRAY_POOL;
            o.UINT8C || (o.UINT8C = r([32, 0])),
            o.BUFFER || (o.BUFFER = r([32, 0]));
            var h = o.DATA
              , l = o.BUFFER;
            function c(e) {
                if (e) {
                    var t = e.length || e.byteLength
                      , i = s.log2(t);
                    h[i].push(e)
                }
            }
            function u(e) {
                e = s.nextPow2(e);
                var t = s.log2(e)
                  , i = h[t];
                return i.length > 0 ? i.pop() : new ArrayBuffer(e)
            }
            function d(e) {
                return new Uint8Array(u(e),0,e)
            }
            function f(e) {
                return new Uint16Array(u(2 * e),0,e)
            }
            function _(e) {
                return new Uint32Array(u(4 * e),0,e)
            }
            function p(e) {
                return new Int8Array(u(e),0,e)
            }
            function m(e) {
                return new Int16Array(u(2 * e),0,e)
            }
            function g(e) {
                return new Int32Array(u(4 * e),0,e)
            }
            function v(e) {
                return new Float32Array(u(4 * e),0,e)
            }
            function y(e) {
                return new Float64Array(u(8 * e),0,e)
            }
            function b(e) {
                return a ? new Uint8ClampedArray(u(e),0,e) : d(e)
            }
            function x(e) {
                return new DataView(u(e),0,e)
            }
            t.free = function(e) {
                if (n(e))
                    l[s.log2(e.length)].push(e);
                else {
                    if ("[object ArrayBuffer]" !== Object.prototype.toString.call(e) && (e = e.buffer),
                    !e)
                        return;
                    var t = e.length || e.byteLength
                      , i = 0 | s.log2(t);
                    h[i].push(e)
                }
            }
            ,
            t.freeUint8 = t.freeUint16 = t.freeUint32 = t.freeInt8 = t.freeInt16 = t.freeInt32 = t.freeFloat32 = t.freeFloat = t.freeFloat64 = t.freeDouble = t.freeUint8Clamped = t.freeDataView = function(e) {
                c(e.buffer)
            }
            ,
            t.freeArrayBuffer = c,
            t.freeBuffer = function(e) {
                l[s.log2(e.length)].push(e)
            }
            ,
            t.malloc = function(e, t) {
                if (void 0 === t || "arraybuffer" === t)
                    return u(e);
                switch (t) {
                case "uint8":
                    return d(e);
                case "uint16":
                    return f(e);
                case "uint32":
                    return _(e);
                case "int8":
                    return p(e);
                case "int16":
                    return m(e);
                case "int32":
                    return g(e);
                case "float":
                case "float32":
                    return v(e);
                case "double":
                case "float64":
                    return y(e);
                case "uint8_clamped":
                    return b(e);
                case "buffer":
                    throw "Buffer not supported";
                case "data":
                case "dataview":
                    return x(e);
                default:
                    return null
                }
                return null
            }
            ,
            t.mallocArrayBuffer = u,
            t.mallocUint8 = d,
            t.mallocUint16 = f,
            t.mallocUint32 = _,
            t.mallocInt8 = p,
            t.mallocInt16 = m,
            t.mallocInt32 = g,
            t.mallocFloat32 = t.mallocFloat = v,
            t.mallocFloat64 = t.mallocDouble = y,
            t.mallocUint8Clamped = b,
            t.mallocDataView = x,
            t.clearCache = function() {
                for (var e = 0; e < 32; ++e)
                    o.UINT8[e].length = 0,
                    o.UINT16[e].length = 0,
                    o.UINT32[e].length = 0,
                    o.INT8[e].length = 0,
                    o.INT16[e].length = 0,
                    o.INT32[e].length = 0,
                    o.FLOAT[e].length = 0,
                    o.DOUBLE[e].length = 0,
                    o.UINT8C[e].length = 0,
                    h[e].length = 0,
                    l[e].length = 0
            }
        }
        ,
        6591: e => {
            e.exports = function(e) {
                var t = new Float32Array(3);
                return t[0] = e[0],
                t[1] = e[1],
                t[2] = e[2],
                t
            }
        }
        ,
        6936: e => {
            e.exports = function(e, t, i) {
                return e[0] = t[0] * i[0],
                e[1] = t[1] * i[1],
                e[2] = t[2] * i[2],
                e
            }
        }
        ,
        7007: e => {
            "use strict";
            var t, i = "object" == typeof Reflect ? Reflect : null, s = i && "function" == typeof i.apply ? i.apply : function(e, t, i) {
                return Function.prototype.apply.call(e, t, i)
            }
            ;
            t = i && "function" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function(e) {
                return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
            }
            : function(e) {
                return Object.getOwnPropertyNames(e)
            }
            ;
            var r = Number.isNaN || function(e) {
                return e != e
            }
            ;
            function n() {
                n.init.call(this)
            }
            e.exports = n,
            e.exports.once = function(e, t) {
                return new Promise((function(i, s) {
                    function r(i) {
                        e.removeListener(t, n),
                        s(i)
                    }
                    function n() {
                        "function" == typeof e.removeListener && e.removeListener("error", r),
                        i([].slice.call(arguments))
                    }
                    p(e, t, n, {
                        once: !0
                    }),
                    "error" !== t && function(e, t) {
                        "function" == typeof e.on && p(e, "error", t, {
                            once: !0
                        })
                    }(e, r)
                }
                ))
            }
            ,
            n.EventEmitter = n,
            n.prototype._events = void 0,
            n.prototype._eventsCount = 0,
            n.prototype._maxListeners = void 0;
            var a = 10;
            function o(e) {
                if ("function" != typeof e)
                    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
            }
            function h(e) {
                return void 0 === e._maxListeners ? n.defaultMaxListeners : e._maxListeners
            }
            function l(e, t, i, s) {
                var r, n, a, l;
                if (o(i),
                void 0 === (n = e._events) ? (n = e._events = Object.create(null),
                e._eventsCount = 0) : (void 0 !== n.newListener && (e.emit("newListener", t, i.listener ? i.listener : i),
                n = e._events),
                a = n[t]),
                void 0 === a)
                    a = n[t] = i,
                    ++e._eventsCount;
                else if ("function" == typeof a ? a = n[t] = s ? [i, a] : [a, i] : s ? a.unshift(i) : a.push(i),
                (r = h(e)) > 0 && a.length > r && !a.warned) {
                    a.warned = !0;
                    var c = new Error("Possible EventEmitter memory leak detected. " + a.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
                    c.name = "MaxListenersExceededWarning",
                    c.emitter = e,
                    c.type = t,
                    c.count = a.length,
                    l = c,
                    console && console.warn && console.warn(l)
                }
                return e
            }
            function c() {
                if (!this.fired)
                    return this.target.removeListener(this.type, this.wrapFn),
                    this.fired = !0,
                    0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
            }
            function u(e, t, i) {
                var s = {
                    fired: !1,
                    wrapFn: void 0,
                    target: e,
                    type: t,
                    listener: i
                }
                  , r = c.bind(s);
                return r.listener = i,
                s.wrapFn = r,
                r
            }
            function d(e, t, i) {
                var s = e._events;
                if (void 0 === s)
                    return [];
                var r = s[t];
                return void 0 === r ? [] : "function" == typeof r ? i ? [r.listener || r] : [r] : i ? function(e) {
                    for (var t = new Array(e.length), i = 0; i < t.length; ++i)
                        t[i] = e[i].listener || e[i];
                    return t
                }(r) : _(r, r.length)
            }
            function f(e) {
                var t = this._events;
                if (void 0 !== t) {
                    var i = t[e];
                    if ("function" == typeof i)
                        return 1;
                    if (void 0 !== i)
                        return i.length
                }
                return 0
            }
            function _(e, t) {
                for (var i = new Array(t), s = 0; s < t; ++s)
                    i[s] = e[s];
                return i
            }
            function p(e, t, i, s) {
                if ("function" == typeof e.on)
                    s.once ? e.once(t, i) : e.on(t, i);
                else {
                    if ("function" != typeof e.addEventListener)
                        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
                    e.addEventListener(t, (function r(n) {
                        s.once && e.removeEventListener(t, r),
                        i(n)
                    }
                    ))
                }
            }
            Object.defineProperty(n, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                    return a
                },
                set: function(e) {
                    if ("number" != typeof e || e < 0 || r(e))
                        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
                    a = e
                }
            }),
            n.init = function() {
                void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null),
                this._eventsCount = 0),
                this._maxListeners = this._maxListeners || void 0
            }
            ,
            n.prototype.setMaxListeners = function(e) {
                if ("number" != typeof e || e < 0 || r(e))
                    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
                return this._maxListeners = e,
                this
            }
            ,
            n.prototype.getMaxListeners = function() {
                return h(this)
            }
            ,
            n.prototype.emit = function(e) {
                for (var t = [], i = 1; i < arguments.length; i++)
                    t.push(arguments[i]);
                var r = "error" === e
                  , n = this._events;
                if (void 0 !== n)
                    r = r && void 0 === n.error;
                else if (!r)
                    return !1;
                if (r) {
                    var a;
                    if (t.length > 0 && (a = t[0]),
                    a instanceof Error)
                        throw a;
                    var o = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
                    throw o.context = a,
                    o
                }
                var h = n[e];
                if (void 0 === h)
                    return !1;
                if ("function" == typeof h)
                    s(h, this, t);
                else {
                    var l = h.length
                      , c = _(h, l);
                    for (i = 0; i < l; ++i)
                        s(c[i], this, t)
                }
                return !0
            }
            ,
            n.prototype.addListener = function(e, t) {
                return l(this, e, t, !1)
            }
            ,
            n.prototype.on = n.prototype.addListener,
            n.prototype.prependListener = function(e, t) {
                return l(this, e, t, !0)
            }
            ,
            n.prototype.once = function(e, t) {
                return o(t),
                this.on(e, u(this, e, t)),
                this
            }
            ,
            n.prototype.prependOnceListener = function(e, t) {
                return o(t),
                this.prependListener(e, u(this, e, t)),
                this
            }
            ,
            n.prototype.removeListener = function(e, t) {
                var i, s, r, n, a;
                if (o(t),
                void 0 === (s = this._events))
                    return this;
                if (void 0 === (i = s[e]))
                    return this;
                if (i === t || i.listener === t)
                    0 == --this._eventsCount ? this._events = Object.create(null) : (delete s[e],
                    s.removeListener && this.emit("removeListener", e, i.listener || t));
                else if ("function" != typeof i) {
                    for (r = -1,
                    n = i.length - 1; n >= 0; n--)
                        if (i[n] === t || i[n].listener === t) {
                            a = i[n].listener,
                            r = n;
                            break
                        }
                    if (r < 0)
                        return this;
                    0 === r ? i.shift() : function(e, t) {
                        for (; t + 1 < e.length; t++)
                            e[t] = e[t + 1];
                        e.pop()
                    }(i, r),
                    1 === i.length && (s[e] = i[0]),
                    void 0 !== s.removeListener && this.emit("removeListener", e, a || t)
                }
                return this
            }
            ,
            n.prototype.off = n.prototype.removeListener,
            n.prototype.removeAllListeners = function(e) {
                var t, i, s;
                if (void 0 === (i = this._events))
                    return this;
                if (void 0 === i.removeListener)
                    return 0 === arguments.length ? (this._events = Object.create(null),
                    this._eventsCount = 0) : void 0 !== i[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete i[e]),
                    this;
                if (0 === arguments.length) {
                    var r, n = Object.keys(i);
                    for (s = 0; s < n.length; ++s)
                        "removeListener" !== (r = n[s]) && this.removeAllListeners(r);
                    return this.removeAllListeners("removeListener"),
                    this._events = Object.create(null),
                    this._eventsCount = 0,
                    this
                }
                if ("function" == typeof (t = i[e]))
                    this.removeListener(e, t);
                else if (void 0 !== t)
                    for (s = t.length - 1; s >= 0; s--)
                        this.removeListener(e, t[s]);
                return this
            }
            ,
            n.prototype.listeners = function(e) {
                return d(this, e, !0)
            }
            ,
            n.prototype.rawListeners = function(e) {
                return d(this, e, !1)
            }
            ,
            n.listenerCount = function(e, t) {
                return "function" == typeof e.listenerCount ? e.listenerCount(t) : f.call(e, t)
            }
            ,
            n.prototype.listenerCount = f,
            n.prototype.eventNames = function() {
                return this._eventsCount > 0 ? t(this._events) : []
            }
        }
        ,
        7206: e => {
            e.exports = function(e) {
                return null != e && null != e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
            }
        }
        ,
        7258: (e, t, i) => {
            "use strict";
            e.exports = function(e, t, i) {
                switch (arguments.length) {
                case 1:
                    return s = [],
                    l(r = e, r, c, !0),
                    s;
                case 2:
                    return "function" == typeof t ? l(e, e, t, !0) : function(e, t) {
                        return s = [],
                        l(e, t, c, !1),
                        s
                    }(e, t);
                case 3:
                    return l(e, t, i, !1);
                default:
                    throw new Error("box-intersect: Invalid arguments")
                }
                var r
            }
            ;
            var s, r = i(6325), n = i(3146), a = i(4931);
            function o(e, t) {
                for (var i = 0; i < e; ++i)
                    if (!(t[i] <= t[i + e]))
                        return !0;
                return !1
            }
            function h(e, t, i, s) {
                for (var r = 0, n = 0, a = 0, h = e.length; a < h; ++a) {
                    var l = e[a];
                    if (!o(t, l)) {
                        for (var c = 0; c < 2 * t; ++c)
                            i[r++] = l[c];
                        s[n++] = a
                    }
                }
                return n
            }
            function l(e, t, i, s) {
                var o = e.length
                  , l = t.length;
                if (!(o <= 0 || l <= 0)) {
                    var c = e[0].length >>> 1;
                    if (!(c <= 0)) {
                        var u, d = r.mallocDouble(2 * c * o), f = r.mallocInt32(o);
                        if ((o = h(e, c, d, f)) > 0) {
                            if (1 === c && s)
                                n.init(o),
                                u = n.sweepComplete(c, i, 0, o, d, f, 0, o, d, f);
                            else {
                                var _ = r.mallocDouble(2 * c * l)
                                  , p = r.mallocInt32(l);
                                (l = h(t, c, _, p)) > 0 && (n.init(o + l),
                                u = 1 === c ? n.sweepBipartite(c, i, 0, o, d, f, 0, l, _, p) : a(c, i, s, o, d, f, l, _, p),
                                r.free(_),
                                r.free(p))
                            }
                            r.free(d),
                            r.free(f)
                        }
                        return u
                    }
                }
            }
            function c(e, t) {
                s.push([e, t])
            }
        }
        ,
        8051: e => {
            e.exports = function(e, t) {
                var i = t[0] - e[0]
                  , s = t[1] - e[1]
                  , r = t[2] - e[2];
                return Math.sqrt(i * i + s * s + r * r)
            }
        }
        ,
        8104: e => {
            e.exports = function(e, t, i, s) {
                var r = i[0]
                  , n = i[2]
                  , a = t[0] - r
                  , o = t[2] - n
                  , h = Math.sin(s)
                  , l = Math.cos(s);
                return e[0] = r + o * h + a * l,
                e[1] = t[1],
                e[2] = n + o * l - a * h,
                e
            }
        }
        ,
        8288: e => {
            "use strict";
            e.exports = function(e, i) {
                var s = "abcdef".split("").concat(i)
                  , r = [];
                return e.indexOf("lo") >= 0 && r.push("lo=e[k+n]"),
                e.indexOf("hi") >= 0 && r.push("hi=e[k+o]"),
                s.push(t.replace("_", r.join()).replace("$", e)),
                Function.apply(void 0, s)
            }
            ;
            var t = "for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m"
        }
        ,
        8317: e => {
            e.exports = function(e, t, i) {
                var s = t[0]
                  , r = t[1]
                  , n = t[2];
                return e[0] = s * i[0] + r * i[3] + n * i[6],
                e[1] = s * i[1] + r * i[4] + n * i[7],
                e[2] = s * i[2] + r * i[5] + n * i[8],
                e
            }
        }
        ,
        8655: (e, t, i) => {
            var s = i(2219)
              , r = i(9757)
              , n = "undefined" != typeof Float64Array;
            function a(e, t) {
                return e[0] - t[0]
            }
            function o() {
                var e, t = this.stride, i = new Array(t.length);
                for (e = 0; e < i.length; ++e)
                    i[e] = [Math.abs(t[e]), e];
                i.sort(a);
                var s = new Array(i.length);
                for (e = 0; e < s.length; ++e)
                    s[e] = i[e][1];
                return s
            }
            function h(e, t) {
                var i = ["View", t, "d", e].join("");
                t < 0 && (i = "View_Nil" + e);
                var r = "generic" === e;
                if (-1 === t) {
                    var n = "function " + i + "(a){this.data=a;};var proto=" + i + ".prototype;proto.dtype='" + e + "';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new " + i + "(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_" + i + "(a){return new " + i + "(a);}";
                    return new Function(n)()
                }
                if (0 === t)
                    return n = "function " + i + "(a,d) {this.data = a;this.offset = d};var proto=" + i + ".prototype;proto.dtype='" + e + "';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function " + i + "_copy() {return new " + i + "(this.data,this.offset)};proto.pick=function " + i + "_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function " + i + "_get(){return " + (r ? "this.data.get(this.offset)" : "this.data[this.offset]") + "};proto.set=function " + i + "_set(v){return " + (r ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v") + "};return function construct_" + i + "(a,b,c,d){return new " + i + "(a,d)}",
                    new Function("TrivialArray",n)(l[e][0]);
                n = ["'use strict'"];
                var a = s(t)
                  , h = a.map((function(e) {
                    return "i" + e
                }
                ))
                  , c = "this.offset+" + a.map((function(e) {
                    return "this.stride[" + e + "]*i" + e
                }
                )).join("+")
                  , u = a.map((function(e) {
                    return "b" + e
                }
                )).join(",")
                  , d = a.map((function(e) {
                    return "c" + e
                }
                )).join(",");
                n.push("function " + i + "(a," + u + "," + d + ",d){this.data=a", "this.shape=[" + u + "]", "this.stride=[" + d + "]", "this.offset=d|0}", "var proto=" + i + ".prototype", "proto.dtype='" + e + "'", "proto.dimension=" + t),
                n.push("Object.defineProperty(proto,'size',{get:function " + i + "_size(){return " + a.map((function(e) {
                    return "this.shape[" + e + "]"
                }
                )).join("*"), "}})"),
                1 === t ? n.push("proto.order=[0]") : (n.push("Object.defineProperty(proto,'order',{get:"),
                t < 4 ? (n.push("function " + i + "_order(){"),
                2 === t ? n.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})") : 3 === t && n.push("var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})")) : n.push("ORDER})")),
                n.push("proto.set=function " + i + "_set(" + h.join(",") + ",v){"),
                r ? n.push("return this.data.set(" + c + ",v)}") : n.push("return this.data[" + c + "]=v}"),
                n.push("proto.get=function " + i + "_get(" + h.join(",") + "){"),
                r ? n.push("return this.data.get(" + c + ")}") : n.push("return this.data[" + c + "]}"),
                n.push("proto.index=function " + i + "_index(", h.join(), "){return " + c + "}"),
                n.push("proto.hi=function " + i + "_hi(" + h.join(",") + "){return new " + i + "(this.data," + a.map((function(e) {
                    return ["(typeof i", e, "!=='number'||i", e, "<0)?this.shape[", e, "]:i", e, "|0"].join("")
                }
                )).join(",") + "," + a.map((function(e) {
                    return "this.stride[" + e + "]"
                }
                )).join(",") + ",this.offset)}");
                var f = a.map((function(e) {
                    return "a" + e + "=this.shape[" + e + "]"
                }
                ))
                  , _ = a.map((function(e) {
                    return "c" + e + "=this.stride[" + e + "]"
                }
                ));
                n.push("proto.lo=function " + i + "_lo(" + h.join(",") + "){var b=this.offset,d=0," + f.join(",") + "," + _.join(","));
                for (var p = 0; p < t; ++p)
                    n.push("if(typeof i" + p + "==='number'&&i" + p + ">=0){d=i" + p + "|0;b+=c" + p + "*d;a" + p + "-=d}");
                for (n.push("return new " + i + "(this.data," + a.map((function(e) {
                    return "a" + e
                }
                )).join(",") + "," + a.map((function(e) {
                    return "c" + e
                }
                )).join(",") + ",b)}"),
                n.push("proto.step=function " + i + "_step(" + h.join(",") + "){var " + a.map((function(e) {
                    return "a" + e + "=this.shape[" + e + "]"
                }
                )).join(",") + "," + a.map((function(e) {
                    return "b" + e + "=this.stride[" + e + "]"
                }
                )).join(",") + ",c=this.offset,d=0,ceil=Math.ceil"),
                p = 0; p < t; ++p)
                    n.push("if(typeof i" + p + "==='number'){d=i" + p + "|0;if(d<0){c+=b" + p + "*(a" + p + "-1);a" + p + "=ceil(-a" + p + "/d)}else{a" + p + "=ceil(a" + p + "/d)}b" + p + "*=d}");
                n.push("return new " + i + "(this.data," + a.map((function(e) {
                    return "a" + e
                }
                )).join(",") + "," + a.map((function(e) {
                    return "b" + e
                }
                )).join(",") + ",c)}");
                var m = new Array(t)
                  , g = new Array(t);
                for (p = 0; p < t; ++p)
                    m[p] = "a[i" + p + "]",
                    g[p] = "b[i" + p + "]";
                for (n.push("proto.transpose=function " + i + "_transpose(" + h + "){" + h.map((function(e, t) {
                    return e + "=(" + e + "===undefined?" + t + ":" + e + "|0)"
                }
                )).join(";"), "var a=this.shape,b=this.stride;return new " + i + "(this.data," + m.join(",") + "," + g.join(",") + ",this.offset)}"),
                n.push("proto.pick=function " + i + "_pick(" + h + "){var a=[],b=[],c=this.offset"),
                p = 0; p < t; ++p)
                    n.push("if(typeof i" + p + "==='number'&&i" + p + ">=0){c=(c+this.stride[" + p + "]*i" + p + ")|0}else{a.push(this.shape[" + p + "]);b.push(this.stride[" + p + "])}");
                return n.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}"),
                n.push("return function construct_" + i + "(data,shape,stride,offset){return new " + i + "(data," + a.map((function(e) {
                    return "shape[" + e + "]"
                }
                )).join(",") + "," + a.map((function(e) {
                    return "stride[" + e + "]"
                }
                )).join(",") + ",offset)}"),
                new Function("CTOR_LIST","ORDER",n.join("\n"))(l[e], o)
            }
            var l = {
                float32: [],
                float64: [],
                int8: [],
                int16: [],
                int32: [],
                uint8: [],
                uint16: [],
                uint32: [],
                array: [],
                uint8_clamped: [],
                bigint64: [],
                biguint64: [],
                buffer: [],
                generic: []
            };
            e.exports = function(e, t, i, s) {
                if (void 0 === e)
                    return (0,
                    l.array[0])([]);
                "number" == typeof e && (e = [e]),
                void 0 === t && (t = [e.length]);
                var a = t.length;
                if (void 0 === i) {
                    i = new Array(a);
                    for (var o = a - 1, c = 1; o >= 0; --o)
                        i[o] = c,
                        c *= t[o]
                }
                if (void 0 === s)
                    for (s = 0,
                    o = 0; o < a; ++o)
                        i[o] < 0 && (s -= (t[o] - 1) * i[o]);
                for (var u = function(e) {
                    if (r(e))
                        return "buffer";
                    if (n)
                        switch (Object.prototype.toString.call(e)) {
                        case "[object Float64Array]":
                            return "float64";
                        case "[object Float32Array]":
                            return "float32";
                        case "[object Int8Array]":
                            return "int8";
                        case "[object Int16Array]":
                            return "int16";
                        case "[object Int32Array]":
                            return "int32";
                        case "[object Uint8Array]":
                            return "uint8";
                        case "[object Uint16Array]":
                            return "uint16";
                        case "[object Uint32Array]":
                            return "uint32";
                        case "[object Uint8ClampedArray]":
                            return "uint8_clamped";
                        case "[object BigInt64Array]":
                            return "bigint64";
                        case "[object BigUint64Array]":
                            return "biguint64"
                        }
                    return Array.isArray(e) ? "array" : "generic"
                }(e), d = l[u]; d.length <= a + 1; )
                    d.push(h(u, d.length - 1));
                return (0,
                d[a + 1])(e, t, i, s)
            }
        }
        ,
        8817: (e, t, i) => {
            e.exports = function(e, t) {
                var i = e[0]
                  , r = e[1]
                  , n = e[2]
                  , a = t[0]
                  , o = t[1]
                  , h = t[2];
                return Math.abs(i - a) <= s * Math.max(1, Math.abs(i), Math.abs(a)) && Math.abs(r - o) <= s * Math.max(1, Math.abs(r), Math.abs(o)) && Math.abs(n - h) <= s * Math.max(1, Math.abs(n), Math.abs(h))
            }
            ;
            var s = i(2864)
        }
        ,
        9059: e => {
            e.exports = function(e) {
                var t = e[0]
                  , i = e[1]
                  , s = e[2];
                return t * t + i * i + s * s
            }
        }
        ,
        9137: e => {
            e.exports = function(e, t, i, s) {
                var r = i[0]
                  , n = i[1]
                  , a = t[0] - r
                  , o = t[1] - n
                  , h = Math.sin(s)
                  , l = Math.cos(s);
                return e[0] = r + a * l - o * h,
                e[1] = n + a * h + o * l,
                e[2] = t[2],
                e
            }
        }
        ,
        9200: e => {
            e.exports = function(e, t, i) {
                return e[0] = Math.max(t[0], i[0]),
                e[1] = Math.max(t[1], i[1]),
                e[2] = Math.max(t[2], i[2]),
                e
            }
        }
        ,
        9692: e => {
            "use strict";
            e.exports = function(e, t, i, s, r, n) {
                var a = +t[0]
                  , o = +t[1]
                  , h = +t[2]
                  , l = +i[0]
                  , c = +i[1]
                  , u = +i[2]
                  , d = Math.sqrt(l * l + c * c + u * u);
                if (0 === d)
                    throw new Error("Can't raycast along a zero vector");
                return function(e, t, i, s, r, n, a, o, h, l) {
                    for (var c = 0, u = Math.floor, d = 0 | u(t), f = 0 | u(i), _ = 0 | u(s), p = r > 0 ? 1 : -1, m = n > 0 ? 1 : -1, g = a > 0 ? 1 : -1, v = Math.abs(1 / r), y = Math.abs(1 / n), b = Math.abs(1 / a), x = v < 1 / 0 ? v * (p > 0 ? d + 1 - t : t - d) : 1 / 0, T = y < 1 / 0 ? y * (m > 0 ? f + 1 - i : i - f) : 1 / 0, E = b < 1 / 0 ? b * (g > 0 ? _ + 1 - s : s - _) : 1 / 0, M = -1; c <= o; ) {
                        var S = e(d, f, _);
                        if (S)
                            return h && (h[0] = t + c * r,
                            h[1] = i + c * n,
                            h[2] = s + c * a),
                            l && (l[0] = l[1] = l[2] = 0,
                            0 === M && (l[0] = -p),
                            1 === M && (l[1] = -m),
                            2 === M && (l[2] = -g)),
                            S;
                        x < T ? x < E ? (d += p,
                        c = x,
                        x += v,
                        M = 0) : (_ += g,
                        c = E,
                        E += b,
                        M = 2) : T < E ? (f += m,
                        c = T,
                        T += y,
                        M = 1) : (_ += g,
                        c = E,
                        E += b,
                        M = 2)
                    }
                    return h && (h[0] = t + c * r,
                    h[1] = i + c * n,
                    h[2] = s + c * a),
                    l && (l[0] = l[1] = l[2] = 0),
                    0
                }(e, a, o, h, l /= d, c /= d, u /= d, s = void 0 === s ? 64 : +s, r, n)
            }
        }
        ,
        9757: e => {
            function t(e) {
                return !!e.constructor && "function" == typeof e.constructor.isBuffer && e.constructor.isBuffer(e)
            }
            e.exports = function(e) {
                return null != e && (t(e) || function(e) {
                    return "function" == typeof e.readFloatLE && "function" == typeof e.slice && t(e.slice(0, 0))
                }(e) || !!e._isBuffer)
            }
        }
        ,
        9765: (e, t, i) => {
            e.exports = i(4136)
        }
    }
      , t = {};
    function i(s) {
        var r = t[s];
        if (void 0 !== r)
            return r.exports;
        var n = t[s] = {
            exports: {}
        };
        return e[s](n, n.exports, i),
        n.exports
    }
    i.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return i.d(t, {
            a: t
        }),
        t
    }
    ,
    i.d = (e, t) => {
        for (var s in t)
            i.o(t, s) && !i.o(e, s) && Object.defineProperty(e, s, {
                enumerable: !0,
                get: t[s]
            })
    }
    ,
    i.g = function() {
        if ("object" == typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window)
                return window
        }
    }(),
    i.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
    ( () => {
        "use strict";
        i(3625);
        var e = i(7007)
          , t = i.n(e)
          , s = i(4226)
          , r = i.n(s)
          , n = i(8655)
          , a = i.n(n)
          , o = i(9692)
          , h = i.n(o);
        function l() {
            this.preventDefaults = !1,
            this.stopPropagation = !1,
            this.allowContextMenu = !1,
            this.disabled = !1
        }
        class c {
            constructor(t, i) {
                this.version = "0.8.0";
                var s = Object.assign({}, new l, i || {});
                this.element = t || document,
                this.preventDefaults = !!s.preventDefaults,
                this.stopPropagation = !!s.stopPropagation,
                this.allowContextMenu = !!s.allowContextMenu,
                this.disabled = !!s.disabled,
                this.filterEvents = (e, t) => !0,
                this.down = new e.EventEmitter,
                this.up = new e.EventEmitter,
                this.state = {},
                this.pointerState = {
                    dx: 0,
                    dy: 0,
                    scrollx: 0,
                    scrolly: 0,
                    scrollz: 0
                },
                this.pressCount = {},
                this.releaseCount = {},
                this._keyBindmap = {},
                this._keyStates = {},
                this._bindPressCount = {},
                this._touches = {
                    lastX: 0,
                    lastY: 0,
                    currID: null
                },
                this._pressedDuringMeta = {},
                "loading" !== document.readyState ? d(this) : document.addEventListener("DOMContentLoaded", (e => {
                    d(this)
                }
                ), {
                    once: !0
                })
            }
            bind(e, ...t) {
                t.forEach((t => {
                    var i = this._keyBindmap[t] || [];
                    i.includes(e) || (i.push(e),
                    this._keyBindmap[t] = i)
                }
                )),
                this.state[e] = !!this.state[e],
                this.pressCount[e] = this.pressCount[e] || 0,
                this.releaseCount[e] = this.releaseCount[e] || 0
            }
            unbind(e) {
                for (var t in this._keyBindmap) {
                    var i = this._keyBindmap[t]
                      , s = i.indexOf(e);
                    s > -1 && i.splice(s, 1)
                }
            }
            getBindings() {
                var e = {};
                for (var t in this._keyBindmap)
                    this._keyBindmap[t].forEach((i => {
                        e[i] = e[i] || [],
                        e[i].push(t)
                    }
                    ));
                return e
            }
            tick() {
                u(this.pointerState),
                u(this.pressCount),
                u(this.releaseCount)
            }
        }
        function u(e) {
            for (var t in e)
                e[t] = 0
        }
        function d(e) {
            window.addEventListener("keydown", f.bind(null, e, !0), !1),
            window.addEventListener("keyup", f.bind(null, e, !1), !1);
            var t = {
                passive: !0
            };
            window.PointerEvent ? (e.element.addEventListener("pointerdown", _.bind(null, e, !0), t),
            window.document.addEventListener("pointerup", _.bind(null, e, !1), t),
            e.element.addEventListener("pointermove", p.bind(null, e), t)) : (e.element.addEventListener("mousedown", _.bind(null, e, !0), t),
            window.document.addEventListener("mouseup", _.bind(null, e, !1), t),
            e.element.addEventListener("mousemove", p.bind(null, e), t)),
            e.element.addEventListener("wheel", m.bind(null, e), t),
            e.element.addEventListener("contextmenu", g.bind(null, e), !1),
            window.addEventListener("blur", v.bind(null, e), !1)
        }
        function f(e, t, i) {
            y(i.code, t, e, i),
            function(e, t, i) {
                var s = /^Meta/.test(i.code);
                if (i.metaKey && !s && e)
                    t._pressedDuringMeta[i.code] = !0;
                else if (s && !e) {
                    for (var r in t._pressedDuringMeta)
                        t._keyStates[r] && (/^Mouse\d/.test(r) || y(r, !1, t, {
                            code: r,
                            note: "This is a mocked KeyboardEvent made by the 'game-inputs' module",
                            preventDefault: () => {}
                            ,
                            stopPropagation: () => {}
                        }));
                    t._pressedDuringMeta = {}
                }
            }(t, e, i)
        }
        function _(e, t, i) {
            if ("pointerId"in i)
                if (t) {
                    if (null !== e._touches.currID)
                        return;
                    e._touches.currID = i.pointerId
                } else {
                    if (e._touches.currID !== i.pointerId)
                        return;
                    e._touches.currID = null
                }
            return y("Mouse" + ("button"in i ? i.button + 1 : 1), t, e, i),
            !1
        }
        function p(e, t) {
            if (!("pointerId"in t) || null === e._touches.currID || e._touches.currID === t.pointerId) {
                var i = t.movementX || t.mozMovementX || 0
                  , s = t.movementY || t.mozMovementY || 0;
                e.pointerState.dx += i,
                e.pointerState.dy += s
            }
        }
        function m(e, t) {
            var i = 1;
            switch (t.deltaMode) {
            case 0:
                i = 1;
                break;
            case 1:
                i = 12;
                break;
            case 2:
                i = e.element.clientHeight || window.innerHeight
            }
            e.pointerState.scrollx += (t.deltaX || 0) * i,
            e.pointerState.scrolly += (t.deltaY || 0) * i,
            e.pointerState.scrollz += (t.deltaZ || 0) * i
        }
        function g(e, t) {
            if (!e.allowContextMenu)
                return t.preventDefault(),
                !1
        }
        function v(e) {
            for (var t in e._keyStates)
                e._keyStates[t] && (/^Mouse\d/.test(t) || y(t, !1, e, {
                    code: t,
                    note: "This is a mocked KeyboardEvent made by the 'game-inputs' module",
                    preventDefault: () => {}
                    ,
                    stopPropagation: () => {}
                }))
        }
        function y(e, t, i, s) {
            var r = i._keyBindmap[e];
            r && (b(i._keyStates[e], t) && (i._keyStates[e] = t,
            r.forEach((e => {
                (!i.filterEvents || i.filterEvents(s, e)) && function(e, t, i, s) {
                    var r = t ? i.pressCount : i.releaseCount;
                    r[e] = (r[e] || 0) + 1;
                    var n = i._bindPressCount[e] || 0;
                    if ((n += t ? 1 : -1) < 0 && (n = 0),
                    i._bindPressCount[e] = n,
                    b(i.state[e], n)) {
                        i.state[e] = n > 0;
                        var a = t ? i.down : i.up;
                        i.disabled || a.emit(e, s)
                    }
                }(e, t, i, s)
            }
            ))),
            "button"in s || (i.preventDefaults && !s.defaultPrevented && s.preventDefault(),
            i.stopPropagation && s.stopPropagation()))
        }
        function b(e, t) {
            return e ? !t : t
        }
        var x = {
            preventDefaults: !1,
            stopPropagation: !1,
            allowContextMenu: !1
        }
          , T = {
            forward: ["KeyW", "ArrowUp"],
            backward: ["KeyS", "ArrowDown"],
            left: ["KeyA", "ArrowLeft"],
            right: ["KeyD", "ArrowRight"],
            fire: "Mouse1",
            "mid-fire": ["Mouse2", "KeyQ"],
            "alt-fire": ["Mouse3", "KeyE"],
            jump: "Space"
        };
        class E extends c {
            constructor(e, t, i) {
                super(i, t = Object.assign({}, x, t));
                var s = t.bindings || T;
                for (var r in s) {
                    var n = Array.isArray(s[r]) ? s[r] : [s[r]];
                    this.bind(r, ...n)
                }
            }
        }
        class M {
            constructor(e=null, t=10) {
                this.stickyPointerLock = !1,
                this.stickyFullscreen = !1,
                this.tickRate = 30,
                this.maxRenderRate = 0,
                this.maxTickTime = 100,
                this.pointerLock = !1,
                this.fullscreen = !1,
                this.onTick = function(e) {}
                ,
                this.onRender = function(e, t, i) {}
                ,
                this.onInit = function() {}
                ,
                this.onResize = function() {}
                ,
                this.onPointerLockChanged = function(e=!1) {}
                ,
                this.onFullscreenChanged = function(e=!1) {}
                ,
                this.onPointerLockError = function(e) {}
                ,
                this._data = new S(t),
                function(e) {
                    if ("loading" === document.readyState) {
                        var t = () => {
                            document.removeEventListener("readystatechange", t),
                            e()
                        }
                        ;
                        document.addEventListener("readystatechange", t)
                    } else
                        setTimeout(e, 0)
                }(( () => {
                    var t, i, s;
                    s = (i = (t = this)._data).nowObject.now(),
                    i.lastTickStarted = s,
                    i.lastFrameStarted = s,
                    i.lastRenderStarted = s,
                    i.frameCB = () => function(e) {
                        var t = e._data;
                        requestAnimationFrame(t.frameCB),
                        A(e);
                        var i = t.nowObject.now()
                          , s = i - t.lastFrameStarted;
                        if (t.lastFrameStarted = i,
                        e.maxRenderRate > 0) {
                            t.renderAccum += s;
                            var r = 1e3 / e.maxRenderRate;
                            if (t.renderAccum < r)
                                return;
                            t.renderAccum -= r,
                            t.renderAccum > r && (t.renderAccum = r)
                        }
                        var n = i - t.lastRenderStarted;
                        t.lastRenderStarted = i;
                        var a = 1e3 / e.tickRate
                          , o = (i - t.lastTickStarted) / a;
                        o < 0 && (o = 0),
                        e.onRender(n, o, a),
                        setTimeout(A, 0, e, !0)
                    }(t),
                    i.intervalCB = () => A(t),
                    requestAnimationFrame(i.frameCB),
                    i.pollTime > 0 && (i.intervalID = setInterval(i.intervalCB, i.pollTime)),
                    function(e, t) {
                        if (t) {
                            var i = !1
                              , s = !1
                              , r = e => {
                                if (!!e != (i = t === document.pointerLockElement))
                                    if (e) {
                                        var s = t.requestPointerLock();
                                        s && s.catch && s.catch((e => {}
                                        ))
                                    } else
                                        document.exitPointerLock()
                            }
                              , n = e => {
                                !!e != (s = t === document.fullscreenElement) && (e ? t.requestFullscreen ? t.requestFullscreen() : t.webkitRequestFullscreen && t.webkitRequestFullscreen() : document.exitFullscreen ? document.exitFullscreen() : document.webkitExitFullscreen && document.webkitExitFullscreen())
                            }
                            ;
                            document.addEventListener("pointerlockchange", (s => {
                                i = t === document.pointerLockElement,
                                e.onPointerLockChanged(i)
                            }
                            )),
                            document.addEventListener("fullscreenchange", (i => {
                                s = t === document.fullscreenElement,
                                e.onFullscreenChanged(s)
                            }
                            )),
                            document.addEventListener("pointerlockerror", (s => {
                                i = t === document.pointerLockElement,
                                e.onPointerLockError(s)
                            }
                            )),
                            Object.defineProperty(e, "pointerLock", {
                                get: () => i,
                                set: r
                            }),
                            Object.defineProperty(e, "fullscreen", {
                                get: () => s,
                                set: n
                            }),
                            t.addEventListener("click", (t => {
                                e.stickyPointerLock && r(!0),
                                e.stickyFullscreen && n(!0)
                            }
                            ));
                            var a = () => e.onResize();
                            window.ResizeObserver ? new ResizeObserver(a).observe(t) : window.addEventListener("resize", a)
                        }
                    }(this, e),
                    this.onInit()
                }
                ))
            }
        }
        function S(e=10) {
            this.nowObject = performance || Date,
            this.pollTime = e,
            this.renderAccum = 0,
            this.lastTickStarted = 0,
            this.lastFrameStarted = 0,
            this.lastRenderStarted = 0,
            this.avgTickTime = 2,
            this.frameCB = null,
            this.intervalCB = null,
            this.intervalID = -1
        }
        function A(e, t=!1) {
            var i = e._data
              , s = i.nowObject.now()
              , r = s;
            t && (r += i.avgTickTime);
            var n, a, o = s + e.maxTickTime;
            o > s || (o = s + 1);
            for (var h = 1e3 / e.tickRate; i.lastTickStarted + h < r; ) {
                e.onTick(h),
                i.lastTickStarted += h;
                var l = i.nowObject.now();
                if (i.avgTickTime = (n = i.avgTickTime,
                (a = l - s) > 4 * n && (a = 4 * n),
                a < .25 * n && (a = .25 * n),
                .9 * n + .1 * a),
                (s = l) > o)
                    return void (i.lastTickStarted = s)
            }
        }
        class I extends e.EventEmitter {
            constructor(e, t) {
                super(),
                t = t || {},
                this.noa = e;
                var i, s, r, n = t.domElement || null;
                "string" == typeof n && (n = document.querySelector(n)),
                this.element = n || ((i = document.createElement("div")).tabIndex = 1,
                i.style.position = "fixed",
                i.style.left = "0px",
                i.style.right = "0px",
                i.style.top = "0px",
                i.style.bottom = "0px",
                i.style.height = "100%",
                i.style.overflow = "hidden",
                document.body.appendChild(i),
                document.body.style.overflow = "hidden",
                document.body.style.height = "100%",
                i.id = "noa-container",
                i),
                this.canvas = (s = this.element,
                (r = s.querySelector("canvas")) || ((r = document.createElement("canvas")).style.position = "absolute",
                r.style.left = "0px",
                r.style.top = "0px",
                r.style.height = "100%",
                r.style.width = "100%",
                r.id = "noa-canvas",
                s.insertBefore(r, s.firstChild)),
                r),
                function(e, t) {
                    var i = 0
                      , s = () => {
                        var r = t.width;
                        t.width = r + 1,
                        t.width = r,
                        i++ > 10 && e.off("beforeRender", s)
                    }
                    ;
                    e.on("beforeRender", s)
                }(e, this.canvas),
                this.supportsPointerLock = !1,
                this.pointerInGame = !1,
                this.isFocused = !!document.hasFocus(),
                this.hasPointerLock = !1,
                this._shell = new M(this.element,10),
                this._shell.tickRate = t.tickRate,
                this._shell.maxRenderRate = t.maxRenderRate,
                this._shell.stickyPointerLock = t.stickyPointerLock,
                this._shell.stickyFullscreen = t.stickyFullscreen,
                this._shell.maxTickTime = 50,
                this._shell.onTick = e.tick.bind(e),
                this._shell.onRender = e.render.bind(e),
                this._shell.onPointerLockChanged = e => {
                    this.hasPointerLock = e,
                    this.emit(e ? "gainedPointerLock" : "lostPointerLock"),
                    e && (this.pointerInGame = !0)
                }
                ,
                this._shell.onInit = () => {
                    this._shell.onResize = e.rendering.resize.bind(e.rendering),
                    function(e) {
                        if ("pointerLockElement"in document || "mozPointerLockElement"in document || "webkitPointerLockElement"in document) {
                            e.supportsPointerLock = !0;
                            var t = function(i) {
                                e.supportsPointerLock = !1,
                                document.removeEventListener(i.type, t)
                            };
                            document.addEventListener("touchmove", t)
                        }
                    }(this),
                    this.element.addEventListener("mouseenter", ( () => {
                        this.pointerInGame = !0
                    }
                    )),
                    this.element.addEventListener("mouseleave", ( () => {
                        this.pointerInGame = !1
                    }
                    )),
                    window.addEventListener("focus", ( () => {
                        this.isFocused = !0
                    }
                    )),
                    window.addEventListener("blur", ( () => {
                        this.isFocused = !1
                    }
                    ));
                    var t = () => {
                        this.pointerInGame = !0,
                        this.isFocused = !0,
                        this.element.removeEventListener("mousedown", t)
                    }
                    ;
                    this.element.addEventListener("mousedown", t),
                    this.emit("DOMready"),
                    this._shell.onInit = null
                }
            }
            appendTo(e) {
                this.element.appendChild(e)
            }
            setPointerLock(e=!1) {
                this._shell.pointerLock = !!e
            }
        }
        var R = "undefined" != typeof Float32Array ? Float32Array : Array;
        function C() {
            var e = new R(3);
            return R != Float32Array && (e[0] = 0,
            e[1] = 0,
            e[2] = 0),
            e
        }
        function P(e, t, i) {
            return e[0] = t[0] + i[0],
            e[1] = t[1] + i[1],
            e[2] = t[2] + i[2],
            e
        }
        function D(e, t, i) {
            return e[0] = Math.min(t[0], i[0]),
            e[1] = Math.min(t[1], i[1]),
            e[2] = Math.min(t[2], i[2]),
            e
        }
        function w(e, t, i) {
            return e[0] = Math.max(t[0], i[0]),
            e[1] = Math.max(t[1], i[1]),
            e[2] = Math.max(t[2], i[2]),
            e
        }
        Math.random,
        Math.PI,
        Math.hypot || (Math.hypot = function() {
            for (var e = 0, t = arguments.length; t--; )
                e += arguments[t] * arguments[t];
            return Math.sqrt(e)
        }
        ),
        C();
        class F {
            base;
            vec;
            max;
            mag;
            constructor(e, t) {
                const i = C();
                P(i, e, t),
                this.base = D(C(), e, i),
                this.vec = function(e) {
                    var t = new R(3);
                    return t[0] = e[0],
                    t[1] = e[1],
                    t[2] = e[2],
                    t
                }(t),
                this.max = w(C(), e, i),
                this.mag = function(e) {
                    var t = e[0]
                      , i = e[1]
                      , s = e[2];
                    return Math.hypot(t, i, s)
                }(this.vec)
            }
            width() {
                return this.vec[0]
            }
            height() {
                return this.vec[1]
            }
            depth() {
                return this.vec[2]
            }
            x0() {
                return this.base[0]
            }
            y0() {
                return this.base[1]
            }
            z0() {
                return this.base[2]
            }
            x1() {
                return this.max[0]
            }
            y1() {
                return this.max[1]
            }
            z1() {
                return this.max[2]
            }
            translate(e) {
                return P(this.max, this.max, e),
                P(this.base, this.base, e),
                this
            }
            setPosition(e) {
                return P(this.max, e, this.vec),
                function(e, t) {
                    e[0] = t[0],
                    e[1] = t[1],
                    e[2] = t[2]
                }(this.base, e),
                this
            }
            expand(e) {
                const t = C()
                  , i = C();
                return w(t, e.max, this.max),
                D(i, e.base, this.base),
                function(e, t, i) {
                    e[0] = t[0] - i[0],
                    e[1] = t[1] - i[1],
                    e[2] = t[2] - i[2]
                }(t, t, i),
                new F(i,t)
            }
            intersects(e) {
                return !(e.base[0] > this.max[0] || e.base[1] > this.max[1] || e.base[2] > this.max[2] || e.max[0] < this.base[0] || e.max[1] < this.base[1] || e.max[2] < this.base[2])
            }
            touches(e) {
                const t = this.union(e);
                return null !== t && (0 == t.width() || 0 == t.height() || 0 == t.depth())
            }
            union(e) {
                if (!this.intersects(e))
                    return null;
                const t = Math.max(e.base[0], this.base[0])
                  , i = Math.max(e.base[1], this.base[1])
                  , s = Math.max(e.base[2], this.base[2])
                  , r = Math.min(e.max[0], this.max[0])
                  , n = Math.min(e.max[1], this.max[1])
                  , a = Math.min(e.max[2], this.max[2]);
                return new F([t, i, s],[r - t, n - i, a - s])
            }
        }
        var O = i(4601)
          , L = i.n(O);
        function B() {
            this.inverseX = !1,
            this.inverseY = !1,
            this.sensitivityMult = 1,
            this.sensitivityMultOutsidePointerlock = 0,
            this.sensitivityX = 10,
            this.sensitivityY = 10,
            this.initialZoom = 0,
            this.zoomSpeed = .2
        }
        var N = [r().create(), r().create(), r().create()]
          , U = r().create();
        class k {
            constructor(e, t) {
                t = Object.assign({}, new B, t),
                this.noa = e,
                this.sensitivityX = +t.sensitivityX,
                this.sensitivityY = +t.sensitivityY,
                this.inverseX = !!t.inverseX,
                this.inverseY = !!t.inverseY,
                this.sensitivityMult = t.sensitivityMult,
                this.sensitivityMultOutsidePointerlock = t.sensitivityMultOutsidePointerlock,
                this.heading = 0,
                this.pitch = 0,
                this.cameraTarget = this.noa.ents.createEntity(["position"]);
                var i = .9 * e.ents.getPositionData(e.playerEntity).height;
                e.ents.addComponent(this.cameraTarget, "followsEntity", {
                    entity: e.playerEntity,
                    offset: [0, i, 0]
                }),
                this.zoomDistance = t.initialZoom,
                this.zoomSpeed = t.zoomSpeed,
                this.currentZoom = t.initialZoom,
                this._dirVector = r().fromValues(0, 0, 1)
            }
            _localGetTargetPosition() {
                var e = this.noa.ents.getPositionData(this.cameraTarget)
                  , t = N[0];
                return r().copy(t, e._renderPosition)
            }
            _localGetPosition() {
                var e = this._localGetTargetPosition();
                return 0 === this.currentZoom ? e : r().scaleAndAdd(e, e, this._dirVector, -this.currentZoom)
            }
            getTargetPosition() {
                var e = this._localGetTargetPosition()
                  , t = N[1];
                return this.noa.localToGlobal(e, t)
            }
            getPosition() {
                var e = this._localGetPosition()
                  , t = N[2];
                return this.noa.localToGlobal(e, t)
            }
            getDirection() {
                return this._dirVector
            }
            applyInputsToCamera() {
                var e = this.sensitivityMult;
                if (this.noa.container.supportsPointerLock && (this.noa.container.hasPointerLock || (e *= this.sensitivityMultOutsidePointerlock)),
                0 !== e) {
                    var t = this.noa.inputs.pointerState;
                    !function(e) {
                        var t = e.dx
                          , i = e.dy
                          , s = Math.abs(t) > 400 && Math.abs(t / V) > 4
                          , r = Math.abs(i) > 400 && Math.abs(i / G) > 4;
                        s || r ? (e.dx = V,
                        e.dy = G,
                        V = (V + t) / 2,
                        G = (G + i) / 2) : (V = t || 1,
                        G = i || 1)
                    }(t);
                    var i = .0066 * Math.PI / 180
                      , s = t.dx * this.sensitivityX * e * i
                      , n = t.dy * this.sensitivityY * e * i;
                    this.inverseX && (s = -s),
                    this.inverseY && (n = -n);
                    var a = 2 * Math.PI;
                    this.heading += s < 0 ? s + a : s,
                    this.heading > a && (this.heading -= a);
                    var o = Math.PI / 2 - .001;
                    this.pitch = Math.max(-o, Math.min(o, this.pitch + n)),
                    r().set(this._dirVector, 0, 0, 1);
                    var h = this._dirVector
                      , l = U;
                    r().rotateX(h, h, l, this.pitch),
                    r().rotateY(h, h, l, this.heading)
                }
            }
            updateBeforeEntityRenderSystems() {
                this.currentZoom += (this.zoomDistance - this.currentZoom) * this.zoomSpeed
            }
            updateAfterEntityRenderSystems() {
                var e = function(e) {
                    e._sweepBox || (e._sweepBox = new F([0, 0, 0],[.2, .2, .2]),
                    e._sweepGetVoxel = e.noa.world.getBlockSolidity.bind(e.noa.world),
                    e._sweepVec = r().create(),
                    e._sweepHit = () => !0);
                    var t = r().copy(e._sweepVec, e._localGetTargetPosition());
                    r().add(t, t, e.noa.worldOriginOffset);
                    for (var i = 0; i < 3; i++)
                        t[i] -= .1;
                    e._sweepBox.setPosition(t);
                    var s = Math.max(e.zoomDistance, e.currentZoom) + .1;
                    return r().scale(e._sweepVec, e.getDirection(), -s),
                    L()(e._sweepGetVoxel, e._sweepBox, e._sweepVec, e._sweepHit, !0)
                }(this);
                this.currentZoom > e && (this.currentZoom = e)
            }
        }
        var V = 0
          , G = 0
          , z = i(4962)
          , W = i.n(z);
        class X {
            constructor() {
                this.position = null,
                this.width = .8,
                this.height = .8,
                this._localPosition = null,
                this._renderPosition = null,
                this._extents = null
            }
        }
        function H(e) {
            return {
                name: "position",
                order: 60,
                state: new X,
                onAdd: function(t, i) {
                    var s = [0, 0, 0];
                    i.position && r().copy(s, i.position),
                    i.position = s,
                    i._localPosition = r().create(),
                    i._renderPosition = r().create(),
                    i._extents = new Float32Array(6),
                    e.globalToLocal(i.position, null, i._localPosition),
                    r().copy(i._renderPosition, i._localPosition),
                    K(i)
                },
                onRemove: null,
                system: function(t, i) {
                    for (var s = e.worldOriginOffset, n = 0; n < i.length; n++) {
                        var a = i[n];
                        r().add(a.position, a._localPosition, s),
                        K(a)
                    }
                }
            }
        }
        function K(e) {
            var t = e.width / 2
              , i = e._localPosition
              , s = e._extents;
            s[0] = i[0] - t,
            s[1] = i[1],
            s[2] = i[2] - t,
            s[3] = i[0] + t,
            s[4] = i[1] + e.height,
            s[5] = i[2] + t
        }
        class Y {
            constructor() {
                this.body = null
            }
        }
        function j(e) {
            return {
                name: "physics",
                order: 40,
                state: new Y,
                onAdd: function(t, i) {
                    i.body = e.physics.addBody(),
                    Z(i, e.ents.getPositionData(i.__id))
                },
                onRemove: function(t, i) {
                    if (e.ents.hasPosition(i.__id)) {
                        var s = e.ents.getPositionData(i.__id);
                        Q(i, s),
                        $(i, s, 0, !1)
                    }
                    e.physics.removeBody(i.body)
                },
                system: function(t, i) {
                    for (var s = 0; s < i.length; s++) {
                        var r = i[s];
                        Q(r, e.ents.getPositionData(r.__id))
                    }
                },
                renderSystem: function(t, i) {
                    for (var s = e.positionInCurrentTick, r = 1e3 / e.container._shell.tickRate, n = (s * (r *= e.timeScale) - r) / 1e3, a = 0; a < i.length; a++) {
                        var o = i[a]
                          , h = o.__id;
                        $(o, e.ents.getPositionData(h), n, e.ents.cameraSmoothed(h))
                    }
                }
            }
        }
        var q = r().create();
        function Z(e, t) {
            var i = e.body.aabb
              , s = t._extents;
            r().copy(i.base, s),
            r().set(i.vec, t.width, t.height, t.width),
            r().add(i.max, i.base, i.vec)
        }
        function Q(e, t) {
            var i = e.body.aabb.base
              , s = t.width / 2;
            r().set(t._localPosition, i[0] + s, i[1], i[2] + s)
        }
        function $(e, t, i, s) {
            var n = e.body.velocity;
            r().scaleAndAdd(q, t._localPosition, n, i),
            s && r().lerp(q, t._renderPosition, q, .3),
            r().copy(t._renderPosition, q)
        }
        var J = i(7258)
          , ee = i.n(J);
        function te(e) {
            var t = [];
            return {
                name: "collideEntities",
                order: 70,
                state: {
                    cylinder: !1,
                    collideBits: 1,
                    collideMask: 1,
                    callback: null
                },
                onAdd: null,
                onRemove: null,
                system: function(s, r) {
                    for (var n = e.ents, a = 0; a < r.length; a++) {
                        var o = r[a].__id
                          , h = n.getPositionData(o);
                        t[a] = h._extents
                    }
                    t.length = r.length,
                    ee()(t, (function(s, n) {
                        var a = r[s]
                          , o = r[n];
                        a && o && function(e, t, s, r) {
                            return e.cylinder ? t.cylinder ? function(e, t) {
                                var i = (e[3] - e[0]) / 2
                                  , s = (t[3] - t[0]) / 2
                                  , r = e[0] + i - (t[0] + s)
                                  , n = e[2] + i - (t[2] + s)
                                  , a = i + s;
                                return r * r + n * n <= a * a
                            }(s, r) : i(s, r) : !t.cylinder || i(r, s)
                        }(a, o, t[s], t[n]) && function(e, t, i) {
                            var s = t.__id
                              , r = i.__id;
                            t.collideMask & i.collideBits && t.callback && t.callback(r),
                            i.collideMask & t.collideBits && i.callback && i.callback(s),
                            e.ents.onPairwiseEntityCollision(s, r)
                        }(e, a, o)
                    }
                    ))
                }
            };
            function i(e, t) {
                var i = (e[3] - e[0]) / 2
                  , r = e[0] + i
                  , n = e[2] + i
                  , a = s(r, t[0], t[3]) - r
                  , o = s(n, t[2], t[5]) - n;
                return a * a + o * o <= i * i
            }
            function s(e, t, i) {
                return e < t ? t : e > i ? i : e
            }
        }
        function ie(e) {
            return {
                name: "collideTerrain",
                order: 0,
                state: {
                    callback: null
                },
                onAdd: function(t, i) {
                    var s = e.entities;
                    s.hasPhysics(t) && (s.getPhysics(t).body.onCollide = function(i) {
                        var s = e.ents.getCollideTerrain(t).callback;
                        s && s(i, t)
                    }
                    )
                },
                onRemove: function(t, i) {
                    var s = e.entities;
                    s.hasPhysics(t) && (s.getPhysics(t).body.onCollide = null)
                }
            }
        }
        function se(e) {
            return {
                name: "fadeOnZoom",
                order: 99,
                state: {
                    cutoff: 1.5
                },
                onAdd: null,
                onRemove: null,
                system: function(t, i) {
                    for (var s = e.camera.currentZoom, r = 0; r < i.length; r++)
                        re(i[r], s, e)
                }
            }
        }
        function re(e, t, i) {
            if (i.ents.hasMesh(e.__id)) {
                var s = i.ents.getMeshData(e.__id).mesh;
                if (s.metadata) {
                    var r = t < e.cutoff;
                    i.rendering.setMeshVisibility(s, !r)
                }
            }
        }
        function ne(e) {
            return {
                name: "followsEntity",
                order: 50,
                state: {
                    entity: 0,
                    offset: null,
                    onTargetMissing: null
                },
                onAdd: function(e, s) {
                    var n = r().create();
                    s.offset = s.offset ? r().copy(n, s.offset) : n,
                    t(s),
                    i(s)
                },
                onRemove: null,
                system: function(e, i) {
                    for (var s = 0; s < i.length; s++)
                        t(i[s])
                },
                renderSystem: function(e, t) {
                    for (var s = 0; s < t.length; s++)
                        i(t[s])
                }
            };
            function t(t) {
                var i = t.__id
                  , s = e.ents.getPositionData(i)
                  , n = e.ents.getPositionData(t.entity);
                n ? r().add(s._localPosition, n._localPosition, t.offset) : (t.onTargetMissing && t.onTargetMissing(i),
                e.ents.removeComponent(i, e.ents.names.followsEntity))
            }
            function i(t) {
                var i = t.__id
                  , s = e.ents.getPositionData(i)
                  , n = e.ents.getPositionData(t.entity);
                n && r().add(s._renderPosition, n._renderPosition, t.offset)
            }
        }
        function ae(e) {
            return {
                name: "mesh",
                order: 100,
                state: {
                    mesh: null,
                    offset: null
                },
                onAdd: function(t, i) {
                    var s = e.ents.getPositionData(t);
                    if (!i.mesh)
                        throw new Error("Mesh component added without a mesh - probably a bug!");
                    e.rendering.addMeshToScene(i.mesh, !1, s.position),
                    i.offset || (i.offset = r().create());
                    var n = s._renderPosition;
                    i.mesh.position.copyFromFloats(n[0] + i.offset[0], n[1] + i.offset[1], n[2] + i.offset[2])
                },
                onRemove: function(e, t) {
                    t.mesh.dispose()
                },
                renderSystem: function(t, i) {
                    for (var s = 0; s < i.length; s++) {
                        var r = i[s]
                          , n = r.__id
                          , a = e.ents.getPositionData(n)._renderPosition;
                        r.mesh.position.copyFromFloats(a[0] + r.offset[0], a[1] + r.offset[1], a[2] + r.offset[2])
                    }
                }
            }
        }
        function oe() {
            this.heading = 0,
            this.running = !1,
            this.jumping = !1,
            this.maxSpeed = 10,
            this.moveForce = 30,
            this.responsiveness = 15,
            this.runningFriction = 0,
            this.standingFriction = 2,
            this.airMoveMult = .5,
            this.jumpImpulse = 10,
            this.jumpForce = 12,
            this.jumpTime = 500,
            this.airJumps = 1,
            this._jumpCount = 0,
            this._currjumptime = 0,
            this._isJumping = !1
        }
        function he(e) {
            return {
                name: "movement",
                order: 30,
                state: new oe,
                onAdd: null,
                onRemove: null,
                system: function(t, i) {
                    for (var s = e.entities, r = 0; r < i.length; r++) {
                        var n = i[r]
                          , a = s.getPhysics(n.__id);
                        a && de(t, n, a.body)
                    }
                }
            }
        }
        var le = r().create()
          , ce = r().create()
          , ue = r().create();
        function de(e, t, i) {
            var s = i.atRestY() < 0
              , n = s || t._jumpCount < t.airJumps;
            if (s && (t._isJumping = !1,
            t._jumpCount = 0),
            t.jumping)
                if (t._isJumping) {
                    if (t._currjumptime > 0) {
                        var a = t.jumpForce;
                        t._currjumptime < e && (a *= t._currjumptime / e),
                        i.applyForce([0, a, 0]),
                        t._currjumptime -= e
                    }
                } else
                    n && (t._isJumping = !0,
                    s || t._jumpCount++,
                    t._currjumptime = t.jumpTime,
                    i.applyImpulse([0, t.jumpImpulse, 0]),
                    !s && i.velocity[1] < 0 && (i.velocity[1] = 0));
            else
                t._isJumping = !1;
            var o = le
              , h = ce;
            if (t.running) {
                var l = t.maxSpeed;
                r().set(o, 0, 0, l),
                r().rotateY(o, o, ue, t.heading),
                r().subtract(h, o, i.velocity),
                h[1] = 0;
                var c = r().length(h);
                if (r().normalize(h, h),
                c > 0) {
                    var u = t.moveForce;
                    s || (u *= t.airMoveMult);
                    var d = t.responsiveness * c;
                    u > d && (u = d),
                    r().scale(h, h, u),
                    i.applyForce(h)
                }
                i.friction = t.runningFriction
            } else
                i.friction = t.standingFriction
        }
        function fe(e) {
            return {
                name: "receivesInputs",
                order: 20,
                state: {},
                onAdd: null,
                onRemove: null,
                system: function(t, i) {
                    for (var s = e.entities, r = e.inputs.state, n = e.camera.heading, a = 0; a < i.length; a++) {
                        var o = i[a];
                        _e(s.getMovement(o.__id), r, n)
                    }
                }
            }
        }
        function _e(e, t, i) {
            e.jumping = !!t.jump;
            var s = t.forward ? t.backward ? 0 : 1 : t.backward ? -1 : 0
              , r = t.right ? t.left ? 0 : 1 : t.left ? -1 : 0;
            s | r ? (e.running = !0,
            s ? (-1 == s && (i += Math.PI),
            r && (i += Math.PI / 4 * s * r)) : i += r * Math.PI / 2,
            e.heading = i) : e.running = !1
        }
        function pe(e, t, i=1401298e-51) {
            return Math.abs(e - t) <= i
        }
        function me(e, t) {
            return e === t ? e : Math.random() * (t - e) + e
        }
        function ge(e, t, i) {
            return e + (t - e) * i
        }
        function ve(e, t=0, i=1) {
            return Math.min(i, Math.max(t, e))
        }
        function ye(e) {
            return e - 2 * Math.PI * Math.floor((e + Math.PI) / (2 * Math.PI))
        }
        function be(e) {
            const t = e.toString(16);
            return e <= 15 ? ("0" + t).toUpperCase() : t.toUpperCase()
        }
        class xe {
            static Sign(e) {
                return 0 == (e = +e) || isNaN(e) ? e : e > 0 ? 1 : -1
            }
            static Log2(e) {
                return Math.log(e) * Math.LOG2E
            }
            static ILog2(e) {
                if (Math.log2)
                    return Math.floor(Math.log2(e));
                if (e < 0)
                    return NaN;
                if (0 === e)
                    return -1 / 0;
                let t = 0;
                if (e < 1) {
                    for (; e < 1; )
                        t++,
                        e *= 2;
                    t = -t
                } else if (e > 1)
                    for (; e > 1; )
                        t++,
                        e = Math.floor(e / 2);
                return t
            }
            static Repeat(e, t) {
                return e - Math.floor(e / t) * t
            }
            static Normalize(e, t, i) {
                return (e - t) / (i - t)
            }
            static Denormalize(e, t, i) {
                return e * (i - t) + t
            }
            static DeltaAngle(e, t) {
                let i = xe.Repeat(t - e, 360);
                return i > 180 && (i -= 360),
                i
            }
            static PingPong(e, t) {
                const i = xe.Repeat(e, 2 * t);
                return t - Math.abs(i - t)
            }
            static SmoothStep(e, t, i) {
                let s = xe.Clamp(i);
                return s = -2 * s * s * s + 3 * s * s,
                t * s + e * (1 - s)
            }
            static MoveTowards(e, t, i) {
                let s = 0;
                return s = Math.abs(t - e) <= i ? t : e + xe.Sign(t - e) * i,
                s
            }
            static MoveTowardsAngle(e, t, i) {
                const s = xe.DeltaAngle(e, t);
                let r = 0;
                return -i < s && s < i ? r = t : (t = e + s,
                r = xe.MoveTowards(e, t, i)),
                r
            }
            static LerpAngle(e, t, i) {
                let s = xe.Repeat(t - e, 360);
                return s > 180 && (s -= 360),
                e + s * ve(i)
            }
            static InverseLerp(e, t, i) {
                let s = 0;
                return s = e != t ? ve((i - e) / (t - e)) : 0,
                s
            }
            static Hermite(e, t, i, s, r) {
                const n = r * r
                  , a = r * n;
                return e * (2 * a - 3 * n + 1) + i * (-2 * a + 3 * n) + t * (a - 2 * n + r) + s * (a - n)
            }
            static Hermite1stDerivative(e, t, i, s, r) {
                const n = r * r;
                return 6 * (n - r) * e + (3 * n - 4 * r + 1) * t + 6 * (-n + r) * i + (3 * n - 2 * r) * s
            }
            static RangeToPercent(e, t, i) {
                return (e - t) / (i - t)
            }
            static PercentToRange(e, t, i) {
                return (i - t) * e + t
            }
            static HCF(e, t) {
                const i = e % t;
                return 0 === i ? t : xe.HCF(t, i)
            }
        }
        xe.TwoPi = 2 * Math.PI,
        xe.WithinEpsilon = pe,
        xe.ToHex = be,
        xe.Clamp = ve,
        xe.Lerp = ge,
        xe.RandomRange = me,
        xe.NormalizeRadians = ye;
        const Te = 1 / 2.2
          , Ee = (Math.sqrt(5),
        .001);
        class Me {
            static BuildArray(e, t) {
                const i = [];
                for (let s = 0; s < e; ++s)
                    i.push(t());
                return i
            }
            static BuildTuple(e, t) {
                return Me.BuildArray(e, t)
            }
        }
        const Se = ["push", "splice", "pop", "shift", "unshift"]
          , Ae = {};
        function Ie(e, t) {
            Ae[e] = t
        }
        function Re(e) {
            return Ae[e]
        }
        function Ce(e) {
            return Math.pow(e, 2.2)
        }
        function Pe(e) {
            return e <= .04045 ? .0773993808 * e : Math.pow(.947867299 * (e + .055), 2.4)
        }
        function De(e) {
            return Math.pow(e, Te)
        }
        function we(e) {
            return e <= .0031308 ? 12.92 * e : 1.055 * Math.pow(e, .41666) - .055
        }
        class Fe {
            constructor(e=0, t=0, i=0) {
                this.r = e,
                this.g = t,
                this.b = i
            }
            toString() {
                return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}"
            }
            getClassName() {
                return "Color3"
            }
            getHashCode() {
                let e = 255 * this.r | 0;
                return e = 397 * e ^ 255 * this.g,
                e = 397 * e ^ 255 * this.b,
                e
            }
            toArray(e, t=0) {
                return e[t] = this.r,
                e[t + 1] = this.g,
                e[t + 2] = this.b,
                this
            }
            fromArray(e, t=0) {
                return Fe.FromArrayToRef(e, t, this),
                this
            }
            toColor4(e=1) {
                return new Oe(this.r,this.g,this.b,e)
            }
            asArray() {
                return [this.r, this.g, this.b]
            }
            toLuminance() {
                return .3 * this.r + .59 * this.g + .11 * this.b
            }
            multiply(e) {
                return new this.constructor(this.r * e.r,this.g * e.g,this.b * e.b)
            }
            multiplyToRef(e, t) {
                return t.r = this.r * e.r,
                t.g = this.g * e.g,
                t.b = this.b * e.b,
                t
            }
            multiplyInPlace(e) {
                return this.r *= e.r,
                this.g *= e.g,
                this.b *= e.b,
                this
            }
            multiplyByFloats(e, t, i) {
                return new this.constructor(this.r * e,this.g * t,this.b * i)
            }
            divide(e) {
                throw new ReferenceError("Can not divide a color")
            }
            divideToRef(e, t) {
                throw new ReferenceError("Can not divide a color")
            }
            divideInPlace(e) {
                throw new ReferenceError("Can not divide a color")
            }
            minimizeInPlace(e) {
                return this.minimizeInPlaceFromFloats(e.r, e.g, e.b)
            }
            maximizeInPlace(e) {
                return this.maximizeInPlaceFromFloats(e.r, e.g, e.b)
            }
            minimizeInPlaceFromFloats(e, t, i) {
                return this.r = Math.min(e, this.r),
                this.g = Math.min(t, this.g),
                this.b = Math.min(i, this.b),
                this
            }
            maximizeInPlaceFromFloats(e, t, i) {
                return this.r = Math.max(e, this.r),
                this.g = Math.max(t, this.g),
                this.b = Math.max(i, this.b),
                this
            }
            floorToRef(e) {
                throw new ReferenceError("Can not floor a color")
            }
            floor() {
                throw new ReferenceError("Can not floor a color")
            }
            fractToRef(e) {
                throw new ReferenceError("Can not fract a color")
            }
            fract() {
                throw new ReferenceError("Can not fract a color")
            }
            equals(e) {
                return e && this.r === e.r && this.g === e.g && this.b === e.b
            }
            equalsFloats(e, t, i) {
                return this.equalsToFloats(e, t, i)
            }
            equalsToFloats(e, t, i) {
                return this.r === e && this.g === t && this.b === i
            }
            equalsWithEpsilon(e, t=.001) {
                return xe.WithinEpsilon(this.r, e.r, t) && xe.WithinEpsilon(this.g, e.g, t) && xe.WithinEpsilon(this.b, e.b, t)
            }
            negate() {
                throw new ReferenceError("Can not negate a color")
            }
            negateInPlace() {
                throw new ReferenceError("Can not negate a color")
            }
            negateToRef(e) {
                throw new ReferenceError("Can not negate a color")
            }
            scale(e) {
                return new this.constructor(this.r * e,this.g * e,this.b * e)
            }
            scaleInPlace(e) {
                return this.r *= e,
                this.g *= e,
                this.b *= e,
                this
            }
            scaleToRef(e, t) {
                return t.r = this.r * e,
                t.g = this.g * e,
                t.b = this.b * e,
                t
            }
            scaleAndAddToRef(e, t) {
                return t.r += this.r * e,
                t.g += this.g * e,
                t.b += this.b * e,
                t
            }
            clampToRef(e=0, t=1, i) {
                return i.r = ve(this.r, e, t),
                i.g = ve(this.g, e, t),
                i.b = ve(this.b, e, t),
                i
            }
            add(e) {
                return new this.constructor(this.r + e.r,this.g + e.g,this.b + e.b)
            }
            addInPlace(e) {
                return this.r += e.r,
                this.g += e.g,
                this.b += e.b,
                this
            }
            addInPlaceFromFloats(e, t, i) {
                return this.r += e,
                this.g += t,
                this.b += i,
                this
            }
            addToRef(e, t) {
                return t.r = this.r + e.r,
                t.g = this.g + e.g,
                t.b = this.b + e.b,
                t
            }
            subtract(e) {
                return new this.constructor(this.r - e.r,this.g - e.g,this.b - e.b)
            }
            subtractToRef(e, t) {
                return t.r = this.r - e.r,
                t.g = this.g - e.g,
                t.b = this.b - e.b,
                t
            }
            subtractInPlace(e) {
                return this.r -= e.r,
                this.g -= e.g,
                this.b -= e.b,
                this
            }
            subtractFromFloats(e, t, i) {
                return new this.constructor(this.r - e,this.g - t,this.b - i)
            }
            subtractFromFloatsToRef(e, t, i, s) {
                return s.copyFromFloats(this.r - e, this.g - t, this.b - i)
            }
            clone() {
                return new this.constructor(this.r,this.g,this.b)
            }
            copyFrom(e) {
                return this.r = e.r,
                this.g = e.g,
                this.b = e.b,
                this
            }
            copyFromFloats(e, t, i) {
                return this.r = e,
                this.g = t,
                this.b = i,
                this
            }
            set(e, t, i) {
                return this.copyFromFloats(e, t, i)
            }
            setAll(e) {
                return this.r = this.g = this.b = e,
                this
            }
            toHexString() {
                const e = Math.round(255 * this.r)
                  , t = Math.round(255 * this.g)
                  , i = Math.round(255 * this.b);
                return "#" + be(e) + be(t) + be(i)
            }
            toHSV() {
                const e = new this.constructor;
                return this.toHSVToRef(e),
                e
            }
            toHSVToRef(e) {
                const t = this.r
                  , i = this.g
                  , s = this.b
                  , r = Math.max(t, i, s)
                  , n = Math.min(t, i, s);
                let a = 0
                  , o = 0;
                const h = r
                  , l = r - n;
                0 !== r && (o = l / r),
                r != n && (r == t ? (a = (i - s) / l,
                i < s && (a += 6)) : r == i ? a = (s - t) / l + 2 : r == s && (a = (t - i) / l + 4),
                a *= 60),
                e.r = a,
                e.g = o,
                e.b = h
            }
            toLinearSpace(e=!1) {
                const t = new this.constructor;
                return this.toLinearSpaceToRef(t, e),
                t
            }
            toLinearSpaceToRef(e, t=!1) {
                return t ? (e.r = Pe(this.r),
                e.g = Pe(this.g),
                e.b = Pe(this.b)) : (e.r = Ce(this.r),
                e.g = Ce(this.g),
                e.b = Ce(this.b)),
                this
            }
            toGammaSpace(e=!1) {
                const t = new this.constructor;
                return this.toGammaSpaceToRef(t, e),
                t
            }
            toGammaSpaceToRef(e, t=!1) {
                return t ? (e.r = we(this.r),
                e.g = we(this.g),
                e.b = we(this.b)) : (e.r = De(this.r),
                e.g = De(this.g),
                e.b = De(this.b)),
                this
            }
            static HSVtoRGBToRef(e, t, i, s) {
                const r = i * t
                  , n = e / 60
                  , a = r * (1 - Math.abs(n % 2 - 1));
                let o = 0
                  , h = 0
                  , l = 0;
                n >= 0 && n <= 1 ? (o = r,
                h = a) : n >= 1 && n <= 2 ? (o = a,
                h = r) : n >= 2 && n <= 3 ? (h = r,
                l = a) : n >= 3 && n <= 4 ? (h = a,
                l = r) : n >= 4 && n <= 5 ? (o = a,
                l = r) : n >= 5 && n <= 6 && (o = r,
                l = a);
                const c = i - r;
                s.set(o + c, h + c, l + c)
            }
            static FromHSV(e, t, i) {
                const s = new Fe(0,0,0);
                return Fe.HSVtoRGBToRef(e, t, i, s),
                s
            }
            static FromHexString(e) {
                if ("#" !== e.substring(0, 1) || 7 !== e.length)
                    return new Fe(0,0,0);
                const t = parseInt(e.substring(1, 3), 16)
                  , i = parseInt(e.substring(3, 5), 16)
                  , s = parseInt(e.substring(5, 7), 16);
                return Fe.FromInts(t, i, s)
            }
            static FromArray(e, t=0) {
                return new Fe(e[t],e[t + 1],e[t + 2])
            }
            static FromArrayToRef(e, t=0, i) {
                i.r = e[t],
                i.g = e[t + 1],
                i.b = e[t + 2]
            }
            static FromInts(e, t, i) {
                return new Fe(e / 255,t / 255,i / 255)
            }
            static Lerp(e, t, i) {
                const s = new Fe(0,0,0);
                return Fe.LerpToRef(e, t, i, s),
                s
            }
            static LerpToRef(e, t, i, s) {
                s.r = e.r + (t.r - e.r) * i,
                s.g = e.g + (t.g - e.g) * i,
                s.b = e.b + (t.b - e.b) * i
            }
            static Hermite(e, t, i, s, r) {
                const n = r * r
                  , a = r * n
                  , o = 2 * a - 3 * n + 1
                  , h = -2 * a + 3 * n
                  , l = a - 2 * n + r
                  , c = a - n
                  , u = e.r * o + i.r * h + t.r * l + s.r * c
                  , d = e.g * o + i.g * h + t.g * l + s.g * c
                  , f = e.b * o + i.b * h + t.b * l + s.b * c;
                return new Fe(u,d,f)
            }
            static Hermite1stDerivative(e, t, i, s, r) {
                const n = Fe.Black();
                return this.Hermite1stDerivativeToRef(e, t, i, s, r, n),
                n
            }
            static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
                const a = r * r;
                n.r = 6 * (a - r) * e.r + (3 * a - 4 * r + 1) * t.r + 6 * (-a + r) * i.r + (3 * a - 2 * r) * s.r,
                n.g = 6 * (a - r) * e.g + (3 * a - 4 * r + 1) * t.g + 6 * (-a + r) * i.g + (3 * a - 2 * r) * s.g,
                n.b = 6 * (a - r) * e.b + (3 * a - 4 * r + 1) * t.b + 6 * (-a + r) * i.b + (3 * a - 2 * r) * s.b
            }
            static Red() {
                return new Fe(1,0,0)
            }
            static Green() {
                return new Fe(0,1,0)
            }
            static Blue() {
                return new Fe(0,0,1)
            }
            static Black() {
                return new Fe(0,0,0)
            }
            static get BlackReadOnly() {
                return Fe._BlackReadOnly
            }
            static White() {
                return new Fe(1,1,1)
            }
            static Purple() {
                return new Fe(.5,0,.5)
            }
            static Magenta() {
                return new Fe(1,0,1)
            }
            static Yellow() {
                return new Fe(1,1,0)
            }
            static Gray() {
                return new Fe(.5,.5,.5)
            }
            static Teal() {
                return new Fe(0,1,1)
            }
            static Random() {
                return new Fe(Math.random(),Math.random(),Math.random())
            }
        }
        Fe._BlackReadOnly = Fe.Black(),
        Object.defineProperties(Fe.prototype, {
            dimension: {
                value: [3]
            },
            rank: {
                value: 1
            }
        });
        class Oe {
            constructor(e=0, t=0, i=0, s=1) {
                this.r = e,
                this.g = t,
                this.b = i,
                this.a = s
            }
            asArray() {
                return [this.r, this.g, this.b, this.a]
            }
            toArray(e, t=0) {
                return e[t] = this.r,
                e[t + 1] = this.g,
                e[t + 2] = this.b,
                e[t + 3] = this.a,
                this
            }
            fromArray(e, t=0) {
                return this.r = e[t],
                this.g = e[t + 1],
                this.b = e[t + 2],
                this.a = e[t + 3],
                this
            }
            equals(e) {
                return e && this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a
            }
            add(e) {
                return new this.constructor(this.r + e.r,this.g + e.g,this.b + e.b,this.a + e.a)
            }
            addToRef(e, t) {
                return t.r = this.r + e.r,
                t.g = this.g + e.g,
                t.b = this.b + e.b,
                t.a = this.a + e.a,
                t
            }
            addInPlace(e) {
                return this.r += e.r,
                this.g += e.g,
                this.b += e.b,
                this.a += e.a,
                this
            }
            addInPlaceFromFloats(e, t, i, s) {
                return this.r += e,
                this.g += t,
                this.b += i,
                this.a += s,
                this
            }
            subtract(e) {
                return new this.constructor(this.r - e.r,this.g - e.g,this.b - e.b,this.a - e.a)
            }
            subtractToRef(e, t) {
                return t.r = this.r - e.r,
                t.g = this.g - e.g,
                t.b = this.b - e.b,
                t.a = this.a - e.a,
                t
            }
            subtractInPlace(e) {
                return this.r -= e.r,
                this.g -= e.g,
                this.b -= e.b,
                this.a -= e.a,
                this
            }
            subtractFromFloats(e, t, i, s) {
                return new this.constructor(this.r - e,this.g - t,this.b - i,this.a - s)
            }
            subtractFromFloatsToRef(e, t, i, s, r) {
                return r.r = this.r - e,
                r.g = this.g - t,
                r.b = this.b - i,
                r.a = this.a - s,
                r
            }
            scale(e) {
                return new this.constructor(this.r * e,this.g * e,this.b * e,this.a * e)
            }
            scaleInPlace(e) {
                return this.r *= e,
                this.g *= e,
                this.b *= e,
                this.a *= e,
                this
            }
            scaleToRef(e, t) {
                return t.r = this.r * e,
                t.g = this.g * e,
                t.b = this.b * e,
                t.a = this.a * e,
                t
            }
            scaleAndAddToRef(e, t) {
                return t.r += this.r * e,
                t.g += this.g * e,
                t.b += this.b * e,
                t.a += this.a * e,
                t
            }
            clampToRef(e=0, t=1, i) {
                return i.r = ve(this.r, e, t),
                i.g = ve(this.g, e, t),
                i.b = ve(this.b, e, t),
                i.a = ve(this.a, e, t),
                i
            }
            multiply(e) {
                return new this.constructor(this.r * e.r,this.g * e.g,this.b * e.b,this.a * e.a)
            }
            multiplyToRef(e, t) {
                return t.r = this.r * e.r,
                t.g = this.g * e.g,
                t.b = this.b * e.b,
                t.a = this.a * e.a,
                t
            }
            multiplyInPlace(e) {
                return this.r *= e.r,
                this.g *= e.g,
                this.b *= e.b,
                this.a *= e.a,
                this
            }
            multiplyByFloats(e, t, i, s) {
                return new this.constructor(this.r * e,this.g * t,this.b * i,this.a * s)
            }
            divide(e) {
                throw new ReferenceError("Can not divide a color")
            }
            divideToRef(e, t) {
                throw new ReferenceError("Can not divide a color")
            }
            divideInPlace(e) {
                throw new ReferenceError("Can not divide a color")
            }
            minimizeInPlace(e) {
                return this.r = Math.min(this.r, e.r),
                this.g = Math.min(this.g, e.g),
                this.b = Math.min(this.b, e.b),
                this.a = Math.min(this.a, e.a),
                this
            }
            maximizeInPlace(e) {
                return this.r = Math.max(this.r, e.r),
                this.g = Math.max(this.g, e.g),
                this.b = Math.max(this.b, e.b),
                this.a = Math.max(this.a, e.a),
                this
            }
            minimizeInPlaceFromFloats(e, t, i, s) {
                return this.r = Math.min(e, this.r),
                this.g = Math.min(t, this.g),
                this.b = Math.min(i, this.b),
                this.a = Math.min(s, this.a),
                this
            }
            maximizeInPlaceFromFloats(e, t, i, s) {
                return this.r = Math.max(e, this.r),
                this.g = Math.max(t, this.g),
                this.b = Math.max(i, this.b),
                this.a = Math.max(s, this.a),
                this
            }
            floorToRef(e) {
                throw new ReferenceError("Can not floor a color")
            }
            floor() {
                throw new ReferenceError("Can not floor a color")
            }
            fractToRef(e) {
                throw new ReferenceError("Can not fract a color")
            }
            fract() {
                throw new ReferenceError("Can not fract a color")
            }
            negate() {
                throw new ReferenceError("Can not negate a color")
            }
            negateInPlace() {
                throw new ReferenceError("Can not negate a color")
            }
            negateToRef(e) {
                throw new ReferenceError("Can not negate a color")
            }
            equalsWithEpsilon(e, t=.001) {
                return xe.WithinEpsilon(this.r, e.r, t) && xe.WithinEpsilon(this.g, e.g, t) && xe.WithinEpsilon(this.b, e.b, t) && xe.WithinEpsilon(this.a, e.a, t)
            }
            equalsToFloats(e, t, i, s) {
                return this.r === e && this.g === t && this.b === i && this.a === s
            }
            toString() {
                return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}"
            }
            getClassName() {
                return "Color4"
            }
            getHashCode() {
                let e = 255 * this.r | 0;
                return e = 397 * e ^ 255 * this.g,
                e = 397 * e ^ 255 * this.b,
                e = 397 * e ^ 255 * this.a,
                e
            }
            clone() {
                return (new this.constructor).copyFrom(this)
            }
            copyFrom(e) {
                return this.r = e.r,
                this.g = e.g,
                this.b = e.b,
                this.a = e.a,
                this
            }
            copyFromFloats(e, t, i, s) {
                return this.r = e,
                this.g = t,
                this.b = i,
                this.a = s,
                this
            }
            set(e, t, i, s) {
                return this.copyFromFloats(e, t, i, s)
            }
            setAll(e) {
                return this.r = this.g = this.b = this.a = e,
                this
            }
            toHexString(e=!1) {
                const t = Math.round(255 * this.r)
                  , i = Math.round(255 * this.g)
                  , s = Math.round(255 * this.b);
                if (e)
                    return "#" + be(t) + be(i) + be(s);
                const r = Math.round(255 * this.a);
                return "#" + be(t) + be(i) + be(s) + be(r)
            }
            toLinearSpace(e=!1) {
                const t = new Oe;
                return this.toLinearSpaceToRef(t, e),
                t
            }
            toLinearSpaceToRef(e, t=!1) {
                return t ? (e.r = Pe(this.r),
                e.g = Pe(this.g),
                e.b = Pe(this.b)) : (e.r = Ce(this.r),
                e.g = Ce(this.g),
                e.b = Ce(this.b)),
                e.a = this.a,
                this
            }
            toGammaSpace(e=!1) {
                const t = new Oe;
                return this.toGammaSpaceToRef(t, e),
                t
            }
            toGammaSpaceToRef(e, t=!1) {
                return t ? (e.r = we(this.r),
                e.g = we(this.g),
                e.b = we(this.b)) : (e.r = De(this.r),
                e.g = De(this.g),
                e.b = De(this.b)),
                e.a = this.a,
                this
            }
            static FromHexString(e) {
                if ("#" !== e.substring(0, 1) || 9 !== e.length && 7 !== e.length)
                    return new Oe(0,0,0,0);
                const t = parseInt(e.substring(1, 3), 16)
                  , i = parseInt(e.substring(3, 5), 16)
                  , s = parseInt(e.substring(5, 7), 16)
                  , r = 9 === e.length ? parseInt(e.substring(7, 9), 16) : 255;
                return Oe.FromInts(t, i, s, r)
            }
            static Lerp(e, t, i) {
                const s = new Oe(0,0,0,0);
                return Oe.LerpToRef(e, t, i, s),
                s
            }
            static LerpToRef(e, t, i, s) {
                s.r = e.r + (t.r - e.r) * i,
                s.g = e.g + (t.g - e.g) * i,
                s.b = e.b + (t.b - e.b) * i,
                s.a = e.a + (t.a - e.a) * i
            }
            static Hermite(e, t, i, s, r) {
                const n = r * r
                  , a = r * n
                  , o = 2 * a - 3 * n + 1
                  , h = -2 * a + 3 * n
                  , l = a - 2 * n + r
                  , c = a - n
                  , u = e.r * o + i.r * h + t.r * l + s.r * c
                  , d = e.g * o + i.g * h + t.g * l + s.g * c
                  , f = e.b * o + i.b * h + t.b * l + s.b * c
                  , _ = e.a * o + i.a * h + t.a * l + s.a * c;
                return new Oe(u,d,f,_)
            }
            static Hermite1stDerivative(e, t, i, s, r) {
                const n = new Oe;
                return this.Hermite1stDerivativeToRef(e, t, i, s, r, n),
                n
            }
            static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
                const a = r * r;
                n.r = 6 * (a - r) * e.r + (3 * a - 4 * r + 1) * t.r + 6 * (-a + r) * i.r + (3 * a - 2 * r) * s.r,
                n.g = 6 * (a - r) * e.g + (3 * a - 4 * r + 1) * t.g + 6 * (-a + r) * i.g + (3 * a - 2 * r) * s.g,
                n.b = 6 * (a - r) * e.b + (3 * a - 4 * r + 1) * t.b + 6 * (-a + r) * i.b + (3 * a - 2 * r) * s.b,
                n.a = 6 * (a - r) * e.a + (3 * a - 4 * r + 1) * t.a + 6 * (-a + r) * i.a + (3 * a - 2 * r) * s.a
            }
            static FromColor3(e, t=1) {
                return new Oe(e.r,e.g,e.b,t)
            }
            static FromArray(e, t=0) {
                return new Oe(e[t],e[t + 1],e[t + 2],e[t + 3])
            }
            static FromArrayToRef(e, t=0, i) {
                i.r = e[t],
                i.g = e[t + 1],
                i.b = e[t + 2],
                i.a = e[t + 3]
            }
            static FromInts(e, t, i, s) {
                return new Oe(e / 255,t / 255,i / 255,s / 255)
            }
            static CheckColors4(e, t) {
                if (e.length === 3 * t) {
                    const t = [];
                    for (let i = 0; i < e.length; i += 3) {
                        const s = i / 3 * 4;
                        t[s] = e[i],
                        t[s + 1] = e[i + 1],
                        t[s + 2] = e[i + 2],
                        t[s + 3] = 1
                    }
                    return t
                }
                return e
            }
        }
        Object.defineProperties(Oe.prototype, {
            dimension: {
                value: [4]
            },
            rank: {
                value: 1
            }
        });
        class Le {
        }
        Le.Color3 = Me.BuildArray(3, Fe.Black),
        Le.Color4 = Me.BuildArray(3, ( () => new Oe(0,0,0,0))),
        Ie("BABYLON.Color3", Fe),
        Ie("BABYLON.Color4", Oe);
        class Be {
            constructor(e, t=!1, i, s) {
                this.initialize(e, t, i, s)
            }
            initialize(e, t=!1, i, s) {
                return this.mask = e,
                this.skipNextObservers = t,
                this.target = i,
                this.currentTarget = s,
                this
            }
        }
        class Ne {
            constructor(e, t, i=null) {
                this.callback = e,
                this.mask = t,
                this.scope = i,
                this._willBeUnregistered = !1,
                this.unregisterOnNextCall = !1,
                this._remove = null
            }
            remove() {
                this._remove && this._remove()
            }
        }
        class Ue {
            static FromPromise(e, t) {
                const i = new Ue;
                return e.then((e => {
                    i.notifyObservers(e)
                }
                )).catch((e => {
                    if (!t)
                        throw e;
                    t.notifyObservers(e)
                }
                )),
                i
            }
            get observers() {
                return this._observers
            }
            constructor(e, t=!1) {
                this.notifyIfTriggered = t,
                this._observers = new Array,
                this._numObserversMarkedAsDeleted = 0,
                this._hasNotified = !1,
                this._eventState = new Be(0),
                e && (this._onObserverAdded = e)
            }
            add(e, t=-1, i=!1, s=null, r=!1) {
                if (!e)
                    return null;
                const n = new Ne(e,t,s);
                return n.unregisterOnNextCall = r,
                i ? this._observers.unshift(n) : this._observers.push(n),
                this._onObserverAdded && this._onObserverAdded(n),
                this._hasNotified && this.notifyIfTriggered && void 0 !== this._lastNotifiedValue && this.notifyObserver(n, this._lastNotifiedValue),
                n._remove = () => {
                    this.remove(n)
                }
                ,
                n
            }
            addOnce(e) {
                return this.add(e, void 0, void 0, void 0, !0)
            }
            remove(e) {
                return !!e && (e._remove = null,
                -1 !== this._observers.indexOf(e) && (this._deferUnregister(e),
                !0))
            }
            removeCallback(e, t) {
                for (let i = 0; i < this._observers.length; i++) {
                    const s = this._observers[i];
                    if (!(s._willBeUnregistered || s.callback !== e || t && t !== s.scope))
                        return this._deferUnregister(s),
                        !0
                }
                return !1
            }
            _deferUnregister(e) {
                e._willBeUnregistered || (this._numObserversMarkedAsDeleted++,
                e.unregisterOnNextCall = !1,
                e._willBeUnregistered = !0,
                setTimeout(( () => {
                    this._remove(e)
                }
                ), 0))
            }
            _remove(e, t=!0) {
                if (!e)
                    return !1;
                const i = this._observers.indexOf(e);
                return -1 !== i && (t && this._numObserversMarkedAsDeleted--,
                this._observers.splice(i, 1),
                !0)
            }
            makeObserverTopPriority(e) {
                this._remove(e, !1),
                this._observers.unshift(e)
            }
            makeObserverBottomPriority(e) {
                this._remove(e, !1),
                this._observers.push(e)
            }
            notifyObservers(e, t=-1, i, s, r) {
                if (this.notifyIfTriggered && (this._hasNotified = !0,
                this._lastNotifiedValue = e),
                !this._observers.length)
                    return !0;
                const n = this._eventState;
                n.mask = t,
                n.target = i,
                n.currentTarget = s,
                n.skipNextObservers = !1,
                n.lastReturnValue = e,
                n.userInfo = r;
                for (const i of this._observers)
                    if (!i._willBeUnregistered && (i.mask & t && (i.unregisterOnNextCall && this._deferUnregister(i),
                    i.scope ? n.lastReturnValue = i.callback.apply(i.scope, [e, n]) : n.lastReturnValue = i.callback(e, n)),
                    n.skipNextObservers))
                        return !1;
                return !0
            }
            notifyObserver(e, t, i=-1) {
                if (this.notifyIfTriggered && (this._hasNotified = !0,
                this._lastNotifiedValue = t),
                e._willBeUnregistered)
                    return;
                const s = this._eventState;
                s.mask = i,
                s.skipNextObservers = !1,
                e.unregisterOnNextCall && this._deferUnregister(e),
                e.callback(t, s)
            }
            hasObservers() {
                return this._observers.length - this._numObserversMarkedAsDeleted > 0
            }
            clear() {
                for (; this._observers.length; ) {
                    const e = this._observers.pop();
                    e && (e._remove = null)
                }
                this._onObserverAdded = null,
                this._numObserversMarkedAsDeleted = 0,
                this.cleanLastNotifiedState()
            }
            cleanLastNotifiedState() {
                this._hasNotified = !1,
                this._lastNotifiedValue = void 0
            }
            clone() {
                const e = new Ue;
                return e._observers = this._observers.slice(0),
                e
            }
            hasSpecificMask(e=-1) {
                for (const t of this._observers)
                    if (t.mask & e || t.mask === e)
                        return !0;
                return !1
            }
        }
        function ke() {
            return "undefined" != typeof window
        }
        function Ve() {
            return "undefined" != typeof navigator
        }
        function Ge() {
            return "undefined" != typeof document
        }
        function ze(e) {
            let t = ""
              , i = e.firstChild;
            for (; i; )
                3 === i.nodeType && (t += i.textContent),
                i = i.nextSibling;
            return t
        }
        class We {
            static _CheckLimit(e, t) {
                let i = We._LogLimitOutputs[e];
                return i ? i.current++ : (i = {
                    limit: t,
                    current: 1
                },
                We._LogLimitOutputs[e] = i),
                i.current <= i.limit
            }
            static _GenerateLimitMessage(e, t=1) {
                const i = We._LogLimitOutputs[e];
                if (!i || !We.MessageLimitReached)
                    return;
                const s = this._Levels[t];
                i.current === i.limit && We[s.name](We.MessageLimitReached.replace(/%LIMIT%/g, "" + i.limit).replace(/%TYPE%/g, s.name ?? ""))
            }
            static _AddLogEntry(e) {
                We._LogCache = e + We._LogCache,
                We.OnNewCacheEntry && We.OnNewCacheEntry(e)
            }
            static _FormatMessage(e) {
                const t = e => e < 10 ? "0" + e : "" + e
                  , i = new Date;
                return "[" + t(i.getHours()) + ":" + t(i.getMinutes()) + ":" + t(i.getSeconds()) + "]: " + e
            }
            static _LogDisabled(e, t) {}
            static _LogEnabled(e=1, t, i) {
                const s = Array.isArray(t) ? t[0] : t;
                if (void 0 !== i && !We._CheckLimit(s, i))
                    return;
                const r = We._FormatMessage(s)
                  , n = this._Levels[e]
                  , a = Array.isArray(t) ? t.slice(1) : [];
                n.logFunc && n.logFunc("BJS - " + r, ...a);
                const o = `<div style='color:${n.color}'>${r}</div><br>`;
                We._AddLogEntry(o),
                We._GenerateLimitMessage(s, e)
            }
            static get LogCache() {
                return We._LogCache
            }
            static ClearLogCache() {
                We._LogCache = "",
                We._LogLimitOutputs = {},
                We.errorsCount = 0
            }
            static set LogLevels(e) {
                We.Log = We._LogDisabled,
                We.Warn = We._LogDisabled,
                We.Error = We._LogDisabled,
                [We.MessageLogLevel, We.WarningLogLevel, We.ErrorLogLevel].forEach((t => {
                    if ((e & t) === t) {
                        const e = this._Levels[t];
                        We[e.name] = We._LogEnabled.bind(We, t)
                    }
                }
                ))
            }
        }
        We.NoneLogLevel = 0,
        We.MessageLogLevel = 1,
        We.WarningLogLevel = 2,
        We.ErrorLogLevel = 4,
        We.AllLogLevel = 7,
        We.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.",
        We._LogCache = "",
        We._LogLimitOutputs = {},
        We._Levels = [{}, {
            color: "white",
            logFunc: console.log,
            name: "Log"
        }, {
            color: "orange",
            logFunc: console.warn,
            name: "Warn"
        }, {}, {
            color: "red",
            logFunc: console.error,
            name: "Error"
        }],
        We.errorsCount = 0,
        We.Log = We._LogEnabled.bind(We, We.MessageLogLevel),
        We.Warn = We._LogEnabled.bind(We, We.WarningLogLevel),
        We.Error = We._LogEnabled.bind(We, We.ErrorLogLevel);
        const Xe = (e, t, i) => e ? e.getClassName && "Mesh" === e.getClassName() ? null : !e.getClassName || "SubMesh" !== e.getClassName() && "PhysicsBody" !== e.getClassName() ? e.clone ? e.clone() : Array.isArray(e) ? e.slice() : i && "object" == typeof e ? {
            ...e
        } : null : e.clone(t) : null;
        class He {
            static DeepCopy(e, t, i, s, r=!1) {
                const n = function(e) {
                    const t = [];
                    do {
                        Object.getOwnPropertyNames(e).forEach((function(e) {
                            -1 === t.indexOf(e) && t.push(e)
                        }
                        ))
                    } while (e = Object.getPrototypeOf(e));
                    return t
                }(e);
                for (const a of n) {
                    if ("_" === a[0] && (!s || -1 === s.indexOf(a)))
                        continue;
                    if (a.endsWith("Observable"))
                        continue;
                    if (i && -1 !== i.indexOf(a))
                        continue;
                    const n = e[a]
                      , o = typeof n;
                    if ("function" !== o)
                        try {
                            if ("object" === o)
                                if (n instanceof Uint8Array)
                                    t[a] = Uint8Array.from(n);
                                else if (n instanceof Array) {
                                    if (t[a] = [],
                                    n.length > 0)
                                        if ("object" == typeof n[0])
                                            for (let e = 0; e < n.length; e++) {
                                                const i = Xe(n[e], t, r);
                                                -1 === t[a].indexOf(i) && t[a].push(i)
                                            }
                                        else
                                            t[a] = n.slice(0)
                                } else
                                    t[a] = Xe(n, t, r);
                            else
                                t[a] = n
                        } catch (e) {
                            We.Warn(e.message)
                        }
                }
            }
        }
        class Ke {
            static get Now() {
                return ke() && window.performance && window.performance.now ? window.performance.now() : Date.now()
            }
        }
        const Ye = {};
        function je(e, t=!1) {
            if (!t || !Ye[e])
                return Ye[e] = !0,
                `${e} needs to be imported before as it contains a side-effect required by your code.`
        }
        class qe {
            constructor() {
                this._xhr = "undefined" != typeof _native && _native.XMLHttpRequest ? new _native.XMLHttpRequest : new XMLHttpRequest,
                this._requestURL = ""
            }
            static get IsCustomRequestAvailable() {
                return Object.keys(qe.CustomRequestHeaders).length > 0 || qe.CustomRequestModifiers.length > 0
            }
            _injectCustomRequestHeaders() {
                if (!this._shouldSkipRequestModifications(this._requestURL))
                    for (const e in qe.CustomRequestHeaders) {
                        const t = qe.CustomRequestHeaders[e];
                        t && this._xhr.setRequestHeader(e, t)
                    }
            }
            _shouldSkipRequestModifications(e) {
                return qe.SkipRequestModificationForBabylonCDN && (e.includes("preview.babylonjs.com") || e.includes("cdn.babylonjs.com"))
            }
            get onprogress() {
                return this._xhr.onprogress
            }
            set onprogress(e) {
                this._xhr.onprogress = e
            }
            get readyState() {
                return this._xhr.readyState
            }
            get status() {
                return this._xhr.status
            }
            get statusText() {
                return this._xhr.statusText
            }
            get response() {
                return this._xhr.response
            }
            get responseURL() {
                return this._xhr.responseURL
            }
            get responseText() {
                return this._xhr.responseText
            }
            get responseType() {
                return this._xhr.responseType
            }
            set responseType(e) {
                this._xhr.responseType = e
            }
            get timeout() {
                return this._xhr.timeout
            }
            set timeout(e) {
                this._xhr.timeout = e
            }
            addEventListener(e, t, i) {
                this._xhr.addEventListener(e, t, i)
            }
            removeEventListener(e, t, i) {
                this._xhr.removeEventListener(e, t, i)
            }
            abort() {
                this._xhr.abort()
            }
            send(e) {
                qe.CustomRequestHeaders && this._injectCustomRequestHeaders(),
                this._xhr.send(e)
            }
            open(e, t) {
                for (const e of qe.CustomRequestModifiers) {
                    if (this._shouldSkipRequestModifications(t))
                        return;
                    e(this._xhr, t)
                }
                t = (t = t.replace("file:http:", "http:")).replace("file:https:", "https:"),
                this._requestURL = t,
                this._xhr.open(e, t, !0)
            }
            setRequestHeader(e, t) {
                this._xhr.setRequestHeader(e, t)
            }
            getResponseHeader(e) {
                return this._xhr.getResponseHeader(e)
            }
        }
        qe.CustomRequestHeaders = {},
        qe.CustomRequestModifiers = new Array,
        qe.SkipRequestModificationForBabylonCDN = !0;
        class Ze {
            static get LastCreatedEngine() {
                return 0 === this.Instances.length ? null : this.Instances[this.Instances.length - 1]
            }
            static get LastCreatedScene() {
                return this._LastCreatedScene
            }
        }
        Ze.Instances = [],
        Ze.OnEnginesDisposedObservable = new Ue,
        Ze._LastCreatedScene = null,
        Ze.UseFallbackTexture = !0,
        Ze.FallbackTexture = "";
        class Qe {
        }
        Qe.FilesToLoad = {};
        class $e extends Error {
        }
        $e._setPrototypeOf = Object.setPrototypeOf || ( (e, t) => (e.__proto__ = t,
        e));
        class Je extends $e {
            constructor(e, t, i) {
                super(e),
                this.errorCode = t,
                this.innerError = i,
                this.name = "RuntimeError",
                $e._setPrototypeOf(this, Je.prototype)
            }
        }
        const et = e => {
            const t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            let i, s, r, n, a, o, h, l = "", c = 0;
            const u = ArrayBuffer.isView(e) ? new Uint8Array(e.buffer,e.byteOffset,e.byteLength) : new Uint8Array(e);
            for (; c < u.length; )
                i = u[c++],
                s = c < u.length ? u[c++] : Number.NaN,
                r = c < u.length ? u[c++] : Number.NaN,
                n = i >> 2,
                a = (3 & i) << 4 | s >> 4,
                o = (15 & s) << 2 | r >> 6,
                h = 63 & r,
                isNaN(s) ? o = h = 64 : isNaN(r) && (h = 64),
                l += t.charAt(n) + t.charAt(a) + t.charAt(o) + t.charAt(h);
            return l
        }
          , tt = e => atob(e);
        class it {
            constructor() {
                this.children = []
            }
            isValid(e) {
                return !0
            }
            process(e, t) {
                let i = "";
                if (this.line) {
                    let s = this.line;
                    const r = t.processor;
                    if (r) {
                        r.lineProcessor && (s = r.lineProcessor(s, t.isFragment, t.processingContext));
                        const i = t.processor?.attributeKeywordName ?? "attribute"
                          , n = t.isFragment && t.processor?.varyingFragmentKeywordName ? t.processor?.varyingFragmentKeywordName : !t.isFragment && t.processor?.varyingVertexKeywordName ? t.processor?.varyingVertexKeywordName : "varying";
                        !t.isFragment && r.attributeProcessor && this.line.startsWith(i) ? s = r.attributeProcessor(this.line, e, t.processingContext) : r.varyingProcessor && (r.varyingCheck?.(this.line, t.isFragment) || !r.varyingCheck && this.line.startsWith(n)) ? s = r.varyingProcessor(this.line, t.isFragment, e, t.processingContext) : r.uniformProcessor && r.uniformRegexp && r.uniformRegexp.test(this.line) ? t.lookForClosingBracketForUniformBuffer || (s = r.uniformProcessor(this.line, t.isFragment, e, t.processingContext)) : r.uniformBufferProcessor && r.uniformBufferRegexp && r.uniformBufferRegexp.test(this.line) ? t.lookForClosingBracketForUniformBuffer || (s = r.uniformBufferProcessor(this.line, t.isFragment, t.processingContext),
                        t.lookForClosingBracketForUniformBuffer = !0) : r.textureProcessor && r.textureRegexp && r.textureRegexp.test(this.line) ? s = r.textureProcessor(this.line, t.isFragment, e, t.processingContext) : (r.uniformProcessor || r.uniformBufferProcessor) && this.line.startsWith("uniform") && !t.lookForClosingBracketForUniformBuffer && (/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line) ? r.uniformProcessor && (s = r.uniformProcessor(this.line, t.isFragment, e, t.processingContext)) : r.uniformBufferProcessor && (s = r.uniformBufferProcessor(this.line, t.isFragment, t.processingContext),
                        t.lookForClosingBracketForUniformBuffer = !0)),
                        t.lookForClosingBracketForUniformBuffer && -1 !== this.line.indexOf("}") && (t.lookForClosingBracketForUniformBuffer = !1,
                        r.endOfUniformBufferProcessor && (s = r.endOfUniformBufferProcessor(this.line, t.isFragment, t.processingContext)))
                    }
                    i += s + "\n"
                }
                return this.children.forEach((s => {
                    i += s.process(e, t)
                }
                )),
                this.additionalDefineKey && (e[this.additionalDefineKey] = this.additionalDefineValue || "true"),
                i
            }
        }
        class st {
            constructor() {
                this._lines = []
            }
            get currentLine() {
                return this._lines[this.lineIndex]
            }
            get canRead() {
                return this.lineIndex < this._lines.length - 1
            }
            set lines(e) {
                this._lines.length = 0;
                for (const t of e) {
                    if (!t || "\r" === t)
                        continue;
                    if ("#" === t[0]) {
                        this._lines.push(t);
                        continue
                    }
                    const e = t.trim();
                    if (!e)
                        continue;
                    if (e.startsWith("//")) {
                        this._lines.push(t);
                        continue
                    }
                    const i = e.indexOf(";");
                    if (-1 === i)
                        this._lines.push(e);
                    else if (i === e.length - 1)
                        e.length > 1 && this._lines.push(e);
                    else {
                        const e = t.split(";");
                        for (let t = 0; t < e.length; t++) {
                            let i = e[t];
                            i && (i = i.trim(),
                            i && this._lines.push(i + (t !== e.length - 1 ? ";" : "")))
                        }
                    }
                }
            }
        }
        class rt extends it {
            process(e, t) {
                for (let i = 0; i < this.children.length; i++) {
                    const s = this.children[i];
                    if (s.isValid(e))
                        return s.process(e, t)
                }
                return ""
            }
        }
        class nt extends it {
            isValid(e) {
                return this.testExpression.isTrue(e)
            }
        }
        class at {
            isTrue(e) {
                return !0
            }
            static postfixToInfix(e) {
                const t = [];
                for (const i of e)
                    if (void 0 === at._OperatorPriority[i])
                        t.push(i);
                    else {
                        const e = t[t.length - 1]
                          , s = t[t.length - 2];
                        t.length -= 2,
                        t.push(`(${s}${i}${e})`)
                    }
                return t[t.length - 1]
            }
            static infixToPostfix(e) {
                const t = at._InfixToPostfixCache.get(e);
                if (t)
                    return t.accessTime = Date.now(),
                    t.result;
                if (!(e.includes("&&") || e.includes("||") || e.includes(")") || e.includes("(")))
                    return [e];
                const i = [];
                let s = -1;
                const r = () => {
                    l = l.trim(),
                    "" !== l && (i.push(l),
                    l = "")
                }
                  , n = e => {
                    s < at._Stack.length - 1 && (at._Stack[++s] = e)
                }
                  , a = () => at._Stack[s]
                  , o = () => -1 === s ? "!!INVALID EXPRESSION!!" : at._Stack[s--];
                let h = 0
                  , l = "";
                for (; h < e.length; ) {
                    const t = e.charAt(h)
                      , c = h < e.length - 1 ? e.substr(h, 2) : "";
                    if ("(" === t)
                        l = "",
                        n(t);
                    else if (")" === t) {
                        for (r(); -1 !== s && "(" !== a(); )
                            i.push(o());
                        o()
                    } else if (at._OperatorPriority[c] > 1) {
                        for (r(); -1 !== s && at._OperatorPriority[a()] >= at._OperatorPriority[c]; )
                            i.push(o());
                        n(c),
                        h++
                    } else
                        l += t;
                    h++
                }
                for (r(); -1 !== s; )
                    "(" === a() ? o() : i.push(o());
                return at._InfixToPostfixCache.size >= at.InfixToPostfixCacheLimitSize && at.ClearCache(),
                at._InfixToPostfixCache.set(e, {
                    result: i,
                    accessTime: Date.now()
                }),
                i
            }
            static ClearCache() {
                const e = Array.from(at._InfixToPostfixCache.entries()).sort(( (e, t) => e[1].accessTime - t[1].accessTime));
                for (let t = 0; t < at.InfixToPostfixCacheCleanupSize; t++)
                    at._InfixToPostfixCache.delete(e[t][0])
            }
        }
        at.InfixToPostfixCacheLimitSize = 5e4,
        at.InfixToPostfixCacheCleanupSize = 25e3,
        at._InfixToPostfixCache = new Map,
        at._OperatorPriority = {
            ")": 0,
            "(": 1,
            "||": 2,
            "&&": 3
        },
        at._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
        class ot extends at {
            constructor(e, t=!1) {
                super(),
                this.define = e,
                this.not = t
            }
            isTrue(e) {
                let t = void 0 !== e[this.define];
                return this.not && (t = !t),
                t
            }
        }
        class ht extends at {
            isTrue(e) {
                return this.leftOperand.isTrue(e) || this.rightOperand.isTrue(e)
            }
        }
        class lt extends at {
            isTrue(e) {
                return this.leftOperand.isTrue(e) && this.rightOperand.isTrue(e)
            }
        }
        class ct extends at {
            constructor(e, t, i) {
                super(),
                this.define = e,
                this.operand = t,
                this.testValue = i
            }
            isTrue(e) {
                let t = e[this.define];
                void 0 === t && (t = this.define);
                let i = !1;
                const s = parseInt(t)
                  , r = parseInt(this.testValue);
                switch (this.operand) {
                case ">":
                    i = s > r;
                    break;
                case "<":
                    i = s < r;
                    break;
                case "<=":
                    i = s <= r;
                    break;
                case ">=":
                    i = s >= r;
                    break;
                case "==":
                    i = s === r;
                    break;
                case "!=":
                    i = s !== r
                }
                return i
            }
        }
        var ut;
        !function(e) {
            e[e.GLSL = 0] = "GLSL",
            e[e.WGSL = 1] = "WGSL"
        }(ut || (ut = {}));
        const dt = /defined\s*?\((.+?)\)/g
          , ft = /defined\s*?\[(.+?)\]/g
          , _t = /#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g
          , pt = /__decl__/
          , mt = /light\{X\}.(\w*)/g
          , gt = /\{X\}/g
          , vt = [];
        class yt {
            static Initialize(e) {
                e.processor && e.processor.initializeShaders && e.processor.initializeShaders(e.processingContext)
            }
            static Process(e, t, i, s) {
                t.processor?.preProcessShaderCode && (e = t.processor.preProcessShaderCode(e, t.isFragment)),
                this._ProcessIncludes(e, t, (e => {
                    t.processCodeAfterIncludes && (e = t.processCodeAfterIncludes(t.isFragment ? "fragment" : "vertex", e));
                    const r = this._ProcessShaderConversion(e, t, s);
                    i(r, e)
                }
                ))
            }
            static PreProcess(e, t, i, s) {
                t.processor?.preProcessShaderCode && (e = t.processor.preProcessShaderCode(e, t.isFragment)),
                this._ProcessIncludes(e, t, (e => {
                    t.processCodeAfterIncludes && (e = t.processCodeAfterIncludes(t.isFragment ? "fragment" : "vertex", e));
                    const r = this._ApplyPreProcessing(e, t, s);
                    i(r, e)
                }
                ))
            }
            static Finalize(e, t, i) {
                return i.processor && i.processor.finalizeShaders ? i.processor.finalizeShaders(e, t, i.processingContext) : {
                    vertexCode: e,
                    fragmentCode: t
                }
            }
            static _ProcessPrecision(e, t) {
                if (t.processor?.noPrecision)
                    return e;
                const i = t.shouldUseHighPrecisionShader;
                return -1 === e.indexOf("precision highp float") ? e = i ? "precision highp float;\n" + e : "precision mediump float;\n" + e : i || (e = e.replace("precision highp float", "precision mediump float")),
                e
            }
            static _ExtractOperation(e) {
                const t = /defined\((.+)\)/.exec(e);
                if (t && t.length)
                    return new ot(t[1].trim(),"!" === e[0]);
                const i = ["==", "!=", ">=", "<=", "<", ">"];
                let s = ""
                  , r = 0;
                for (s of i)
                    if (r = e.indexOf(s),
                    r > -1)
                        break;
                if (-1 === r)
                    return new ot(e);
                const n = e.substring(0, r).trim()
                  , a = e.substring(r + s.length).trim();
                return new ct(n,s,a)
            }
            static _BuildSubExpression(e) {
                e = e.replace(dt, "defined[$1]");
                const t = at.infixToPostfix(e)
                  , i = [];
                for (const e of t)
                    if ("||" !== e && "&&" !== e)
                        i.push(e);
                    else if (i.length >= 2) {
                        let t = i[i.length - 1]
                          , s = i[i.length - 2];
                        i.length -= 2;
                        const r = "&&" == e ? new lt : new ht;
                        "string" == typeof t && (t = t.replace(ft, "defined($1)")),
                        "string" == typeof s && (s = s.replace(ft, "defined($1)")),
                        r.leftOperand = "string" == typeof s ? this._ExtractOperation(s) : s,
                        r.rightOperand = "string" == typeof t ? this._ExtractOperation(t) : t,
                        i.push(r)
                    }
                let s = i[i.length - 1];
                return "string" == typeof s && (s = s.replace(ft, "defined($1)")),
                "string" == typeof s ? this._ExtractOperation(s) : s
            }
            static _BuildExpression(e, t) {
                const i = new nt
                  , s = e.substring(0, t);
                let r = e.substring(t);
                return r = r.substring(0, (r.indexOf("//") + 1 || r.length + 1) - 1).trim(),
                i.testExpression = "#ifdef" === s ? new ot(r) : "#ifndef" === s ? new ot(r,!0) : this._BuildSubExpression(r),
                i
            }
            static _MoveCursorWithinIf(e, t, i) {
                let s = e.currentLine;
                for (; this._MoveCursor(e, i); ) {
                    s = e.currentLine;
                    const r = s.substring(0, 5).toLowerCase();
                    if ("#else" === r) {
                        const i = new it;
                        return t.children.push(i),
                        void this._MoveCursor(e, i)
                    }
                    if ("#elif" === r) {
                        const e = this._BuildExpression(s, 5);
                        t.children.push(e),
                        i = e
                    }
                }
            }
            static _MoveCursor(e, t) {
                for (; e.canRead; ) {
                    e.lineIndex++;
                    const i = e.currentLine;
                    if (i.indexOf("#") >= 0) {
                        const s = yt._MoveCursorRegex.exec(i);
                        if (s && s.length) {
                            switch (s[0]) {
                            case "#ifdef":
                                {
                                    const s = new rt;
                                    t.children.push(s);
                                    const r = this._BuildExpression(i, 6);
                                    s.children.push(r),
                                    this._MoveCursorWithinIf(e, s, r);
                                    break
                                }
                            case "#else":
                            case "#elif":
                                return !0;
                            case "#endif":
                                return !1;
                            case "#ifndef":
                                {
                                    const s = new rt;
                                    t.children.push(s);
                                    const r = this._BuildExpression(i, 7);
                                    s.children.push(r),
                                    this._MoveCursorWithinIf(e, s, r);
                                    break
                                }
                            case "#if":
                                {
                                    const s = new rt
                                      , r = this._BuildExpression(i, 3);
                                    t.children.push(s),
                                    s.children.push(r),
                                    this._MoveCursorWithinIf(e, s, r);
                                    break
                                }
                            }
                            continue
                        }
                    }
                    const s = new it;
                    if (s.line = i,
                    t.children.push(s),
                    "#" === i[0] && "d" === i[1]) {
                        const e = i.replace(";", "").split(" ");
                        s.additionalDefineKey = e[1],
                        3 === e.length && (s.additionalDefineValue = e[2])
                    }
                }
                return !1
            }
            static _EvaluatePreProcessors(e, t, i) {
                const s = new it
                  , r = new st;
                return r.lineIndex = -1,
                r.lines = e.split("\n"),
                this._MoveCursor(r, s),
                s.process(t, i)
            }
            static _PreparePreProcessors(e, t) {
                const i = e.defines
                  , s = {};
                for (const e of i) {
                    const t = e.replace("#define", "").replace(";", "").trim().split(" ");
                    s[t[0]] = t.length > 1 ? t[1] : ""
                }
                return e.processor?.shaderLanguage === ut.GLSL && (s.GL_ES = "true"),
                s.__VERSION__ = e.version,
                s[e.platformName] = "true",
                t._getGlobalDefines(s),
                s
            }
            static _ProcessShaderConversion(e, t, i) {
                let s = this._ProcessPrecision(e, t);
                if (!t.processor)
                    return s;
                if (t.processor.shaderLanguage === ut.GLSL && -1 !== s.indexOf("#version 3") && (s = s.replace("#version 300 es", ""),
                !t.processor.parseGLES3))
                    return s;
                const r = t.defines
                  , n = this._PreparePreProcessors(t, i);
                return t.processor.preProcessor && (s = t.processor.preProcessor(s, r, t.isFragment, t.processingContext)),
                s = this._EvaluatePreProcessors(s, n, t),
                t.processor.postProcessor && (s = t.processor.postProcessor(s, r, t.isFragment, t.processingContext, i)),
                i._features.needShaderCodeInlining && (s = i.inlineShaderCode(s)),
                s
            }
            static _ApplyPreProcessing(e, t, i) {
                let s = e;
                const r = t.defines
                  , n = this._PreparePreProcessors(t, i);
                return t.processor?.preProcessor && (s = t.processor.preProcessor(s, r, t.isFragment, t.processingContext)),
                s = this._EvaluatePreProcessors(s, n, t),
                t.processor?.postProcessor && (s = t.processor.postProcessor(s, r, t.isFragment, t.processingContext, i)),
                i._features.needShaderCodeInlining && (s = i.inlineShaderCode(s)),
                s
            }
            static _ProcessIncludes(e, t, i) {
                let s;
                for (vt.length = 0; null !== (s = _t.exec(e)); )
                    vt.push(s);
                let r = String(e)
                  , n = [e]
                  , a = !1;
                for (const e of vt) {
                    let s = e[1];
                    if (-1 !== s.indexOf("__decl__") && (s = s.replace(pt, ""),
                    t.supportsUniformBuffers && (s = s.replace("Vertex", "Ubo").replace("Fragment", "Ubo")),
                    s += "Declaration"),
                    !t.includesShadersStore[s]) {
                        const e = t.shadersRepository + "ShadersInclude/" + s + ".fx";
                        return void yt._FileToolsLoadFile(e, (e => {
                            t.includesShadersStore[s] = e,
                            this._ProcessIncludes(n.join(""), t, i)
                        }
                        ))
                    }
                    {
                        let i = t.includesShadersStore[s];
                        if (e[2]) {
                            const t = e[3].split(",");
                            for (let e = 0; e < t.length; e += 2) {
                                const s = new RegExp(t[e],"g")
                                  , r = t[e + 1];
                                i = i.replace(s, r)
                            }
                        }
                        if (e[4]) {
                            const s = e[5];
                            if (-1 !== s.indexOf("..")) {
                                const e = s.split("..")
                                  , r = parseInt(e[0]);
                                let n = parseInt(e[1])
                                  , a = i.slice(0);
                                i = "",
                                isNaN(n) && (n = t.indexParameters[e[1]]);
                                for (let e = r; e < n; e++)
                                    t.supportsUniformBuffers || (a = a.replace(mt, ( (e, t) => t + "{X}"))),
                                    i += a.replace(gt, e.toString()) + "\n"
                            } else
                                t.supportsUniformBuffers || (i = i.replace(mt, ( (e, t) => t + "{X}"))),
                                i = i.replace(gt, s)
                        }
                        const r = [];
                        for (const t of n) {
                            const s = t.split(e[0]);
                            for (let e = 0; e < s.length - 1; e++)
                                r.push(s[e]),
                                r.push(i);
                            r.push(s[s.length - 1])
                        }
                        n = r,
                        a = a || i.indexOf("#include<") >= 0 || i.indexOf("#include <") >= 0
                    }
                }
                vt.length = 0,
                r = n.join(""),
                a ? this._ProcessIncludes(r.toString(), t, i) : i(r)
            }
            static _FileToolsLoadFile(e, t, i, s, r, n) {
                throw je("FileTools")
            }
        }
        yt._MoveCursorRegex = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;
        class bt {
            static GetShadersRepository(e=ut.GLSL) {
                return e === ut.GLSL ? bt.ShadersRepository : bt.ShadersRepositoryWGSL
            }
            static GetShadersStore(e=ut.GLSL) {
                return e === ut.GLSL ? bt.ShadersStore : bt.ShadersStoreWGSL
            }
            static GetIncludesShadersStore(e=ut.GLSL) {
                return e === ut.GLSL ? bt.IncludesShadersStore : bt.IncludesShadersStoreWGSL
            }
        }
        bt.ShadersRepository = "src/Shaders/",
        bt.ShadersStore = {},
        bt.IncludesShadersStore = {},
        bt.ShadersRepositoryWGSL = "src/ShadersWGSL/",
        bt.ShadersStoreWGSL = {},
        bt.IncludesShadersStoreWGSL = {};
        class xt {
            static get ShadersRepository() {
                return bt.ShadersRepository
            }
            static set ShadersRepository(e) {
                bt.ShadersRepository = e
            }
            get onBindObservable() {
                return this._onBindObservable || (this._onBindObservable = new Ue),
                this._onBindObservable
            }
            get shaderLanguage() {
                return this._shaderLanguage
            }
            constructor(e, t, i, s=null, r, n=null, a=null, o=null, h=null, l, c="", u=ut.GLSL) {
                if (this.name = null,
                this.defines = "",
                this.onCompiled = null,
                this.onError = null,
                this.onBind = null,
                this.uniqueId = 0,
                this.onCompileObservable = new Ue,
                this.onErrorObservable = new Ue,
                this._onBindObservable = null,
                this._isDisposed = !1,
                this._bonesComputationForcedToCPU = !1,
                this._uniformBuffersNames = {},
                this._multiTarget = !1,
                this._samplers = {},
                this._isReady = !1,
                this._compilationError = "",
                this._allFallbacksProcessed = !1,
                this._uniforms = {},
                this._key = "",
                this._fallbacks = null,
                this._vertexSourceCodeOverride = "",
                this._fragmentSourceCodeOverride = "",
                this._transformFeedbackVaryings = null,
                this._pipelineContext = null,
                this._vertexSourceCode = "",
                this._fragmentSourceCode = "",
                this._vertexSourceCodeBeforeMigration = "",
                this._fragmentSourceCodeBeforeMigration = "",
                this._rawVertexSourceCode = "",
                this._rawFragmentSourceCode = "",
                this._processCodeAfterIncludes = void 0,
                this._processFinalCode = null,
                this.name = e,
                this._key = c,
                t.attributes) {
                    const e = t;
                    if (this._engine = i,
                    this._attributesNames = e.attributes,
                    this._uniformsNames = e.uniformsNames.concat(e.samplers),
                    this._samplerList = e.samplers.slice(),
                    this.defines = e.defines,
                    this.onError = e.onError,
                    this.onCompiled = e.onCompiled,
                    this._fallbacks = e.fallbacks,
                    this._indexParameters = e.indexParameters,
                    this._transformFeedbackVaryings = e.transformFeedbackVaryings || null,
                    this._multiTarget = !!e.multiTarget,
                    this._shaderLanguage = e.shaderLanguage ?? ut.GLSL,
                    e.uniformBuffersNames) {
                        this._uniformBuffersNamesList = e.uniformBuffersNames.slice();
                        for (let t = 0; t < e.uniformBuffersNames.length; t++)
                            this._uniformBuffersNames[e.uniformBuffersNames[t]] = t
                    }
                    this._processFinalCode = e.processFinalCode ?? null,
                    this._processCodeAfterIncludes = e.processCodeAfterIncludes ?? void 0
                } else
                    this._engine = r,
                    this.defines = null == n ? "" : n,
                    this._uniformsNames = i.concat(s),
                    this._samplerList = s ? s.slice() : [],
                    this._attributesNames = t,
                    this._uniformBuffersNamesList = [],
                    this._shaderLanguage = u,
                    this.onError = h,
                    this.onCompiled = o,
                    this._indexParameters = l,
                    this._fallbacks = a;
                this._attributeLocationByName = {},
                this.uniqueId = xt._UniqueIdSeed++,
                this._processShaderCode()
            }
            _processShaderCode(e=null, t=!1) {
                let i, s;
                const r = this.name
                  , n = ke() ? this._engine.getHostDocument() : null;
                r.vertexSource ? i = "source:" + r.vertexSource : r.vertexElement ? (i = n ? n.getElementById(r.vertexElement) : null,
                i || (i = r.vertexElement)) : i = r.vertex || r,
                r.fragmentSource ? s = "source:" + r.fragmentSource : r.fragmentElement ? (s = n ? n.getElementById(r.fragmentElement) : null,
                s || (s = r.fragmentElement)) : s = r.fragment || r,
                this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);
                let a = {
                    defines: this.defines.split("\n"),
                    indexParameters: this._indexParameters,
                    isFragment: !1,
                    shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
                    processor: e ?? this._engine._getShaderProcessor(this._shaderLanguage),
                    supportsUniformBuffers: this._engine.supportsUniformBuffers,
                    shadersRepository: bt.GetShadersRepository(this._shaderLanguage),
                    includesShadersStore: bt.GetIncludesShadersStore(this._shaderLanguage),
                    version: (100 * this._engine.version).toString(),
                    platformName: this._engine.shaderPlatformName,
                    processingContext: this._processingContext,
                    isNDCHalfZRange: this._engine.isNDCHalfZRange,
                    useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
                    processCodeAfterIncludes: this._processCodeAfterIncludes
                };
                const o = [void 0, void 0]
                  , h = () => {
                    if (o[0] && o[1]) {
                        a.isFragment = !0;
                        const [e,i] = o;
                        yt.Process(i, a, ( (i, s) => {
                            this._fragmentSourceCodeBeforeMigration = s,
                            this._processFinalCode && (i = this._processFinalCode("fragment", i));
                            const n = yt.Finalize(e, i, a);
                            a = null,
                            this._useFinalCode(n.vertexCode, n.fragmentCode, r, t)
                        }
                        ), this._engine)
                    }
                }
                ;
                this._loadShader(i, "Vertex", "", (e => {
                    yt.Initialize(a),
                    yt.Process(e, a, ( (t, i) => {
                        this._rawVertexSourceCode = e,
                        this._vertexSourceCodeBeforeMigration = i,
                        this._processFinalCode && (t = this._processFinalCode("vertex", t)),
                        o[0] = t,
                        h()
                    }
                    ), this._engine)
                }
                )),
                this._loadShader(s, "Fragment", "Pixel", (e => {
                    this._rawFragmentSourceCode = e,
                    o[1] = e,
                    h()
                }
                ))
            }
            _useFinalCode(e, t, i, s=!1) {
                if (i) {
                    const s = i.vertexElement || i.vertex || i.spectorName || i
                      , r = i.fragmentElement || i.fragment || i.spectorName || i;
                    this._vertexSourceCode = (this._shaderLanguage === ut.WGSL ? "//" : "") + "#define SHADER_NAME vertex:" + s + "\n" + e,
                    this._fragmentSourceCode = (this._shaderLanguage === ut.WGSL ? "//" : "") + "#define SHADER_NAME fragment:" + r + "\n" + t
                } else
                    this._vertexSourceCode = e,
                    this._fragmentSourceCode = t;
                this._prepareEffect(s)
            }
            get key() {
                return this._key
            }
            isReady() {
                try {
                    return this._isReadyInternal()
                } catch {
                    return !1
                }
            }
            _isReadyInternal() {
                return !!this._isReady || !!this._pipelineContext && this._pipelineContext.isReady
            }
            getEngine() {
                return this._engine
            }
            getPipelineContext() {
                return this._pipelineContext
            }
            getAttributesNames() {
                return this._attributesNames
            }
            getAttributeLocation(e) {
                return this._attributes[e]
            }
            getAttributeLocationByName(e) {
                return this._attributeLocationByName[e]
            }
            getAttributesCount() {
                return this._attributes.length
            }
            getUniformIndex(e) {
                return this._uniformsNames.indexOf(e)
            }
            getUniform(e) {
                return this._uniforms[e]
            }
            getSamplers() {
                return this._samplerList
            }
            getUniformNames() {
                return this._uniformsNames
            }
            getUniformBuffersNames() {
                return this._uniformBuffersNamesList
            }
            getIndexParameters() {
                return this._indexParameters
            }
            getCompilationError() {
                return this._compilationError
            }
            allFallbacksProcessed() {
                return this._allFallbacksProcessed
            }
            executeWhenCompiled(e) {
                this.isReady() ? e(this) : (this.onCompileObservable.add((t => {
                    e(t)
                }
                )),
                this._pipelineContext && !this._pipelineContext.isAsync || setTimeout(( () => {
                    this._checkIsReady(null)
                }
                ), 16))
            }
            _checkIsReady(e) {
                try {
                    if (this._isReadyInternal())
                        return
                } catch (t) {
                    return void this._processCompilationErrors(t, e)
                }
                this._isDisposed || setTimeout(( () => {
                    this._checkIsReady(e)
                }
                ), 16)
            }
            _loadShader(e, t, i, s) {
                if ("undefined" != typeof HTMLElement && e instanceof HTMLElement)
                    return void s(ze(e));
                if ("source:" === e.substr(0, 7))
                    return void s(e.substr(7));
                if ("base64:" === e.substr(0, 7))
                    return void s(window.atob(e.substr(7)));
                const r = bt.GetShadersStore(this._shaderLanguage);
                if (r[e + t + "Shader"])
                    return void s(r[e + t + "Shader"]);
                if (i && r[e + i + "Shader"])
                    return void s(r[e + i + "Shader"]);
                let n;
                n = "." === e[0] || "/" === e[0] || e.indexOf("http") > -1 ? e : bt.GetShadersRepository(this._shaderLanguage) + e,
                this._engine._loadFile(n + "." + t.toLowerCase() + ".fx", s)
            }
            get vertexSourceCode() {
                return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : this._pipelineContext?._getVertexShaderCode() ?? this._vertexSourceCode
            }
            get fragmentSourceCode() {
                return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : this._pipelineContext?._getFragmentShaderCode() ?? this._fragmentSourceCode
            }
            get vertexSourceCodeBeforeMigration() {
                return this._vertexSourceCodeBeforeMigration
            }
            get fragmentSourceCodeBeforeMigration() {
                return this._fragmentSourceCodeBeforeMigration
            }
            get rawVertexSourceCode() {
                return this._rawVertexSourceCode
            }
            get rawFragmentSourceCode() {
                return this._rawFragmentSourceCode
            }
            _rebuildProgram(e, t, i, s) {
                this._isReady = !1,
                this._vertexSourceCodeOverride = e,
                this._fragmentSourceCodeOverride = t,
                this.onError = (e, t) => {
                    s && s(t)
                }
                ,
                this.onCompiled = () => {
                    const e = this.getEngine().scenes;
                    if (e)
                        for (let t = 0; t < e.length; t++)
                            e[t].markAllMaterialsAsDirty(63);
                    this._pipelineContext._handlesSpectorRebuildCallback?.(i)
                }
                ,
                this._fallbacks = null,
                this._prepareEffect()
            }
            _prepareEffect(e=!1) {
                const t = this._attributesNames
                  , i = this.defines
                  , s = this._pipelineContext;
                this._isReady = !1;
                try {
                    const r = this._engine;
                    this._pipelineContext = (e ? s : void 0) ?? r.createPipelineContext(this._processingContext),
                    this._pipelineContext._name = this._key.replace(/\r/g, "").replace(/\n/g, "|");
                    const n = (e, t, i, s) => this._rebuildProgram(e, t, i, s);
                    this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? r._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, !0, this._rawVertexSourceCode, this._rawFragmentSourceCode, n, null, this._transformFeedbackVaryings, this._key) : r._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, !1, this._rawVertexSourceCode, this._rawFragmentSourceCode, n, i, this._transformFeedbackVaryings, this._key),
                    r._executeWhenRenderingStateIsCompiled(this._pipelineContext, ( () => {
                        if (this._attributes = [],
                        this._pipelineContext._fillEffectInformation(this, this._uniformBuffersNames, this._uniformsNames, this._uniforms, this._samplerList, this._samplers, t, this._attributes),
                        t)
                            for (let e = 0; e < t.length; e++) {
                                const i = t[e];
                                this._attributeLocationByName[i] = this._attributes[e]
                            }
                        r.bindSamplers(this),
                        this._compilationError = "",
                        this._isReady = !0,
                        this.onCompiled && this.onCompiled(this),
                        this.onCompileObservable.notifyObservers(this),
                        this.onCompileObservable.clear(),
                        this._fallbacks && this._fallbacks.unBindMesh(),
                        s && !e && this.getEngine()._deletePipelineContext(s)
                    }
                    )),
                    this._pipelineContext.isAsync && this._checkIsReady(s)
                } catch (e) {
                    this._processCompilationErrors(e, s)
                }
            }
            _getShaderCodeAndErrorLine(e, t, i) {
                const s = i ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/;
                let r = null;
                if (t && e) {
                    const n = t.match(s);
                    if (n && 2 === n.length) {
                        const t = parseInt(n[1])
                          , s = e.split("\n", -1);
                        s.length >= t && (r = `Offending line [${t}] in ${i ? "fragment" : "vertex"} code: ${s[t - 1]}`)
                    }
                }
                return [e, r]
            }
            _processCompilationErrors(e, t=null) {
                this._compilationError = e.message;
                const i = this._attributesNames
                  , s = this._fallbacks;
                if (We.Error("Unable to compile effect:"),
                We.Error("Uniforms: " + this._uniformsNames.map((function(e) {
                    return " " + e
                }
                ))),
                We.Error("Attributes: " + i.map((function(e) {
                    return " " + e
                }
                ))),
                We.Error("Defines:\n" + this.defines),
                xt.LogShaderCodeOnCompilationError) {
                    let e = null
                      , t = null
                      , i = null;
                    this._pipelineContext?._getVertexShaderCode() && ([i,e] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, !1),
                    i && (We.Error("Vertex code:"),
                    We.Error(i))),
                    this._pipelineContext?._getFragmentShaderCode() && ([i,t] = this._getShaderCodeAndErrorLine(this._pipelineContext?._getFragmentShaderCode(), this._compilationError, !0),
                    i && (We.Error("Fragment code:"),
                    We.Error(i))),
                    e && We.Error(e),
                    t && We.Error(t)
                }
                We.Error("Error: " + this._compilationError);
                const r = () => {
                    this.onError && this.onError(this, this._compilationError),
                    this.onErrorObservable.notifyObservers(this)
                }
                ;
                t && (this._pipelineContext = t,
                this._isReady = !0,
                r()),
                s ? (this._pipelineContext = null,
                s.hasMoreFallbacks ? (this._allFallbacksProcessed = !1,
                We.Error("Trying next fallback."),
                this.defines = s.reduce(this.defines, this),
                this._prepareEffect()) : (this._allFallbacksProcessed = !0,
                r(),
                this.onErrorObservable.clear(),
                this._fallbacks && this._fallbacks.unBindMesh())) : (this._allFallbacksProcessed = !0,
                t || r())
            }
            get isSupported() {
                return "" === this._compilationError
            }
            _bindTexture(e, t) {
                this._engine._bindTexture(this._samplers[e], t, e)
            }
            setTexture(e, t) {
                this._engine.setTexture(this._samplers[e], this._uniforms[e], t, e)
            }
            setDepthStencilTexture(e, t) {
                this._engine.setDepthStencilTexture(this._samplers[e], this._uniforms[e], t, e)
            }
            setTextureArray(e, t) {
                const i = e + "Ex";
                if (-1 === this._samplerList.indexOf(i + "0")) {
                    const s = this._samplerList.indexOf(e);
                    for (let e = 1; e < t.length; e++) {
                        const t = i + (e - 1).toString();
                        this._samplerList.splice(s + e, 0, t)
                    }
                    let r = 0;
                    for (const e of this._samplerList)
                        this._samplers[e] = r,
                        r += 1
                }
                this._engine.setTextureArray(this._samplers[e], this._uniforms[e], t, e)
            }
            setTextureFromPostProcess(e, t) {
                this._engine.setTextureFromPostProcess(this._samplers[e], t, e)
            }
            setTextureFromPostProcessOutput(e, t) {
                this._engine.setTextureFromPostProcessOutput(this._samplers[e], t, e)
            }
            bindUniformBuffer(e, t) {
                const i = this._uniformBuffersNames[t];
                void 0 === i || xt._BaseCache[i] === e && this._engine._features.useUBOBindingCache || (xt._BaseCache[i] = e,
                this._engine.bindUniformBufferBase(e, i, t))
            }
            bindUniformBlock(e, t) {
                this._engine.bindUniformBlock(this._pipelineContext, e, t)
            }
            setInt(e, t) {
                return this._pipelineContext.setInt(e, t),
                this
            }
            setInt2(e, t, i) {
                return this._pipelineContext.setInt2(e, t, i),
                this
            }
            setInt3(e, t, i, s) {
                return this._pipelineContext.setInt3(e, t, i, s),
                this
            }
            setInt4(e, t, i, s, r) {
                return this._pipelineContext.setInt4(e, t, i, s, r),
                this
            }
            setIntArray(e, t) {
                return this._pipelineContext.setIntArray(e, t),
                this
            }
            setIntArray2(e, t) {
                return this._pipelineContext.setIntArray2(e, t),
                this
            }
            setIntArray3(e, t) {
                return this._pipelineContext.setIntArray3(e, t),
                this
            }
            setIntArray4(e, t) {
                return this._pipelineContext.setIntArray4(e, t),
                this
            }
            setUInt(e, t) {
                return this._pipelineContext.setUInt(e, t),
                this
            }
            setUInt2(e, t, i) {
                return this._pipelineContext.setUInt2(e, t, i),
                this
            }
            setUInt3(e, t, i, s) {
                return this._pipelineContext.setUInt3(e, t, i, s),
                this
            }
            setUInt4(e, t, i, s, r) {
                return this._pipelineContext.setUInt4(e, t, i, s, r),
                this
            }
            setUIntArray(e, t) {
                return this._pipelineContext.setUIntArray(e, t),
                this
            }
            setUIntArray2(e, t) {
                return this._pipelineContext.setUIntArray2(e, t),
                this
            }
            setUIntArray3(e, t) {
                return this._pipelineContext.setUIntArray3(e, t),
                this
            }
            setUIntArray4(e, t) {
                return this._pipelineContext.setUIntArray4(e, t),
                this
            }
            setFloatArray(e, t) {
                return this._pipelineContext.setArray(e, t),
                this
            }
            setFloatArray2(e, t) {
                return this._pipelineContext.setArray2(e, t),
                this
            }
            setFloatArray3(e, t) {
                return this._pipelineContext.setArray3(e, t),
                this
            }
            setFloatArray4(e, t) {
                return this._pipelineContext.setArray4(e, t),
                this
            }
            setArray(e, t) {
                return this._pipelineContext.setArray(e, t),
                this
            }
            setArray2(e, t) {
                return this._pipelineContext.setArray2(e, t),
                this
            }
            setArray3(e, t) {
                return this._pipelineContext.setArray3(e, t),
                this
            }
            setArray4(e, t) {
                return this._pipelineContext.setArray4(e, t),
                this
            }
            setMatrices(e, t) {
                return this._pipelineContext.setMatrices(e, t),
                this
            }
            setMatrix(e, t) {
                return this._pipelineContext.setMatrix(e, t),
                this
            }
            setMatrix3x3(e, t) {
                return this._pipelineContext.setMatrix3x3(e, t),
                this
            }
            setMatrix2x2(e, t) {
                return this._pipelineContext.setMatrix2x2(e, t),
                this
            }
            setFloat(e, t) {
                return this._pipelineContext.setFloat(e, t),
                this
            }
            setBool(e, t) {
                return this._pipelineContext.setInt(e, t ? 1 : 0),
                this
            }
            setVector2(e, t) {
                return this._pipelineContext.setVector2(e, t),
                this
            }
            setFloat2(e, t, i) {
                return this._pipelineContext.setFloat2(e, t, i),
                this
            }
            setVector3(e, t) {
                return this._pipelineContext.setVector3(e, t),
                this
            }
            setFloat3(e, t, i, s) {
                return this._pipelineContext.setFloat3(e, t, i, s),
                this
            }
            setVector4(e, t) {
                return this._pipelineContext.setVector4(e, t),
                this
            }
            setQuaternion(e, t) {
                return this._pipelineContext.setQuaternion(e, t),
                this
            }
            setFloat4(e, t, i, s, r) {
                return this._pipelineContext.setFloat4(e, t, i, s, r),
                this
            }
            setColor3(e, t) {
                return this._pipelineContext.setColor3(e, t),
                this
            }
            setColor4(e, t, i) {
                return this._pipelineContext.setColor4(e, t, i),
                this
            }
            setDirectColor4(e, t) {
                return this._pipelineContext.setDirectColor4(e, t),
                this
            }
            dispose() {
                this._pipelineContext && this._pipelineContext.dispose(),
                this._engine._releaseEffect(this),
                this._isDisposed = !0
            }
            static RegisterShader(e, t, i, s=ut.GLSL) {
                t && (bt.GetShadersStore(s)[`${e}PixelShader`] = t),
                i && (bt.GetShadersStore(s)[`${e}VertexShader`] = i)
            }
            static ResetCache() {
                xt._BaseCache = {}
            }
        }
        xt.LogShaderCodeOnCompilationError = !0,
        xt._UniqueIdSeed = 0,
        xt._BaseCache = {},
        xt.ShadersStore = bt.ShadersStore,
        xt.IncludesShadersStore = bt.IncludesShadersStore;
        class Tt {
            constructor(e=!0) {
                this._isDepthTestDirty = !1,
                this._isDepthMaskDirty = !1,
                this._isDepthFuncDirty = !1,
                this._isCullFaceDirty = !1,
                this._isCullDirty = !1,
                this._isZOffsetDirty = !1,
                this._isFrontFaceDirty = !1,
                e && this.reset()
            }
            get isDirty() {
                return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty
            }
            get zOffset() {
                return this._zOffset
            }
            set zOffset(e) {
                this._zOffset !== e && (this._zOffset = e,
                this._isZOffsetDirty = !0)
            }
            get zOffsetUnits() {
                return this._zOffsetUnits
            }
            set zOffsetUnits(e) {
                this._zOffsetUnits !== e && (this._zOffsetUnits = e,
                this._isZOffsetDirty = !0)
            }
            get cullFace() {
                return this._cullFace
            }
            set cullFace(e) {
                this._cullFace !== e && (this._cullFace = e,
                this._isCullFaceDirty = !0)
            }
            get cull() {
                return this._cull
            }
            set cull(e) {
                this._cull !== e && (this._cull = e,
                this._isCullDirty = !0)
            }
            get depthFunc() {
                return this._depthFunc
            }
            set depthFunc(e) {
                this._depthFunc !== e && (this._depthFunc = e,
                this._isDepthFuncDirty = !0)
            }
            get depthMask() {
                return this._depthMask
            }
            set depthMask(e) {
                this._depthMask !== e && (this._depthMask = e,
                this._isDepthMaskDirty = !0)
            }
            get depthTest() {
                return this._depthTest
            }
            set depthTest(e) {
                this._depthTest !== e && (this._depthTest = e,
                this._isDepthTestDirty = !0)
            }
            get frontFace() {
                return this._frontFace
            }
            set frontFace(e) {
                this._frontFace !== e && (this._frontFace = e,
                this._isFrontFaceDirty = !0)
            }
            reset() {
                this._depthMask = !0,
                this._depthTest = !0,
                this._depthFunc = null,
                this._cullFace = null,
                this._cull = null,
                this._zOffset = 0,
                this._zOffsetUnits = 0,
                this._frontFace = null,
                this._isDepthTestDirty = !0,
                this._isDepthMaskDirty = !0,
                this._isDepthFuncDirty = !1,
                this._isCullFaceDirty = !1,
                this._isCullDirty = !1,
                this._isZOffsetDirty = !0,
                this._isFrontFaceDirty = !1
            }
            apply(e) {
                this.isDirty && (this._isCullDirty && (this.cull ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE),
                this._isCullDirty = !1),
                this._isCullFaceDirty && (e.cullFace(this.cullFace),
                this._isCullFaceDirty = !1),
                this._isDepthMaskDirty && (e.depthMask(this.depthMask),
                this._isDepthMaskDirty = !1),
                this._isDepthTestDirty && (this.depthTest ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST),
                this._isDepthTestDirty = !1),
                this._isDepthFuncDirty && (e.depthFunc(this.depthFunc),
                this._isDepthFuncDirty = !1),
                this._isZOffsetDirty && (this.zOffset || this.zOffsetUnits ? (e.enable(e.POLYGON_OFFSET_FILL),
                e.polygonOffset(this.zOffset, this.zOffsetUnits)) : e.disable(e.POLYGON_OFFSET_FILL),
                this._isZOffsetDirty = !1),
                this._isFrontFaceDirty && (e.frontFace(this.frontFace),
                this._isFrontFaceDirty = !1))
            }
        }
        class Et {
            constructor() {
                this.reset()
            }
            reset() {
                this.enabled = !1,
                this.mask = 255,
                this.func = Et.ALWAYS,
                this.funcRef = 1,
                this.funcMask = 255,
                this.opStencilFail = Et.KEEP,
                this.opDepthFail = Et.KEEP,
                this.opStencilDepthPass = Et.REPLACE
            }
            get stencilFunc() {
                return this.func
            }
            set stencilFunc(e) {
                this.func = e
            }
            get stencilFuncRef() {
                return this.funcRef
            }
            set stencilFuncRef(e) {
                this.funcRef = e
            }
            get stencilFuncMask() {
                return this.funcMask
            }
            set stencilFuncMask(e) {
                this.funcMask = e
            }
            get stencilOpStencilFail() {
                return this.opStencilFail
            }
            set stencilOpStencilFail(e) {
                this.opStencilFail = e
            }
            get stencilOpDepthFail() {
                return this.opDepthFail
            }
            set stencilOpDepthFail(e) {
                this.opDepthFail = e
            }
            get stencilOpStencilDepthPass() {
                return this.opStencilDepthPass
            }
            set stencilOpStencilDepthPass(e) {
                this.opStencilDepthPass = e
            }
            get stencilMask() {
                return this.mask
            }
            set stencilMask(e) {
                this.mask = e
            }
            get stencilTest() {
                return this.enabled
            }
            set stencilTest(e) {
                this.enabled = e
            }
        }
        Et.ALWAYS = 519,
        Et.KEEP = 7680,
        Et.REPLACE = 7681;
        class Mt {
            constructor() {
                this._blendFunctionParameters = new Array(4),
                this._blendEquationParameters = new Array(2),
                this._blendConstants = new Array(4),
                this._isBlendConstantsDirty = !1,
                this._alphaBlend = !1,
                this._isAlphaBlendDirty = !1,
                this._isBlendFunctionParametersDirty = !1,
                this._isBlendEquationParametersDirty = !1,
                this.reset()
            }
            get isDirty() {
                return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty
            }
            get alphaBlend() {
                return this._alphaBlend
            }
            set alphaBlend(e) {
                this._alphaBlend !== e && (this._alphaBlend = e,
                this._isAlphaBlendDirty = !0)
            }
            setAlphaBlendConstants(e, t, i, s) {
                this._blendConstants[0] === e && this._blendConstants[1] === t && this._blendConstants[2] === i && this._blendConstants[3] === s || (this._blendConstants[0] = e,
                this._blendConstants[1] = t,
                this._blendConstants[2] = i,
                this._blendConstants[3] = s,
                this._isBlendConstantsDirty = !0)
            }
            setAlphaBlendFunctionParameters(e, t, i, s) {
                this._blendFunctionParameters[0] === e && this._blendFunctionParameters[1] === t && this._blendFunctionParameters[2] === i && this._blendFunctionParameters[3] === s || (this._blendFunctionParameters[0] = e,
                this._blendFunctionParameters[1] = t,
                this._blendFunctionParameters[2] = i,
                this._blendFunctionParameters[3] = s,
                this._isBlendFunctionParametersDirty = !0)
            }
            setAlphaEquationParameters(e, t) {
                this._blendEquationParameters[0] === e && this._blendEquationParameters[1] === t || (this._blendEquationParameters[0] = e,
                this._blendEquationParameters[1] = t,
                this._isBlendEquationParametersDirty = !0)
            }
            reset() {
                this._alphaBlend = !1,
                this._blendFunctionParameters[0] = null,
                this._blendFunctionParameters[1] = null,
                this._blendFunctionParameters[2] = null,
                this._blendFunctionParameters[3] = null,
                this._blendEquationParameters[0] = null,
                this._blendEquationParameters[1] = null,
                this._blendConstants[0] = null,
                this._blendConstants[1] = null,
                this._blendConstants[2] = null,
                this._blendConstants[3] = null,
                this._isAlphaBlendDirty = !0,
                this._isBlendFunctionParametersDirty = !1,
                this._isBlendEquationParametersDirty = !1,
                this._isBlendConstantsDirty = !1
            }
            apply(e) {
                this.isDirty && (this._isAlphaBlendDirty && (this._alphaBlend ? e.enable(e.BLEND) : e.disable(e.BLEND),
                this._isAlphaBlendDirty = !1),
                this._isBlendFunctionParametersDirty && (e.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]),
                this._isBlendFunctionParametersDirty = !1),
                this._isBlendEquationParametersDirty && (e.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]),
                this._isBlendEquationParametersDirty = !1),
                this._isBlendConstantsDirty && (e.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]),
                this._isBlendConstantsDirty = !1))
            }
        }
        class St {
            get wrapU() {
                return this._cachedWrapU
            }
            set wrapU(e) {
                this._cachedWrapU = e
            }
            get wrapV() {
                return this._cachedWrapV
            }
            set wrapV(e) {
                this._cachedWrapV = e
            }
            get wrapR() {
                return this._cachedWrapR
            }
            set wrapR(e) {
                this._cachedWrapR = e
            }
            get anisotropicFilteringLevel() {
                return this._cachedAnisotropicFilteringLevel
            }
            set anisotropicFilteringLevel(e) {
                this._cachedAnisotropicFilteringLevel = e
            }
            get comparisonFunction() {
                return this._comparisonFunction
            }
            set comparisonFunction(e) {
                this._comparisonFunction = e
            }
            get useMipMaps() {
                return this._useMipMaps
            }
            set useMipMaps(e) {
                this._useMipMaps = e
            }
            constructor() {
                this.samplingMode = -1,
                this._useMipMaps = !0,
                this._cachedWrapU = null,
                this._cachedWrapV = null,
                this._cachedWrapR = null,
                this._cachedAnisotropicFilteringLevel = null,
                this._comparisonFunction = 0
            }
            setParameters(e=1, t=1, i=1, s=1, r=2, n=0) {
                return this._cachedWrapU = e,
                this._cachedWrapV = t,
                this._cachedWrapR = i,
                this._cachedAnisotropicFilteringLevel = s,
                this.samplingMode = r,
                this._comparisonFunction = n,
                this
            }
            compareSampler(e) {
                return this._cachedWrapU === e._cachedWrapU && this._cachedWrapV === e._cachedWrapV && this._cachedWrapR === e._cachedWrapR && this._cachedAnisotropicFilteringLevel === e._cachedAnisotropicFilteringLevel && this.samplingMode === e.samplingMode && this._comparisonFunction === e._comparisonFunction && this._useMipMaps === e._useMipMaps
            }
        }
        var At;
        !function(e) {
            e[e.Unknown = 0] = "Unknown",
            e[e.Url = 1] = "Url",
            e[e.Temp = 2] = "Temp",
            e[e.Raw = 3] = "Raw",
            e[e.Dynamic = 4] = "Dynamic",
            e[e.RenderTarget = 5] = "RenderTarget",
            e[e.MultiRenderTarget = 6] = "MultiRenderTarget",
            e[e.Cube = 7] = "Cube",
            e[e.CubeRaw = 8] = "CubeRaw",
            e[e.CubePrefiltered = 9] = "CubePrefiltered",
            e[e.Raw3D = 10] = "Raw3D",
            e[e.Raw2DArray = 11] = "Raw2DArray",
            e[e.DepthStencil = 12] = "DepthStencil",
            e[e.CubeRawRGBD = 13] = "CubeRawRGBD",
            e[e.Depth = 14] = "Depth"
        }(At || (At = {}));
        class It extends St {
            get useMipMaps() {
                return this.generateMipMaps
            }
            set useMipMaps(e) {
                this.generateMipMaps = e
            }
            get uniqueId() {
                return this._uniqueId
            }
            _setUniqueId(e) {
                this._uniqueId = e
            }
            getEngine() {
                return this._engine
            }
            get source() {
                return this._source
            }
            constructor(e, t, i=!1) {
                super(),
                this.isReady = !1,
                this.isCube = !1,
                this.is3D = !1,
                this.is2DArray = !1,
                this.isMultiview = !1,
                this.url = "",
                this.generateMipMaps = !1,
                this.samples = 0,
                this.type = -1,
                this.format = -1,
                this.onLoadedObservable = new Ue,
                this.onErrorObservable = new Ue,
                this.onRebuildCallback = null,
                this.width = 0,
                this.height = 0,
                this.depth = 0,
                this.baseWidth = 0,
                this.baseHeight = 0,
                this.baseDepth = 0,
                this.invertY = !1,
                this._invertVScale = !1,
                this._associatedChannel = -1,
                this._source = At.Unknown,
                this._buffer = null,
                this._bufferView = null,
                this._bufferViewArray = null,
                this._bufferViewArrayArray = null,
                this._size = 0,
                this._extension = "",
                this._files = null,
                this._workingCanvas = null,
                this._workingContext = null,
                this._cachedCoordinatesMode = null,
                this._isDisabled = !1,
                this._compression = null,
                this._sphericalPolynomial = null,
                this._sphericalPolynomialPromise = null,
                this._sphericalPolynomialComputed = !1,
                this._lodGenerationScale = 0,
                this._lodGenerationOffset = 0,
                this._useSRGBBuffer = !1,
                this._creationFlags = 0,
                this._lodTextureHigh = null,
                this._lodTextureMid = null,
                this._lodTextureLow = null,
                this._isRGBD = !1,
                this._linearSpecularLOD = !1,
                this._irradianceTexture = null,
                this._hardwareTexture = null,
                this._maxLodLevel = null,
                this._references = 1,
                this._gammaSpace = null,
                this._premulAlpha = !1,
                this._dynamicTextureSource = null,
                this._engine = e,
                this._source = t,
                this._uniqueId = It._Counter++,
                i || (this._hardwareTexture = e._createHardwareTexture())
            }
            incrementReferences() {
                this._references++
            }
            updateSize(e, t, i=1) {
                this._engine.updateTextureDimensions(this, e, t, i),
                this.width = e,
                this.height = t,
                this.depth = i,
                this.baseWidth = e,
                this.baseHeight = t,
                this.baseDepth = i,
                this._size = e * t * i
            }
            _rebuild() {
                if (this.isReady = !1,
                this._cachedCoordinatesMode = null,
                this._cachedWrapU = null,
                this._cachedWrapV = null,
                this._cachedWrapR = null,
                this._cachedAnisotropicFilteringLevel = null,
                this.onRebuildCallback) {
                    const e = this.onRebuildCallback(this)
                      , t = t => {
                        t._swapAndDie(this, !1),
                        this.isReady = e.isReady
                    }
                    ;
                    return void (e.isAsync ? e.proxy.then(t) : t(e.proxy))
                }
                let e;
                switch (this.source) {
                case At.Temp:
                    break;
                case At.Url:
                    return void (e = this._engine.createTexture(this._originalUrl ?? this.url, !this.generateMipMaps, this.invertY, null, this.samplingMode, (e => {
                        e._swapAndDie(this, !1),
                        this.isReady = !0
                    }
                    ), null, this._buffer, void 0, this.format, this._extension, void 0, void 0, void 0, this._useSRGBBuffer));
                case At.Raw:
                    e = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type, this._creationFlags, this._useSRGBBuffer),
                    e._swapAndDie(this, !1),
                    this.isReady = !0;
                    break;
                case At.Raw3D:
                    e = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type),
                    e._swapAndDie(this, !1),
                    this.isReady = !0;
                    break;
                case At.Raw2DArray:
                    e = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type),
                    e._swapAndDie(this, !1),
                    this.isReady = !0;
                    break;
                case At.Dynamic:
                    e = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode),
                    e._swapAndDie(this, !1),
                    this._dynamicTextureSource && this._engine.updateDynamicTexture(this, this._dynamicTextureSource, this.invertY, this._premulAlpha, this.format, !0);
                    break;
                case At.Cube:
                    return void (e = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, ( () => {
                        e._swapAndDie(this, !1),
                        this.isReady = !0
                    }
                    ), null, this.format, this._extension, !1, 0, 0, null, void 0, this._useSRGBBuffer));
                case At.CubeRaw:
                    e = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this._originalFormat ?? this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression),
                    e._swapAndDie(this, !1),
                    this.isReady = !0;
                    break;
                case At.CubeRawRGBD:
                    return;
                case At.CubePrefiltered:
                    return e = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, (e => {
                        e && e._swapAndDie(this, !1),
                        this.isReady = !0
                    }
                    ), null, this.format, this._extension),
                    void (e._sphericalPolynomial = this._sphericalPolynomial);
                case At.DepthStencil:
                case At.Depth:
                }
            }
            _swapAndDie(e, t=!0) {
                this._hardwareTexture?.setUsage(e._source, this.generateMipMaps, this.is2DArray, this.isCube, this.is3D, this.width, this.height, this.depth),
                e._hardwareTexture = this._hardwareTexture,
                t && (e._isRGBD = this._isRGBD),
                this._lodTextureHigh && (e._lodTextureHigh && e._lodTextureHigh.dispose(),
                e._lodTextureHigh = this._lodTextureHigh),
                this._lodTextureMid && (e._lodTextureMid && e._lodTextureMid.dispose(),
                e._lodTextureMid = this._lodTextureMid),
                this._lodTextureLow && (e._lodTextureLow && e._lodTextureLow.dispose(),
                e._lodTextureLow = this._lodTextureLow),
                this._irradianceTexture && (e._irradianceTexture && e._irradianceTexture.dispose(),
                e._irradianceTexture = this._irradianceTexture);
                const i = this._engine.getLoadedTexturesCache();
                let s = i.indexOf(this);
                -1 !== s && i.splice(s, 1),
                s = i.indexOf(e),
                -1 === s && i.push(e)
            }
            dispose() {
                this._references--,
                this.onLoadedObservable.clear(),
                this.onErrorObservable.clear(),
                0 === this._references && (this._engine._releaseTexture(this),
                this._hardwareTexture = null,
                this._dynamicTextureSource = null)
            }
        }
        It._Counter = 0;
        class Rt {
            constructor() {
                this.shaderLanguage = ut.GLSL
            }
            postProcessor(e, t, i, s, r) {
                if (!r.getCaps().drawBuffersExtension) {
                    const t = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
                    e = e.replace(t, "")
                }
                return e
            }
        }
        const Ct = /(flat\s)?\s*varying\s*.*/;
        class Pt {
            constructor() {
                this.shaderLanguage = ut.GLSL
            }
            attributeProcessor(e) {
                return e.replace("attribute", "in")
            }
            varyingCheck(e, t) {
                return Ct.test(e)
            }
            varyingProcessor(e, t) {
                return e.replace("varying", t ? "in" : "out")
            }
            postProcessor(e, t, i) {
                const s = -1 !== e.search(/#extension.+GL_EXT_draw_buffers.+require/);
                if (e = (e = e.replace(/#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g, "")).replace(/texture2D\s*\(/g, "texture("),
                i) {
                    const t = -1 !== e.search(/layout *\(location *= *0\) *out/g);
                    e = (e = (e = (e = (e = (e = (e = e.replace(/texture2DLodEXT\s*\(/g, "textureLod(")).replace(/textureCubeLodEXT\s*\(/g, "textureLod(")).replace(/textureCube\s*\(/g, "texture(")).replace(/gl_FragDepthEXT/g, "gl_FragDepth")).replace(/gl_FragColor/g, "glFragColor")).replace(/gl_FragData/g, "glFragData")).replace(/void\s+?main\s*\(/g, (s || t ? "" : "layout(location = 0) out vec4 glFragColor;\n") + "void main(")
                } else if (-1 !== t.indexOf("#define MULTIVIEW"))
                    return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + e;
                return e
            }
        }
        class Dt {
            get underlyingResource() {
                return null
            }
            constructor() {
                this.references = 0,
                this.capacity = 0,
                this.is32Bits = !1,
                this.uniqueId = Dt._Counter++
            }
        }
        Dt._Counter = 0;
        class wt extends Dt {
            constructor(e) {
                super(),
                this._buffer = e
            }
            get underlyingResource() {
                return this._buffer
            }
        }
        class Ft {
            constructor() {
                this._valueCache = {},
                this.vertexCompilationError = null,
                this.fragmentCompilationError = null,
                this.programLinkError = null,
                this.programValidationError = null,
                this._isDisposed = !1
            }
            get isAsync() {
                return this.isParallelCompiled
            }
            get isReady() {
                return !!this.program && (!this.isParallelCompiled || this.engine._isRenderingStateCompiled(this))
            }
            _handlesSpectorRebuildCallback(e) {
                e && this.program && e(this.program)
            }
            _fillEffectInformation(e, t, i, s, r, n, a, o) {
                const h = this.engine;
                if (h.supportsUniformBuffers)
                    for (const i in t)
                        e.bindUniformBlock(i, t[i]);
                let l;
                for (this.engine.getUniforms(this, i).forEach(( (e, t) => {
                    s[i[t]] = e
                }
                )),
                this._uniforms = s,
                l = 0; l < r.length; l++)
                    null == e.getUniform(r[l]) && (r.splice(l, 1),
                    l--);
                r.forEach(( (e, t) => {
                    n[e] = t
                }
                ));
                for (const e of h.getAttributes(this, a))
                    o.push(e)
            }
            dispose() {
                this._uniforms = {},
                this._isDisposed = !0
            }
            _cacheMatrix(e, t) {
                const i = this._valueCache[e]
                  , s = t.updateFlag;
                return (void 0 === i || i !== s) && (this._valueCache[e] = s,
                !0)
            }
            _cacheFloat2(e, t, i) {
                let s = this._valueCache[e];
                if (!s || 2 !== s.length)
                    return s = [t, i],
                    this._valueCache[e] = s,
                    !0;
                let r = !1;
                return s[0] !== t && (s[0] = t,
                r = !0),
                s[1] !== i && (s[1] = i,
                r = !0),
                r
            }
            _cacheFloat3(e, t, i, s) {
                let r = this._valueCache[e];
                if (!r || 3 !== r.length)
                    return r = [t, i, s],
                    this._valueCache[e] = r,
                    !0;
                let n = !1;
                return r[0] !== t && (r[0] = t,
                n = !0),
                r[1] !== i && (r[1] = i,
                n = !0),
                r[2] !== s && (r[2] = s,
                n = !0),
                n
            }
            _cacheFloat4(e, t, i, s, r) {
                let n = this._valueCache[e];
                if (!n || 4 !== n.length)
                    return n = [t, i, s, r],
                    this._valueCache[e] = n,
                    !0;
                let a = !1;
                return n[0] !== t && (n[0] = t,
                a = !0),
                n[1] !== i && (n[1] = i,
                a = !0),
                n[2] !== s && (n[2] = s,
                a = !0),
                n[3] !== r && (n[3] = r,
                a = !0),
                a
            }
            setInt(e, t) {
                const i = this._valueCache[e];
                void 0 !== i && i === t || this.engine.setInt(this._uniforms[e], t) && (this._valueCache[e] = t)
            }
            setInt2(e, t, i) {
                this._cacheFloat2(e, t, i) && (this.engine.setInt2(this._uniforms[e], t, i) || (this._valueCache[e] = null))
            }
            setInt3(e, t, i, s) {
                this._cacheFloat3(e, t, i, s) && (this.engine.setInt3(this._uniforms[e], t, i, s) || (this._valueCache[e] = null))
            }
            setInt4(e, t, i, s, r) {
                this._cacheFloat4(e, t, i, s, r) && (this.engine.setInt4(this._uniforms[e], t, i, s, r) || (this._valueCache[e] = null))
            }
            setIntArray(e, t) {
                this._valueCache[e] = null,
                this.engine.setIntArray(this._uniforms[e], t)
            }
            setIntArray2(e, t) {
                this._valueCache[e] = null,
                this.engine.setIntArray2(this._uniforms[e], t)
            }
            setIntArray3(e, t) {
                this._valueCache[e] = null,
                this.engine.setIntArray3(this._uniforms[e], t)
            }
            setIntArray4(e, t) {
                this._valueCache[e] = null,
                this.engine.setIntArray4(this._uniforms[e], t)
            }
            setUInt(e, t) {
                const i = this._valueCache[e];
                void 0 !== i && i === t || this.engine.setUInt(this._uniforms[e], t) && (this._valueCache[e] = t)
            }
            setUInt2(e, t, i) {
                this._cacheFloat2(e, t, i) && (this.engine.setUInt2(this._uniforms[e], t, i) || (this._valueCache[e] = null))
            }
            setUInt3(e, t, i, s) {
                this._cacheFloat3(e, t, i, s) && (this.engine.setUInt3(this._uniforms[e], t, i, s) || (this._valueCache[e] = null))
            }
            setUInt4(e, t, i, s, r) {
                this._cacheFloat4(e, t, i, s, r) && (this.engine.setUInt4(this._uniforms[e], t, i, s, r) || (this._valueCache[e] = null))
            }
            setUIntArray(e, t) {
                this._valueCache[e] = null,
                this.engine.setUIntArray(this._uniforms[e], t)
            }
            setUIntArray2(e, t) {
                this._valueCache[e] = null,
                this.engine.setUIntArray2(this._uniforms[e], t)
            }
            setUIntArray3(e, t) {
                this._valueCache[e] = null,
                this.engine.setUIntArray3(this._uniforms[e], t)
            }
            setUIntArray4(e, t) {
                this._valueCache[e] = null,
                this.engine.setUIntArray4(this._uniforms[e], t)
            }
            setArray(e, t) {
                this._valueCache[e] = null,
                this.engine.setArray(this._uniforms[e], t)
            }
            setArray2(e, t) {
                this._valueCache[e] = null,
                this.engine.setArray2(this._uniforms[e], t)
            }
            setArray3(e, t) {
                this._valueCache[e] = null,
                this.engine.setArray3(this._uniforms[e], t)
            }
            setArray4(e, t) {
                this._valueCache[e] = null,
                this.engine.setArray4(this._uniforms[e], t)
            }
            setMatrices(e, t) {
                t && (this._valueCache[e] = null,
                this.engine.setMatrices(this._uniforms[e], t))
            }
            setMatrix(e, t) {
                this._cacheMatrix(e, t) && (this.engine.setMatrices(this._uniforms[e], t.asArray()) || (this._valueCache[e] = null))
            }
            setMatrix3x3(e, t) {
                this._valueCache[e] = null,
                this.engine.setMatrix3x3(this._uniforms[e], t)
            }
            setMatrix2x2(e, t) {
                this._valueCache[e] = null,
                this.engine.setMatrix2x2(this._uniforms[e], t)
            }
            setFloat(e, t) {
                const i = this._valueCache[e];
                void 0 !== i && i === t || this.engine.setFloat(this._uniforms[e], t) && (this._valueCache[e] = t)
            }
            setVector2(e, t) {
                this._cacheFloat2(e, t.x, t.y) && (this.engine.setFloat2(this._uniforms[e], t.x, t.y) || (this._valueCache[e] = null))
            }
            setFloat2(e, t, i) {
                this._cacheFloat2(e, t, i) && (this.engine.setFloat2(this._uniforms[e], t, i) || (this._valueCache[e] = null))
            }
            setVector3(e, t) {
                this._cacheFloat3(e, t.x, t.y, t.z) && (this.engine.setFloat3(this._uniforms[e], t.x, t.y, t.z) || (this._valueCache[e] = null))
            }
            setFloat3(e, t, i, s) {
                this._cacheFloat3(e, t, i, s) && (this.engine.setFloat3(this._uniforms[e], t, i, s) || (this._valueCache[e] = null))
            }
            setVector4(e, t) {
                this._cacheFloat4(e, t.x, t.y, t.z, t.w) && (this.engine.setFloat4(this._uniforms[e], t.x, t.y, t.z, t.w) || (this._valueCache[e] = null))
            }
            setQuaternion(e, t) {
                this._cacheFloat4(e, t.x, t.y, t.z, t.w) && (this.engine.setFloat4(this._uniforms[e], t.x, t.y, t.z, t.w) || (this._valueCache[e] = null))
            }
            setFloat4(e, t, i, s, r) {
                this._cacheFloat4(e, t, i, s, r) && (this.engine.setFloat4(this._uniforms[e], t, i, s, r) || (this._valueCache[e] = null))
            }
            setColor3(e, t) {
                this._cacheFloat3(e, t.r, t.g, t.b) && (this.engine.setFloat3(this._uniforms[e], t.r, t.g, t.b) || (this._valueCache[e] = null))
            }
            setColor4(e, t, i) {
                this._cacheFloat4(e, t.r, t.g, t.b, i) && (this.engine.setFloat4(this._uniforms[e], t.r, t.g, t.b, i) || (this._valueCache[e] = null))
            }
            setDirectColor4(e, t) {
                this._cacheFloat4(e, t.r, t.g, t.b, t.a) && (this.engine.setFloat4(this._uniforms[e], t.r, t.g, t.b, t.a) || (this._valueCache[e] = null))
            }
            _getVertexShaderCode() {
                return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null
            }
            _getFragmentShaderCode() {
                return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null
            }
        }
        class Ot {
            static SetMatrixPrecision(e) {
                if (Ot.MatrixTrackPrecisionChange = !1,
                e && !Ot.MatrixUse64Bits && Ot.MatrixTrackedMatrices)
                    for (let e = 0; e < Ot.MatrixTrackedMatrices.length; ++e) {
                        const t = Ot.MatrixTrackedMatrices[e]
                          , i = t._m;
                        t._m = new Array(16);
                        for (let e = 0; e < 16; ++e)
                            t._m[e] = i[e]
                    }
                Ot.MatrixUse64Bits = e,
                Ot.MatrixCurrentType = Ot.MatrixUse64Bits ? Array : Float32Array,
                Ot.MatrixTrackedMatrices = null
            }
        }
        Ot.MatrixUse64Bits = !1,
        Ot.MatrixTrackPrecisionChange = !0,
        Ot.MatrixCurrentType = Float32Array,
        Ot.MatrixTrackedMatrices = [];
        class Lt {
            get underlyingResource() {
                return this._webGLTexture
            }
            constructor(e=null, t) {
                if (this._MSAARenderBuffers = null,
                this._context = t,
                !e && !(e = t.createTexture()))
                    throw new Error("Unable to create webGL texture");
                this.set(e)
            }
            setUsage() {}
            set(e) {
                this._webGLTexture = e
            }
            reset() {
                this._webGLTexture = null,
                this._MSAARenderBuffers = null
            }
            addMSAARenderBuffer(e) {
                this._MSAARenderBuffers || (this._MSAARenderBuffers = []),
                this._MSAARenderBuffers.push(e)
            }
            releaseMSAARenderBuffers() {
                if (this._MSAARenderBuffers) {
                    for (const e of this._MSAARenderBuffers)
                        this._context.deleteRenderbuffer(e);
                    this._MSAARenderBuffers = null
                }
            }
            getMSAARenderBuffer(e=0) {
                return this._MSAARenderBuffers?.[e] ?? null
            }
            release() {
                this.releaseMSAARenderBuffers(),
                this._webGLTexture && this._context.deleteTexture(this._webGLTexture),
                this.reset()
            }
        }
        class Bt {
            static IsWrapper(e) {
                return void 0 === e.getPipelineContext
            }
            static GetEffect(e) {
                return void 0 === e.getPipelineContext ? e.effect : e
            }
            constructor(e, t=!0) {
                this._wasPreviouslyReady = !1,
                this._forceRebindOnNextCall = !0,
                this._wasPreviouslyUsingInstances = null,
                this.effect = null,
                this.defines = null,
                this.drawContext = e.createDrawContext(),
                t && (this.materialContext = e.createMaterialContext())
            }
            setEffect(e, t, i=!0) {
                this.effect = e,
                void 0 !== t && (this.defines = t),
                i && this.drawContext?.reset()
            }
            dispose() {
                this.drawContext?.dispose()
            }
        }
        class Nt {
            get isDirty() {
                return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty
            }
            get func() {
                return this._func
            }
            set func(e) {
                this._func !== e && (this._func = e,
                this._isStencilFuncDirty = !0)
            }
            get funcRef() {
                return this._funcRef
            }
            set funcRef(e) {
                this._funcRef !== e && (this._funcRef = e,
                this._isStencilFuncDirty = !0)
            }
            get funcMask() {
                return this._funcMask
            }
            set funcMask(e) {
                this._funcMask !== e && (this._funcMask = e,
                this._isStencilFuncDirty = !0)
            }
            get opStencilFail() {
                return this._opStencilFail
            }
            set opStencilFail(e) {
                this._opStencilFail !== e && (this._opStencilFail = e,
                this._isStencilOpDirty = !0)
            }
            get opDepthFail() {
                return this._opDepthFail
            }
            set opDepthFail(e) {
                this._opDepthFail !== e && (this._opDepthFail = e,
                this._isStencilOpDirty = !0)
            }
            get opStencilDepthPass() {
                return this._opStencilDepthPass
            }
            set opStencilDepthPass(e) {
                this._opStencilDepthPass !== e && (this._opStencilDepthPass = e,
                this._isStencilOpDirty = !0)
            }
            get mask() {
                return this._mask
            }
            set mask(e) {
                this._mask !== e && (this._mask = e,
                this._isStencilMaskDirty = !0)
            }
            get enabled() {
                return this._enabled
            }
            set enabled(e) {
                this._enabled !== e && (this._enabled = e,
                this._isStencilTestDirty = !0)
            }
            constructor(e=!0) {
                this._isStencilTestDirty = !1,
                this._isStencilMaskDirty = !1,
                this._isStencilFuncDirty = !1,
                this._isStencilOpDirty = !1,
                this.useStencilGlobalOnly = !1,
                e && this.reset()
            }
            reset() {
                this.stencilMaterial = void 0,
                this.stencilGlobal?.reset(),
                this._isStencilTestDirty = !0,
                this._isStencilMaskDirty = !0,
                this._isStencilFuncDirty = !0,
                this._isStencilOpDirty = !0
            }
            apply(e) {
                if (!e)
                    return;
                const t = !this.useStencilGlobalOnly && !!this.stencilMaterial?.enabled;
                this.enabled = t ? this.stencilMaterial.enabled : this.stencilGlobal.enabled,
                this.func = t ? this.stencilMaterial.func : this.stencilGlobal.func,
                this.funcRef = t ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef,
                this.funcMask = t ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask,
                this.opStencilFail = t ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail,
                this.opDepthFail = t ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail,
                this.opStencilDepthPass = t ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass,
                this.mask = t ? this.stencilMaterial.mask : this.stencilGlobal.mask,
                this.isDirty && (this._isStencilTestDirty && (this.enabled ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST),
                this._isStencilTestDirty = !1),
                this._isStencilMaskDirty && (e.stencilMask(this.mask),
                this._isStencilMaskDirty = !1),
                this._isStencilFuncDirty && (e.stencilFunc(this.func, this.funcRef, this.funcMask),
                this._isStencilFuncDirty = !1),
                this._isStencilOpDirty && (e.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass),
                this._isStencilOpDirty = !1))
            }
        }
        class Ut {
        }
        class kt {
            static get NpmPackage() {
                return "babylonjs@6.49.0"
            }
            static get Version() {
                return "6.49.0"
            }
            get description() {
                let e = this.name + this.webGLVersion;
                return this._caps.parallelShaderCompile && (e += " - Parallel shader compilation"),
                e
            }
            get name() {
                return this._name
            }
            set name(e) {
                this._name = e
            }
            get version() {
                return this._webGLVersion
            }
            get isDisposed() {
                return this._isDisposed
            }
            static get ShadersRepository() {
                return xt.ShadersRepository
            }
            static set ShadersRepository(e) {
                xt.ShadersRepository = e
            }
            _getShaderProcessor(e) {
                return this._shaderProcessor
            }
            get useReverseDepthBuffer() {
                return this._useReverseDepthBuffer
            }
            set useReverseDepthBuffer(e) {
                e !== this._useReverseDepthBuffer && (this._useReverseDepthBuffer = e,
                this._depthCullingState.depthFunc = e ? 518 : 515)
            }
            get frameId() {
                return this._frameId
            }
            get supportsUniformBuffers() {
                return this.webGLVersion > 1 && !this.disableUniformBuffers
            }
            getCreationOptions() {
                return this._creationOptions
            }
            get _shouldUseHighPrecisionShader() {
                return !(!this._caps.highPrecisionShaderSupported || !this._highPrecisionShadersAllowed)
            }
            get needPOTTextures() {
                return this._webGLVersion < 2 || this.forcePOTTextures
            }
            get activeRenderLoops() {
                return this._activeRenderLoops
            }
            get doNotHandleContextLost() {
                return this._doNotHandleContextLost
            }
            set doNotHandleContextLost(e) {
                this._doNotHandleContextLost = e
            }
            get _supportsHardwareTextureRescaling() {
                return !1
            }
            set framebufferDimensionsObject(e) {
                this._framebufferDimensionsObject = e
            }
            get currentViewport() {
                return this._cachedViewport
            }
            get emptyTexture() {
                return this._emptyTexture || (this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, !1, !1, 1)),
                this._emptyTexture
            }
            get emptyTexture3D() {
                return this._emptyTexture3D || (this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, !1, !1, 1)),
                this._emptyTexture3D
            }
            get emptyTexture2DArray() {
                return this._emptyTexture2DArray || (this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, !1, !1, 1)),
                this._emptyTexture2DArray
            }
            get emptyCubeTexture() {
                if (!this._emptyCubeTexture) {
                    const e = new Uint8Array(4)
                      , t = [e, e, e, e, e, e];
                    this._emptyCubeTexture = this.createRawCubeTexture(t, 1, 5, 0, !1, !1, 1)
                }
                return this._emptyCubeTexture
            }
            get isWebGPU() {
                return this._isWebGPU
            }
            get shaderPlatformName() {
                return this._shaderPlatformName
            }
            get snapshotRendering() {
                return !1
            }
            set snapshotRendering(e) {}
            get snapshotRenderingMode() {
                return this._snapshotRenderingMode
            }
            set snapshotRenderingMode(e) {
                this._snapshotRenderingMode = e
            }
            snapshotRenderingReset() {
                this.snapshotRendering = !1
            }
            static _CreateCanvas(e, t) {
                if ("undefined" == typeof document)
                    return new OffscreenCanvas(e,t);
                const i = document.createElement("canvas");
                return i.width = e,
                i.height = t,
                i
            }
            createCanvas(e, t) {
                return kt._CreateCanvas(e, t)
            }
            createCanvasImage() {
                return document.createElement("img")
            }
            constructor(e, t, i, s) {
                this._name = "WebGL",
                this._isDisposed = !1,
                this.forcePOTTextures = !1,
                this.isFullscreen = !1,
                this.cullBackFaces = null,
                this.renderEvenInBackground = !0,
                this.preventCacheWipeBetweenFrames = !1,
                this.validateShaderPrograms = !1,
                this._useReverseDepthBuffer = !1,
                this.isNDCHalfZRange = !1,
                this.hasOriginBottomLeft = !0,
                this.disableUniformBuffers = !1,
                this.onDisposeObservable = new Ue,
                this._frameId = 0,
                this._uniformBuffers = new Array,
                this._storageBuffers = new Array,
                this._webGLVersion = 1,
                this._windowIsBackground = !1,
                this._highPrecisionShadersAllowed = !0,
                this._badOS = !1,
                this._badDesktopOS = !1,
                this._activeRenderLoops = new Array,
                this.onContextLostObservable = new Ue,
                this.onContextRestoredObservable = new Ue,
                this._contextWasLost = !1,
                this._doNotHandleContextLost = !1,
                this.disableVertexArrayObjects = !1,
                this._colorWrite = !0,
                this._colorWriteChanged = !0,
                this._depthCullingState = new Tt,
                this._stencilStateComposer = new Nt,
                this._stencilState = new Et,
                this._alphaState = new Mt,
                this._alphaMode = 1,
                this._alphaEquation = 0,
                this._internalTexturesCache = new Array,
                this._renderTargetWrapperCache = new Array,
                this._activeChannel = 0,
                this._currentTextureChannel = -1,
                this._boundTexturesCache = {},
                this._compiledEffects = {},
                this._vertexAttribArraysEnabled = [],
                this._currentRenderTarget = null,
                this._uintIndicesCurrentlySet = !1,
                this._currentBoundBuffer = new Array,
                this._currentFramebuffer = null,
                this._dummyFramebuffer = null,
                this._currentBufferPointers = new Array,
                this._currentInstanceLocations = new Array,
                this._currentInstanceBuffers = new Array,
                this._boundRenderFunction = () => this._renderLoop(),
                this._vaoRecordInProgress = !1,
                this._mustWipeVertexAttributes = !1,
                this._frameHandler = 0,
                this._nextFreeTextureSlots = new Array,
                this._maxSimultaneousTextures = 0,
                this._maxMSAASamplesOverride = null,
                this._activeRequests = new Array,
                this.adaptToDeviceRatio = !1,
                this._lastDevicePixelRatio = 1,
                this._transformTextureUrl = null,
                this.hostInformation = {
                    isMobile: !1
                },
                this.premultipliedAlpha = !0,
                this.onBeforeTextureInitObservable = new Ue,
                this._isWebGPU = !1,
                this._snapshotRenderingMode = 0,
                this._viewportCached = {
                    x: 0,
                    y: 0,
                    z: 0,
                    w: 0
                },
                this._unpackFlipYCached = null,
                this.enableUnpackFlipYCached = !0,
                this._boundUniforms = {},
                this.startTime = Ke.Now;
                let r = null;
                i = i || {},
                this._creationOptions = i,
                this.adaptToDeviceRatio = s ?? !1,
                this._stencilStateComposer.stencilGlobal = this._stencilState,
                Ot.SetMatrixPrecision(!!i.useHighPrecisionMatrix),
                i.antialias = t ?? i.antialias,
                i.deterministicLockstep = i.deterministicLockstep ?? !1,
                i.lockstepMaxSteps = i.lockstepMaxSteps ?? 4,
                i.timeStep = i.timeStep ?? 1 / 60,
                i.audioEngine = i.audioEngine ?? !0,
                i.stencil = i.stencil ?? !0,
                this._audioContext = i.audioEngineOptions?.audioContext ?? null,
                this._audioDestination = i.audioEngineOptions?.audioDestination ?? null,
                this.premultipliedAlpha = i.premultipliedAlpha ?? !0,
                this.useExactSrgbConversions = i.useExactSrgbConversions ?? !1,
                this._doNotHandleContextLost = !!i.doNotHandleContextLost,
                this._isStencilEnable = !!i.stencil,
                s = s || i.adaptToDeviceRatio || !1;
                const n = ke() && window.devicePixelRatio || 1
                  , a = i.limitDeviceRatio || n;
                if (this._hardwareScalingLevel = s ? 1 / Math.min(a, n) : 1,
                this._lastDevicePixelRatio = n,
                !e)
                    return;
                if (e.getContext) {
                    if (r = e,
                    this._renderingCanvas = r,
                    void 0 === i.preserveDrawingBuffer && (i.preserveDrawingBuffer = !1),
                    void 0 === i.xrCompatible && (i.xrCompatible = !0),
                    navigator && navigator.userAgent) {
                        this._setupMobileChecks();
                        const e = navigator.userAgent;
                        for (const t of kt.ExceptionList) {
                            const s = t.key
                              , r = t.targets;
                            if (new RegExp(s).test(e)) {
                                if (t.capture && t.captureConstraint) {
                                    const i = t.capture
                                      , s = t.captureConstraint
                                      , r = new RegExp(i).exec(e);
                                    if (r && r.length > 0 && parseInt(r[r.length - 1]) >= s)
                                        continue
                                }
                                for (const e of r)
                                    switch (e) {
                                    case "uniformBuffer":
                                        this.disableUniformBuffers = !0;
                                        break;
                                    case "vao":
                                        this.disableVertexArrayObjects = !0;
                                        break;
                                    case "antialias":
                                        i.antialias = !1;
                                        break;
                                    case "maxMSAASamples":
                                        this._maxMSAASamplesOverride = 1
                                    }
                            }
                        }
                    }
                    if (this._doNotHandleContextLost || (this._onContextLost = e => {
                        e.preventDefault(),
                        this._contextWasLost = !0,
                        We.Warn("WebGL context lost."),
                        this.onContextLostObservable.notifyObservers(this)
                    }
                    ,
                    this._onContextRestored = () => {
                        this._restoreEngineAfterContextLost(( () => this._initGLContext()))
                    }
                    ,
                    r.addEventListener("webglcontextlost", this._onContextLost, !1),
                    r.addEventListener("webglcontextrestored", this._onContextRestored, !1),
                    i.powerPreference = i.powerPreference || "high-performance"),
                    this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
                    this._badDesktopOS && (i.xrCompatible = !1),
                    !i.disableWebGL2Support)
                        try {
                            this._gl = r.getContext("webgl2", i) || r.getContext("experimental-webgl2", i),
                            this._gl && (this._webGLVersion = 2,
                            this._shaderPlatformName = "WEBGL2",
                            this._gl.deleteQuery || (this._webGLVersion = 1,
                            this._shaderPlatformName = "WEBGL1"))
                        } catch (e) {}
                    if (!this._gl) {
                        if (!r)
                            throw new Error("The provided canvas is null or undefined.");
                        try {
                            this._gl = r.getContext("webgl", i) || r.getContext("experimental-webgl", i)
                        } catch (e) {
                            throw new Error("WebGL not supported")
                        }
                    }
                    if (!this._gl)
                        throw new Error("WebGL not supported")
                } else {
                    this._gl = e,
                    this._renderingCanvas = this._gl.canvas,
                    this._gl.renderbufferStorageMultisample ? (this._webGLVersion = 2,
                    this._shaderPlatformName = "WEBGL2") : this._shaderPlatformName = "WEBGL1";
                    const t = this._gl.getContextAttributes();
                    t && (i.stencil = t.stencil)
                }
                this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE),
                void 0 !== i.useHighPrecisionFloats && (this._highPrecisionShadersAllowed = i.useHighPrecisionFloats),
                this.resize(),
                this._initGLContext(),
                this._initFeatures();
                for (let e = 0; e < this._caps.maxVertexAttribs; e++)
                    this._currentBufferPointers[e] = new Ut;
                this._shaderProcessor = this.webGLVersion > 1 ? new Pt : new Rt,
                this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);
                const o = `Babylon.js v${kt.Version}`;
                We.Log(o + ` - ${this.description}`),
                this._renderingCanvas && this._renderingCanvas.setAttribute && this._renderingCanvas.setAttribute("data-engine", o)
            }
            _setupMobileChecks() {
                navigator && navigator.userAgent && (this._checkForMobile = () => {
                    const e = navigator.userAgent;
                    this.hostInformation.isMobile = -1 !== e.indexOf("Mobile") || -1 !== e.indexOf("Mac") && Ge() && "ontouchend"in document
                }
                ,
                this._checkForMobile(),
                ke() && window.addEventListener("resize", this._checkForMobile))
            }
            _clearEmptyResources() {
                this._dummyFramebuffer = null,
                this._emptyTexture = null,
                this._emptyCubeTexture = null,
                this._emptyTexture3D = null,
                this._emptyTexture2DArray = null
            }
            _rebuildGraphicsResources() {
                this.wipeCaches(!0),
                this._rebuildEffects(),
                this._rebuildComputeEffects?.(),
                this._rebuildBuffers(),
                this._rebuildInternalTextures(),
                this._rebuildTextures(),
                this._rebuildRenderTargetWrappers(),
                this.wipeCaches(!0)
            }
            _flagContextRestored() {
                We.Warn(this.name + " context successfully restored."),
                this.onContextRestoredObservable.notifyObservers(this),
                this._contextWasLost = !1
            }
            _restoreEngineAfterContextLost(e) {
                setTimeout((async () => {
                    this._clearEmptyResources();
                    const t = this._depthCullingState.depthTest
                      , i = this._depthCullingState.depthFunc
                      , s = this._depthCullingState.depthMask
                      , r = this._stencilState.stencilTest;
                    await e(),
                    this._rebuildGraphicsResources(),
                    this._depthCullingState.depthTest = t,
                    this._depthCullingState.depthFunc = i,
                    this._depthCullingState.depthMask = s,
                    this._stencilState.stencilTest = r,
                    this._flagContextRestored()
                }
                ), 0)
            }
            _sharedInit(e) {
                this._renderingCanvas = e
            }
            _getShaderProcessingContext(e) {
                return null
            }
            _rebuildInternalTextures() {
                const e = this._internalTexturesCache.slice();
                for (const t of e)
                    t._rebuild()
            }
            _rebuildRenderTargetWrappers() {
                const e = this._renderTargetWrapperCache.slice();
                for (const t of e)
                    t._rebuild()
            }
            _rebuildEffects() {
                for (const e in this._compiledEffects) {
                    const t = this._compiledEffects[e];
                    t._pipelineContext = null,
                    t._prepareEffect()
                }
                xt.ResetCache()
            }
            areAllEffectsReady() {
                for (const e in this._compiledEffects)
                    if (!this._compiledEffects[e].isReady())
                        return !1;
                return !0
            }
            _rebuildBuffers() {
                for (const e of this._uniformBuffers)
                    e._rebuildAfterContextLost()
            }
            _rebuildTextures() {}
            _initGLContext() {
                this._caps = {
                    maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
                    maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
                    maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                    maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
                    maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
                    maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
                    maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
                    maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
                    maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
                    maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
                    maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
                    parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || void 0,
                    standardDerivatives: this._webGLVersion > 1 || null !== this._gl.getExtension("OES_standard_derivatives"),
                    maxAnisotropy: 1,
                    astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
                    bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
                    s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
                    s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
                    pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                    etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
                    etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"),
                    textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
                    uintIndices: this._webGLVersion > 1 || null !== this._gl.getExtension("OES_element_index_uint"),
                    fragmentDepthSupported: this._webGLVersion > 1 || null !== this._gl.getExtension("EXT_frag_depth"),
                    highPrecisionShaderSupported: !1,
                    timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
                    supportOcclusionQuery: this._webGLVersion > 1,
                    canUseTimestampForTimerQuery: !1,
                    drawBuffersExtension: !1,
                    maxMSAASamples: 1,
                    colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")),
                    supportFloatTexturesResolve: !1,
                    rg11b10ufColorRenderable: !1,
                    colorBufferHalfFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_half_float")),
                    textureFloat: !!(this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float")),
                    textureHalfFloat: !!(this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float")),
                    textureHalfFloatRender: !1,
                    textureFloatLinearFiltering: !1,
                    textureFloatRender: !1,
                    textureHalfFloatLinearFiltering: !1,
                    vertexArrayObject: !1,
                    instancedArrays: !1,
                    textureLOD: !!(this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod")),
                    texelFetch: 1 !== this._webGLVersion,
                    blendMinMax: !1,
                    multiview: this._gl.getExtension("OVR_multiview2"),
                    oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
                    depthTextureExtension: !1,
                    canUseGLInstanceID: this._webGLVersion > 1,
                    canUseGLVertexID: this._webGLVersion > 1,
                    supportComputeShaders: !1,
                    supportSRGBBuffers: !1,
                    supportTransformFeedbacks: this._webGLVersion > 1,
                    textureMaxLevel: this._webGLVersion > 1,
                    texture2DArrayMaxLayerCount: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_ARRAY_TEXTURE_LAYERS) : 128,
                    disableMorphTargetTexture: !1
                },
                this._caps.supportFloatTexturesResolve = this._caps.colorBufferFloat,
                this._caps.rg11b10ufColorRenderable = this._caps.colorBufferFloat,
                this._glVersion = this._gl.getParameter(this._gl.VERSION);
                const e = this._gl.getExtension("WEBGL_debug_renderer_info");
                if (null != e && (this._glRenderer = this._gl.getParameter(e.UNMASKED_RENDERER_WEBGL),
                this._glVendor = this._gl.getParameter(e.UNMASKED_VENDOR_WEBGL)),
                this._glVendor || (this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor"),
                this._glRenderer || (this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer"),
                36193 !== this._gl.HALF_FLOAT_OES && (this._gl.HALF_FLOAT_OES = 36193),
                34842 !== this._gl.RGBA16F && (this._gl.RGBA16F = 34842),
                34836 !== this._gl.RGBA32F && (this._gl.RGBA32F = 34836),
                35056 !== this._gl.DEPTH24_STENCIL8 && (this._gl.DEPTH24_STENCIL8 = 35056),
                this._caps.timerQuery && (1 === this._webGLVersion && (this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery)),
                this._caps.canUseTimestampForTimerQuery = (this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT) ?? 0) > 0),
                this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0,
                this._caps.textureFloatLinearFiltering = !(!this._caps.textureFloat || !this._gl.getExtension("OES_texture_float_linear")),
                this._caps.textureFloatRender = !(!this._caps.textureFloat || !this._canRenderToFloatFramebuffer()),
                this._caps.textureHalfFloatLinearFiltering = !!(this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear")),
                this._caps.astc && (this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR),
                this._caps.bptc && (this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT),
                this._caps.s3tc_srgb && (this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT,
                this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
                this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT),
                this._caps.etc2 && (this._gl.COMPRESSED_SRGB8_ETC2 = this._caps.etc2.COMPRESSED_SRGB8_ETC2,
                this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC),
                this._webGLVersion > 1 && 5131 !== this._gl.HALF_FLOAT_OES && (this._gl.HALF_FLOAT_OES = 5131),
                this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer(),
                this._webGLVersion > 1)
                    this._caps.drawBuffersExtension = !0,
                    this._caps.maxMSAASamples = null !== this._maxMSAASamplesOverride ? this._maxMSAASamplesOverride : this._gl.getParameter(this._gl.MAX_SAMPLES);
                else {
                    const e = this._gl.getExtension("WEBGL_draw_buffers");
                    if (null !== e) {
                        this._caps.drawBuffersExtension = !0,
                        this._gl.drawBuffers = e.drawBuffersWEBGL.bind(e),
                        this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
                        for (let t = 0; t < 16; t++)
                            this._gl["COLOR_ATTACHMENT" + t + "_WEBGL"] = e["COLOR_ATTACHMENT" + t + "_WEBGL"]
                    }
                }
                if (this._webGLVersion > 1)
                    this._caps.depthTextureExtension = !0;
                else {
                    const e = this._gl.getExtension("WEBGL_depth_texture");
                    null != e && (this._caps.depthTextureExtension = !0,
                    this._gl.UNSIGNED_INT_24_8 = e.UNSIGNED_INT_24_8_WEBGL)
                }
                if (this.disableVertexArrayObjects)
                    this._caps.vertexArrayObject = !1;
                else if (this._webGLVersion > 1)
                    this._caps.vertexArrayObject = !0;
                else {
                    const e = this._gl.getExtension("OES_vertex_array_object");
                    null != e && (this._caps.vertexArrayObject = !0,
                    this._gl.createVertexArray = e.createVertexArrayOES.bind(e),
                    this._gl.bindVertexArray = e.bindVertexArrayOES.bind(e),
                    this._gl.deleteVertexArray = e.deleteVertexArrayOES.bind(e))
                }
                if (this._webGLVersion > 1)
                    this._caps.instancedArrays = !0;
                else {
                    const e = this._gl.getExtension("ANGLE_instanced_arrays");
                    null != e ? (this._caps.instancedArrays = !0,
                    this._gl.drawArraysInstanced = e.drawArraysInstancedANGLE.bind(e),
                    this._gl.drawElementsInstanced = e.drawElementsInstancedANGLE.bind(e),
                    this._gl.vertexAttribDivisor = e.vertexAttribDivisorANGLE.bind(e)) : this._caps.instancedArrays = !1
                }
                if (this._gl.getShaderPrecisionFormat) {
                    const e = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT)
                      , t = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
                    e && t && (this._caps.highPrecisionShaderSupported = 0 !== e.precision && 0 !== t.precision)
                }
                if (this._webGLVersion > 1)
                    this._caps.blendMinMax = !0;
                else {
                    const e = this._gl.getExtension("EXT_blend_minmax");
                    null != e && (this._caps.blendMinMax = !0,
                    this._gl.MAX = e.MAX_EXT,
                    this._gl.MIN = e.MIN_EXT)
                }
                if (!this._caps.supportSRGBBuffers) {
                    if (this._webGLVersion > 1)
                        this._caps.supportSRGBBuffers = !0,
                        this._glSRGBExtensionValues = {
                            SRGB: WebGL2RenderingContext.SRGB,
                            SRGB8: WebGL2RenderingContext.SRGB8,
                            SRGB8_ALPHA8: WebGL2RenderingContext.SRGB8_ALPHA8
                        };
                    else {
                        const e = this._gl.getExtension("EXT_sRGB");
                        null != e && (this._caps.supportSRGBBuffers = !0,
                        this._glSRGBExtensionValues = {
                            SRGB: e.SRGB_EXT,
                            SRGB8: e.SRGB_ALPHA_EXT,
                            SRGB8_ALPHA8: e.SRGB_ALPHA_EXT
                        })
                    }
                    this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !(!this._creationOptions || !this._creationOptions.forceSRGBBufferSupportState)
                }
                this._depthCullingState.depthTest = !0,
                this._depthCullingState.depthFunc = this._gl.LEQUAL,
                this._depthCullingState.depthMask = !0,
                this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
                for (let e = 0; e < this._maxSimultaneousTextures; e++)
                    this._nextFreeTextureSlots.push(e);
                "Mali-G72" === this._glRenderer && (this._caps.disableMorphTargetTexture = !0)
            }
            _initFeatures() {
                this._features = {
                    forceBitmapOverHTMLImageElement: "undefined" == typeof HTMLImageElement,
                    supportRenderAndCopyToLodForFloatTextures: 1 !== this._webGLVersion,
                    supportDepthStencilTexture: 1 !== this._webGLVersion,
                    supportShadowSamplers: 1 !== this._webGLVersion,
                    uniformBufferHardCheckMatrix: !1,
                    allowTexturePrefiltering: 1 !== this._webGLVersion,
                    trackUbosInFrame: !1,
                    checkUbosContentBeforeUpload: !1,
                    supportCSM: 1 !== this._webGLVersion,
                    basisNeedsPOT: 1 === this._webGLVersion,
                    support3DTextures: 1 !== this._webGLVersion,
                    needTypeSuffixInShaderConstants: 1 !== this._webGLVersion,
                    supportMSAA: 1 !== this._webGLVersion,
                    supportSSAO2: 1 !== this._webGLVersion,
                    supportExtendedTextureFormats: 1 !== this._webGLVersion,
                    supportSwitchCaseInShader: 1 !== this._webGLVersion,
                    supportSyncTextureRead: !0,
                    needsInvertingBitmap: !0,
                    useUBOBindingCache: !0,
                    needShaderCodeInlining: !1,
                    needToAlwaysBindUniformBuffers: !1,
                    supportRenderPasses: !1,
                    supportSpriteInstancing: !0,
                    forceVertexBufferStrideAndOffsetMultiple4Bytes: !1,
                    _collectUbosUpdatedInFrame: !1
                }
            }
            get webGLVersion() {
                return this._webGLVersion
            }
            getClassName() {
                return "ThinEngine"
            }
            get isStencilEnable() {
                return this._isStencilEnable
            }
            _prepareWorkingCanvas() {
                if (this._workingCanvas)
                    return;
                this._workingCanvas = this.createCanvas(1, 1);
                const e = this._workingCanvas.getContext("2d");
                e && (this._workingContext = e)
            }
            resetTextureCache() {
                for (const e in this._boundTexturesCache)
                    Object.prototype.hasOwnProperty.call(this._boundTexturesCache, e) && (this._boundTexturesCache[e] = null);
                this._currentTextureChannel = -1
            }
            getInfo() {
                return this.getGlInfo()
            }
            getGlInfo() {
                return {
                    vendor: this._glVendor,
                    renderer: this._glRenderer,
                    version: this._glVersion
                }
            }
            setHardwareScalingLevel(e) {
                this._hardwareScalingLevel = e,
                this.resize()
            }
            getHardwareScalingLevel() {
                return this._hardwareScalingLevel
            }
            getLoadedTexturesCache() {
                return this._internalTexturesCache
            }
            getCaps() {
                return this._caps
            }
            stopRenderLoop(e) {
                if (!e)
                    return this._activeRenderLoops.length = 0,
                    void this._cancelFrame();
                const t = this._activeRenderLoops.indexOf(e);
                t >= 0 && (this._activeRenderLoops.splice(t, 1),
                0 == this._activeRenderLoops.length && this._cancelFrame())
            }
            _cancelFrame() {
                if (0 !== this._frameHandler) {
                    const e = this._frameHandler;
                    if (this._frameHandler = 0,
                    ke()) {
                        const {cancelAnimationFrame: t} = this.getHostWindow() || window;
                        if ("function" == typeof t)
                            return t(e)
                    } else if ("function" == typeof cancelAnimationFrame)
                        return cancelAnimationFrame(e);
                    return clearTimeout(e)
                }
            }
            _renderLoop() {
                if (this._frameHandler = 0,
                !this._contextWasLost) {
                    let e = !0;
                    if ((this._isDisposed || !this.renderEvenInBackground && this._windowIsBackground) && (e = !1),
                    e) {
                        this.beginFrame();
                        for (let e = 0; e < this._activeRenderLoops.length; e++)
                            (0,
                            this._activeRenderLoops[e])();
                        this.endFrame()
                    }
                }
                0 === this._frameHandler && (this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()))
            }
            getRenderingCanvas() {
                return this._renderingCanvas
            }
            getAudioContext() {
                return this._audioContext
            }
            getAudioDestination() {
                return this._audioDestination
            }
            getHostWindow() {
                return ke() ? this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView ? this._renderingCanvas.ownerDocument.defaultView : window : null
            }
            getRenderWidth(e=!1) {
                return !e && this._currentRenderTarget ? this._currentRenderTarget.width : this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth
            }
            getRenderHeight(e=!1) {
                return !e && this._currentRenderTarget ? this._currentRenderTarget.height : this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight
            }
            _queueNewFrame(e, t) {
                return kt.QueueNewFrame(e, t)
            }
            runRenderLoop(e) {
                -1 === this._activeRenderLoops.indexOf(e) && (this._activeRenderLoops.push(e),
                1 === this._activeRenderLoops.length && 0 === this._frameHandler && (this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow())))
            }
            clear(e, t, i, s=!1) {
                const r = this.stencilStateComposer.useStencilGlobalOnly;
                this.stencilStateComposer.useStencilGlobalOnly = !0,
                this.applyStates(),
                this.stencilStateComposer.useStencilGlobalOnly = r;
                let n = 0;
                if (t && e) {
                    let t = !0;
                    if (this._currentRenderTarget) {
                        const i = this._currentRenderTarget.texture?.format;
                        if (8 === i || 9 === i || 10 === i || 11 === i) {
                            const i = this._currentRenderTarget.texture?.type;
                            7 === i || 5 === i ? (kt._TempClearColorUint32[0] = 255 * e.r,
                            kt._TempClearColorUint32[1] = 255 * e.g,
                            kt._TempClearColorUint32[2] = 255 * e.b,
                            kt._TempClearColorUint32[3] = 255 * e.a,
                            this._gl.clearBufferuiv(this._gl.COLOR, 0, kt._TempClearColorUint32),
                            t = !1) : (kt._TempClearColorInt32[0] = 255 * e.r,
                            kt._TempClearColorInt32[1] = 255 * e.g,
                            kt._TempClearColorInt32[2] = 255 * e.b,
                            kt._TempClearColorInt32[3] = 255 * e.a,
                            this._gl.clearBufferiv(this._gl.COLOR, 0, kt._TempClearColorInt32),
                            t = !1)
                        }
                    }
                    t && (this._gl.clearColor(e.r, e.g, e.b, void 0 !== e.a ? e.a : 1),
                    n |= this._gl.COLOR_BUFFER_BIT)
                }
                i && (this.useReverseDepthBuffer ? (this._depthCullingState.depthFunc = this._gl.GEQUAL,
                this._gl.clearDepth(0)) : this._gl.clearDepth(1),
                n |= this._gl.DEPTH_BUFFER_BIT),
                s && (this._gl.clearStencil(0),
                n |= this._gl.STENCIL_BUFFER_BIT),
                this._gl.clear(n)
            }
            _viewport(e, t, i, s) {
                e === this._viewportCached.x && t === this._viewportCached.y && i === this._viewportCached.z && s === this._viewportCached.w || (this._viewportCached.x = e,
                this._viewportCached.y = t,
                this._viewportCached.z = i,
                this._viewportCached.w = s,
                this._gl.viewport(e, t, i, s))
            }
            setViewport(e, t, i) {
                const s = t || this.getRenderWidth()
                  , r = i || this.getRenderHeight()
                  , n = e.x || 0
                  , a = e.y || 0;
                this._cachedViewport = e,
                this._viewport(n * s, a * r, s * e.width, r * e.height)
            }
            beginFrame() {}
            endFrame() {
                this._badOS && this.flushFramebuffer(),
                this._frameId++
            }
            resize(e=!1) {
                let t, i;
                if (this.adaptToDeviceRatio) {
                    const e = ke() && window.devicePixelRatio || 1
                      , t = this._lastDevicePixelRatio / e;
                    this._lastDevicePixelRatio = e,
                    this._hardwareScalingLevel *= t
                }
                if (ke() && Ge())
                    if (this._renderingCanvas) {
                        const e = this._renderingCanvas.getBoundingClientRect ? this._renderingCanvas.getBoundingClientRect() : {
                            width: this._renderingCanvas.width * this._hardwareScalingLevel,
                            height: this._renderingCanvas.height * this._hardwareScalingLevel
                        };
                        t = this._renderingCanvas.clientWidth || e.width || this._renderingCanvas.width || 100,
                        i = this._renderingCanvas.clientHeight || e.height || this._renderingCanvas.height || 100
                    } else
                        t = window.innerWidth,
                        i = window.innerHeight;
                else
                    t = this._renderingCanvas ? this._renderingCanvas.width : 100,
                    i = this._renderingCanvas ? this._renderingCanvas.height : 100;
                this.setSize(t / this._hardwareScalingLevel, i / this._hardwareScalingLevel, e)
            }
            setSize(e, t, i=!1) {
                return !(!this._renderingCanvas || (e |= 0,
                t |= 0,
                !i && this._renderingCanvas.width === e && this._renderingCanvas.height === t || (this._renderingCanvas.width = e,
                this._renderingCanvas.height = t,
                0)))
            }
            bindFramebuffer(e, t=0, i, s, r, n=0, a=0) {
                const o = e;
                this._currentRenderTarget && this.unBindFramebuffer(this._currentRenderTarget),
                this._currentRenderTarget = e,
                this._bindUnboundFramebuffer(o._MSAAFramebuffer ? o._MSAAFramebuffer : o._framebuffer);
                const h = this._gl;
                e.isMulti || (e.is2DArray ? h.framebufferTextureLayer(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, e.texture._hardwareTexture?.underlyingResource, n, a) : e.isCube ? h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_CUBE_MAP_POSITIVE_X + t, e.texture._hardwareTexture?.underlyingResource, n) : o._currentLOD !== n && (h.framebufferTexture2D(h.FRAMEBUFFER, h.COLOR_ATTACHMENT0, h.TEXTURE_2D, e.texture._hardwareTexture?.underlyingResource, n),
                o._currentLOD = n));
                const l = e._depthStencilTexture;
                if (l) {
                    const i = e._depthStencilTextureWithStencil ? h.DEPTH_STENCIL_ATTACHMENT : h.DEPTH_ATTACHMENT;
                    e.is2DArray ? h.framebufferTextureLayer(h.FRAMEBUFFER, i, l._hardwareTexture?.underlyingResource, n, a) : e.isCube ? h.framebufferTexture2D(h.FRAMEBUFFER, i, h.TEXTURE_CUBE_MAP_POSITIVE_X + t, l._hardwareTexture?.underlyingResource, n) : h.framebufferTexture2D(h.FRAMEBUFFER, i, h.TEXTURE_2D, l._hardwareTexture?.underlyingResource, n)
                }
                this._cachedViewport && !r ? this.setViewport(this._cachedViewport, i, s) : (i || (i = e.width,
                n && (i /= Math.pow(2, n))),
                s || (s = e.height,
                n && (s /= Math.pow(2, n))),
                this._viewport(0, 0, i, s)),
                this.wipeCaches()
            }
            setState(e, t=0, i, s=!1, r, n, a=0) {
                (this._depthCullingState.cull !== e || i) && (this._depthCullingState.cull = e);
                const o = this.cullBackFaces ?? r ?? 1 ? this._gl.BACK : this._gl.FRONT;
                (this._depthCullingState.cullFace !== o || i) && (this._depthCullingState.cullFace = o),
                this.setZOffset(t),
                this.setZOffsetUnits(a);
                const h = s ? this._gl.CW : this._gl.CCW;
                (this._depthCullingState.frontFace !== h || i) && (this._depthCullingState.frontFace = h),
                this._stencilStateComposer.stencilMaterial = n
            }
            getDepthBuffer() {
                return this._depthCullingState.depthTest
            }
            setDepthBuffer(e) {
                this._depthCullingState.depthTest = e
            }
            setZOffset(e) {
                this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -e : e
            }
            getZOffset() {
                const e = this._depthCullingState.zOffset;
                return this.useReverseDepthBuffer ? -e : e
            }
            setZOffsetUnits(e) {
                this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -e : e
            }
            getZOffsetUnits() {
                const e = this._depthCullingState.zOffsetUnits;
                return this.useReverseDepthBuffer ? -e : e
            }
            _bindUnboundFramebuffer(e) {
                this._currentFramebuffer !== e && (this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, e),
                this._currentFramebuffer = e)
            }
            _currentFrameBufferIsDefaultFrameBuffer() {
                return null === this._currentFramebuffer
            }
            generateMipmaps(e) {
                this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0),
                this._gl.generateMipmap(this._gl.TEXTURE_2D),
                this._bindTextureDirectly(this._gl.TEXTURE_2D, null)
            }
            unBindFramebuffer(e, t=!1, i) {
                const s = e;
                this._currentRenderTarget = null;
                const r = this._gl;
                if (s._MSAAFramebuffer) {
                    if (e.isMulti)
                        return void this.unBindMultiColorAttachmentFramebuffer(e, t, i);
                    r.bindFramebuffer(r.READ_FRAMEBUFFER, s._MSAAFramebuffer),
                    r.bindFramebuffer(r.DRAW_FRAMEBUFFER, s._framebuffer),
                    r.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, r.COLOR_BUFFER_BIT, r.NEAREST)
                }
                !e.texture?.generateMipMaps || t || e.isCube || this.generateMipmaps(e.texture),
                i && (s._MSAAFramebuffer && this._bindUnboundFramebuffer(s._framebuffer),
                i()),
                this._bindUnboundFramebuffer(null)
            }
            flushFramebuffer() {
                this._gl.flush()
            }
            restoreDefaultFramebuffer() {
                this._currentRenderTarget ? this.unBindFramebuffer(this._currentRenderTarget) : this._bindUnboundFramebuffer(null),
                this._cachedViewport && this.setViewport(this._cachedViewport),
                this.wipeCaches()
            }
            _resetVertexBufferBinding() {
                this.bindArrayBuffer(null),
                this._cachedVertexBuffers = null
            }
            createVertexBuffer(e, t, i) {
                return this._createVertexBuffer(e, this._gl.STATIC_DRAW)
            }
            _createVertexBuffer(e, t) {
                const i = this._gl.createBuffer();
                if (!i)
                    throw new Error("Unable to create vertex buffer");
                const s = new wt(i);
                return this.bindArrayBuffer(s),
                "number" != typeof e ? e instanceof Array ? (this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(e), t),
                s.capacity = 4 * e.length) : (this._gl.bufferData(this._gl.ARRAY_BUFFER, e, t),
                s.capacity = e.byteLength) : (this._gl.bufferData(this._gl.ARRAY_BUFFER, new Uint8Array(e), t),
                s.capacity = e),
                this._resetVertexBufferBinding(),
                s.references = 1,
                s
            }
            createDynamicVertexBuffer(e, t) {
                return this._createVertexBuffer(e, this._gl.DYNAMIC_DRAW)
            }
            _resetIndexBufferBinding() {
                this.bindIndexBuffer(null),
                this._cachedIndexBuffer = null
            }
            createIndexBuffer(e, t, i) {
                const s = this._gl.createBuffer()
                  , r = new wt(s);
                if (!s)
                    throw new Error("Unable to create index buffer");
                this.bindIndexBuffer(r);
                const n = this._normalizeIndexData(e);
                return this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, n, t ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW),
                this._resetIndexBufferBinding(),
                r.references = 1,
                r.is32Bits = 4 === n.BYTES_PER_ELEMENT,
                r
            }
            _normalizeIndexData(e) {
                if (2 === e.BYTES_PER_ELEMENT)
                    return e;
                if (this._caps.uintIndices) {
                    if (e instanceof Uint32Array)
                        return e;
                    for (let t = 0; t < e.length; t++)
                        if (e[t] >= 65535)
                            return new Uint32Array(e);
                    return new Uint16Array(e)
                }
                return new Uint16Array(e)
            }
            bindArrayBuffer(e) {
                this._vaoRecordInProgress || this._unbindVertexArrayObject(),
                this._bindBuffer(e, this._gl.ARRAY_BUFFER)
            }
            bindUniformBlock(e, t, i) {
                const s = e.program
                  , r = this._gl.getUniformBlockIndex(s, t);
                this._gl.uniformBlockBinding(s, r, i)
            }
            bindIndexBuffer(e) {
                this._vaoRecordInProgress || this._unbindVertexArrayObject(),
                this._bindBuffer(e, this._gl.ELEMENT_ARRAY_BUFFER)
            }
            _bindBuffer(e, t) {
                (this._vaoRecordInProgress || this._currentBoundBuffer[t] !== e) && (this._gl.bindBuffer(t, e ? e.underlyingResource : null),
                this._currentBoundBuffer[t] = e)
            }
            updateArrayBuffer(e) {
                this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, e)
            }
            _vertexAttribPointer(e, t, i, s, r, n, a) {
                const o = this._currentBufferPointers[t];
                if (!o)
                    return;
                let h = !1;
                o.active ? (o.buffer !== e && (o.buffer = e,
                h = !0),
                o.size !== i && (o.size = i,
                h = !0),
                o.type !== s && (o.type = s,
                h = !0),
                o.normalized !== r && (o.normalized = r,
                h = !0),
                o.stride !== n && (o.stride = n,
                h = !0),
                o.offset !== a && (o.offset = a,
                h = !0)) : (h = !0,
                o.active = !0,
                o.index = t,
                o.size = i,
                o.type = s,
                o.normalized = r,
                o.stride = n,
                o.offset = a,
                o.buffer = e),
                (h || this._vaoRecordInProgress) && (this.bindArrayBuffer(e),
                s === this._gl.UNSIGNED_INT || s === this._gl.INT ? this._gl.vertexAttribIPointer(t, i, s, n, a) : this._gl.vertexAttribPointer(t, i, s, r, n, a))
            }
            _bindIndexBufferWithCache(e) {
                null != e && this._cachedIndexBuffer !== e && (this._cachedIndexBuffer = e,
                this.bindIndexBuffer(e),
                this._uintIndicesCurrentlySet = e.is32Bits)
            }
            _bindVertexBuffersAttributes(e, t, i) {
                const s = t.getAttributesNames();
                this._vaoRecordInProgress || this._unbindVertexArrayObject(),
                this.unbindAllAttributes();
                for (let r = 0; r < s.length; r++) {
                    const n = t.getAttributeLocation(r);
                    if (n >= 0) {
                        const t = s[r];
                        let a = null;
                        if (i && (a = i[t]),
                        a || (a = e[t]),
                        !a)
                            continue;
                        this._gl.enableVertexAttribArray(n),
                        this._vaoRecordInProgress || (this._vertexAttribArraysEnabled[n] = !0);
                        const o = a.getBuffer();
                        o && (this._vertexAttribPointer(o, n, a.getSize(), a.type, a.normalized, a.byteStride, a.byteOffset),
                        a.getIsInstanced() && (this._gl.vertexAttribDivisor(n, a.getInstanceDivisor()),
                        this._vaoRecordInProgress || (this._currentInstanceLocations.push(n),
                        this._currentInstanceBuffers.push(o))))
                    }
                }
            }
            recordVertexArrayObject(e, t, i, s) {
                const r = this._gl.createVertexArray();
                if (!r)
                    throw new Error("Unable to create VAO");
                return this._vaoRecordInProgress = !0,
                this._gl.bindVertexArray(r),
                this._mustWipeVertexAttributes = !0,
                this._bindVertexBuffersAttributes(e, i, s),
                this.bindIndexBuffer(t),
                this._vaoRecordInProgress = !1,
                this._gl.bindVertexArray(null),
                r
            }
            bindVertexArrayObject(e, t) {
                this._cachedVertexArrayObject !== e && (this._cachedVertexArrayObject = e,
                this._gl.bindVertexArray(e),
                this._cachedVertexBuffers = null,
                this._cachedIndexBuffer = null,
                this._uintIndicesCurrentlySet = null != t && t.is32Bits,
                this._mustWipeVertexAttributes = !0)
            }
            bindBuffersDirectly(e, t, i, s, r) {
                if (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== r) {
                    this._cachedVertexBuffers = e,
                    this._cachedEffectForVertexBuffers = r;
                    const t = r.getAttributesCount();
                    this._unbindVertexArrayObject(),
                    this.unbindAllAttributes();
                    let n = 0;
                    for (let a = 0; a < t; a++)
                        if (a < i.length) {
                            const t = r.getAttributeLocation(a);
                            t >= 0 && (this._gl.enableVertexAttribArray(t),
                            this._vertexAttribArraysEnabled[t] = !0,
                            this._vertexAttribPointer(e, t, i[a], this._gl.FLOAT, !1, s, n)),
                            n += 4 * i[a]
                        }
                }
                this._bindIndexBufferWithCache(t)
            }
            _unbindVertexArrayObject() {
                this._cachedVertexArrayObject && (this._cachedVertexArrayObject = null,
                this._gl.bindVertexArray(null))
            }
            bindBuffers(e, t, i, s) {
                this._cachedVertexBuffers === e && this._cachedEffectForVertexBuffers === i || (this._cachedVertexBuffers = e,
                this._cachedEffectForVertexBuffers = i,
                this._bindVertexBuffersAttributes(e, i, s)),
                this._bindIndexBufferWithCache(t)
            }
            unbindInstanceAttributes() {
                let e;
                for (let t = 0, i = this._currentInstanceLocations.length; t < i; t++) {
                    const i = this._currentInstanceBuffers[t];
                    e != i && i.references && (e = i,
                    this.bindArrayBuffer(i));
                    const s = this._currentInstanceLocations[t];
                    this._gl.vertexAttribDivisor(s, 0)
                }
                this._currentInstanceBuffers.length = 0,
                this._currentInstanceLocations.length = 0
            }
            releaseVertexArrayObject(e) {
                this._gl.deleteVertexArray(e)
            }
            _releaseBuffer(e) {
                return e.references--,
                0 === e.references && (this._deleteBuffer(e),
                !0)
            }
            _deleteBuffer(e) {
                this._gl.deleteBuffer(e.underlyingResource)
            }
            updateAndBindInstancesBuffer(e, t, i) {
                if (this.bindArrayBuffer(e),
                t && this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, t),
                void 0 !== i[0].index)
                    this.bindInstancesBuffer(e, i, !0);
                else
                    for (let t = 0; t < 4; t++) {
                        const s = i[t];
                        this._vertexAttribArraysEnabled[s] || (this._gl.enableVertexAttribArray(s),
                        this._vertexAttribArraysEnabled[s] = !0),
                        this._vertexAttribPointer(e, s, 4, this._gl.FLOAT, !1, 64, 16 * t),
                        this._gl.vertexAttribDivisor(s, 1),
                        this._currentInstanceLocations.push(s),
                        this._currentInstanceBuffers.push(e)
                    }
            }
            bindInstancesBuffer(e, t, i=!0) {
                this.bindArrayBuffer(e);
                let s = 0;
                if (i)
                    for (let e = 0; e < t.length; e++)
                        s += 4 * t[e].attributeSize;
                for (let i = 0; i < t.length; i++) {
                    const r = t[i];
                    void 0 === r.index && (r.index = this._currentEffect.getAttributeLocationByName(r.attributeName)),
                    r.index < 0 || (this._vertexAttribArraysEnabled[r.index] || (this._gl.enableVertexAttribArray(r.index),
                    this._vertexAttribArraysEnabled[r.index] = !0),
                    this._vertexAttribPointer(e, r.index, r.attributeSize, r.attributeType || this._gl.FLOAT, r.normalized || !1, s, r.offset),
                    this._gl.vertexAttribDivisor(r.index, void 0 === r.divisor ? 1 : r.divisor),
                    this._currentInstanceLocations.push(r.index),
                    this._currentInstanceBuffers.push(e))
                }
            }
            disableInstanceAttributeByName(e) {
                if (!this._currentEffect)
                    return;
                const t = this._currentEffect.getAttributeLocationByName(e);
                this.disableInstanceAttribute(t)
            }
            disableInstanceAttribute(e) {
                let t, i = !1;
                for (; -1 !== (t = this._currentInstanceLocations.indexOf(e)); )
                    this._currentInstanceLocations.splice(t, 1),
                    this._currentInstanceBuffers.splice(t, 1),
                    i = !0,
                    t = this._currentInstanceLocations.indexOf(e);
                i && (this._gl.vertexAttribDivisor(e, 0),
                this.disableAttributeByIndex(e))
            }
            disableAttributeByIndex(e) {
                this._gl.disableVertexAttribArray(e),
                this._vertexAttribArraysEnabled[e] = !1,
                this._currentBufferPointers[e].active = !1
            }
            draw(e, t, i, s) {
                this.drawElementsType(e ? 0 : 1, t, i, s)
            }
            drawPointClouds(e, t, i) {
                this.drawArraysType(2, e, t, i)
            }
            drawUnIndexed(e, t, i, s) {
                this.drawArraysType(e ? 0 : 1, t, i, s)
            }
            drawElementsType(e, t, i, s) {
                this.applyStates(),
                this._reportDrawCall();
                const r = this._drawMode(e)
                  , n = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT
                  , a = this._uintIndicesCurrentlySet ? 4 : 2;
                s ? this._gl.drawElementsInstanced(r, i, n, t * a, s) : this._gl.drawElements(r, i, n, t * a)
            }
            drawArraysType(e, t, i, s) {
                this.applyStates(),
                this._reportDrawCall();
                const r = this._drawMode(e);
                s ? this._gl.drawArraysInstanced(r, t, i, s) : this._gl.drawArrays(r, t, i)
            }
            _drawMode(e) {
                switch (e) {
                case 0:
                default:
                    return this._gl.TRIANGLES;
                case 2:
                case 3:
                    return this._gl.POINTS;
                case 1:
                case 4:
                    return this._gl.LINES;
                case 5:
                    return this._gl.LINE_LOOP;
                case 6:
                    return this._gl.LINE_STRIP;
                case 7:
                    return this._gl.TRIANGLE_STRIP;
                case 8:
                    return this._gl.TRIANGLE_FAN
                }
            }
            _reportDrawCall() {}
            _releaseEffect(e) {
                this._compiledEffects[e._key] && delete this._compiledEffects[e._key];
                const t = e.getPipelineContext();
                t && this._deletePipelineContext(t)
            }
            _deletePipelineContext(e) {
                const t = e;
                t && t.program && (t.program.__SPECTOR_rebuildProgram = null,
                this._gl.deleteProgram(t.program))
            }
            _getGlobalDefines(e) {
                if (e)
                    return this.isNDCHalfZRange ? e.IS_NDC_HALF_ZRANGE = "" : delete e.IS_NDC_HALF_ZRANGE,
                    this.useReverseDepthBuffer ? e.USE_REVERSE_DEPTHBUFFER = "" : delete e.USE_REVERSE_DEPTHBUFFER,
                    void (this.useExactSrgbConversions ? e.USE_EXACT_SRGB_CONVERSIONS = "" : delete e.USE_EXACT_SRGB_CONVERSIONS);
                {
                    let e = "";
                    return this.isNDCHalfZRange && (e += "#define IS_NDC_HALF_ZRANGE"),
                    this.useReverseDepthBuffer && (e && (e += "\n"),
                    e += "#define USE_REVERSE_DEPTHBUFFER"),
                    this.useExactSrgbConversions && (e && (e += "\n"),
                    e += "#define USE_EXACT_SRGB_CONVERSIONS"),
                    e
                }
            }
            createEffect(e, t, i, s, r, n, a, o, h, l=ut.GLSL) {
                const c = e.vertexElement || e.vertex || e.vertexToken || e.vertexSource || e
                  , u = e.fragmentElement || e.fragment || e.fragmentToken || e.fragmentSource || e
                  , d = this._getGlobalDefines();
                let f = r ?? t.defines ?? "";
                d && (f += d);
                const _ = c + "+" + u + "@" + f;
                if (this._compiledEffects[_]) {
                    const e = this._compiledEffects[_];
                    return a && e.isReady() && a(e),
                    e
                }
                const p = new xt(e,t,i,s,this,r,n,a,o,h,_,l);
                return this._compiledEffects[_] = p,
                p
            }
            static _ConcatenateShader(e, t, i="") {
                return i + (t ? t + "\n" : "") + e
            }
            _compileShader(e, t, i, s) {
                return this._compileRawShader(kt._ConcatenateShader(e, i, s), t)
            }
            _compileRawShader(e, t) {
                const i = this._gl
                  , s = i.createShader("vertex" === t ? i.VERTEX_SHADER : i.FRAGMENT_SHADER);
                if (!s) {
                    let e = i.NO_ERROR
                      , s = i.NO_ERROR;
                    for (; (s = i.getError()) !== i.NO_ERROR; )
                        e = s;
                    throw new Error(`Something went wrong while creating a gl ${t} shader object. gl error=${e}, gl isContextLost=${i.isContextLost()}, _contextWasLost=${this._contextWasLost}`)
                }
                return i.shaderSource(s, e),
                i.compileShader(s),
                s
            }
            _getShaderSource(e) {
                return this._gl.getShaderSource(e)
            }
            createRawShaderProgram(e, t, i, s, r=null) {
                s = s || this._gl;
                const n = this._compileRawShader(t, "vertex")
                  , a = this._compileRawShader(i, "fragment");
                return this._createShaderProgram(e, n, a, s, r)
            }
            createShaderProgram(e, t, i, s, r, n=null) {
                r = r || this._gl;
                const a = this._webGLVersion > 1 ? "#version 300 es\n#define WEBGL2 \n" : ""
                  , o = this._compileShader(t, "vertex", s, a)
                  , h = this._compileShader(i, "fragment", s, a);
                return this._createShaderProgram(e, o, h, r, n)
            }
            inlineShaderCode(e) {
                return e
            }
            createPipelineContext(e) {
                const t = new Ft;
                return t.engine = this,
                this._caps.parallelShaderCompile && (t.isParallelCompiled = !0),
                t
            }
            createMaterialContext() {}
            createDrawContext() {}
            _createShaderProgram(e, t, i, s, r=null) {
                const n = s.createProgram();
                if (e.program = n,
                !n)
                    throw new Error("Unable to create program");
                return s.attachShader(n, t),
                s.attachShader(n, i),
                s.linkProgram(n),
                e.context = s,
                e.vertexShader = t,
                e.fragmentShader = i,
                e.isParallelCompiled || this._finalizePipelineContext(e),
                n
            }
            _finalizePipelineContext(e) {
                const t = e.context
                  , i = e.vertexShader
                  , s = e.fragmentShader
                  , r = e.program;
                if (!t.getProgramParameter(r, t.LINK_STATUS)) {
                    if (!this._gl.getShaderParameter(i, this._gl.COMPILE_STATUS)) {
                        const t = this._gl.getShaderInfoLog(i);
                        if (t)
                            throw e.vertexCompilationError = t,
                            new Error("VERTEX SHADER " + t)
                    }
                    if (!this._gl.getShaderParameter(s, this._gl.COMPILE_STATUS)) {
                        const t = this._gl.getShaderInfoLog(s);
                        if (t)
                            throw e.fragmentCompilationError = t,
                            new Error("FRAGMENT SHADER " + t)
                    }
                    const n = t.getProgramInfoLog(r);
                    if (n)
                        throw e.programLinkError = n,
                        new Error(n)
                }
                if (this.validateShaderPrograms && (t.validateProgram(r),
                !t.getProgramParameter(r, t.VALIDATE_STATUS))) {
                    const i = t.getProgramInfoLog(r);
                    if (i)
                        throw e.programValidationError = i,
                        new Error(i)
                }
                t.deleteShader(i),
                t.deleteShader(s),
                e.vertexShader = void 0,
                e.fragmentShader = void 0,
                e.onCompiled && (e.onCompiled(),
                e.onCompiled = void 0)
            }
            _preparePipelineContext(e, t, i, s, r, n, a, o, h, l) {
                const c = e;
                c.program = s ? this.createRawShaderProgram(c, t, i, void 0, h) : this.createShaderProgram(c, t, i, o, void 0, h),
                c.program.__SPECTOR_rebuildProgram = a
            }
            _isRenderingStateCompiled(e) {
                const t = e;
                return !(this._isDisposed || t._isDisposed || !this._gl.getProgramParameter(t.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR) || (this._finalizePipelineContext(t),
                0))
            }
            _executeWhenRenderingStateIsCompiled(e, t) {
                const i = e;
                if (!i.isParallelCompiled)
                    return void t();
                const s = i.onCompiled;
                i.onCompiled = s ? () => {
                    s(),
                    t()
                }
                : t
            }
            getUniforms(e, t) {
                const i = new Array
                  , s = e;
                for (let e = 0; e < t.length; e++)
                    i.push(this._gl.getUniformLocation(s.program, t[e]));
                return i
            }
            getAttributes(e, t) {
                const i = []
                  , s = e;
                for (let e = 0; e < t.length; e++)
                    try {
                        i.push(this._gl.getAttribLocation(s.program, t[e]))
                    } catch (e) {
                        i.push(-1)
                    }
                return i
            }
            enableEffect(e) {
                (e = null !== e && Bt.IsWrapper(e) ? e.effect : e) && e !== this._currentEffect && (this._stencilStateComposer.stencilMaterial = void 0,
                this.bindSamplers(e),
                this._currentEffect = e,
                e.onBind && e.onBind(e),
                e._onBindObservable && e._onBindObservable.notifyObservers(e))
            }
            setInt(e, t) {
                return !!e && (this._gl.uniform1i(e, t),
                !0)
            }
            setInt2(e, t, i) {
                return !!e && (this._gl.uniform2i(e, t, i),
                !0)
            }
            setInt3(e, t, i, s) {
                return !!e && (this._gl.uniform3i(e, t, i, s),
                !0)
            }
            setInt4(e, t, i, s, r) {
                return !!e && (this._gl.uniform4i(e, t, i, s, r),
                !0)
            }
            setIntArray(e, t) {
                return !!e && (this._gl.uniform1iv(e, t),
                !0)
            }
            setIntArray2(e, t) {
                return !(!e || t.length % 2 != 0 || (this._gl.uniform2iv(e, t),
                0))
            }
            setIntArray3(e, t) {
                return !(!e || t.length % 3 != 0 || (this._gl.uniform3iv(e, t),
                0))
            }
            setIntArray4(e, t) {
                return !(!e || t.length % 4 != 0 || (this._gl.uniform4iv(e, t),
                0))
            }
            setUInt(e, t) {
                return !!e && (this._gl.uniform1ui(e, t),
                !0)
            }
            setUInt2(e, t, i) {
                return !!e && (this._gl.uniform2ui(e, t, i),
                !0)
            }
            setUInt3(e, t, i, s) {
                return !!e && (this._gl.uniform3ui(e, t, i, s),
                !0)
            }
            setUInt4(e, t, i, s, r) {
                return !!e && (this._gl.uniform4ui(e, t, i, s, r),
                !0)
            }
            setUIntArray(e, t) {
                return !!e && (this._gl.uniform1uiv(e, t),
                !0)
            }
            setUIntArray2(e, t) {
                return !(!e || t.length % 2 != 0 || (this._gl.uniform2uiv(e, t),
                0))
            }
            setUIntArray3(e, t) {
                return !(!e || t.length % 3 != 0 || (this._gl.uniform3uiv(e, t),
                0))
            }
            setUIntArray4(e, t) {
                return !(!e || t.length % 4 != 0 || (this._gl.uniform4uiv(e, t),
                0))
            }
            setArray(e, t) {
                return !(!e || t.length < 1 || (this._gl.uniform1fv(e, t),
                0))
            }
            setArray2(e, t) {
                return !(!e || t.length % 2 != 0 || (this._gl.uniform2fv(e, t),
                0))
            }
            setArray3(e, t) {
                return !(!e || t.length % 3 != 0 || (this._gl.uniform3fv(e, t),
                0))
            }
            setArray4(e, t) {
                return !(!e || t.length % 4 != 0 || (this._gl.uniform4fv(e, t),
                0))
            }
            setMatrices(e, t) {
                return !!e && (this._gl.uniformMatrix4fv(e, !1, t),
                !0)
            }
            setMatrix3x3(e, t) {
                return !!e && (this._gl.uniformMatrix3fv(e, !1, t),
                !0)
            }
            setMatrix2x2(e, t) {
                return !!e && (this._gl.uniformMatrix2fv(e, !1, t),
                !0)
            }
            setFloat(e, t) {
                return !!e && (this._gl.uniform1f(e, t),
                !0)
            }
            setFloat2(e, t, i) {
                return !!e && (this._gl.uniform2f(e, t, i),
                !0)
            }
            setFloat3(e, t, i, s) {
                return !!e && (this._gl.uniform3f(e, t, i, s),
                !0)
            }
            setFloat4(e, t, i, s, r) {
                return !!e && (this._gl.uniform4f(e, t, i, s, r),
                !0)
            }
            applyStates() {
                if (this._depthCullingState.apply(this._gl),
                this._stencilStateComposer.apply(this._gl),
                this._alphaState.apply(this._gl),
                this._colorWriteChanged) {
                    this._colorWriteChanged = !1;
                    const e = this._colorWrite;
                    this._gl.colorMask(e, e, e, e)
                }
            }
            setColorWrite(e) {
                e !== this._colorWrite && (this._colorWriteChanged = !0,
                this._colorWrite = e)
            }
            getColorWrite() {
                return this._colorWrite
            }
            get depthCullingState() {
                return this._depthCullingState
            }
            get alphaState() {
                return this._alphaState
            }
            get stencilState() {
                return this._stencilState
            }
            get stencilStateComposer() {
                return this._stencilStateComposer
            }
            clearInternalTexturesCache() {
                this._internalTexturesCache.length = 0
            }
            wipeCaches(e) {
                this.preventCacheWipeBetweenFrames && !e || (this._currentEffect = null,
                this._viewportCached.x = 0,
                this._viewportCached.y = 0,
                this._viewportCached.z = 0,
                this._viewportCached.w = 0,
                this._unbindVertexArrayObject(),
                e && (this._currentProgram = null,
                this.resetTextureCache(),
                this._stencilStateComposer.reset(),
                this._depthCullingState.reset(),
                this._depthCullingState.depthFunc = this._gl.LEQUAL,
                this._alphaState.reset(),
                this._alphaMode = 1,
                this._alphaEquation = 0,
                this._colorWrite = !0,
                this._colorWriteChanged = !0,
                this._unpackFlipYCached = null,
                this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE),
                this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0),
                this._mustWipeVertexAttributes = !0,
                this.unbindAllAttributes()),
                this._resetVertexBufferBinding(),
                this._cachedIndexBuffer = null,
                this._cachedEffectForVertexBuffers = null,
                this.bindIndexBuffer(null))
            }
            _getSamplingParameters(e, t) {
                const i = this._gl;
                let s = i.NEAREST
                  , r = i.NEAREST;
                switch (e) {
                case 11:
                    s = i.LINEAR,
                    r = t ? i.LINEAR_MIPMAP_NEAREST : i.LINEAR;
                    break;
                case 3:
                    s = i.LINEAR,
                    r = t ? i.LINEAR_MIPMAP_LINEAR : i.LINEAR;
                    break;
                case 8:
                    s = i.NEAREST,
                    r = t ? i.NEAREST_MIPMAP_LINEAR : i.NEAREST;
                    break;
                case 4:
                    s = i.NEAREST,
                    r = t ? i.NEAREST_MIPMAP_NEAREST : i.NEAREST;
                    break;
                case 5:
                    s = i.NEAREST,
                    r = t ? i.LINEAR_MIPMAP_NEAREST : i.LINEAR;
                    break;
                case 6:
                    s = i.NEAREST,
                    r = t ? i.LINEAR_MIPMAP_LINEAR : i.LINEAR;
                    break;
                case 7:
                    s = i.NEAREST,
                    r = i.LINEAR;
                    break;
                case 1:
                    s = i.NEAREST,
                    r = i.NEAREST;
                    break;
                case 9:
                    s = i.LINEAR,
                    r = t ? i.NEAREST_MIPMAP_NEAREST : i.NEAREST;
                    break;
                case 10:
                    s = i.LINEAR,
                    r = t ? i.NEAREST_MIPMAP_LINEAR : i.NEAREST;
                    break;
                case 2:
                    s = i.LINEAR,
                    r = i.LINEAR;
                    break;
                case 12:
                    s = i.LINEAR,
                    r = i.NEAREST
                }
                return {
                    min: r,
                    mag: s
                }
            }
            _createTexture() {
                const e = this._gl.createTexture();
                if (!e)
                    throw new Error("Unable to create texture");
                return e
            }
            _createHardwareTexture() {
                return new Lt(this._createTexture(),this._gl)
            }
            _createInternalTexture(e, t, i=!0, s=At.Unknown) {
                let r, n = !1, a = 0, o = 3, h = 5, l = !1, c = 1;
                void 0 !== t && "object" == typeof t ? (n = !!t.generateMipMaps,
                a = void 0 === t.type ? 0 : t.type,
                o = void 0 === t.samplingMode ? 3 : t.samplingMode,
                h = void 0 === t.format ? 5 : t.format,
                l = void 0 !== t.useSRGBBuffer && t.useSRGBBuffer,
                c = t.samples ?? 1,
                r = t.label) : n = !!t,
                l && (l = this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU)),
                (1 !== a || this._caps.textureFloatLinearFiltering) && (2 !== a || this._caps.textureHalfFloatLinearFiltering) || (o = 1),
                1 !== a || this._caps.textureFloat || (a = 0,
                We.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE"));
                const u = this._gl
                  , d = new It(this,s)
                  , f = e.width || e
                  , _ = e.height || e
                  , p = e.layers || 0
                  , m = this._getSamplingParameters(o, n)
                  , g = 0 !== p ? u.TEXTURE_2D_ARRAY : u.TEXTURE_2D
                  , v = this._getRGBABufferInternalSizedFormat(a, h, l)
                  , y = this._getInternalFormat(h)
                  , b = this._getWebGLTextureType(a);
                return this._bindTextureDirectly(g, d),
                0 !== p ? (d.is2DArray = !0,
                u.texImage3D(g, 0, v, f, _, p, 0, y, b, null)) : u.texImage2D(g, 0, v, f, _, 0, y, b, null),
                u.texParameteri(g, u.TEXTURE_MAG_FILTER, m.mag),
                u.texParameteri(g, u.TEXTURE_MIN_FILTER, m.min),
                u.texParameteri(g, u.TEXTURE_WRAP_S, u.CLAMP_TO_EDGE),
                u.texParameteri(g, u.TEXTURE_WRAP_T, u.CLAMP_TO_EDGE),
                n && this._gl.generateMipmap(g),
                this._bindTextureDirectly(g, null),
                d._useSRGBBuffer = l,
                d.baseWidth = f,
                d.baseHeight = _,
                d.width = f,
                d.height = _,
                d.depth = p,
                d.isReady = !0,
                d.samples = c,
                d.generateMipMaps = n,
                d.samplingMode = o,
                d.type = a,
                d.format = h,
                d.label = r,
                this._internalTexturesCache.push(d),
                d
            }
            _getUseSRGBBuffer(e, t) {
                return e && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || t)
            }
            _createTextureBase(e, t, i, s, r=3, n=null, a=null, o, h, l=null, c=null, u=null, d=null, f, _, p) {
                const m = "data:" === (e = e || "").substr(0, 5)
                  , g = "blob:" === e.substr(0, 5)
                  , v = m && -1 !== e.indexOf(";base64,")
                  , y = c || new It(this,At.Url);
                y !== c && (y.label = e.substring(0, 60));
                const b = e;
                !this._transformTextureUrl || v || c || l || (e = this._transformTextureUrl(e)),
                b !== e && (y._originalUrl = b);
                const x = e.lastIndexOf(".");
                let T = d || (x > -1 ? e.substring(x).toLowerCase() : "")
                  , E = null;
                T.indexOf("?") > -1 && (T = T.split("?")[0]);
                for (const e of kt._TextureLoaders)
                    if (e.canLoad(T, f)) {
                        E = e;
                        break
                    }
                s && s.addPendingData(y),
                y.url = e,
                y.generateMipMaps = !t,
                y.samplingMode = r,
                y.invertY = i,
                y._useSRGBBuffer = this._getUseSRGBBuffer(!!p, t),
                this._doNotHandleContextLost || (y._buffer = l);
                let M = null;
                n && !c && (M = y.onLoadedObservable.add(n)),
                c || this._internalTexturesCache.push(y);
                const S = (i, c) => {
                    s && s.removePendingData(y),
                    e === b ? (M && y.onLoadedObservable.remove(M),
                    Ze.UseFallbackTexture && e !== Ze.FallbackTexture && this._createTextureBase(Ze.FallbackTexture, t, y.invertY, s, r, null, a, o, h, l, y),
                    i = (i || "Unknown error") + (Ze.UseFallbackTexture ? " - Fallback texture was used" : ""),
                    y.onErrorObservable.notifyObservers({
                        message: i,
                        exception: c
                    }),
                    a && a(i, c)) : (We.Warn(`Failed to load ${e}, falling back to ${b}`),
                    this._createTextureBase(b, t, y.invertY, s, r, n, a, o, h, l, y, u, d, f, _, p))
                }
                ;
                if (E) {
                    const t = e => {
                        E.loadData(e, y, ( (e, t, i, n, a, h) => {
                            h ? S("TextureLoader failed to load data") : o(y, T, s, {
                                width: e,
                                height: t
                            }, y.invertY, !i, n, ( () => (a(),
                            !1)), r)
                        }
                        ), _)
                    }
                    ;
                    l ? l instanceof ArrayBuffer ? t(new Uint8Array(l)) : ArrayBuffer.isView(l) ? t(l) : a && a("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null) : this._loadFile(e, (e => t(new Uint8Array(e))), void 0, s ? s.offlineProvider : void 0, !0, ( (e, t) => {
                        S("Unable to load " + (e && e.responseURL,
                        t))
                    }
                    ))
                } else {
                    const i = e => {
                        g && !this._doNotHandleContextLost && (y._buffer = e),
                        o(y, T, s, e, y.invertY, t, !1, h, r)
                    }
                    ;
                    !m || v ? l && ("string" == typeof l.decoding || l.close) ? i(l) : kt._FileToolsLoadImage(e, i, S, s ? s.offlineProvider : null, f, y.invertY && this._features.needsInvertingBitmap ? {
                        imageOrientation: "flipY"
                    } : void 0) : "string" == typeof l || l instanceof ArrayBuffer || ArrayBuffer.isView(l) || l instanceof Blob ? kt._FileToolsLoadImage(l, i, S, s ? s.offlineProvider : null, f, y.invertY && this._features.needsInvertingBitmap ? {
                        imageOrientation: "flipY"
                    } : void 0) : l && i(l)
                }
                return y
            }
            createTexture(e, t, i, s, r=3, n=null, a=null, o=null, h=null, l=null, c=null, u, d, f, _) {
                return this._createTextureBase(e, t, i, s, r, n, a, this._prepareWebGLTexture.bind(this), ( (e, t, i, r, n, a) => {
                    const o = this._gl
                      , h = i.width === e && i.height === t;
                    n._creationFlags = f ?? 0;
                    const c = this._getTexImageParametersForCreateTexture(l, r, n._useSRGBBuffer);
                    if (h)
                        return o.texImage2D(o.TEXTURE_2D, 0, c.internalFormat, c.format, c.type, i),
                        !1;
                    const u = this._caps.maxTextureSize;
                    if (i.width > u || i.height > u || !this._supportsHardwareTextureRescaling)
                        return this._prepareWorkingCanvas(),
                        !(!this._workingCanvas || !this._workingContext || (this._workingCanvas.width = e,
                        this._workingCanvas.height = t,
                        this._workingContext.drawImage(i, 0, 0, i.width, i.height, 0, 0, e, t),
                        o.texImage2D(o.TEXTURE_2D, 0, c.internalFormat, c.format, c.type, this._workingCanvas),
                        n.width = e,
                        n.height = t,
                        1));
                    {
                        const e = new It(this,At.Temp);
                        this._bindTextureDirectly(o.TEXTURE_2D, e, !0),
                        o.texImage2D(o.TEXTURE_2D, 0, c.internalFormat, c.format, c.type, i),
                        this._rescaleTexture(e, n, s, c.format, ( () => {
                            this._releaseTexture(e),
                            this._bindTextureDirectly(o.TEXTURE_2D, n, !0),
                            a()
                        }
                        ))
                    }
                    return !0
                }
                ), o, h, l, c, u, d, _)
            }
            _getTexImageParametersForCreateTexture(e, t, i) {
                let s, r;
                return null == e && (e = ".jpg" !== t || i ? 5 : 4),
                1 === this.webGLVersion ? (s = this._getInternalFormat(e, i),
                r = s) : (s = this._getInternalFormat(e, !1),
                r = this._getRGBABufferInternalSizedFormat(0, e, i)),
                {
                    internalFormat: r,
                    format: s,
                    type: this._gl.UNSIGNED_BYTE
                }
            }
            static _FileToolsLoadImage(e, t, i, s, r, n) {
                throw je("FileTools")
            }
            _rescaleTexture(e, t, i, s, r) {}
            createRawTexture(e, t, i, s, r, n, a, o=null, h=0, l=0, c=!1) {
                throw je("Engine.RawTexture")
            }
            createRawCubeTexture(e, t, i, s, r, n, a, o=null) {
                throw je("Engine.RawTexture")
            }
            createRawTexture3D(e, t, i, s, r, n, a, o, h=null, l=0) {
                throw je("Engine.RawTexture")
            }
            createRawTexture2DArray(e, t, i, s, r, n, a, o, h=null, l=0) {
                throw je("Engine.RawTexture")
            }
            _unpackFlipY(e) {
                this._unpackFlipYCached !== e && (this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, e ? 1 : 0),
                this.enableUnpackFlipYCached && (this._unpackFlipYCached = e))
            }
            _getUnpackAlignement() {
                return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT)
            }
            _getTextureTarget(e) {
                return e.isCube ? this._gl.TEXTURE_CUBE_MAP : e.is3D ? this._gl.TEXTURE_3D : e.is2DArray || e.isMultiview ? this._gl.TEXTURE_2D_ARRAY : this._gl.TEXTURE_2D
            }
            updateTextureSamplingMode(e, t, i=!1) {
                const s = this._getTextureTarget(t)
                  , r = this._getSamplingParameters(e, t.useMipMaps || i);
                this._setTextureParameterInteger(s, this._gl.TEXTURE_MAG_FILTER, r.mag, t),
                this._setTextureParameterInteger(s, this._gl.TEXTURE_MIN_FILTER, r.min),
                i && (t.generateMipMaps = !0,
                this._gl.generateMipmap(s)),
                this._bindTextureDirectly(s, null),
                t.samplingMode = e
            }
            updateTextureDimensions(e, t, i, s=1) {}
            updateTextureWrappingMode(e, t, i=null, s=null) {
                const r = this._getTextureTarget(e);
                null !== t && (this._setTextureParameterInteger(r, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t), e),
                e._cachedWrapU = t),
                null !== i && (this._setTextureParameterInteger(r, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(i), e),
                e._cachedWrapV = i),
                (e.is2DArray || e.is3D) && null !== s && (this._setTextureParameterInteger(r, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(s), e),
                e._cachedWrapR = s),
                this._bindTextureDirectly(r, null)
            }
            _setupDepthStencilTexture(e, t, i, s, r, n=1) {
                const a = t.width || t
                  , o = t.height || t
                  , h = t.layers || 0;
                e.baseWidth = a,
                e.baseHeight = o,
                e.width = a,
                e.height = o,
                e.is2DArray = h > 0,
                e.depth = h,
                e.isReady = !0,
                e.samples = n,
                e.generateMipMaps = !1,
                e.samplingMode = s ? 2 : 1,
                e.type = 0,
                e._comparisonFunction = r;
                const l = this._gl
                  , c = this._getTextureTarget(e)
                  , u = this._getSamplingParameters(e.samplingMode, !1);
                l.texParameteri(c, l.TEXTURE_MAG_FILTER, u.mag),
                l.texParameteri(c, l.TEXTURE_MIN_FILTER, u.min),
                l.texParameteri(c, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE),
                l.texParameteri(c, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE),
                this.webGLVersion > 1 && (0 === r ? (l.texParameteri(c, l.TEXTURE_COMPARE_FUNC, 515),
                l.texParameteri(c, l.TEXTURE_COMPARE_MODE, l.NONE)) : (l.texParameteri(c, l.TEXTURE_COMPARE_FUNC, r),
                l.texParameteri(c, l.TEXTURE_COMPARE_MODE, l.COMPARE_REF_TO_TEXTURE)))
            }
            _uploadCompressedDataToTextureDirectly(e, t, i, s, r, n=0, a=0) {
                const o = this._gl;
                let h = o.TEXTURE_2D;
                if (e.isCube && (h = o.TEXTURE_CUBE_MAP_POSITIVE_X + n),
                e._useSRGBBuffer)
                    switch (t) {
                    case 37492:
                    case 36196:
                        this._caps.etc2 ? t = o.COMPRESSED_SRGB8_ETC2 : e._useSRGBBuffer = !1;
                        break;
                    case 37496:
                        this._caps.etc2 ? t = o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : e._useSRGBBuffer = !1;
                        break;
                    case 36492:
                        t = o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
                        break;
                    case 37808:
                        t = o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
                        break;
                    case 33776:
                        this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_S3TC_DXT1_EXT : e._useSRGBBuffer = !1;
                        break;
                    case 33777:
                        this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT : e._useSRGBBuffer = !1;
                        break;
                    case 33779:
                        this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT : e._useSRGBBuffer = !1;
                        break;
                    default:
                        e._useSRGBBuffer = !1
                    }
                this._gl.compressedTexImage2D(h, a, t, i, s, 0, r)
            }
            _uploadDataToTextureDirectly(e, t, i=0, s=0, r, n=!1) {
                const a = this._gl
                  , o = this._getWebGLTextureType(e.type)
                  , h = this._getInternalFormat(e.format)
                  , l = void 0 === r ? this._getRGBABufferInternalSizedFormat(e.type, e.format, e._useSRGBBuffer) : this._getInternalFormat(r, e._useSRGBBuffer);
                this._unpackFlipY(e.invertY);
                let c = a.TEXTURE_2D;
                e.isCube && (c = a.TEXTURE_CUBE_MAP_POSITIVE_X + i);
                const u = Math.round(Math.log(e.width) * Math.LOG2E)
                  , d = Math.round(Math.log(e.height) * Math.LOG2E)
                  , f = n ? e.width : Math.pow(2, Math.max(u - s, 0))
                  , _ = n ? e.height : Math.pow(2, Math.max(d - s, 0));
                a.texImage2D(c, s, l, f, _, 0, h, o, t)
            }
            updateTextureData(e, t, i, s, r, n, a=0, o=0, h=!1) {
                const l = this._gl
                  , c = this._getWebGLTextureType(e.type)
                  , u = this._getInternalFormat(e.format);
                this._unpackFlipY(e.invertY);
                let d = l.TEXTURE_2D
                  , f = l.TEXTURE_2D;
                e.isCube && (f = l.TEXTURE_CUBE_MAP_POSITIVE_X + a,
                d = l.TEXTURE_CUBE_MAP),
                this._bindTextureDirectly(d, e, !0),
                l.texSubImage2D(f, o, i, s, r, n, u, c, t),
                h && this._gl.generateMipmap(f),
                this._bindTextureDirectly(d, null)
            }
            _uploadArrayBufferViewToTexture(e, t, i=0, s=0) {
                const r = this._gl
                  , n = e.isCube ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D;
                this._bindTextureDirectly(n, e, !0),
                this._uploadDataToTextureDirectly(e, t, i, s),
                this._bindTextureDirectly(n, null, !0)
            }
            _prepareWebGLTextureContinuation(e, t, i, s, r) {
                const n = this._gl;
                if (!n)
                    return;
                const a = this._getSamplingParameters(r, !i);
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, a.mag),
                n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, a.min),
                i || s || n.generateMipmap(n.TEXTURE_2D),
                this._bindTextureDirectly(n.TEXTURE_2D, null),
                t && t.removePendingData(e),
                e.onLoadedObservable.notifyObservers(e),
                e.onLoadedObservable.clear()
            }
            _prepareWebGLTexture(e, t, i, s, r, n, a, o, h=3) {
                const l = this.getCaps().maxTextureSize
                  , c = Math.min(l, this.needPOTTextures ? kt.GetExponentOfTwo(s.width, l) : s.width)
                  , u = Math.min(l, this.needPOTTextures ? kt.GetExponentOfTwo(s.height, l) : s.height)
                  , d = this._gl;
                d && (e._hardwareTexture ? (this._bindTextureDirectly(d.TEXTURE_2D, e, !0),
                this._unpackFlipY(void 0 === r || !!r),
                e.baseWidth = s.width,
                e.baseHeight = s.height,
                e.width = c,
                e.height = u,
                e.isReady = !0,
                e.type = -1 !== e.type ? e.type : 0,
                e.format = -1 !== e.format ? e.format : ".jpg" !== t || e._useSRGBBuffer ? 5 : 4,
                o(c, u, s, t, e, ( () => {
                    this._prepareWebGLTextureContinuation(e, i, n, a, h)
                }
                )) || this._prepareWebGLTextureContinuation(e, i, n, a, h)) : i && i.removePendingData(e))
            }
            _setupFramebufferDepthAttachments(e, t, i, s, r=1) {
                const n = this._gl;
                if (e && t)
                    return this._createRenderBuffer(i, s, r, n.DEPTH_STENCIL, n.DEPTH24_STENCIL8, n.DEPTH_STENCIL_ATTACHMENT);
                if (t) {
                    let e = n.DEPTH_COMPONENT16;
                    return this._webGLVersion > 1 && (e = n.DEPTH_COMPONENT32F),
                    this._createRenderBuffer(i, s, r, e, e, n.DEPTH_ATTACHMENT)
                }
                return e ? this._createRenderBuffer(i, s, r, n.STENCIL_INDEX8, n.STENCIL_INDEX8, n.STENCIL_ATTACHMENT) : null
            }
            _createRenderBuffer(e, t, i, s, r, n, a=!0) {
                const o = this._gl.createRenderbuffer();
                return this._updateRenderBuffer(o, e, t, i, s, r, n, a)
            }
            _updateRenderBuffer(e, t, i, s, r, n, a, o=!0) {
                const h = this._gl;
                return h.bindRenderbuffer(h.RENDERBUFFER, e),
                s > 1 && h.renderbufferStorageMultisample ? h.renderbufferStorageMultisample(h.RENDERBUFFER, s, n, t, i) : h.renderbufferStorage(h.RENDERBUFFER, r, t, i),
                h.framebufferRenderbuffer(h.FRAMEBUFFER, a, h.RENDERBUFFER, e),
                o && h.bindRenderbuffer(h.RENDERBUFFER, null),
                e
            }
            _releaseTexture(e) {
                this._deleteTexture(e._hardwareTexture?.underlyingResource),
                this.unbindAllTextures();
                const t = this._internalTexturesCache.indexOf(e);
                -1 !== t && this._internalTexturesCache.splice(t, 1),
                e._lodTextureHigh && e._lodTextureHigh.dispose(),
                e._lodTextureMid && e._lodTextureMid.dispose(),
                e._lodTextureLow && e._lodTextureLow.dispose(),
                e._irradianceTexture && e._irradianceTexture.dispose()
            }
            _releaseRenderTargetWrapper(e) {
                const t = this._renderTargetWrapperCache.indexOf(e);
                -1 !== t && this._renderTargetWrapperCache.splice(t, 1)
            }
            _deleteTexture(e) {
                e && this._gl.deleteTexture(e)
            }
            _setProgram(e) {
                this._currentProgram !== e && (this._gl.useProgram(e),
                this._currentProgram = e)
            }
            bindSamplers(e) {
                const t = e.getPipelineContext();
                this._setProgram(t.program);
                const i = e.getSamplers();
                for (let t = 0; t < i.length; t++) {
                    const s = e.getUniform(i[t]);
                    s && (this._boundUniforms[t] = s)
                }
                this._currentEffect = null
            }
            _activateCurrentTexture() {
                this._currentTextureChannel !== this._activeChannel && (this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel),
                this._currentTextureChannel = this._activeChannel)
            }
            _bindTextureDirectly(e, t, i=!1, s=!1) {
                let r = !1;
                const n = t && t._associatedChannel > -1;
                if (i && n && (this._activeChannel = t._associatedChannel),
                this._boundTexturesCache[this._activeChannel] !== t || s) {
                    if (this._activateCurrentTexture(),
                    t && t.isMultiview)
                        throw We.Error(["_bindTextureDirectly called with a multiview texture!", e, t]),
                        "_bindTextureDirectly called with a multiview texture!";
                    this._gl.bindTexture(e, t?._hardwareTexture?.underlyingResource ?? null),
                    this._boundTexturesCache[this._activeChannel] = t,
                    t && (t._associatedChannel = this._activeChannel)
                } else
                    i && (r = !0,
                    this._activateCurrentTexture());
                return n && !i && this._bindSamplerUniformToChannel(t._associatedChannel, this._activeChannel),
                r
            }
            _bindTexture(e, t, i) {
                if (void 0 === e)
                    return;
                t && (t._associatedChannel = e),
                this._activeChannel = e;
                const s = t ? this._getTextureTarget(t) : this._gl.TEXTURE_2D;
                this._bindTextureDirectly(s, t)
            }
            unbindAllTextures() {
                for (let e = 0; e < this._maxSimultaneousTextures; e++)
                    this._activeChannel = e,
                    this._bindTextureDirectly(this._gl.TEXTURE_2D, null),
                    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null),
                    this.webGLVersion > 1 && (this._bindTextureDirectly(this._gl.TEXTURE_3D, null),
                    this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null))
            }
            setTexture(e, t, i, s) {
                void 0 !== e && (t && (this._boundUniforms[e] = t),
                this._setTexture(e, i))
            }
            _bindSamplerUniformToChannel(e, t) {
                const i = this._boundUniforms[e];
                i && i._currentState !== t && (this._gl.uniform1i(i, t),
                i._currentState = t)
            }
            _getTextureWrapMode(e) {
                switch (e) {
                case 1:
                    return this._gl.REPEAT;
                case 0:
                    return this._gl.CLAMP_TO_EDGE;
                case 2:
                    return this._gl.MIRRORED_REPEAT
                }
                return this._gl.REPEAT
            }
            _setTexture(e, t, i=!1, s=!1, r="") {
                if (!t)
                    return null != this._boundTexturesCache[e] && (this._activeChannel = e,
                    this._bindTextureDirectly(this._gl.TEXTURE_2D, null),
                    this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null),
                    this.webGLVersion > 1 && (this._bindTextureDirectly(this._gl.TEXTURE_3D, null),
                    this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null))),
                    !1;
                if (t.video) {
                    this._activeChannel = e;
                    const i = t.getInternalTexture();
                    i && (i._associatedChannel = e),
                    t.update()
                } else if (4 === t.delayLoadState)
                    return t.delayLoad(),
                    !1;
                let n;
                n = s ? t.depthStencilTexture : t.isReady() ? t.getInternalTexture() : t.isCube ? this.emptyCubeTexture : t.is3D ? this.emptyTexture3D : t.is2DArray ? this.emptyTexture2DArray : this.emptyTexture,
                !i && n && (n._associatedChannel = e);
                let a = !0;
                this._boundTexturesCache[e] === n && (i || this._bindSamplerUniformToChannel(n._associatedChannel, e),
                a = !1),
                this._activeChannel = e;
                const o = this._getTextureTarget(n);
                if (a && this._bindTextureDirectly(o, n, i),
                n && !n.isMultiview) {
                    if (n.isCube && n._cachedCoordinatesMode !== t.coordinatesMode) {
                        n._cachedCoordinatesMode = t.coordinatesMode;
                        const e = 3 !== t.coordinatesMode && 5 !== t.coordinatesMode ? 1 : 0;
                        t.wrapU = e,
                        t.wrapV = e
                    }
                    n._cachedWrapU !== t.wrapU && (n._cachedWrapU = t.wrapU,
                    this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t.wrapU), n)),
                    n._cachedWrapV !== t.wrapV && (n._cachedWrapV = t.wrapV,
                    this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(t.wrapV), n)),
                    n.is3D && n._cachedWrapR !== t.wrapR && (n._cachedWrapR = t.wrapR,
                    this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(t.wrapR), n)),
                    this._setAnisotropicLevel(o, n, t.anisotropicFilteringLevel)
                }
                return !0
            }
            setTextureArray(e, t, i, s) {
                if (void 0 !== e && t) {
                    this._textureUnits && this._textureUnits.length === i.length || (this._textureUnits = new Int32Array(i.length));
                    for (let t = 0; t < i.length; t++) {
                        const s = i[t].getInternalTexture();
                        s ? (this._textureUnits[t] = e + t,
                        s._associatedChannel = e + t) : this._textureUnits[t] = -1
                    }
                    this._gl.uniform1iv(t, this._textureUnits);
                    for (let e = 0; e < i.length; e++)
                        this._setTexture(this._textureUnits[e], i[e], !0)
                }
            }
            _setAnisotropicLevel(e, t, i) {
                const s = this._caps.textureAnisotropicFilterExtension;
                11 !== t.samplingMode && 3 !== t.samplingMode && 2 !== t.samplingMode && (i = 1),
                s && t._cachedAnisotropicFilteringLevel !== i && (this._setTextureParameterFloat(e, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i, this._caps.maxAnisotropy), t),
                t._cachedAnisotropicFilteringLevel = i)
            }
            _setTextureParameterFloat(e, t, i, s) {
                this._bindTextureDirectly(e, s, !0, !0),
                this._gl.texParameterf(e, t, i)
            }
            _setTextureParameterInteger(e, t, i, s) {
                s && this._bindTextureDirectly(e, s, !0, !0),
                this._gl.texParameteri(e, t, i)
            }
            unbindAllAttributes() {
                if (this._mustWipeVertexAttributes) {
                    this._mustWipeVertexAttributes = !1;
                    for (let e = 0; e < this._caps.maxVertexAttribs; e++)
                        this.disableAttributeByIndex(e)
                } else
                    for (let e = 0, t = this._vertexAttribArraysEnabled.length; e < t; e++)
                        e >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[e] || this.disableAttributeByIndex(e)
            }
            releaseEffects() {
                for (const e in this._compiledEffects) {
                    const t = this._compiledEffects[e].getPipelineContext();
                    this._deletePipelineContext(t)
                }
                this._compiledEffects = {}
            }
            dispose() {
                this._isDisposed = !0,
                this.stopRenderLoop(),
                this.onBeforeTextureInitObservable && this.onBeforeTextureInitObservable.clear(),
                this._emptyTexture && (this._releaseTexture(this._emptyTexture),
                this._emptyTexture = null),
                this._emptyCubeTexture && (this._releaseTexture(this._emptyCubeTexture),
                this._emptyCubeTexture = null),
                this._dummyFramebuffer && this._gl.deleteFramebuffer(this._dummyFramebuffer),
                this.releaseEffects(),
                this.releaseComputeEffects?.(),
                this.unbindAllAttributes(),
                this._boundUniforms = {},
                ke() && this._renderingCanvas && (this._doNotHandleContextLost || (this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost),
                this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored)),
                window.removeEventListener("resize", this._checkForMobile)),
                this._workingCanvas = null,
                this._workingContext = null,
                this._currentBufferPointers.length = 0,
                this._renderingCanvas = null,
                this._currentProgram = null,
                this._boundRenderFunction = null,
                xt.ResetCache();
                for (const e of this._activeRequests)
                    e.abort();
                this.onDisposeObservable.notifyObservers(this),
                this.onDisposeObservable.clear(),
                this._creationOptions.loseContextOnDispose && this._gl.getExtension("WEBGL_lose_context")?.loseContext()
            }
            attachContextLostEvent(e) {
                this._renderingCanvas && this._renderingCanvas.addEventListener("webglcontextlost", e, !1)
            }
            attachContextRestoredEvent(e) {
                this._renderingCanvas && this._renderingCanvas.addEventListener("webglcontextrestored", e, !1)
            }
            getError() {
                return this._gl.getError()
            }
            _canRenderToFloatFramebuffer() {
                return this._webGLVersion > 1 ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(1)
            }
            _canRenderToHalfFloatFramebuffer() {
                return this._webGLVersion > 1 ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(2)
            }
            _canRenderToFramebuffer(e) {
                const t = this._gl;
                for (; t.getError() !== t.NO_ERROR; )
                    ;
                let i = !0;
                const s = t.createTexture();
                t.bindTexture(t.TEXTURE_2D, s),
                t.texImage2D(t.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(e), 1, 1, 0, t.RGBA, this._getWebGLTextureType(e), null),
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST),
                t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST);
                const r = t.createFramebuffer();
                t.bindFramebuffer(t.FRAMEBUFFER, r),
                t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, s, 0);
                const n = t.checkFramebufferStatus(t.FRAMEBUFFER);
                if (i = i && n === t.FRAMEBUFFER_COMPLETE,
                i = i && t.getError() === t.NO_ERROR,
                i && (t.clear(t.COLOR_BUFFER_BIT),
                i = i && t.getError() === t.NO_ERROR),
                i) {
                    t.bindFramebuffer(t.FRAMEBUFFER, null);
                    const e = t.RGBA
                      , s = t.UNSIGNED_BYTE
                      , r = new Uint8Array(4);
                    t.readPixels(0, 0, 1, 1, e, s, r),
                    i = i && t.getError() === t.NO_ERROR
                }
                for (t.deleteTexture(s),
                t.deleteFramebuffer(r),
                t.bindFramebuffer(t.FRAMEBUFFER, null); !i && t.getError() !== t.NO_ERROR; )
                    ;
                return i
            }
            _getWebGLTextureType(e) {
                if (1 === this._webGLVersion) {
                    switch (e) {
                    case 1:
                        return this._gl.FLOAT;
                    case 2:
                        return this._gl.HALF_FLOAT_OES;
                    case 0:
                        return this._gl.UNSIGNED_BYTE;
                    case 8:
                        return this._gl.UNSIGNED_SHORT_4_4_4_4;
                    case 9:
                        return this._gl.UNSIGNED_SHORT_5_5_5_1;
                    case 10:
                        return this._gl.UNSIGNED_SHORT_5_6_5
                    }
                    return this._gl.UNSIGNED_BYTE
                }
                switch (e) {
                case 3:
                    return this._gl.BYTE;
                case 0:
                    return this._gl.UNSIGNED_BYTE;
                case 4:
                    return this._gl.SHORT;
                case 5:
                    return this._gl.UNSIGNED_SHORT;
                case 6:
                    return this._gl.INT;
                case 7:
                    return this._gl.UNSIGNED_INT;
                case 1:
                    return this._gl.FLOAT;
                case 2:
                    return this._gl.HALF_FLOAT;
                case 8:
                    return this._gl.UNSIGNED_SHORT_4_4_4_4;
                case 9:
                    return this._gl.UNSIGNED_SHORT_5_5_5_1;
                case 10:
                    return this._gl.UNSIGNED_SHORT_5_6_5;
                case 11:
                    return this._gl.UNSIGNED_INT_2_10_10_10_REV;
                case 12:
                    return this._gl.UNSIGNED_INT_24_8;
                case 13:
                    return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
                case 14:
                    return this._gl.UNSIGNED_INT_5_9_9_9_REV;
                case 15:
                    return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV
                }
                return this._gl.UNSIGNED_BYTE
            }
            _getInternalFormat(e, t=!1) {
                let i = t ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA;
                switch (e) {
                case 0:
                    i = this._gl.ALPHA;
                    break;
                case 1:
                    i = this._gl.LUMINANCE;
                    break;
                case 2:
                    i = this._gl.LUMINANCE_ALPHA;
                    break;
                case 6:
                    i = this._gl.RED;
                    break;
                case 7:
                    i = this._gl.RG;
                    break;
                case 4:
                    i = t ? this._glSRGBExtensionValues.SRGB : this._gl.RGB;
                    break;
                case 5:
                    i = t ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA
                }
                if (this._webGLVersion > 1)
                    switch (e) {
                    case 8:
                        i = this._gl.RED_INTEGER;
                        break;
                    case 9:
                        i = this._gl.RG_INTEGER;
                        break;
                    case 10:
                        i = this._gl.RGB_INTEGER;
                        break;
                    case 11:
                        i = this._gl.RGBA_INTEGER
                    }
                return i
            }
            _getRGBABufferInternalSizedFormat(e, t, i=!1) {
                if (1 === this._webGLVersion) {
                    if (void 0 !== t)
                        switch (t) {
                        case 0:
                            return this._gl.ALPHA;
                        case 1:
                            return this._gl.LUMINANCE;
                        case 2:
                            return this._gl.LUMINANCE_ALPHA;
                        case 4:
                            return i ? this._glSRGBExtensionValues.SRGB : this._gl.RGB
                        }
                    return this._gl.RGBA
                }
                switch (e) {
                case 3:
                    switch (t) {
                    case 6:
                        return this._gl.R8_SNORM;
                    case 7:
                        return this._gl.RG8_SNORM;
                    case 4:
                        return this._gl.RGB8_SNORM;
                    case 8:
                        return this._gl.R8I;
                    case 9:
                        return this._gl.RG8I;
                    case 10:
                        return this._gl.RGB8I;
                    case 11:
                        return this._gl.RGBA8I;
                    default:
                        return this._gl.RGBA8_SNORM
                    }
                case 0:
                    switch (t) {
                    case 6:
                        return this._gl.R8;
                    case 7:
                        return this._gl.RG8;
                    case 4:
                        return i ? this._glSRGBExtensionValues.SRGB8 : this._gl.RGB8;
                    case 5:
                        return i ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8;
                    case 8:
                        return this._gl.R8UI;
                    case 9:
                        return this._gl.RG8UI;
                    case 10:
                        return this._gl.RGB8UI;
                    case 11:
                        return this._gl.RGBA8UI;
                    case 0:
                        return this._gl.ALPHA;
                    case 1:
                        return this._gl.LUMINANCE;
                    case 2:
                        return this._gl.LUMINANCE_ALPHA;
                    default:
                        return this._gl.RGBA8
                    }
                case 4:
                    switch (t) {
                    case 8:
                        return this._gl.R16I;
                    case 9:
                        return this._gl.RG16I;
                    case 10:
                        return this._gl.RGB16I;
                    default:
                        return this._gl.RGBA16I
                    }
                case 5:
                    switch (t) {
                    case 8:
                        return this._gl.R16UI;
                    case 9:
                        return this._gl.RG16UI;
                    case 10:
                        return this._gl.RGB16UI;
                    default:
                        return this._gl.RGBA16UI
                    }
                case 6:
                    switch (t) {
                    case 8:
                        return this._gl.R32I;
                    case 9:
                        return this._gl.RG32I;
                    case 10:
                        return this._gl.RGB32I;
                    default:
                        return this._gl.RGBA32I
                    }
                case 7:
                    switch (t) {
                    case 8:
                        return this._gl.R32UI;
                    case 9:
                        return this._gl.RG32UI;
                    case 10:
                        return this._gl.RGB32UI;
                    default:
                        return this._gl.RGBA32UI
                    }
                case 1:
                    switch (t) {
                    case 6:
                        return this._gl.R32F;
                    case 7:
                        return this._gl.RG32F;
                    case 4:
                        return this._gl.RGB32F;
                    default:
                        return this._gl.RGBA32F
                    }
                case 2:
                    switch (t) {
                    case 6:
                        return this._gl.R16F;
                    case 7:
                        return this._gl.RG16F;
                    case 4:
                        return this._gl.RGB16F;
                    default:
                        return this._gl.RGBA16F
                    }
                case 10:
                    return this._gl.RGB565;
                case 13:
                    return this._gl.R11F_G11F_B10F;
                case 14:
                    return this._gl.RGB9_E5;
                case 8:
                    return this._gl.RGBA4;
                case 9:
                    return this._gl.RGB5_A1;
                case 11:
                    switch (t) {
                    case 5:
                    default:
                        return this._gl.RGB10_A2;
                    case 11:
                        return this._gl.RGB10_A2UI
                    }
                }
                return i ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8
            }
            _loadFile(e, t, i, s, r, n) {
                const a = kt._FileToolsLoadFile(e, t, i, s, r, n);
                return this._activeRequests.push(a),
                a.onCompleteObservable.add((e => {
                    this._activeRequests.splice(this._activeRequests.indexOf(e), 1)
                }
                )),
                a
            }
            static _FileToolsLoadFile(e, t, i, s, r, n) {
                throw je("FileTools")
            }
            readPixels(e, t, i, s, r=!0, n=!0) {
                const a = r ? 4 : 3
                  , o = r ? this._gl.RGBA : this._gl.RGB
                  , h = new Uint8Array(s * i * a);
                return n && this.flushFramebuffer(),
                this._gl.readPixels(e, t, i, s, o, this._gl.UNSIGNED_BYTE, h),
                Promise.resolve(h)
            }
            static get IsSupportedAsync() {
                return Promise.resolve(this.isSupported())
            }
            static get IsSupported() {
                return this.isSupported()
            }
            static isSupported() {
                if (null !== this._HasMajorPerformanceCaveat)
                    return !this._HasMajorPerformanceCaveat;
                if (null === this._IsSupported)
                    try {
                        const e = this._CreateCanvas(1, 1)
                          , t = e.getContext("webgl") || e.getContext("experimental-webgl");
                        this._IsSupported = null != t && !!window.WebGLRenderingContext
                    } catch (e) {
                        this._IsSupported = !1
                    }
                return this._IsSupported
            }
            static get HasMajorPerformanceCaveat() {
                if (null === this._HasMajorPerformanceCaveat)
                    try {
                        const e = this._CreateCanvas(1, 1)
                          , t = e.getContext("webgl", {
                            failIfMajorPerformanceCaveat: !0
                        }) || e.getContext("experimental-webgl", {
                            failIfMajorPerformanceCaveat: !0
                        });
                        this._HasMajorPerformanceCaveat = !t
                    } catch (e) {
                        this._HasMajorPerformanceCaveat = !1
                    }
                return this._HasMajorPerformanceCaveat
            }
            static CeilingPOT(e) {
                return e--,
                e |= e >> 1,
                e |= e >> 2,
                e |= e >> 4,
                e |= e >> 8,
                e |= e >> 16,
                ++e
            }
            static FloorPOT(e) {
                return e |= e >> 1,
                e |= e >> 2,
                e |= e >> 4,
                e |= e >> 8,
                (e |= e >> 16) - (e >> 1)
            }
            static NearestPOT(e) {
                const t = kt.CeilingPOT(e)
                  , i = kt.FloorPOT(e);
                return t - e > e - i ? i : t
            }
            static GetExponentOfTwo(e, t, i=2) {
                let s;
                switch (i) {
                case 1:
                    s = kt.FloorPOT(e);
                    break;
                case 2:
                    s = kt.NearestPOT(e);
                    break;
                default:
                    s = kt.CeilingPOT(e)
                }
                return Math.min(s, t)
            }
            static QueueNewFrame(e, t) {
                if (ke()) {
                    const {requestAnimationFrame: i} = t || window;
                    if ("function" == typeof i)
                        return i(e)
                } else if ("function" == typeof requestAnimationFrame)
                    return requestAnimationFrame(e);
                return setTimeout(e, 16)
            }
            getHostDocument() {
                return this._renderingCanvas && this._renderingCanvas.ownerDocument ? this._renderingCanvas.ownerDocument : Ge() ? document : null
            }
        }
        kt._TempClearColorUint32 = new Uint32Array(4),
        kt._TempClearColorInt32 = new Int32Array(4),
        kt.ExceptionList = [{
            key: "Chrome/63.0",
            capture: "63\\.0\\.3239\\.(\\d+)",
            captureConstraint: 108,
            targets: ["uniformBuffer"]
        }, {
            key: "Firefox/58",
            capture: null,
            captureConstraint: null,
            targets: ["uniformBuffer"]
        }, {
            key: "Firefox/59",
            capture: null,
            captureConstraint: null,
            targets: ["uniformBuffer"]
        }, {
            key: "Chrome/72.+?Mobile",
            capture: null,
            captureConstraint: null,
            targets: ["vao"]
        }, {
            key: "Chrome/73.+?Mobile",
            capture: null,
            captureConstraint: null,
            targets: ["vao"]
        }, {
            key: "Chrome/74.+?Mobile",
            capture: null,
            captureConstraint: null,
            targets: ["vao"]
        }, {
            key: "Mac OS.+Chrome/71",
            capture: null,
            captureConstraint: null,
            targets: ["vao"]
        }, {
            key: "Mac OS.+Chrome/72",
            capture: null,
            captureConstraint: null,
            targets: ["vao"]
        }, {
            key: "Mac OS.+Chrome",
            capture: null,
            captureConstraint: null,
            targets: ["uniformBuffer"]
        }, {
            key: "Chrome/12\\d\\..+?Mobile",
            capture: null,
            captureConstraint: null,
            targets: ["uniformBuffer"]
        }, {
            key: ".*AppleWebKit.*(15.4).*Safari",
            capture: null,
            captureConstraint: null,
            targets: ["antialias", "maxMSAASamples"]
        }, {
            key: ".*(15.4).*AppleWebKit.*Safari",
            capture: null,
            captureConstraint: null,
            targets: ["antialias", "maxMSAASamples"]
        }],
        kt._TextureLoaders = [],
        kt.CollisionsEpsilon = .001,
        kt._IsSupported = null,
        kt._HasMajorPerformanceCaveat = null;
        class Vt {
            static SetImmediate(e) {
                ke() && window.setImmediate ? window.setImmediate(e) : setTimeout(e, 1)
            }
        }
        const Gt = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);
        class zt extends Je {
            constructor(e, t) {
                super(e, 4e3),
                this.name = "LoadFileError",
                $e._setPrototypeOf(this, zt.prototype),
                t instanceof qe ? this.request = t : this.file = t
            }
        }
        class Wt extends Je {
            constructor(e, t) {
                super(e, 4001),
                this.request = t,
                this.name = "RequestFileError",
                $e._setPrototypeOf(this, Wt.prototype)
            }
        }
        class Xt extends Je {
            constructor(e, t) {
                super(e, 4002),
                this.file = t,
                this.name = "ReadFileError",
                $e._setPrototypeOf(this, Xt.prototype)
            }
        }
        const Ht = {
            DefaultRetryStrategy: class {
                static ExponentialBackoff(e=3, t=500) {
                    return (i, s, r) => 0 !== s.status || r >= e || -1 !== i.indexOf("file:") ? -1 : Math.pow(2, r) * t
                }
            }
            .ExponentialBackoff(),
            BaseUrl: "",
            CorsBehavior: "anonymous",
            PreprocessUrl: e => e,
            ScriptBaseUrl: "",
            ScriptPreprocessUrl: e => e
        }
          , Kt = e => e.replace(/#/gm, "%23")
          , Yt = (e, t) => {
            if ((!e || 0 !== e.indexOf("data:")) && Ht.CorsBehavior)
                if ("string" == typeof Ht.CorsBehavior || Ht.CorsBehavior instanceof String)
                    t.crossOrigin = Ht.CorsBehavior;
                else {
                    const i = Ht.CorsBehavior(e);
                    i && (t.crossOrigin = i)
                }
        }
          , jt = (e, t, i, s, r="", n) => {
            const a = Ze.LastCreatedEngine;
            if ("undefined" == typeof HTMLImageElement && !a?._features.forceBitmapOverHTMLImageElement)
                return i("LoadImage is only supported in web or BabylonNative environments."),
                null;
            let o, h = !1;
            e instanceof ArrayBuffer || ArrayBuffer.isView(e) ? "undefined" != typeof Blob && "undefined" != typeof URL ? (o = URL.createObjectURL(new Blob([e],{
                type: r
            })),
            h = !0) : o = `data:${r};base64,` + et(e) : e instanceof Blob ? (o = URL.createObjectURL(e),
            h = !0) : (o = Kt(e),
            o = Ht.PreprocessUrl(e));
            const l = t => {
                if (i) {
                    const s = o || e.toString();
                    i(`Error while trying to load image: ${0 === s.indexOf("http") || s.length <= 128 ? s : s.slice(0, 128) + "..."}`, t)
                }
            }
            ;
            if (a?._features.forceBitmapOverHTMLImageElement)
                return Zt(o, (s => {
                    a.createImageBitmap(new Blob([s],{
                        type: r
                    }), {
                        premultiplyAlpha: "none",
                        ...n
                    }).then((e => {
                        t(e),
                        h && URL.revokeObjectURL(o)
                    }
                    )).catch((t => {
                        i && i("Error while trying to load image: " + e, t)
                    }
                    ))
                }
                ), void 0, s || void 0, !0, ( (e, t) => {
                    l(t)
                }
                )),
                null;
            const c = new Image;
            Yt(o, c);
            const u = []
              , d = () => {
                u.forEach((e => {
                    e.target.removeEventListener(e.name, e.handler)
                }
                )),
                u.length = 0
            }
            ;
            u.push({
                target: c,
                name: "load",
                handler: () => {
                    d(),
                    t(c),
                    h && c.src && URL.revokeObjectURL(c.src)
                }
            }),
            u.push({
                target: c,
                name: "error",
                handler: e => {
                    d(),
                    l(e),
                    h && c.src && URL.revokeObjectURL(c.src)
                }
            }),
            u.push({
                target: document,
                name: "securitypolicyviolation",
                handler: e => {
                    if (e.blockedURI !== c.src)
                        return;
                    d();
                    const t = new Error(`CSP violation of policy ${e.effectiveDirective} ${e.blockedURI}. Current policy is ${e.originalPolicy}`);
                    Ze.UseFallbackTexture = !1,
                    l(t),
                    h && c.src && URL.revokeObjectURL(c.src),
                    c.src = ""
                }
            }),
            u.forEach((e => {
                e.target.addEventListener(e.name, e.handler)
            }
            ));
            const f = "blob:" === o.substring(0, 5)
              , _ = "data:" === o.substring(0, 5)
              , p = () => {
                f || _ || !qe.IsCustomRequestAvailable ? c.src = o : Zt(o, ( (e, t, i) => {
                    const s = new Blob([e],{
                        type: !r && i ? i : r
                    })
                      , n = URL.createObjectURL(s);
                    h = !0,
                    c.src = n
                }
                ), void 0, s || void 0, !0, ( (e, t) => {
                    l(t)
                }
                ))
            }
            ;
            if (!f && !_ && s && s.enableTexturesOffline)
                s.open(( () => {
                    s && s.loadImage(o, c)
                }
                ), p);
            else {
                if (-1 !== o.indexOf("file:")) {
                    const e = decodeURIComponent(o.substring(5).toLowerCase());
                    if (Qe.FilesToLoad[e] && "undefined" != typeof URL) {
                        try {
                            let t;
                            try {
                                t = URL.createObjectURL(Qe.FilesToLoad[e])
                            } catch (i) {
                                t = URL.createObjectURL(Qe.FilesToLoad[e])
                            }
                            c.src = t,
                            h = !0
                        } catch (e) {
                            c.src = ""
                        }
                        return c
                    }
                }
                p()
            }
            return c
        }
          , qt = (e, t, i, s, r) => {
            const n = new FileReader
              , a = {
                onCompleteObservable: new Ue,
                abort: () => n.abort()
            };
            return n.onloadend = () => a.onCompleteObservable.notifyObservers(a),
            r && (n.onerror = () => {
                r(new Xt(`Unable to read ${e.name}`,e))
            }
            ),
            n.onload = e => {
                t(e.target.result)
            }
            ,
            i && (n.onprogress = i),
            s ? n.readAsArrayBuffer(e) : n.readAsText(e),
            a
        }
          , Zt = (e, t, i, s, r, n, a) => {
            if (e.name)
                return qt(e, t, i, r, n ? e => {
                    n(void 0, e)
                }
                : void 0);
            const o = e;
            if (-1 !== o.indexOf("file:")) {
                let e = decodeURIComponent(o.substring(5).toLowerCase());
                0 === e.indexOf("./") && (e = e.substring(2));
                const s = Qe.FilesToLoad[e];
                if (s)
                    return qt(s, t, i, r, n ? e => n(void 0, new zt(e.message,e.file)) : void 0)
            }
            const {match: h, type: l} = ei(o);
            if (h) {
                const e = {
                    onCompleteObservable: new Ue,
                    abort: () => () => {}
                };
                try {
                    const e = r ? ti(o) : ii(o);
                    t(e, void 0, l)
                } catch (e) {
                    n ? n(void 0, e) : We.Error(e.message || "Failed to parse the Data URL")
                }
                return Vt.SetImmediate(( () => {
                    e.onCompleteObservable.notifyObservers(e)
                }
                )),
                e
            }
            return Qt(o, ( (e, i) => {
                t(e, i?.responseURL, i?.getResponseHeader("content-type"))
            }
            ), i, s, r, n ? e => {
                n(e.request, new zt(e.message,e.request))
            }
            : void 0, a)
        }
          , Qt = (e, t, i, s, r, n, a) => {
            e = Kt(e),
            e = Ht.PreprocessUrl(e);
            const o = Ht.BaseUrl + e;
            let h = !1;
            const l = {
                onCompleteObservable: new Ue,
                abort: () => h = !0
            }
              , c = () => {
                let e, s = new qe, c = null;
                const u = () => {
                    s && (i && s.removeEventListener("progress", i),
                    e && s.removeEventListener("readystatechange", e),
                    s.removeEventListener("loadend", d))
                }
                ;
                let d = () => {
                    u(),
                    l.onCompleteObservable.notifyObservers(l),
                    l.onCompleteObservable.clear(),
                    i = void 0,
                    e = null,
                    d = null,
                    n = void 0,
                    a = void 0,
                    t = void 0
                }
                ;
                l.abort = () => {
                    h = !0,
                    d && d(),
                    s && s.readyState !== (XMLHttpRequest.DONE || 4) && s.abort(),
                    null !== c && (clearTimeout(c),
                    c = null),
                    s = null
                }
                ;
                const f = e => {
                    const t = e.message || "Unknown error";
                    n && s ? n(new Wt(t,s)) : We.Error(t)
                }
                  , _ = l => {
                    if (s) {
                        if (s.open("GET", o),
                        a)
                            try {
                                a(s)
                            } catch (e) {
                                return void f(e)
                            }
                        r && (s.responseType = "arraybuffer"),
                        i && s.addEventListener("progress", i),
                        d && s.addEventListener("loadend", d),
                        e = () => {
                            if (!h && s && s.readyState === (XMLHttpRequest.DONE || 4)) {
                                if (e && s.removeEventListener("readystatechange", e),
                                s.status >= 200 && s.status < 300 || 0 === s.status && (!ke() || $t())) {
                                    try {
                                        t && t(r ? s.response : s.responseText, s)
                                    } catch (e) {
                                        f(e)
                                    }
                                    return
                                }
                                const i = Ht.DefaultRetryStrategy;
                                if (i) {
                                    const e = i(o, s, l);
                                    if (-1 !== e)
                                        return u(),
                                        s = new qe,
                                        void (c = setTimeout(( () => _(l + 1)), e))
                                }
                                const a = new Wt("Error status: " + s.status + " " + s.statusText + " - Unable to load " + o,s);
                                n && n(a)
                            }
                        }
                        ,
                        s.addEventListener("readystatechange", e),
                        s.send()
                    }
                }
                ;
                _(0)
            }
            ;
            if (s && s.enableSceneOffline) {
                const a = e => {
                    e && e.status > 400 ? n && n(e) : c()
                }
                  , o = () => {
                    s && s.loadFile(Ht.BaseUrl + e, (e => {
                        !h && t && t(e),
                        l.onCompleteObservable.notifyObservers(l)
                    }
                    ), i ? e => {
                        !h && i && i(e)
                    }
                    : void 0, a, r)
                }
                ;
                s.open(o, a)
            } else
                c();
            return l
        }
          , $t = () => "undefined" != typeof location && "file:" === location.protocol
          , Jt = e => Gt.test(e)
          , ei = e => {
            const t = Gt.exec(e);
            return null === t || 0 === t.length ? {
                match: !1,
                type: ""
            } : {
                match: !0,
                type: t[0].replace("data:", "").replace("base64,", "")
            }
        }
        ;
        function ti(e) {
            return (e => {
                const t = tt(e)
                  , i = t.length
                  , s = new Uint8Array(new ArrayBuffer(i));
                for (let e = 0; e < i; e++)
                    s[e] = t.charCodeAt(e);
                return s.buffer
            }
            )(e.split(",")[1])
        }
        const ii = e => tt(e.split(",")[1]);
        let si;
        kt._FileToolsLoadImage = jt,
        kt._FileToolsLoadFile = Zt,
        yt._FileToolsLoadFile = Zt,
        ( (e, t, i, s, r, n, a, o, h, l) => {
            si = {
                DecodeBase64UrlToBinary: e,
                DecodeBase64UrlToString: t,
                DefaultRetryStrategy: i.DefaultRetryStrategy,
                BaseUrl: i.BaseUrl,
                CorsBehavior: i.CorsBehavior,
                PreprocessUrl: i.PreprocessUrl,
                IsBase64DataUrl: s,
                IsFileURL: r,
                LoadFile: n,
                LoadImage: a,
                ReadFile: o,
                RequestFile: h,
                SetCorsBehavior: l
            },
            Object.defineProperty(si, "DefaultRetryStrategy", {
                get: function() {
                    return i.DefaultRetryStrategy
                },
                set: function(e) {
                    i.DefaultRetryStrategy = e
                }
            }),
            Object.defineProperty(si, "BaseUrl", {
                get: function() {
                    return i.BaseUrl
                },
                set: function(e) {
                    i.BaseUrl = e
                }
            }),
            Object.defineProperty(si, "PreprocessUrl", {
                get: function() {
                    return i.PreprocessUrl
                },
                set: function(e) {
                    i.PreprocessUrl = e
                }
            }),
            Object.defineProperty(si, "CorsBehavior", {
                get: function() {
                    return i.CorsBehavior
                },
                set: function(e) {
                    i.CorsBehavior = e
                }
            })
        }
        )(ti, ii, Ht, Jt, $t, Zt, jt, qt, Qt, Yt);
        class ri {
            static Instantiate(e) {
                if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[e])
                    return this.RegisteredExternalClasses[e];
                const t = Re(e);
                if (t)
                    return t;
                We.Warn(e + " not found, you may have missed an import.");
                const i = e.split(".");
                let s = window || this;
                for (let e = 0, t = i.length; e < t; e++)
                    s = s[i[e]];
                return "function" != typeof s ? null : s
            }
        }
        function ni() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (e => {
                const t = 16 * Math.random() | 0;
                return ("x" === e ? t : 3 & t | 8).toString(16)
            }
            ))
        }
        function ai(e) {
            let t = 1;
            do {
                t *= 2
            } while (t < e);
            return t === e
        }
        function oi(e, t, i) {
            return e * (1 - i) + t * i
        }
        ri.RegisteredExternalClasses = {};
        class hi {
            static get BaseUrl() {
                return Ht.BaseUrl
            }
            static set BaseUrl(e) {
                Ht.BaseUrl = e
            }
            static IsAbsoluteUrl(e) {
                return 0 === e.indexOf("//") || -1 !== e.indexOf("://") && -1 !== e.indexOf(".") && -1 !== e.indexOf("/") && !(e.indexOf(":") > e.indexOf("/")) && (e.indexOf("://") < e.indexOf(".") || 0 === e.indexOf("data:") || 0 === e.indexOf("blob:"))
            }
            static set ScriptBaseUrl(e) {
                Ht.ScriptBaseUrl = e
            }
            static get ScriptBaseUrl() {
                return Ht.ScriptBaseUrl
            }
            static set ScriptPreprocessUrl(e) {
                Ht.ScriptPreprocessUrl = e
            }
            static get ScriptPreprocessUrl() {
                return Ht.ScriptPreprocessUrl
            }
            static get DefaultRetryStrategy() {
                return Ht.DefaultRetryStrategy
            }
            static set DefaultRetryStrategy(e) {
                Ht.DefaultRetryStrategy = e
            }
            static get CorsBehavior() {
                return Ht.CorsBehavior
            }
            static set CorsBehavior(e) {
                Ht.CorsBehavior = e
            }
            static get UseFallbackTexture() {
                return Ze.UseFallbackTexture
            }
            static set UseFallbackTexture(e) {
                Ze.UseFallbackTexture = e
            }
            static get RegisteredExternalClasses() {
                return ri.RegisteredExternalClasses
            }
            static set RegisteredExternalClasses(e) {
                ri.RegisteredExternalClasses = e
            }
            static get fallbackTexture() {
                return Ze.FallbackTexture
            }
            static set fallbackTexture(e) {
                Ze.FallbackTexture = e
            }
            static FetchToRef(e, t, i, s, r, n) {
                const a = 4 * ((Math.abs(e) * i % i | 0) + (Math.abs(t) * s % s | 0) * i);
                n.r = r[a] / 255,
                n.g = r[a + 1] / 255,
                n.b = r[a + 2] / 255,
                n.a = r[a + 3] / 255
            }
            static Mix(e, t, i) {
                return 0
            }
            static Instantiate(e) {
                return ri.Instantiate(e)
            }
            static SetImmediate(e) {
                Vt.SetImmediate(e)
            }
            static IsExponentOfTwo(e) {
                return !0
            }
            static FloatRound(e) {
                return Math.fround(e)
            }
            static GetFilename(e) {
                const t = e.lastIndexOf("/");
                return t < 0 ? e : e.substring(t + 1)
            }
            static GetFolderPath(e, t=!1) {
                const i = e.lastIndexOf("/");
                return i < 0 ? t ? e : "" : e.substring(0, i + 1)
            }
            static ToDegrees(e) {
                return 180 * e / Math.PI
            }
            static ToRadians(e) {
                return e * Math.PI / 180
            }
            static SmoothAngleChange(e, t, i=.9) {
                const s = this.ToRadians(e)
                  , r = this.ToRadians(t);
                return this.ToDegrees(Math.atan2((1 - i) * Math.sin(r) + i * Math.sin(s), (1 - i) * Math.cos(r) + i * Math.cos(s)))
            }
            static MakeArray(e, t) {
                return !0 === t || void 0 !== e && null != e ? Array.isArray(e) ? e : [e] : null
            }
            static GetPointerPrefix(e) {
                let t = "pointer";
                return ke() && !window.PointerEvent && (t = "mouse"),
                !e._badDesktopOS || e._badOS || document && "ontouchend"in document || (t = "mouse"),
                t
            }
            static SetCorsBehavior(e, t) {
                Yt(e, t)
            }
            static SetReferrerPolicyBehavior(e, t) {
                t.referrerPolicy = e
            }
            static CleanUrl(e) {
                return e.replace(/#/gm, "%23")
            }
            static get PreprocessUrl() {
                return Ht.PreprocessUrl
            }
            static set PreprocessUrl(e) {
                Ht.PreprocessUrl = e
            }
            static LoadImage(e, t, i, s, r, n) {
                return jt(e, t, i, s, r, n)
            }
            static LoadFile(e, t, i, s, r, n) {
                return Zt(e, t, i, s, r, n)
            }
            static LoadFileAsync(e, t=!0) {
                return new Promise(( (i, s) => {
                    Zt(e, (e => {
                        i(e)
                    }
                    ), void 0, void 0, t, ( (e, t) => {
                        s(t)
                    }
                    ))
                }
                ))
            }
            static GetBabylonScriptURL(e, t) {
                if (!e)
                    return "";
                if (hi.ScriptBaseUrl && e.startsWith(hi._DefaultCdnUrl)) {
                    const t = "/" === hi.ScriptBaseUrl[hi.ScriptBaseUrl.length - 1] ? hi.ScriptBaseUrl.substring(0, hi.ScriptBaseUrl.length - 1) : hi.ScriptBaseUrl;
                    e = e.replace(hi._DefaultCdnUrl, t)
                }
                return e = hi.ScriptPreprocessUrl(e),
                t && (e = hi.GetAbsoluteUrl(e)),
                e
            }
            static LoadBabylonScript(e, t, i, s) {
                e = hi.GetBabylonScriptURL(e),
                hi.LoadScript(e, t, i)
            }
            static LoadBabylonScriptAsync(e) {
                return e = hi.GetBabylonScriptURL(e),
                hi.LoadScriptAsync(e)
            }
            static LoadScript(e, t, i, s) {
                if ("function" == typeof importScripts) {
                    try {
                        importScripts(e),
                        t()
                    } catch (t) {
                        i?.(`Unable to load script '${e}' in worker`, t)
                    }
                    return
                }
                if (!ke())
                    return void i?.(`Cannot load script '${e}' outside of a window or a worker`);
                const r = document.getElementsByTagName("head")[0]
                  , n = document.createElement("script");
                n.setAttribute("type", "text/javascript"),
                n.setAttribute("src", e),
                s && (n.id = s),
                n.onload = () => {
                    t && t()
                }
                ,
                n.onerror = t => {
                    i && i(`Unable to load script '${e}'`, t)
                }
                ,
                r.appendChild(n)
            }
            static LoadScriptAsync(e, t) {
                return new Promise(( (i, s) => {
                    this.LoadScript(e, ( () => {
                        i()
                    }
                    ), ( (e, t) => {
                        s(t || new Error(e))
                    }
                    ), t)
                }
                ))
            }
            static ReadFileAsDataURL(e, t, i) {
                const s = new FileReader
                  , r = {
                    onCompleteObservable: new Ue,
                    abort: () => s.abort()
                };
                return s.onloadend = () => {
                    r.onCompleteObservable.notifyObservers(r)
                }
                ,
                s.onload = e => {
                    t(e.target.result)
                }
                ,
                s.onprogress = i,
                s.readAsDataURL(e),
                r
            }
            static ReadFile(e, t, i, s, r) {
                return qt(e, t, i, s, r)
            }
            static FileAsURL(e) {
                const t = new Blob([e]);
                return window.URL.createObjectURL(t)
            }
            static Format(e, t=2) {
                return e.toFixed(t)
            }
            static DeepCopy(e, t, i, s) {
                He.DeepCopy(e, t, i, s)
            }
            static IsEmpty(e) {
                for (const t in e)
                    if (Object.prototype.hasOwnProperty.call(e, t))
                        return !1;
                return !0
            }
            static RegisterTopRootEvents(e, t) {
                for (let i = 0; i < t.length; i++) {
                    const s = t[i];
                    e.addEventListener(s.name, s.handler, !1);
                    try {
                        window.parent && window.parent.addEventListener(s.name, s.handler, !1)
                    } catch (e) {}
                }
            }
            static UnregisterTopRootEvents(e, t) {
                for (let i = 0; i < t.length; i++) {
                    const s = t[i];
                    e.removeEventListener(s.name, s.handler);
                    try {
                        e.parent && e.parent.removeEventListener(s.name, s.handler)
                    } catch (e) {}
                }
            }
            static async DumpFramebuffer(e, t, i, s, r="image/png", n, a) {
                throw je("DumpTools")
            }
            static DumpData(e, t, i, s, r="image/png", n, a=!1, o=!1, h) {
                throw je("DumpTools")
            }
            static DumpDataAsync(e, t, i, s="image/png", r, n=!1, a=!1, o) {
                throw je("DumpTools")
            }
            static _IsOffScreenCanvas(e) {
                return void 0 !== e.convertToBlob
            }
            static ToBlob(e, t, i="image/png", s) {
                hi._IsOffScreenCanvas(e) || e.toBlob || (e.toBlob = function(e, t, i) {
                    setTimeout(( () => {
                        const s = atob(this.toDataURL(t, i).split(",")[1])
                          , r = s.length
                          , n = new Uint8Array(r);
                        for (let e = 0; e < r; e++)
                            n[e] = s.charCodeAt(e);
                        e(new Blob([n]))
                    }
                    ))
                }
                ),
                hi._IsOffScreenCanvas(e) ? e.convertToBlob({
                    type: i,
                    quality: s
                }).then((e => t(e))) : e.toBlob((function(e) {
                    t(e)
                }
                ), i, s)
            }
            static DownloadBlob(e, t) {
                if ("download"in document.createElement("a")) {
                    if (!t) {
                        const e = new Date;
                        t = "screenshot_" + (e.getFullYear() + "-" + (e.getMonth() + 1)).slice(2) + "-" + e.getDate() + "_" + e.getHours() + "-" + ("0" + e.getMinutes()).slice(-2) + ".png"
                    }
                    hi.Download(e, t)
                } else if (e && "undefined" != typeof URL) {
                    const t = URL.createObjectURL(e)
                      , i = window.open("");
                    if (!i)
                        return;
                    const s = i.document.createElement("img");
                    s.onload = function() {
                        URL.revokeObjectURL(t)
                    }
                    ,
                    s.src = t,
                    i.document.body.appendChild(s)
                }
            }
            static EncodeScreenshotCanvasData(e, t, i="image/png", s, r) {
                if ("string" != typeof s && t) {
                    if (t) {
                        if (hi._IsOffScreenCanvas(e))
                            return void e.convertToBlob({
                                type: i,
                                quality: r
                            }).then((e => {
                                const i = new FileReader;
                                i.readAsDataURL(e),
                                i.onloadend = () => {
                                    const e = i.result;
                                    t(e)
                                }
                            }
                            ));
                        const s = e.toDataURL(i, r);
                        t(s)
                    }
                } else
                    this.ToBlob(e, (function(e) {
                        e && hi.DownloadBlob(e, s),
                        t && t("")
                    }
                    ), i, r)
            }
            static Download(e, t) {
                if ("undefined" == typeof URL)
                    return;
                const i = window.URL.createObjectURL(e)
                  , s = document.createElement("a");
                document.body.appendChild(s),
                s.style.display = "none",
                s.href = i,
                s.download = t,
                s.addEventListener("click", ( () => {
                    s.parentElement && s.parentElement.removeChild(s)
                }
                )),
                s.click(),
                window.URL.revokeObjectURL(i)
            }
            static BackCompatCameraNoPreventDefault(e) {
                return "boolean" == typeof e[0] ? e[0] : "boolean" == typeof e[1] && e[1]
            }
            static CreateScreenshot(e, t, i, s, r="image/png", n=!1, a) {
                throw je("ScreenshotTools")
            }
            static CreateScreenshotAsync(e, t, i, s="image/png", r) {
                throw je("ScreenshotTools")
            }
            static CreateScreenshotUsingRenderTarget(e, t, i, s, r="image/png", n=1, a=!1, o, h=!1, l=!1, c=!0, u) {
                throw je("ScreenshotTools")
            }
            static CreateScreenshotUsingRenderTargetAsync(e, t, i, s="image/png", r=1, n=!1, a, o=!1, h=!1, l=!0, c) {
                throw je("ScreenshotTools")
            }
            static RandomId() {
                return ni()
            }
            static IsBase64(e) {
                return Jt(e)
            }
            static DecodeBase64(e) {
                return ti(e)
            }
            static get errorsCount() {
                return We.errorsCount
            }
            static Log(e) {
                We.Log(e)
            }
            static Warn(e) {
                We.Warn(e)
            }
            static Error(e) {
                We.Error(e)
            }
            static get LogCache() {
                return We.LogCache
            }
            static ClearLogCache() {
                We.ClearLogCache()
            }
            static set LogLevels(e) {
                We.LogLevels = e
            }
            static set PerformanceLogLevel(e) {
                return (e & hi.PerformanceUserMarkLogLevel) === hi.PerformanceUserMarkLogLevel ? (hi.StartPerformanceCounter = hi._StartUserMark,
                void (hi.EndPerformanceCounter = hi._EndUserMark)) : (e & hi.PerformanceConsoleLogLevel) === hi.PerformanceConsoleLogLevel ? (hi.StartPerformanceCounter = hi._StartPerformanceConsole,
                void (hi.EndPerformanceCounter = hi._EndPerformanceConsole)) : (hi.StartPerformanceCounter = hi._StartPerformanceCounterDisabled,
                void (hi.EndPerformanceCounter = hi._EndPerformanceCounterDisabled))
            }
            static _StartPerformanceCounterDisabled(e, t) {}
            static _EndPerformanceCounterDisabled(e, t) {}
            static _StartUserMark(e, t=!0) {
                if (!hi._Performance) {
                    if (!ke())
                        return;
                    hi._Performance = window.performance
                }
                t && hi._Performance.mark && hi._Performance.mark(e + "-Begin")
            }
            static _EndUserMark(e, t=!0) {
                t && hi._Performance.mark && (hi._Performance.mark(e + "-End"),
                hi._Performance.measure(e, e + "-Begin", e + "-End"))
            }
            static _StartPerformanceConsole(e, t=!0) {
                t && (hi._StartUserMark(e, t),
                console.time && console.time(e))
            }
            static _EndPerformanceConsole(e, t=!0) {
                t && (hi._EndUserMark(e, t),
                console.timeEnd(e))
            }
            static get Now() {
                return Ke.Now
            }
            static GetClassName(e, t=!1) {
                let i = null;
                return !t && e.getClassName ? i = e.getClassName() : (e instanceof Object && (i = (t ? e : Object.getPrototypeOf(e)).constructor.__bjsclassName__),
                i || (i = typeof e)),
                i
            }
            static First(e, t) {
                for (const i of e)
                    if (t(i))
                        return i;
                return null
            }
            static getFullClassName(e, t=!1) {
                let i = null
                  , s = null;
                if (!t && e.getClassName)
                    i = e.getClassName();
                else {
                    if (e instanceof Object) {
                        const r = t ? e : Object.getPrototypeOf(e);
                        i = r.constructor.__bjsclassName__,
                        s = r.constructor.__bjsmoduleName__
                    }
                    i || (i = typeof e)
                }
                return i ? (null != s ? s + "." : "") + i : null
            }
            static DelayAsync(e) {
                return new Promise((t => {
                    setTimeout(( () => {
                        t()
                    }
                    ), e)
                }
                ))
            }
            static IsSafari() {
                return !!Ve() && /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
            }
        }
        hi.UseCustomRequestHeaders = !1,
        hi.CustomRequestHeaders = qe.CustomRequestHeaders,
        hi.GetDOMTextContent = ze,
        hi._DefaultCdnUrl = "https://cdn.babylonjs.com",
        hi.GetAbsoluteUrl = "object" == typeof document ? e => {
            const t = document.createElement("a");
            return t.href = e,
            t.href
        }
        : "function" == typeof URL && "object" == typeof location ? e => new URL(e,location.origin).href : () => {
            throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.")
        }
        ,
        hi.NoneLogLevel = We.NoneLogLevel,
        hi.MessageLogLevel = We.MessageLogLevel,
        hi.WarningLogLevel = We.WarningLogLevel,
        hi.ErrorLogLevel = We.ErrorLogLevel,
        hi.AllLogLevel = We.AllLogLevel,
        hi.IsWindowObjectExist = ke,
        hi.PerformanceNoneLogLevel = 0,
        hi.PerformanceUserMarkLogLevel = 1,
        hi.PerformanceConsoleLogLevel = 2,
        hi.StartPerformanceCounter = hi._StartPerformanceCounterDisabled,
        hi.EndPerformanceCounter = hi._EndPerformanceCounterDisabled;
        class li {
            constructor(e, t, i, s=0) {
                this.iterations = e,
                this.index = s - 1,
                this._done = !1,
                this._fn = t,
                this._successCallback = i
            }
            executeNext() {
                this._done || (this.index + 1 < this.iterations ? (++this.index,
                this._fn(this)) : this.breakLoop())
            }
            breakLoop() {
                this._done = !0,
                this._successCallback()
            }
            static Run(e, t, i, s=0) {
                const r = new li(e,t,i,s);
                return r.executeNext(),
                r
            }
            static SyncAsyncForLoop(e, t, i, s, r, n=0) {
                return li.Run(Math.ceil(e / t), (s => {
                    r && r() ? s.breakLoop() : setTimeout(( () => {
                        for (let n = 0; n < t; ++n) {
                            const a = s.index * t + n;
                            if (a >= e)
                                break;
                            if (i(a),
                            r && r()) {
                                s.breakLoop();
                                break
                            }
                        }
                        s.executeNext()
                    }
                    ), n)
                }
                ), s)
            }
        }
        hi.Mix = oi,
        hi.IsExponentOfTwo = ai,
       Ze.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z"
            class ci {
            static Eval(e, t) {
                return "true" === (e = e.match(/\([^()]*\)/g) ? e.replace(/\([^()]*\)/g, (e => (e = e.slice(1, e.length - 1),
                ci._HandleParenthesisContent(e, t)))) : ci._HandleParenthesisContent(e, t)) || "false" !== e && ci.Eval(e, t)
            }
            static _HandleParenthesisContent(e, t) {
                let i;
                t = t || (e => "true" === e);
                const s = e.split("||");
                for (const e in s)
                    if (Object.prototype.hasOwnProperty.call(s, e)) {
                        let r = ci._SimplifyNegation(s[e].trim());
                        const n = r.split("&&");
                        if (n.length > 1)
                            for (let e = 0; e < n.length; ++e) {
                                const s = ci._SimplifyNegation(n[e].trim());
                                if (i = "true" !== s && "false" !== s ? "!" === s[0] ? !t(s.substring(1)) : t(s) : "true" === s,
                                !i) {
                                    r = "false";
                                    break
                                }
                            }
                        if (i || "true" === r) {
                            i = !0;
                            break
                        }
                        i = "true" !== r && "false" !== r ? "!" === r[0] ? !t(r.substring(1)) : t(r) : "true" === r
                    }
                return i ? "true" : "false"
            }
            static _SimplifyNegation(e) {
                return "!true" === (e = (e = e.replace(/^[\s!]+/, (e => (e = e.replace(/[\s]/g, ( () => ""))).length % 2 ? "!" : ""))).trim()) ? e = "false" : "!false" === e && (e = "true"),
                e
            }
        }
        class ui {
            static EnableFor(e) {
                e._tags = e._tags || {},
                e.hasTags = () => ui.HasTags(e),
                e.addTags = t => ui.AddTagsTo(e, t),
                e.removeTags = t => ui.RemoveTagsFrom(e, t),
                e.matchesTagsQuery = t => ui.MatchesQuery(e, t)
            }
            static DisableFor(e) {
                delete e._tags,
                delete e.hasTags,
                delete e.addTags,
                delete e.removeTags,
                delete e.matchesTagsQuery
            }
            static HasTags(e) {
                if (!e._tags)
                    return !1;
                const t = e._tags;
                for (const e in t)
                    if (Object.prototype.hasOwnProperty.call(t, e))
                        return !0;
                return !1
            }
            static GetTags(e, t=!0) {
                if (!e._tags)
                    return null;
                if (t) {
                    const t = [];
                    for (const i in e._tags)
                        Object.prototype.hasOwnProperty.call(e._tags, i) && !0 === e._tags[i] && t.push(i);
                    return t.join(" ")
                }
                return e._tags
            }
            static AddTagsTo(e, t) {
                t && "string" == typeof t && t.split(" ").forEach((function(t) {
                    ui._AddTagTo(e, t)
                }
                ))
            }
            static _AddTagTo(e, t) {
                "" !== (t = t.trim()) && "true" !== t && "false" !== t && (t.match(/[\s]/) || t.match(/^([!]|([|]|[&]){2})/) || (ui.EnableFor(e),
                e._tags[t] = !0))
            }
            static RemoveTagsFrom(e, t) {
                if (!ui.HasTags(e))
                    return;
                const i = t.split(" ");
                for (const t in i)
                    ui._RemoveTagFrom(e, i[t])
            }
            static _RemoveTagFrom(e, t) {
                delete e._tags[t]
            }
            static MatchesQuery(e, t) {
                return void 0 === t || ("" === t ? ui.HasTags(e) : ci.Eval(t, (t => ui.HasTags(e) && e._tags[t])))
            }
        }
        function di(e, t, i) {
            try {
                const s = e.next();
                s.done ? t(s) : s.value ? s.value.then(( () => {
                    s.value = void 0,
                    t(s)
                }
                ), i) : t(s)
            } catch (e) {
                i(e)
            }
        }
        function fi(e, t, i, s, r) {
            const n = () => {
                let a;
                const o = e => {
                    e.done ? i(e.value) : void 0 === a ? a = !0 : n()
                }
                ;
                do {
                    a = void 0,
                    r && r.aborted ? s(new Error("Aborted")) : t(e, o, s),
                    void 0 === a && (a = !1)
                } while (a)
            }
            ;
            n()
        }
        function _i(e, t) {
            let i;
            return fi(e, di, (e => i = e), (e => {
                throw e
            }
            ), t),
            i
        }
        function pi(e, t, i, s) {
            var r, n = arguments.length, a = n < 3 ? t : null === s ? s = Object.getOwnPropertyDescriptor(t, i) : s;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate)
                a = Reflect.decorate(e, t, i, s);
            else
                for (var o = e.length - 1; o >= 0; o--)
                    (r = e[o]) && (a = (n < 3 ? r(a) : n > 3 ? r(t, i, a) : r(t, i)) || a);
            return n > 3 && a && Object.defineProperty(t, i, a),
            a
        }
        Object.create,
        Object.create;
        const mi = {}
          , gi = {};
        function vi(e) {
            const t = e.getClassName();
            if (mi[t])
                return mi[t];
            mi[t] = {};
            const i = mi[t];
            let s = e
              , r = t;
            for (; r; ) {
                const e = gi[r];
                for (const t in e)
                    i[t] = e[t];
                let t, n = !1;
                do {
                    if (t = Object.getPrototypeOf(s),
                    !t.getClassName) {
                        n = !0;
                        break
                    }
                    if (t.getClassName() !== r)
                        break;
                    s = t
                } while (t);
                if (n)
                    break;
                r = t.getClassName(),
                s = t
            }
            return i
        }
        function yi(e, t) {
            return (i, s) => {
                const r = function(e) {
                    const t = e.getClassName();
                    return gi[t] || (gi[t] = {}),
                    gi[t]
                }(i);
                r[s] || (r[s] = {
                    type: e,
                    sourceName: t
                })
            }
        }
        function bi(e, t=null) {
            return function(e, t=null) {
                return (i, s) => {
                    const r = t || "_" + s;
                    Object.defineProperty(i, s, {
                        get: function() {
                            return this[r]
                        },
                        set: function(t) {
                            "function" == typeof this.equals && this.equals(t) || this[r] !== t && (this[r] = t,
                            i[e].apply(this))
                        },
                        enumerable: !0,
                        configurable: !0
                    })
                }
            }(e, t)
        }
        function xi(e) {
            return yi(0, e)
        }
        function Ti(e) {
            return yi(1, e)
        }
        function Ei(e) {
            return yi(2, e)
        }
        function Mi(e) {
            return yi(3, e)
        }
        function Si(e) {
            return yi(5, e)
        }
        function Ai(e, t, i, s) {
            const r = i.value;
            i.value = (...i) => {
                let n = r;
                if ("undefined" != typeof _native && _native[t]) {
                    const e = _native[t];
                    n = s ? (...t) => s(...t) ? e(...t) : r(...t) : e
                }
                return e[t] = n,
                n(...i)
            }
        }
        Ai.filter = function(e) {
            return (t, i, s) => Ai(t, i, s, e)
        }
        ;
        class Ii {
            constructor(e) {
                this.length = 0,
                this.data = new Array(e),
                this._id = Ii._GlobalId++
            }
            push(e) {
                this.data[this.length++] = e,
                this.length > this.data.length && (this.data.length *= 2)
            }
            forEach(e) {
                for (let t = 0; t < this.length; t++)
                    e(this.data[t])
            }
            sort(e) {
                this.data.sort(e)
            }
            reset() {
                this.length = 0
            }
            dispose() {
                this.reset(),
                this.data && (this.data.length = 0)
            }
            concat(e) {
                if (0 !== e.length) {
                    this.length + e.length > this.data.length && (this.data.length = 2 * (this.length + e.length));
                    for (let t = 0; t < e.length; t++)
                        this.data[this.length++] = (e.data || e)[t]
                }
            }
            indexOf(e) {
                const t = this.data.indexOf(e);
                return t >= this.length ? -1 : t
            }
            contains(e) {
                return -1 !== this.indexOf(e)
            }
        }
        Ii._GlobalId = 0;
        class Ri extends Ii {
            constructor() {
                super(...arguments),
                this._duplicateId = 0
            }
            push(e) {
                super.push(e),
                e.__smartArrayFlags || (e.__smartArrayFlags = {}),
                e.__smartArrayFlags[this._id] = this._duplicateId
            }
            pushNoDuplicate(e) {
                return !(e.__smartArrayFlags && e.__smartArrayFlags[this._id] === this._duplicateId || (this.push(e),
                0))
            }
            reset() {
                super.reset(),
                this._duplicateId++
            }
            concatWithNoDuplicate(e) {
                if (0 !== e.length) {
                    this.length + e.length > this.data.length && (this.data.length = 2 * (this.length + e.length));
                    for (let t = 0; t < e.length; t++) {
                        const i = (e.data || e)[t];
                        this.pushNoDuplicate(i)
                    }
                }
            }
        }
        const Ci = e => parseInt(e.toString().replace(/\W/g, ""));
        class Pi {
            constructor(e=0, t=0) {
                this.x = e,
                this.y = t
            }
            toString() {
                return `{X: ${this.x} Y: ${this.y}}`
            }
            getClassName() {
                return "Vector2"
            }
            getHashCode() {
                let e = Ci(this.x);
                return e = 397 * e ^ Ci(this.y),
                e
            }
            toArray(e, t=0) {
                return e[t] = this.x,
                e[t + 1] = this.y,
                this
            }
            fromArray(e, t=0) {
                return Pi.FromArrayToRef(e, t, this),
                this
            }
            asArray() {
                return [this.x, this.y]
            }
            copyFrom(e) {
                return this.x = e.x,
                this.y = e.y,
                this
            }
            copyFromFloats(e, t) {
                return this.x = e,
                this.y = t,
                this
            }
            set(e, t) {
                return this.copyFromFloats(e, t)
            }
            setAll(e) {
                return this.copyFromFloats(e, e)
            }
            add(e) {
                return new this.constructor(this.x + e.x,this.y + e.y)
            }
            addToRef(e, t) {
                return t.x = this.x + e.x,
                t.y = this.y + e.y,
                t
            }
            addInPlace(e) {
                return this.x += e.x,
                this.y += e.y,
                this
            }
            addInPlaceFromFloats(e, t) {
                return this.x += e,
                this.y += t,
                this
            }
            addVector3(e) {
                return new this.constructor(this.x + e.x,this.y + e.y)
            }
            subtract(e) {
                return new this.constructor(this.x - e.x,this.y - e.y)
            }
            subtractToRef(e, t) {
                return t.x = this.x - e.x,
                t.y = this.y - e.y,
                t
            }
            subtractInPlace(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this
            }
            multiplyInPlace(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this
            }
            multiply(e) {
                return new this.constructor(this.x * e.x,this.y * e.y)
            }
            multiplyToRef(e, t) {
                return t.x = this.x * e.x,
                t.y = this.y * e.y,
                t
            }
            multiplyByFloats(e, t) {
                return new this.constructor(this.x * e,this.y * t)
            }
            divide(e) {
                return new this.constructor(this.x / e.x,this.y / e.y)
            }
            divideToRef(e, t) {
                return t.x = this.x / e.x,
                t.y = this.y / e.y,
                t
            }
            divideInPlace(e) {
                return this.x = this.x / e.x,
                this.y = this.y / e.y,
                this
            }
            minimizeInPlace(e) {
                return this.minimizeInPlaceFromFloats(e.x, e.y)
            }
            maximizeInPlace(e) {
                return this.maximizeInPlaceFromFloats(e.x, e.y)
            }
            minimizeInPlaceFromFloats(e, t) {
                return this.x = Math.min(e, this.x),
                this.y = Math.min(t, this.y),
                this
            }
            maximizeInPlaceFromFloats(e, t) {
                return this.x = Math.max(e, this.x),
                this.y = Math.max(t, this.y),
                this
            }
            subtractFromFloats(e, t) {
                return new this.constructor(this.x - e,this.y - t)
            }
            subtractFromFloatsToRef(e, t, i) {
                return i.copyFromFloats(this.x - e, this.y - t)
            }
            negate() {
                return new this.constructor(-this.x,-this.y)
            }
            negateInPlace() {
                return this.x *= -1,
                this.y *= -1,
                this
            }
            negateToRef(e) {
                return e.copyFromFloats(-1 * this.x, -1 * this.y)
            }
            scaleInPlace(e) {
                return this.x *= e,
                this.y *= e,
                this
            }
            scale(e) {
                return new this.constructor(this.x * e,this.y * e)
            }
            scaleToRef(e, t) {
                return t.x = this.x * e,
                t.y = this.y * e,
                t
            }
            scaleAndAddToRef(e, t) {
                return t.x += this.x * e,
                t.y += this.y * e,
                t
            }
            equals(e) {
                return e && this.x === e.x && this.y === e.y
            }
            equalsWithEpsilon(e, t=.001) {
                return e && pe(this.x, e.x, t) && pe(this.y, e.y, t)
            }
            equalsToFloats(e, t) {
                return this.x === e && this.y === t
            }
            floor() {
                return new this.constructor(Math.floor(this.x),Math.floor(this.y))
            }
            floorToRef(e) {
                return e.x = Math.floor(this.x),
                e.y = Math.floor(this.y),
                e
            }
            fract() {
                return new this.constructor(this.x - Math.floor(this.x),this.y - Math.floor(this.y))
            }
            fractToRef(e) {
                return e.x = this.x - Math.floor(this.x),
                e.y = this.y - Math.floor(this.y),
                e
            }
            rotateToRef(e, t) {
                const i = Math.cos(e)
                  , s = Math.sin(e)
                  , r = i * this.x - s * this.y
                  , n = s * this.x + i * this.y;
                return t.x = r,
                t.y = n,
                t
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y)
            }
            lengthSquared() {
                return this.x * this.x + this.y * this.y
            }
            normalize() {
                return this.normalizeFromLength(this.length())
            }
            normalizeFromLength(e) {
                return 0 === e || 1 === e ? this : this.scaleInPlace(1 / e)
            }
            normalizeToNew() {
                const e = new this.constructor;
                return this.normalizeToRef(e),
                e
            }
            normalizeToRef(e) {
                const t = this.length();
                return 0 === t ? e.copyFrom(this) : this.scaleToRef(1 / t, e)
            }
            clone() {
                return new this.constructor(this.x,this.y)
            }
            dot(e) {
                return this.x * e.x + this.y * e.y
            }
            static Zero() {
                return new Pi(0,0)
            }
            static One() {
                return new Pi(1,1)
            }
            static Random(e=0, t=1) {
                return new Pi(me(e, t),me(e, t))
            }
            static RandomToRef(e=0, t=1, i) {
                return i.copyFromFloats(me(e, t), me(e, t))
            }
            static get ZeroReadOnly() {
                return Pi._ZeroReadOnly
            }
            static FromArray(e, t=0) {
                return new Pi(e[t],e[t + 1])
            }
            static FromArrayToRef(e, t, i) {
                return i.x = e[t],
                i.y = e[t + 1],
                i
            }
            static FromFloatsToRef(e, t, i) {
                return i.copyFromFloats(e, t),
                i
            }
            static CatmullRom(e, t, i, s, r) {
                const n = r * r
                  , a = r * n
                  , o = .5 * (2 * t.x + (-e.x + i.x) * r + (2 * e.x - 5 * t.x + 4 * i.x - s.x) * n + (-e.x + 3 * t.x - 3 * i.x + s.x) * a)
                  , h = .5 * (2 * t.y + (-e.y + i.y) * r + (2 * e.y - 5 * t.y + 4 * i.y - s.y) * n + (-e.y + 3 * t.y - 3 * i.y + s.y) * a);
                return new e.constructor(o,h)
            }
            static ClampToRef(e, t, i, s) {
                return s.x = ve(e.x, t.x, i.x),
                s.y = ve(e.y, t.y, i.y),
                s
            }
            static Clamp(e, t, i) {
                const s = ve(e.x, t.x, i.x)
                  , r = ve(e.y, t.y, i.y);
                return new e.constructor(s,r)
            }
            static Hermite(e, t, i, s, r) {
                const n = r * r
                  , a = r * n
                  , o = 2 * a - 3 * n + 1
                  , h = -2 * a + 3 * n
                  , l = a - 2 * n + r
                  , c = a - n
                  , u = e.x * o + i.x * h + t.x * l + s.x * c
                  , d = e.y * o + i.y * h + t.y * l + s.y * c;
                return new e.constructor(u,d)
            }
            static Hermite1stDerivative(e, t, i, s, r) {
                const n = new e.constructor;
                return this.Hermite1stDerivativeToRef(e, t, i, s, r, n),
                n
            }
            static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
                const a = r * r;
                return n.x = 6 * (a - r) * e.x + (3 * a - 4 * r + 1) * t.x + 6 * (-a + r) * i.x + (3 * a - 2 * r) * s.x,
                n.y = 6 * (a - r) * e.y + (3 * a - 4 * r + 1) * t.y + 6 * (-a + r) * i.y + (3 * a - 2 * r) * s.y,
                n
            }
            static Lerp(e, t, i) {
                const s = e.x + (t.x - e.x) * i
                  , r = e.y + (t.y - e.y) * i;
                return new e.constructor(s,r)
            }
            static Dot(e, t) {
                return e.x * t.x + e.y * t.y
            }
            static Normalize(e) {
                const t = new e.constructor;
                return Pi.NormalizeToRef(e, t),
                t
            }
            static NormalizeToRef(e, t) {
                return e.normalizeToRef(t),
                t
            }
            static Minimize(e, t) {
                const i = e.x < t.x ? e.x : t.x
                  , s = e.y < t.y ? e.y : t.y;
                return new e.constructor(i,s)
            }
            static Maximize(e, t) {
                const i = e.x > t.x ? e.x : t.x
                  , s = e.y > t.y ? e.y : t.y;
                return new e.constructor(i,s)
            }
            static Transform(e, t) {
                const i = new e.constructor;
                return Pi.TransformToRef(e, t, i),
                i
            }
            static TransformToRef(e, t, i) {
                const s = t.m
                  , r = e.x * s[0] + e.y * s[4] + s[12]
                  , n = e.x * s[1] + e.y * s[5] + s[13];
                return i.x = r,
                i.y = n,
                i
            }
            static PointInTriangle(e, t, i, s) {
                const r = .5 * (-i.y * s.x + t.y * (-i.x + s.x) + t.x * (i.y - s.y) + i.x * s.y)
                  , n = r < 0 ? -1 : 1
                  , a = (t.y * s.x - t.x * s.y + (s.y - t.y) * e.x + (t.x - s.x) * e.y) * n
                  , o = (t.x * i.y - t.y * i.x + (t.y - i.y) * e.x + (i.x - t.x) * e.y) * n;
                return a > 0 && o > 0 && a + o < 2 * r * n
            }
            static Distance(e, t) {
                return Math.sqrt(Pi.DistanceSquared(e, t))
            }
            static DistanceSquared(e, t) {
                const i = e.x - t.x
                  , s = e.y - t.y;
                return i * i + s * s
            }
            static Center(e, t) {
                const i = new e.constructor;
                return Pi.CenterToRef(e, t, i)
            }
            static CenterToRef(e, t, i) {
                return i.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2)
            }
            static DistanceOfPointFromSegment(e, t, i) {
                const s = Pi.DistanceSquared(t, i);
                if (0 === s)
                    return Pi.Distance(e, t);
                const r = i.subtract(t)
                  , n = Math.max(0, Math.min(1, Pi.Dot(e.subtract(t), r) / s))
                  , a = t.add(r.multiplyByFloats(n, n));
                return Pi.Distance(e, a)
            }
        }
        Pi._ZeroReadOnly = Pi.Zero(),
        Object.defineProperties(Pi.prototype, {
            dimension: {
                value: [2]
            },
            rank: {
                value: 1
            }
        });
        class Di {
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e,
                this._isDirty = !0
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e,
                this._isDirty = !0
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e,
                this._isDirty = !0
            }
            constructor(e=0, t=0, i=0) {
                this._isDirty = !0,
                this._x = e,
                this._y = t,
                this._z = i
            }
            toString() {
                return `{X: ${this._x} Y: ${this._y} Z: ${this._z}}`
            }
            getClassName() {
                return "Vector3"
            }
            getHashCode() {
                let e = Ci(this._x);
                return e = 397 * e ^ Ci(this._y),
                e = 397 * e ^ Ci(this._z),
                e
            }
            asArray() {
                return [this._x, this._y, this._z]
            }
            toArray(e, t=0) {
                return e[t] = this._x,
                e[t + 1] = this._y,
                e[t + 2] = this._z,
                this
            }
            fromArray(e, t=0) {
                return Di.FromArrayToRef(e, t, this),
                this
            }
            toQuaternion() {
                return Fi.RotationYawPitchRoll(this._y, this._x, this._z)
            }
            addInPlace(e) {
                return this._x += e._x,
                this._y += e._y,
                this._z += e._z,
                this._isDirty = !0,
                this
            }
            addInPlaceFromFloats(e, t, i) {
                return this._x += e,
                this._y += t,
                this._z += i,
                this._isDirty = !0,
                this
            }
            add(e) {
                return new this.constructor(this._x + e._x,this._y + e._y,this._z + e._z)
            }
            addToRef(e, t) {
                return t.copyFromFloats(this._x + e._x, this._y + e._y, this._z + e._z)
            }
            subtractInPlace(e) {
                return this._x -= e._x,
                this._y -= e._y,
                this._z -= e._z,
                this._isDirty = !0,
                this
            }
            subtract(e) {
                return new this.constructor(this._x - e._x,this._y - e._y,this._z - e._z)
            }
            subtractToRef(e, t) {
                return this.subtractFromFloatsToRef(e._x, e._y, e._z, t)
            }
            subtractFromFloats(e, t, i) {
                return new this.constructor(this._x - e,this._y - t,this._z - i)
            }
            subtractFromFloatsToRef(e, t, i, s) {
                return s.copyFromFloats(this._x - e, this._y - t, this._z - i)
            }
            negate() {
                return new this.constructor(-this._x,-this._y,-this._z)
            }
            negateInPlace() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._isDirty = !0,
                this
            }
            negateToRef(e) {
                return e.copyFromFloats(-1 * this._x, -1 * this._y, -1 * this._z)
            }
            scaleInPlace(e) {
                return this._x *= e,
                this._y *= e,
                this._z *= e,
                this._isDirty = !0,
                this
            }
            scale(e) {
                return new this.constructor(this._x * e,this._y * e,this._z * e)
            }
            scaleToRef(e, t) {
                return t.copyFromFloats(this._x * e, this._y * e, this._z * e)
            }
            getNormalToRef(e) {
                const t = this.length();
                let i = Math.acos(this.y / t);
                const s = Math.atan2(this.z, this.x);
                i > Math.PI / 2 ? i -= Math.PI / 2 : i += Math.PI / 2;
                const r = t * Math.sin(i) * Math.cos(s)
                  , n = t * Math.cos(i)
                  , a = t * Math.sin(i) * Math.sin(s);
                return e.set(r, n, a),
                e
            }
            applyRotationQuaternionToRef(e, t) {
                const i = this._x
                  , s = this._y
                  , r = this._z
                  , n = e._x
                  , a = e._y
                  , o = e._z
                  , h = e._w
                  , l = 2 * (a * r - o * s)
                  , c = 2 * (o * i - n * r)
                  , u = 2 * (n * s - a * i);
                return t._x = i + h * l + a * u - o * c,
                t._y = s + h * c + o * l - n * u,
                t._z = r + h * u + n * c - a * l,
                t._isDirty = !0,
                t
            }
            applyRotationQuaternionInPlace(e) {
                return this.applyRotationQuaternionToRef(e, this)
            }
            applyRotationQuaternion(e) {
                return this.applyRotationQuaternionToRef(e, new this.constructor)
            }
            scaleAndAddToRef(e, t) {
                return t.addInPlaceFromFloats(this._x * e, this._y * e, this._z * e)
            }
            projectOnPlane(e, t) {
                const i = new this.constructor;
                return this.projectOnPlaneToRef(e, t, i),
                i
            }
            projectOnPlaneToRef(e, t, i) {
                const s = e.normal
                  , r = e.d
                  , n = Li.Vector3[0];
                this.subtractToRef(t, n),
                n.normalize();
                const a = Di.Dot(n, s);
                if (Math.abs(a) < 1e-10)
                    i.setAll(1 / 0);
                else {
                    const e = -(Di.Dot(t, s) + r) / a
                      , o = n.scaleInPlace(e);
                    t.addToRef(o, i)
                }
                return i
            }
            equals(e) {
                return e && this._x === e._x && this._y === e._y && this._z === e._z
            }
            equalsWithEpsilon(e, t=.001) {
                return e && pe(this._x, e._x, t) && pe(this._y, e._y, t) && pe(this._z, e._z, t)
            }
            equalsToFloats(e, t, i) {
                return this._x === e && this._y === t && this._z === i
            }
            multiplyInPlace(e) {
                return this._x *= e._x,
                this._y *= e._y,
                this._z *= e._z,
                this._isDirty = !0,
                this
            }
            multiply(e) {
                return this.multiplyByFloats(e._x, e._y, e._z)
            }
            multiplyToRef(e, t) {
                return t.copyFromFloats(this._x * e._x, this._y * e._y, this._z * e._z)
            }
            multiplyByFloats(e, t, i) {
                return new this.constructor(this._x * e,this._y * t,this._z * i)
            }
            divide(e) {
                return new this.constructor(this._x / e._x,this._y / e._y,this._z / e._z)
            }
            divideToRef(e, t) {
                return t.copyFromFloats(this._x / e._x, this._y / e._y, this._z / e._z)
            }
            divideInPlace(e) {
                return this._x = this._x / e._x,
                this._y = this._y / e._y,
                this._z = this._z / e._z,
                this._isDirty = !0,
                this
            }
            minimizeInPlace(e) {
                return this.minimizeInPlaceFromFloats(e._x, e._y, e._z)
            }
            maximizeInPlace(e) {
                return this.maximizeInPlaceFromFloats(e._x, e._y, e._z)
            }
            minimizeInPlaceFromFloats(e, t, i) {
                return e < this._x && (this.x = e),
                t < this._y && (this.y = t),
                i < this._z && (this.z = i),
                this
            }
            maximizeInPlaceFromFloats(e, t, i) {
                return e > this._x && (this.x = e),
                t > this._y && (this.y = t),
                i > this._z && (this.z = i),
                this
            }
            isNonUniformWithinEpsilon(e) {
                const t = Math.abs(this._x)
                  , i = Math.abs(this._y);
                if (!pe(t, i, e))
                    return !0;
                const s = Math.abs(this._z);
                return !pe(t, s, e) || !pe(i, s, e)
            }
            get isNonUniform() {
                const e = Math.abs(this._x);
                return e !== Math.abs(this._y) || e !== Math.abs(this._z)
            }
            floorToRef(e) {
                return e._x = Math.floor(this._x),
                e._y = Math.floor(this._y),
                e._z = Math.floor(this._z),
                e._isDirty = !0,
                e
            }
            floor() {
                return new this.constructor(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z))
            }
            fractToRef(e) {
                return e._x = this.x - Math.floor(this._x),
                e._y = this.y - Math.floor(this._y),
                e._z = this.z - Math.floor(this._z),
                e._isDirty = !0,
                e
            }
            fract() {
                return new this.constructor(this.x - Math.floor(this._x),this.y - Math.floor(this._y),this.z - Math.floor(this._z))
            }
            length() {
                return Math.sqrt(this.lengthSquared())
            }
            lengthSquared() {
                return this._x * this._x + this._y * this._y + this._z * this._z
            }
            get hasAZeroComponent() {
                return this._x * this._y * this._z == 0
            }
            normalize() {
                return this.normalizeFromLength(this.length())
            }
            reorderInPlace(e) {
                if ("xyz" === (e = e.toLowerCase()))
                    return this;
                const t = Li.Vector3[0].copyFrom(this);
                return this.x = t[e[0]],
                this.y = t[e[1]],
                this.z = t[e[2]],
                this
            }
            rotateByQuaternionToRef(e, t) {
                return e.toRotationMatrix(Li.Matrix[0]),
                Di.TransformCoordinatesToRef(this, Li.Matrix[0], t),
                t
            }
            rotateByQuaternionAroundPointToRef(e, t, i) {
                return this.subtractToRef(t, Li.Vector3[0]),
                Li.Vector3[0].rotateByQuaternionToRef(e, Li.Vector3[0]),
                t.addToRef(Li.Vector3[0], i),
                i
            }
            cross(e) {
                const t = new this.constructor;
                return Di.CrossToRef(this, e, t)
            }
            normalizeFromLength(e) {
                return 0 === e || 1 === e ? this : this.scaleInPlace(1 / e)
            }
            normalizeToNew() {
                const e = new this.constructor(0,0,0);
                return this.normalizeToRef(e),
                e
            }
            normalizeToRef(e) {
                const t = this.length();
                return 0 === t || 1 === t ? e.copyFrom(this) : this.scaleToRef(1 / t, e)
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z)
            }
            copyFrom(e) {
                return this.copyFromFloats(e._x, e._y, e._z)
            }
            copyFromFloats(e, t, i) {
                return this._x = e,
                this._y = t,
                this._z = i,
                this._isDirty = !0,
                this
            }
            set(e, t, i) {
                return this.copyFromFloats(e, t, i)
            }
            setAll(e) {
                return this._x = this._y = this._z = e,
                this._isDirty = !0,
                this
            }
            static GetClipFactor(e, t, i, s) {
                const r = Di.Dot(e, i);
                return (r - s) / (r - Di.Dot(t, i))
            }
            static GetAngleBetweenVectors(e, t, i) {
                const s = e.normalizeToRef(Li.Vector3[1])
                  , r = t.normalizeToRef(Li.Vector3[2]);
                let n = Di.Dot(s, r);
                n = ve(n, -1, 1);
                const a = Math.acos(n)
                  , o = Li.Vector3[3];
                return Di.CrossToRef(s, r, o),
                Di.Dot(o, i) > 0 ? isNaN(a) ? 0 : a : isNaN(a) ? -Math.PI : -Math.acos(n)
            }
            static GetAngleBetweenVectorsOnPlane(e, t, i) {
                Li.Vector3[0].copyFrom(e);
                const s = Li.Vector3[0];
                Li.Vector3[1].copyFrom(t);
                const r = Li.Vector3[1];
                Li.Vector3[2].copyFrom(i);
                const n = Li.Vector3[2]
                  , a = Li.Vector3[3]
                  , o = Li.Vector3[4];
                return s.normalize(),
                r.normalize(),
                n.normalize(),
                Di.CrossToRef(n, s, a),
                Di.CrossToRef(a, n, o),
                ye(Math.atan2(Di.Dot(r, a), Di.Dot(r, o)))
            }
            static PitchYawRollToMoveBetweenPointsToRef(e, t, i) {
                const s = Bi.Vector3[0];
                return t.subtractToRef(e, s),
                i._y = Math.atan2(s.x, s.z) || 0,
                i._x = Math.atan2(Math.sqrt(s.x ** 2 + s.z ** 2), s.y) || 0,
                i._z = 0,
                i._isDirty = !0,
                i
            }
            static PitchYawRollToMoveBetweenPoints(e, t) {
                const i = Di.Zero();
                return Di.PitchYawRollToMoveBetweenPointsToRef(e, t, i)
            }
            static SlerpToRef(e, t, i, s) {
                i = ve(i, 0, 1);
                const r = Li.Vector3[0]
                  , n = Li.Vector3[1];
                r.copyFrom(e);
                const a = r.length();
                r.normalizeFromLength(a),
                n.copyFrom(t);
                const o = n.length();
                n.normalizeFromLength(o);
                const h = Di.Dot(r, n);
                let l, c;
                if (h < .999) {
                    const e = Math.acos(h)
                      , t = 1 / Math.sin(e);
                    l = Math.sin((1 - i) * e) * t,
                    c = Math.sin(i * e) * t
                } else
                    l = 1 - i,
                    c = i;
                return r.scaleInPlace(l),
                n.scaleInPlace(c),
                s.copyFrom(r).addInPlace(n),
                s.scaleInPlace(ge(a, o, i)),
                s
            }
            static SmoothToRef(e, t, i, s, r) {
                return Di.SlerpToRef(e, t, 0 === s ? 1 : i / s, r),
                r
            }
            static FromArray(e, t=0) {
                return new Di(e[t],e[t + 1],e[t + 2])
            }
            static FromFloatArray(e, t) {
                return Di.FromArray(e, t)
            }
            static FromArrayToRef(e, t, i) {
                return i._x = e[t],
                i._y = e[t + 1],
                i._z = e[t + 2],
                i._isDirty = !0,
                i
            }
            static FromFloatArrayToRef(e, t, i) {
                return Di.FromArrayToRef(e, t, i)
            }
            static FromFloatsToRef(e, t, i, s) {
                return s.copyFromFloats(e, t, i),
                s
            }
            static Zero() {
                return new Di(0,0,0)
            }
            static One() {
                return new Di(1,1,1)
            }
            static Up() {
                return new Di(0,1,0)
            }
            static get UpReadOnly() {
                return Di._UpReadOnly
            }
            static get DownReadOnly() {
                return Di._DownReadOnly
            }
            static get RightReadOnly() {
                return Di._RightReadOnly
            }
            static get LeftReadOnly() {
                return Di._LeftReadOnly
            }
            static get LeftHandedForwardReadOnly() {
                return Di._LeftHandedForwardReadOnly
            }
            static get RightHandedForwardReadOnly() {
                return Di._RightHandedForwardReadOnly
            }
            static get LeftHandedBackwardReadOnly() {
                return Di._LeftHandedBackwardReadOnly
            }
            static get RightHandedBackwardReadOnly() {
                return Di._RightHandedBackwardReadOnly
            }
            static get ZeroReadOnly() {
                return Di._ZeroReadOnly
            }
            static get OneReadOnly() {
                return Di._OneReadOnly
            }
            static Down() {
                return new Di(0,-1,0)
            }
            static Forward(e=!1) {
                return new Di(0,0,e ? -1 : 1)
            }
            static Backward(e=!1) {
                return new Di(0,0,e ? 1 : -1)
            }
            static Right() {
                return new Di(1,0,0)
            }
            static Left() {
                return new Di(-1,0,0)
            }
            static Random(e=0, t=1) {
                return new Di(me(e, t),me(e, t),me(e, t))
            }
            static RandomToRef(e=0, t=1, i) {
                return i.copyFromFloats(me(e, t), me(e, t), me(e, t))
            }
            static TransformCoordinates(e, t) {
                const i = Di.Zero();
                return Di.TransformCoordinatesToRef(e, t, i),
                i
            }
            static TransformCoordinatesToRef(e, t, i) {
                return Di.TransformCoordinatesFromFloatsToRef(e._x, e._y, e._z, t, i),
                i
            }
            static TransformCoordinatesFromFloatsToRef(e, t, i, s, r) {
                const n = s.m
                  , a = e * n[0] + t * n[4] + i * n[8] + n[12]
                  , o = e * n[1] + t * n[5] + i * n[9] + n[13]
                  , h = e * n[2] + t * n[6] + i * n[10] + n[14]
                  , l = 1 / (e * n[3] + t * n[7] + i * n[11] + n[15]);
                return r._x = a * l,
                r._y = o * l,
                r._z = h * l,
                r._isDirty = !0,
                r
            }
            static TransformNormal(e, t) {
                const i = Di.Zero();
                return Di.TransformNormalToRef(e, t, i),
                i
            }
            static TransformNormalToRef(e, t, i) {
                return this.TransformNormalFromFloatsToRef(e._x, e._y, e._z, t, i),
                i
            }
            static TransformNormalFromFloatsToRef(e, t, i, s, r) {
                const n = s.m;
                return r._x = e * n[0] + t * n[4] + i * n[8],
                r._y = e * n[1] + t * n[5] + i * n[9],
                r._z = e * n[2] + t * n[6] + i * n[10],
                r._isDirty = !0,
                r
            }
            static CatmullRom(e, t, i, s, r) {
                const n = r * r
                  , a = r * n
                  , o = .5 * (2 * t._x + (-e._x + i._x) * r + (2 * e._x - 5 * t._x + 4 * i._x - s._x) * n + (-e._x + 3 * t._x - 3 * i._x + s._x) * a)
                  , h = .5 * (2 * t._y + (-e._y + i._y) * r + (2 * e._y - 5 * t._y + 4 * i._y - s._y) * n + (-e._y + 3 * t._y - 3 * i._y + s._y) * a)
                  , l = .5 * (2 * t._z + (-e._z + i._z) * r + (2 * e._z - 5 * t._z + 4 * i._z - s._z) * n + (-e._z + 3 * t._z - 3 * i._z + s._z) * a);
                return new e.constructor(o,h,l)
            }
            static Clamp(e, t, i) {
                const s = new e.constructor;
                return Di.ClampToRef(e, t, i, s),
                s
            }
            static ClampToRef(e, t, i, s) {
                let r = e._x;
                r = r > i._x ? i._x : r,
                r = r < t._x ? t._x : r;
                let n = e._y;
                n = n > i._y ? i._y : n,
                n = n < t._y ? t._y : n;
                let a = e._z;
                return a = a > i._z ? i._z : a,
                a = a < t._z ? t._z : a,
                s.copyFromFloats(r, n, a),
                s
            }
            static CheckExtends(e, t, i) {
                t.minimizeInPlace(e),
                i.maximizeInPlace(e)
            }
            static Hermite(e, t, i, s, r) {
                const n = r * r
                  , a = r * n
                  , o = 2 * a - 3 * n + 1
                  , h = -2 * a + 3 * n
                  , l = a - 2 * n + r
                  , c = a - n
                  , u = e._x * o + i._x * h + t._x * l + s._x * c
                  , d = e._y * o + i._y * h + t._y * l + s._y * c
                  , f = e._z * o + i._z * h + t._z * l + s._z * c;
                return new e.constructor(u,d,f)
            }
            static Hermite1stDerivative(e, t, i, s, r) {
                const n = new e.constructor;
                return this.Hermite1stDerivativeToRef(e, t, i, s, r, n),
                n
            }
            static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
                const a = r * r;
                return n._x = 6 * (a - r) * e._x + (3 * a - 4 * r + 1) * t._x + 6 * (-a + r) * i._x + (3 * a - 2 * r) * s._x,
                n._y = 6 * (a - r) * e._y + (3 * a - 4 * r + 1) * t._y + 6 * (-a + r) * i._y + (3 * a - 2 * r) * s._y,
                n._z = 6 * (a - r) * e._z + (3 * a - 4 * r + 1) * t._z + 6 * (-a + r) * i._z + (3 * a - 2 * r) * s._z,
                n._isDirty = !0,
                n
            }
            static Lerp(e, t, i) {
                const s = new e.constructor(0,0,0);
                return Di.LerpToRef(e, t, i, s),
                s
            }
            static LerpToRef(e, t, i, s) {
                return s._x = e._x + (t._x - e._x) * i,
                s._y = e._y + (t._y - e._y) * i,
                s._z = e._z + (t._z - e._z) * i,
                s._isDirty = !0,
                s
            }
            static Dot(e, t) {
                return e._x * t._x + e._y * t._y + e._z * t._z
            }
            dot(e) {
                return this._x * e._x + this._y * e._y + this._z * e._z
            }
            static Cross(e, t) {
                const i = new e.constructor;
                return Di.CrossToRef(e, t, i),
                i
            }
            static CrossToRef(e, t, i) {
                const s = e._y * t._z - e._z * t._y
                  , r = e._z * t._x - e._x * t._z
                  , n = e._x * t._y - e._y * t._x;
                return i.copyFromFloats(s, r, n),
                i
            }
            static Normalize(e) {
                const t = Di.Zero();
                return Di.NormalizeToRef(e, t),
                t
            }
            static NormalizeToRef(e, t) {
                return e.normalizeToRef(t),
                t
            }
            static Project(e, t, i, s) {
                const r = new e.constructor;
                return Di.ProjectToRef(e, t, i, s, r),
                r
            }
            static ProjectToRef(e, t, i, s, r) {
                const n = s.width
                  , a = s.height
                  , o = s.x
                  , h = s.y
                  , l = Li.Matrix[1];
                Oi.FromValuesToRef(n / 2, 0, 0, 0, 0, -a / 2, 0, 0, 0, 0, .5, 0, o + n / 2, a / 2 + h, .5, 1, l);
                const c = Li.Matrix[0];
                return t.multiplyToRef(i, c),
                c.multiplyToRef(l, c),
                Di.TransformCoordinatesToRef(e, c, r),
                r
            }
            static Reflect(e, t) {
                return this.ReflectToRef(e, t, new Di)
            }
            static ReflectToRef(e, t, i) {
                const s = Bi.Vector3[0];
                return s.copyFrom(t).scaleInPlace(2 * Di.Dot(e, t)),
                i.copyFrom(e).subtractInPlace(s)
            }
            static _UnprojectFromInvertedMatrixToRef(e, t, i) {
                Di.TransformCoordinatesToRef(e, t, i);
                const s = t.m
                  , r = e._x * s[3] + e._y * s[7] + e._z * s[11] + s[15];
                return pe(r, 1) && i.scaleInPlace(1 / r),
                i
            }
            static UnprojectFromTransform(e, t, i, s, r) {
                return this.Unproject(e, t, i, s, r, Oi.IdentityReadOnly)
            }
            static Unproject(e, t, i, s, r, n) {
                const a = new e.constructor;
                return Di.UnprojectToRef(e, t, i, s, r, n, a),
                a
            }
            static UnprojectToRef(e, t, i, s, r, n, a) {
                return Di.UnprojectFloatsToRef(e._x, e._y, e._z, t, i, s, r, n, a),
                a
            }
            static UnprojectFloatsToRef(e, t, i, s, r, n, a, o, h) {
                const l = Li.Matrix[0];
                n.multiplyToRef(a, l),
                l.multiplyToRef(o, l),
                l.invert();
                const c = Li.Vector3[0];
                return c.x = e / s * 2 - 1,
                c.y = -(t / r * 2 - 1),
                Ze.LastCreatedEngine?.isNDCHalfZRange ? c.z = i : c.z = 2 * i - 1,
                Di._UnprojectFromInvertedMatrixToRef(c, l, h),
                h
            }
            static Minimize(e, t) {
                const i = new e.constructor;
                return i.copyFrom(e),
                i.minimizeInPlace(t),
                i
            }
            static Maximize(e, t) {
                const i = new e.constructor;
                return i.copyFrom(e),
                i.maximizeInPlace(t),
                i
            }
            static Distance(e, t) {
                return Math.sqrt(Di.DistanceSquared(e, t))
            }
            static DistanceSquared(e, t) {
                const i = e._x - t._x
                  , s = e._y - t._y
                  , r = e._z - t._z;
                return i * i + s * s + r * r
            }
            static ProjectOnTriangleToRef(e, t, i, s, r) {
                const n = Li.Vector3[0]
                  , a = Li.Vector3[1]
                  , o = Li.Vector3[2]
                  , h = Li.Vector3[3]
                  , l = Li.Vector3[4];
                i.subtractToRef(t, n),
                s.subtractToRef(t, a),
                s.subtractToRef(i, o);
                const c = n.length()
                  , u = a.length()
                  , d = o.length();
                if (c < Ee || u < Ee || d < Ee)
                    return r.copyFrom(t),
                    Di.Distance(e, t);
                e.subtractToRef(t, l),
                Di.CrossToRef(n, a, h);
                const f = h.length();
                if (f < Ee)
                    return r.copyFrom(t),
                    Di.Distance(e, t);
                h.normalizeFromLength(f);
                let _ = l.length();
                if (_ < Ee)
                    return r.copyFrom(t),
                    0;
                l.normalizeFromLength(_);
                const p = Di.Dot(h, l)
                  , m = Li.Vector3[5]
                  , g = Li.Vector3[6];
                m.copyFrom(h).scaleInPlace(-_ * p),
                g.copyFrom(e).addInPlace(m);
                const v = Li.Vector3[4]
                  , y = Li.Vector3[5]
                  , b = Li.Vector3[7]
                  , x = Li.Vector3[8];
                v.copyFrom(n).scaleInPlace(1 / c),
                x.copyFrom(a).scaleInPlace(1 / u),
                v.addInPlace(x).scaleInPlace(-1),
                y.copyFrom(n).scaleInPlace(-1 / c),
                x.copyFrom(o).scaleInPlace(1 / d),
                y.addInPlace(x).scaleInPlace(-1),
                b.copyFrom(o).scaleInPlace(-1 / d),
                x.copyFrom(a).scaleInPlace(-1 / u),
                b.addInPlace(x).scaleInPlace(-1);
                const T = Li.Vector3[9];
                let E;
                T.copyFrom(g).subtractInPlace(t),
                Di.CrossToRef(v, T, x),
                E = Di.Dot(x, h);
                const M = E;
                T.copyFrom(g).subtractInPlace(i),
                Di.CrossToRef(y, T, x),
                E = Di.Dot(x, h);
                const S = E;
                T.copyFrom(g).subtractInPlace(s),
                Di.CrossToRef(b, T, x),
                E = Di.Dot(x, h);
                const A = E
                  , I = Li.Vector3[10];
                let R, C;
                M > 0 && S < 0 ? (I.copyFrom(n),
                R = t,
                C = i) : S > 0 && A < 0 ? (I.copyFrom(o),
                R = i,
                C = s) : (I.copyFrom(a).scaleInPlace(-1),
                R = s,
                C = t);
                const P = Li.Vector3[9]
                  , D = Li.Vector3[4];
                if (R.subtractToRef(g, x),
                C.subtractToRef(g, P),
                Di.CrossToRef(x, P, D),
                !(Di.Dot(D, h) < 0))
                    return r.copyFrom(g),
                    Math.abs(_ * p);
                const w = Li.Vector3[5];
                Di.CrossToRef(I, D, w),
                w.normalize();
                const F = Li.Vector3[9];
                F.copyFrom(R).subtractInPlace(g);
                const O = F.length();
                if (O < Ee)
                    return r.copyFrom(R),
                    Di.Distance(e, R);
                F.normalizeFromLength(O);
                const L = Di.Dot(w, F)
                  , B = Li.Vector3[7];
                B.copyFrom(g).addInPlace(w.scaleInPlace(O * L)),
                x.copyFrom(B).subtractInPlace(R),
                _ = I.length(),
                I.normalizeFromLength(_);
                let N = Di.Dot(x, I) / Math.max(_, Ee);
                return N = ve(N, 0, 1),
                B.copyFrom(R).addInPlace(I.scaleInPlace(N * _)),
                r.copyFrom(B),
                Di.Distance(e, B)
            }
            static Center(e, t) {
                return Di.CenterToRef(e, t, Di.Zero())
            }
            static CenterToRef(e, t, i) {
                return i.copyFromFloats((e._x + t._x) / 2, (e._y + t._y) / 2, (e._z + t._z) / 2)
            }
            static RotationFromAxis(e, t, i) {
                const s = new e.constructor;
                return Di.RotationFromAxisToRef(e, t, i, s),
                s
            }
            static RotationFromAxisToRef(e, t, i, s) {
                const r = Li.Quaternion[0];
                return Fi.RotationQuaternionFromAxisToRef(e, t, i, r),
                r.toEulerAnglesToRef(s),
                s
            }
        }
        Di._UpReadOnly = Di.Up(),
        Di._DownReadOnly = Di.Down(),
        Di._LeftHandedForwardReadOnly = Di.Forward(!1),
        Di._RightHandedForwardReadOnly = Di.Forward(!0),
        Di._LeftHandedBackwardReadOnly = Di.Backward(!1),
        Di._RightHandedBackwardReadOnly = Di.Backward(!0),
        Di._RightReadOnly = Di.Right(),
        Di._LeftReadOnly = Di.Left(),
        Di._ZeroReadOnly = Di.Zero(),
        Di._OneReadOnly = Di.One(),
        Object.defineProperties(Di.prototype, {
            dimension: {
                value: [3]
            },
            rank: {
                value: 1
            }
        });
        class wi {
            constructor(e=0, t=0, i=0, s=0) {
                this.x = e,
                this.y = t,
                this.z = i,
                this.w = s
            }
            toString() {
                return `{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`
            }
            getClassName() {
                return "Vector4"
            }
            getHashCode() {
                let e = Ci(this.x);
                return e = 397 * e ^ Ci(this.y),
                e = 397 * e ^ Ci(this.z),
                e = 397 * e ^ Ci(this.w),
                e
            }
            asArray() {
                return [this.x, this.y, this.z, this.w]
            }
            toArray(e, t) {
                return void 0 === t && (t = 0),
                e[t] = this.x,
                e[t + 1] = this.y,
                e[t + 2] = this.z,
                e[t + 3] = this.w,
                this
            }
            fromArray(e, t=0) {
                return wi.FromArrayToRef(e, t, this),
                this
            }
            addInPlace(e) {
                return this.x += e.x,
                this.y += e.y,
                this.z += e.z,
                this.w += e.w,
                this
            }
            addInPlaceFromFloats(e, t, i, s) {
                return this.x += e,
                this.y += t,
                this.z += i,
                this.w += s,
                this
            }
            add(e) {
                return new this.constructor(this.x + e.x,this.y + e.y,this.z + e.z,this.w + e.w)
            }
            addToRef(e, t) {
                return t.x = this.x + e.x,
                t.y = this.y + e.y,
                t.z = this.z + e.z,
                t.w = this.w + e.w,
                t
            }
            subtractInPlace(e) {
                return this.x -= e.x,
                this.y -= e.y,
                this.z -= e.z,
                this.w -= e.w,
                this
            }
            subtract(e) {
                return new this.constructor(this.x - e.x,this.y - e.y,this.z - e.z,this.w - e.w)
            }
            subtractToRef(e, t) {
                return t.x = this.x - e.x,
                t.y = this.y - e.y,
                t.z = this.z - e.z,
                t.w = this.w - e.w,
                t
            }
            subtractFromFloats(e, t, i, s) {
                return new this.constructor(this.x - e,this.y - t,this.z - i,this.w - s)
            }
            subtractFromFloatsToRef(e, t, i, s, r) {
                return r.x = this.x - e,
                r.y = this.y - t,
                r.z = this.z - i,
                r.w = this.w - s,
                r
            }
            negate() {
                return new this.constructor(-this.x,-this.y,-this.z,-this.w)
            }
            negateInPlace() {
                return this.x *= -1,
                this.y *= -1,
                this.z *= -1,
                this.w *= -1,
                this
            }
            negateToRef(e) {
                return e.copyFromFloats(-1 * this.x, -1 * this.y, -1 * this.z, -1 * this.w)
            }
            scaleInPlace(e) {
                return this.x *= e,
                this.y *= e,
                this.z *= e,
                this.w *= e,
                this
            }
            scale(e) {
                return new this.constructor(this.x * e,this.y * e,this.z * e,this.w * e)
            }
            scaleToRef(e, t) {
                return t.x = this.x * e,
                t.y = this.y * e,
                t.z = this.z * e,
                t.w = this.w * e,
                t
            }
            scaleAndAddToRef(e, t) {
                return t.x += this.x * e,
                t.y += this.y * e,
                t.z += this.z * e,
                t.w += this.w * e,
                t
            }
            equals(e) {
                return e && this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w
            }
            equalsWithEpsilon(e, t=.001) {
                return e && pe(this.x, e.x, t) && pe(this.y, e.y, t) && pe(this.z, e.z, t) && pe(this.w, e.w, t)
            }
            equalsToFloats(e, t, i, s) {
                return this.x === e && this.y === t && this.z === i && this.w === s
            }
            multiplyInPlace(e) {
                return this.x *= e.x,
                this.y *= e.y,
                this.z *= e.z,
                this.w *= e.w,
                this
            }
            multiply(e) {
                return new this.constructor(this.x * e.x,this.y * e.y,this.z * e.z,this.w * e.w)
            }
            multiplyToRef(e, t) {
                return t.x = this.x * e.x,
                t.y = this.y * e.y,
                t.z = this.z * e.z,
                t.w = this.w * e.w,
                t
            }
            multiplyByFloats(e, t, i, s) {
                return new this.constructor(this.x * e,this.y * t,this.z * i,this.w * s)
            }
            divide(e) {
                return new this.constructor(this.x / e.x,this.y / e.y,this.z / e.z,this.w / e.w)
            }
            divideToRef(e, t) {
                return t.x = this.x / e.x,
                t.y = this.y / e.y,
                t.z = this.z / e.z,
                t.w = this.w / e.w,
                t
            }
            divideInPlace(e) {
                return this.divideToRef(e, this)
            }
            minimizeInPlace(e) {
                return e.x < this.x && (this.x = e.x),
                e.y < this.y && (this.y = e.y),
                e.z < this.z && (this.z = e.z),
                e.w < this.w && (this.w = e.w),
                this
            }
            maximizeInPlace(e) {
                return e.x > this.x && (this.x = e.x),
                e.y > this.y && (this.y = e.y),
                e.z > this.z && (this.z = e.z),
                e.w > this.w && (this.w = e.w),
                this
            }
            minimizeInPlaceFromFloats(e, t, i, s) {
                return this.x = Math.min(e, this.x),
                this.y = Math.min(t, this.y),
                this.z = Math.min(i, this.z),
                this.w = Math.min(s, this.w),
                this
            }
            maximizeInPlaceFromFloats(e, t, i, s) {
                return this.x = Math.max(e, this.x),
                this.y = Math.max(t, this.y),
                this.z = Math.max(i, this.z),
                this.w = Math.max(s, this.w),
                this
            }
            floorToRef(e) {
                return e.x = Math.floor(this.x),
                e.y = Math.floor(this.y),
                e.z = Math.floor(this.z),
                e.w = Math.floor(this.w),
                e
            }
            floor() {
                return new this.constructor(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z),Math.floor(this.w))
            }
            fractToRef(e) {
                return e.x = this.x - Math.floor(this.x),
                e.y = this.y - Math.floor(this.y),
                e.z = this.z - Math.floor(this.z),
                e.w = this.w - Math.floor(this.w),
                e
            }
            fract() {
                return new this.constructor(this.x - Math.floor(this.x),this.y - Math.floor(this.y),this.z - Math.floor(this.z),this.w - Math.floor(this.w))
            }
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
            }
            lengthSquared() {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
            }
            normalize() {
                return this.normalizeFromLength(this.length())
            }
            normalizeFromLength(e) {
                return 0 === e || 1 === e ? this : this.scaleInPlace(1 / e)
            }
            normalizeToNew() {
                const e = new this.constructor;
                return this.normalizeToRef(e),
                e
            }
            normalizeToRef(e) {
                const t = this.length();
                return 0 === t || 1 === t ? e.copyFrom(this) : this.scaleToRef(1 / t, e)
            }
            toVector3() {
                return new Di(this.x,this.y,this.z)
            }
            clone() {
                return new this.constructor(this.x,this.y,this.z,this.w)
            }
            copyFrom(e) {
                return this.x = e.x,
                this.y = e.y,
                this.z = e.z,
                this.w = e.w,
                this
            }
            copyFromFloats(e, t, i, s) {
                return this.x = e,
                this.y = t,
                this.z = i,
                this.w = s,
                this
            }
            set(e, t, i, s) {
                return this.copyFromFloats(e, t, i, s)
            }
            setAll(e) {
                return this.x = this.y = this.z = this.w = e,
                this
            }
            dot(e) {
                return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
            }
            static FromArray(e, t) {
                return t || (t = 0),
                new wi(e[t],e[t + 1],e[t + 2],e[t + 3])
            }
            static FromArrayToRef(e, t, i) {
                return i.x = e[t],
                i.y = e[t + 1],
                i.z = e[t + 2],
                i.w = e[t + 3],
                i
            }
            static FromFloatArrayToRef(e, t, i) {
                return wi.FromArrayToRef(e, t, i),
                i
            }
            static FromFloatsToRef(e, t, i, s, r) {
                return r.x = e,
                r.y = t,
                r.z = i,
                r.w = s,
                r
            }
            static Zero() {
                return new wi(0,0,0,0)
            }
            static One() {
                return new wi(1,1,1,1)
            }
            static Random(e=0, t=1) {
                return new wi(me(e, t),me(e, t),me(e, t),me(e, t))
            }
            static RandomToRef(e=0, t=1, i) {
                return i.copyFromFloats(me(e, t), me(e, t), me(e, t), me(e, t))
            }
            static Clamp(e, t, i) {
                const s = new e.constructor;
                return wi.ClampToRef(e, t, i, s),
                s
            }
            static ClampToRef(e, t, i, s) {
                return s.copyFromFloats(ve(e.x, t.x, i.x), ve(e.y, t.y, i.y), ve(e.z, t.z, i.z), ve(e.w, t.w, i.w))
            }
            static CheckExtends(e, t, i) {
                t.minimizeInPlace(e),
                i.maximizeInPlace(e)
            }
            static get ZeroReadOnly() {
                return wi._ZeroReadOnly
            }
            static Normalize(e) {
                const t = wi.Zero();
                return wi.NormalizeToRef(e, t),
                t
            }
            static NormalizeToRef(e, t) {
                return e.normalizeToRef(t),
                t
            }
            static Minimize(e, t) {
                const i = new e.constructor;
                return i.copyFrom(e),
                i.minimizeInPlace(t),
                i
            }
            static Maximize(e, t) {
                const i = new e.constructor;
                return i.copyFrom(e),
                i.maximizeInPlace(t),
                i
            }
            static Distance(e, t) {
                return Math.sqrt(wi.DistanceSquared(e, t))
            }
            static DistanceSquared(e, t) {
                const i = e.x - t.x
                  , s = e.y - t.y
                  , r = e.z - t.z
                  , n = e.w - t.w;
                return i * i + s * s + r * r + n * n
            }
            static Center(e, t) {
                return wi.CenterToRef(e, t, wi.Zero())
            }
            static CenterToRef(e, t, i) {
                return i.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2, (e.z + t.z) / 2, (e.w + t.w) / 2)
            }
            static TransformCoordinates(e, t) {
                const i = wi.Zero();
                return wi.TransformCoordinatesToRef(e, t, i),
                i
            }
            static TransformCoordinatesToRef(e, t, i) {
                return wi.TransformCoordinatesFromFloatsToRef(e._x, e._y, e._z, t, i),
                i
            }
            static TransformCoordinatesFromFloatsToRef(e, t, i, s, r) {
                const n = s.m
                  , a = e * n[0] + t * n[4] + i * n[8] + n[12]
                  , o = e * n[1] + t * n[5] + i * n[9] + n[13]
                  , h = e * n[2] + t * n[6] + i * n[10] + n[14]
                  , l = e * n[3] + t * n[7] + i * n[11] + n[15];
                return r.x = a,
                r.y = o,
                r.z = h,
                r.w = l,
                r
            }
            static TransformNormal(e, t) {
                const i = new e.constructor;
                return wi.TransformNormalToRef(e, t, i),
                i
            }
            static TransformNormalToRef(e, t, i) {
                const s = t.m
                  , r = e.x * s[0] + e.y * s[4] + e.z * s[8]
                  , n = e.x * s[1] + e.y * s[5] + e.z * s[9]
                  , a = e.x * s[2] + e.y * s[6] + e.z * s[10];
                return i.x = r,
                i.y = n,
                i.z = a,
                i.w = e.w,
                i
            }
            static TransformNormalFromFloatsToRef(e, t, i, s, r, n) {
                const a = r.m;
                return n.x = e * a[0] + t * a[4] + i * a[8],
                n.y = e * a[1] + t * a[5] + i * a[9],
                n.z = e * a[2] + t * a[6] + i * a[10],
                n.w = s,
                n
            }
            static FromVector3(e, t=0) {
                return new wi(e._x,e._y,e._z,t)
            }
            static Dot(e, t) {
                return e.dot(t)
            }
        }
        wi._ZeroReadOnly = wi.Zero(),
        Object.defineProperties(wi.prototype, {
            dimension: {
                value: [4]
            },
            rank: {
                value: 1
            }
        });
        class Fi {
            get x() {
                return this._x
            }
            set x(e) {
                this._x = e,
                this._isDirty = !0
            }
            get y() {
                return this._y
            }
            set y(e) {
                this._y = e,
                this._isDirty = !0
            }
            get z() {
                return this._z
            }
            set z(e) {
                this._z = e,
                this._isDirty = !0
            }
            get w() {
                return this._w
            }
            set w(e) {
                this._w = e,
                this._isDirty = !0
            }
            constructor(e=0, t=0, i=0, s=1) {
                this._isDirty = !0,
                this._x = e,
                this._y = t,
                this._z = i,
                this._w = s
            }
            toString() {
                return `{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`
            }
            getClassName() {
                return "Quaternion"
            }
            getHashCode() {
                let e = Ci(this._x);
                return e = 397 * e ^ Ci(this._y),
                e = 397 * e ^ Ci(this._z),
                e = 397 * e ^ Ci(this._w),
                e
            }
            asArray() {
                return [this._x, this._y, this._z, this._w]
            }
            toArray(e, t=0) {
                return e[t] = this._x,
                e[t + 1] = this._y,
                e[t + 2] = this._z,
                e[t + 3] = this._w,
                this
            }
            fromArray(e, t=0) {
                return Fi.FromArrayToRef(e, t, this)
            }
            equals(e) {
                return e && this._x === e._x && this._y === e._y && this._z === e._z && this._w === e._w
            }
            equalsWithEpsilon(e, t=.001) {
                return e && pe(this._x, e._x, t) && pe(this._y, e._y, t) && pe(this._z, e._z, t) && pe(this._w, e._w, t)
            }
            clone() {
                return new this.constructor(this._x,this._y,this._z,this._w)
            }
            copyFrom(e) {
                return this._x = e._x,
                this._y = e._y,
                this._z = e._z,
                this._w = e._w,
                this._isDirty = !0,
                this
            }
            copyFromFloats(e, t, i, s) {
                return this._x = e,
                this._y = t,
                this._z = i,
                this._w = s,
                this._isDirty = !0,
                this
            }
            set(e, t, i, s) {
                return this.copyFromFloats(e, t, i, s)
            }
            setAll(e) {
                return this.copyFromFloats(e, e, e, e)
            }
            add(e) {
                return new this.constructor(this._x + e._x,this._y + e._y,this._z + e._z,this._w + e._w)
            }
            addInPlace(e) {
                return this._x += e._x,
                this._y += e._y,
                this._z += e._z,
                this._w += e._w,
                this._isDirty = !0,
                this
            }
            addToRef(e, t) {
                return t._x = this._x + e._x,
                t._y = this._y + e._y,
                t._z = this._z + e._z,
                t._w = this._w + e._w,
                t._isDirty = !0,
                t
            }
            addInPlaceFromFloats(e, t, i, s) {
                return this._x += e,
                this._y += t,
                this._z += i,
                this._w += s,
                this._isDirty = !0,
                this
            }
            subtractToRef(e, t) {
                return t._x = this._x - e._x,
                t._y = this._y - e._y,
                t._z = this._z - e._z,
                t._w = this._w - e._w,
                t._isDirty = !0,
                t
            }
            subtractFromFloats(e, t, i, s) {
                return this.subtractFromFloatsToRef(e, t, i, s, new this.constructor)
            }
            subtractFromFloatsToRef(e, t, i, s, r) {
                return r._x = this._x - e,
                r._y = this._y - t,
                r._z = this._z - i,
                r._w = this._w - s,
                r._isDirty = !0,
                r
            }
            subtract(e) {
                return new this.constructor(this._x - e._x,this._y - e._y,this._z - e._z,this._w - e._w)
            }
            subtractInPlace(e) {
                return this._x -= e._x,
                this._y -= e._y,
                this._z -= e._z,
                this._w -= e._w,
                this._isDirty = !0,
                this
            }
            scale(e) {
                return new this.constructor(this._x * e,this._y * e,this._z * e,this._w * e)
            }
            scaleToRef(e, t) {
                return t._x = this._x * e,
                t._y = this._y * e,
                t._z = this._z * e,
                t._w = this._w * e,
                t._isDirty = !0,
                t
            }
            scaleInPlace(e) {
                return this._x *= e,
                this._y *= e,
                this._z *= e,
                this._w *= e,
                this._isDirty = !0,
                this
            }
            scaleAndAddToRef(e, t) {
                return t._x += this._x * e,
                t._y += this._y * e,
                t._z += this._z * e,
                t._w += this._w * e,
                t._isDirty = !0,
                t
            }
            multiply(e) {
                const t = new this.constructor(0,0,0,1);
                return this.multiplyToRef(e, t),
                t
            }
            multiplyToRef(e, t) {
                const i = this._x * e._w + this._y * e._z - this._z * e._y + this._w * e._x
                  , s = -this._x * e._z + this._y * e._w + this._z * e._x + this._w * e._y
                  , r = this._x * e._y - this._y * e._x + this._z * e._w + this._w * e._z
                  , n = -this._x * e._x - this._y * e._y - this._z * e._z + this._w * e._w;
                return t.copyFromFloats(i, s, r, n),
                t
            }
            multiplyInPlace(e) {
                return this.multiplyToRef(e, this)
            }
            multiplyByFloats(e, t, i, s) {
                return this._x *= e,
                this._y *= t,
                this._z *= i,
                this._w *= s,
                this._isDirty = !0,
                this
            }
            divide(e) {
                throw new ReferenceError("Can not divide a quaternion")
            }
            divideToRef(e, t) {
                throw new ReferenceError("Can not divide a quaternion")
            }
            divideInPlace(e) {
                throw new ReferenceError("Can not divide a quaternion")
            }
            minimizeInPlace() {
                throw new ReferenceError("Can not minimize a quaternion")
            }
            minimizeInPlaceFromFloats() {
                throw new ReferenceError("Can not minimize a quaternion")
            }
            maximizeInPlace() {
                throw new ReferenceError("Can not maximize a quaternion")
            }
            maximizeInPlaceFromFloats() {
                throw new ReferenceError("Can not maximize a quaternion")
            }
            negate() {
                return this.negateToRef(new this.constructor)
            }
            negateInPlace() {
                return this._x = -this._x,
                this._y = -this._y,
                this._z = -this._z,
                this._w = -this._w,
                this._isDirty = !0,
                this
            }
            negateToRef(e) {
                return e._x = -this._x,
                e._y = -this._y,
                e._z = -this._z,
                e._w = -this._w,
                e._isDirty = !0,
                e
            }
            equalsToFloats(e, t, i, s) {
                return this._x === e && this._y === t && this._z === i && this._w === s
            }
            floorToRef(e) {
                throw new ReferenceError("Can not floor a quaternion")
            }
            floor() {
                throw new ReferenceError("Can not floor a quaternion")
            }
            fractToRef(e) {
                throw new ReferenceError("Can not fract a quaternion")
            }
            fract() {
                throw new ReferenceError("Can not fract a quaternion")
            }
            conjugateToRef(e) {
                return e.copyFromFloats(-this._x, -this._y, -this._z, this._w),
                e
            }
            conjugateInPlace() {
                return this._x *= -1,
                this._y *= -1,
                this._z *= -1,
                this._isDirty = !0,
                this
            }
            conjugate() {
                return new this.constructor(-this._x,-this._y,-this._z,this._w)
            }
            invert() {
                const e = this.conjugate()
                  , t = this.lengthSquared();
                return 0 == t || 1 == t || e.scaleInPlace(1 / t),
                e
            }
            invertInPlace() {
                this.conjugateInPlace();
                const e = this.lengthSquared();
                return 0 == e || 1 == e || this.scaleInPlace(1 / e),
                this
            }
            lengthSquared() {
                return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
            }
            length() {
                return Math.sqrt(this.lengthSquared())
            }
            normalize() {
                return this.normalizeFromLength(this.length())
            }
            normalizeFromLength(e) {
                return 0 === e || 1 === e ? this : this.scaleInPlace(1 / e)
            }
            normalizeToNew() {
                const e = new this.constructor(0,0,0,1);
                return this.normalizeToRef(e),
                e
            }
            normalizeToRef(e) {
                const t = this.length();
                return 0 === t || 1 === t ? e.copyFromFloats(this._x, this._y, this._z, this._w) : this.scaleToRef(1 / t, e)
            }
            toEulerAngles() {
                const e = Di.Zero();
                return this.toEulerAnglesToRef(e),
                e
            }
            toEulerAnglesToRef(e) {
                const t = this._z
                  , i = this._x
                  , s = this._y
                  , r = this._w
                  , n = s * t - i * r
                  , a = .4999999;
                if (n < -a)
                    e._y = 2 * Math.atan2(s, r),
                    e._x = Math.PI / 2,
                    e._z = 0,
                    e._isDirty = !0;
                else if (n > a)
                    e._y = 2 * Math.atan2(s, r),
                    e._x = -Math.PI / 2,
                    e._z = 0,
                    e._isDirty = !0;
                else {
                    const a = r * r
                      , o = t * t
                      , h = i * i
                      , l = s * s;
                    e._z = Math.atan2(2 * (i * s + t * r), -o - h + l + a),
                    e._x = Math.asin(-2 * n),
                    e._y = Math.atan2(2 * (t * i + s * r), o - h - l + a),
                    e._isDirty = !0
                }
                return e
            }
            toRotationMatrix(e) {
                return Oi.FromQuaternionToRef(this, e),
                e
            }
            fromRotationMatrix(e) {
                return Fi.FromRotationMatrixToRef(e, this),
                this
            }
            dot(e) {
                return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
            }
            static FromRotationMatrix(e) {
                const t = new Fi;
                return Fi.FromRotationMatrixToRef(e, t),
                t
            }
            static FromRotationMatrixToRef(e, t) {
                const i = e.m
                  , s = i[0]
                  , r = i[4]
                  , n = i[8]
                  , a = i[1]
                  , o = i[5]
                  , h = i[9]
                  , l = i[2]
                  , c = i[6]
                  , u = i[10]
                  , d = s + o + u;
                let f;
                return d > 0 ? (f = .5 / Math.sqrt(d + 1),
                t._w = .25 / f,
                t._x = (c - h) * f,
                t._y = (n - l) * f,
                t._z = (a - r) * f,
                t._isDirty = !0) : s > o && s > u ? (f = 2 * Math.sqrt(1 + s - o - u),
                t._w = (c - h) / f,
                t._x = .25 * f,
                t._y = (r + a) / f,
                t._z = (n + l) / f,
                t._isDirty = !0) : o > u ? (f = 2 * Math.sqrt(1 + o - s - u),
                t._w = (n - l) / f,
                t._x = (r + a) / f,
                t._y = .25 * f,
                t._z = (h + c) / f,
                t._isDirty = !0) : (f = 2 * Math.sqrt(1 + u - s - o),
                t._w = (a - r) / f,
                t._x = (n + l) / f,
                t._y = (h + c) / f,
                t._z = .25 * f,
                t._isDirty = !0),
                t
            }
            static Dot(e, t) {
                return e._x * t._x + e._y * t._y + e._z * t._z + e._w * t._w
            }
            static AreClose(e, t, i=.1) {
                const s = Fi.Dot(e, t);
                return 1 - s * s <= i
            }
            static SmoothToRef(e, t, i, s, r) {
                let n = 0 === s ? 1 : i / s;
                return n = ve(n, 0, 1),
                Fi.SlerpToRef(e, t, n, r),
                r
            }
            static Zero() {
                return new Fi(0,0,0,0)
            }
            static Inverse(e) {
                return new e.constructor(-e._x,-e._y,-e._z,e._w)
            }
            static InverseToRef(e, t) {
                return t.set(-e._x, -e._y, -e._z, e._w),
                t
            }
            static Identity() {
                return new Fi(0,0,0,1)
            }
            static IsIdentity(e) {
                return e && 0 === e._x && 0 === e._y && 0 === e._z && 1 === e._w
            }
            static RotationAxis(e, t) {
                return Fi.RotationAxisToRef(e, t, new Fi)
            }
            static RotationAxisToRef(e, t, i) {
                const s = Math.sin(t / 2);
                return e.normalize(),
                i._w = Math.cos(t / 2),
                i._x = e._x * s,
                i._y = e._y * s,
                i._z = e._z * s,
                i._isDirty = !0,
                i
            }
            static FromArray(e, t) {
                return t || (t = 0),
                new Fi(e[t],e[t + 1],e[t + 2],e[t + 3])
            }
            static FromArrayToRef(e, t, i) {
                return i._x = e[t],
                i._y = e[t + 1],
                i._z = e[t + 2],
                i._w = e[t + 3],
                i._isDirty = !0,
                i
            }
            static FromFloatsToRef(e, t, i, s, r) {
                return r.copyFromFloats(e, t, i, s),
                r
            }
            static FromEulerAngles(e, t, i) {
                const s = new Fi;
                return Fi.RotationYawPitchRollToRef(t, e, i, s),
                s
            }
            static FromEulerAnglesToRef(e, t, i, s) {
                return Fi.RotationYawPitchRollToRef(t, e, i, s),
                s
            }
            static FromEulerVector(e) {
                const t = new Fi;
                return Fi.RotationYawPitchRollToRef(e._y, e._x, e._z, t),
                t
            }
            static FromEulerVectorToRef(e, t) {
                return Fi.RotationYawPitchRollToRef(e._y, e._x, e._z, t),
                t
            }
            static FromUnitVectorsToRef(e, t, i, s=.001) {
                const r = Di.Dot(e, t) + 1;
                return r < s ? Math.abs(e.x) > Math.abs(e.z) ? i.set(-e.y, e.x, 0, 0) : i.set(0, -e.z, e.y, 0) : (Di.CrossToRef(e, t, Bi.Vector3[0]),
                i.set(Bi.Vector3[0].x, Bi.Vector3[0].y, Bi.Vector3[0].z, r)),
                i.normalize()
            }
            static RotationYawPitchRoll(e, t, i) {
                const s = new Fi;
                return Fi.RotationYawPitchRollToRef(e, t, i, s),
                s
            }
            static RotationYawPitchRollToRef(e, t, i, s) {
                const r = .5 * i
                  , n = .5 * t
                  , a = .5 * e
                  , o = Math.sin(r)
                  , h = Math.cos(r)
                  , l = Math.sin(n)
                  , c = Math.cos(n)
                  , u = Math.sin(a)
                  , d = Math.cos(a);
                return s._x = d * l * h + u * c * o,
                s._y = u * c * h - d * l * o,
                s._z = d * c * o - u * l * h,
                s._w = d * c * h + u * l * o,
                s._isDirty = !0,
                s
            }
            static RotationAlphaBetaGamma(e, t, i) {
                const s = new Fi;
                return Fi.RotationAlphaBetaGammaToRef(e, t, i, s),
                s
            }
            static RotationAlphaBetaGammaToRef(e, t, i, s) {
                const r = .5 * (i + e)
                  , n = .5 * (i - e)
                  , a = .5 * t;
                return s._x = Math.cos(n) * Math.sin(a),
                s._y = Math.sin(n) * Math.sin(a),
                s._z = Math.sin(r) * Math.cos(a),
                s._w = Math.cos(r) * Math.cos(a),
                s._isDirty = !0,
                s
            }
            static RotationQuaternionFromAxis(e, t, i) {
                const s = new Fi(0,0,0,0);
                return Fi.RotationQuaternionFromAxisToRef(e, t, i, s),
                s
            }
            static RotationQuaternionFromAxisToRef(e, t, i, s) {
                const r = Li.Matrix[0];
                return Oi.FromXYZAxesToRef(e.normalize(), t.normalize(), i.normalize(), r),
                Fi.FromRotationMatrixToRef(r, s),
                s
            }
            static FromLookDirectionLH(e, t) {
                const i = new Fi;
                return Fi.FromLookDirectionLHToRef(e, t, i),
                i
            }
            static FromLookDirectionLHToRef(e, t, i) {
                const s = Li.Matrix[0];
                return Oi.LookDirectionLHToRef(e, t, s),
                Fi.FromRotationMatrixToRef(s, i),
                i
            }
            static FromLookDirectionRH(e, t) {
                const i = new Fi;
                return Fi.FromLookDirectionRHToRef(e, t, i),
                i
            }
            static FromLookDirectionRHToRef(e, t, i) {
                const s = Li.Matrix[0];
                return Oi.LookDirectionRHToRef(e, t, s),
                Fi.FromRotationMatrixToRef(s, i)
            }
            static Slerp(e, t, i) {
                const s = Fi.Identity();
                return Fi.SlerpToRef(e, t, i, s),
                s
            }
            static SlerpToRef(e, t, i, s) {
                let r, n, a = e._x * t._x + e._y * t._y + e._z * t._z + e._w * t._w, o = !1;
                if (a < 0 && (o = !0,
                a = -a),
                a > .999999)
                    n = 1 - i,
                    r = o ? -i : i;
                else {
                    const e = Math.acos(a)
                      , t = 1 / Math.sin(e);
                    n = Math.sin((1 - i) * e) * t,
                    r = o ? -Math.sin(i * e) * t : Math.sin(i * e) * t
                }
                return s._x = n * e._x + r * t._x,
                s._y = n * e._y + r * t._y,
                s._z = n * e._z + r * t._z,
                s._w = n * e._w + r * t._w,
                s._isDirty = !0,
                s
            }
            static Hermite(e, t, i, s, r) {
                const n = r * r
                  , a = r * n
                  , o = 2 * a - 3 * n + 1
                  , h = -2 * a + 3 * n
                  , l = a - 2 * n + r
                  , c = a - n
                  , u = e._x * o + i._x * h + t._x * l + s._x * c
                  , d = e._y * o + i._y * h + t._y * l + s._y * c
                  , f = e._z * o + i._z * h + t._z * l + s._z * c
                  , _ = e._w * o + i._w * h + t._w * l + s._w * c;
                return new e.constructor(u,d,f,_)
            }
            static Hermite1stDerivative(e, t, i, s, r) {
                const n = new e.constructor;
                return this.Hermite1stDerivativeToRef(e, t, i, s, r, n),
                n
            }
            static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
                const a = r * r;
                return n._x = 6 * (a - r) * e._x + (3 * a - 4 * r + 1) * t._x + 6 * (-a + r) * i._x + (3 * a - 2 * r) * s._x,
                n._y = 6 * (a - r) * e._y + (3 * a - 4 * r + 1) * t._y + 6 * (-a + r) * i._y + (3 * a - 2 * r) * s._y,
                n._z = 6 * (a - r) * e._z + (3 * a - 4 * r + 1) * t._z + 6 * (-a + r) * i._z + (3 * a - 2 * r) * s._z,
                n._w = 6 * (a - r) * e._w + (3 * a - 4 * r + 1) * t._w + 6 * (-a + r) * i._w + (3 * a - 2 * r) * s._w,
                n._isDirty = !0,
                n
            }
            static Normalize(e) {
                const t = Fi.Zero();
                return Fi.NormalizeToRef(e, t),
                t
            }
            static NormalizeToRef(e, t) {
                return e.normalizeToRef(t),
                t
            }
            static Clamp(e, t, i) {
                const s = new e.constructor;
                return Fi.ClampToRef(e, t, i, s),
                s
            }
            static ClampToRef(e, t, i, s) {
                return s.copyFromFloats(ve(e.x, t.x, i.x), ve(e.y, t.y, i.y), ve(e.z, t.z, i.z), ve(e.w, t.w, i.w))
            }
            static Random(e=0, t=1) {
                return new Fi(me(e, t),me(e, t),me(e, t),me(e, t))
            }
            static RandomToRef(e=0, t=1, i) {
                return i.copyFromFloats(me(e, t), me(e, t), me(e, t), me(e, t))
            }
            static Minimize() {
                throw new ReferenceError("Quaternion.Minimize does not make sense")
            }
            static Maximize() {
                throw new ReferenceError("Quaternion.Maximize does not make sense")
            }
            static Distance(e, t) {
                return Math.sqrt(Fi.DistanceSquared(e, t))
            }
            static DistanceSquared(e, t) {
                const i = e.x - t.x
                  , s = e.y - t.y
                  , r = e.z - t.z
                  , n = e.w - t.w;
                return i * i + s * s + r * r + n * n
            }
            static Center(e, t) {
                return Fi.CenterToRef(e, t, Fi.Zero())
            }
            static CenterToRef(e, t, i) {
                return i.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2, (e.z + t.z) / 2, (e.w + t.w) / 2)
            }
        }
        Object.defineProperties(Fi.prototype, {
            dimension: {
                value: [4]
            },
            rank: {
                value: 1
            }
        });
        class Oi {
            static get Use64Bits() {
                return Ot.MatrixUse64Bits
            }
            get m() {
                return this._m
            }
            markAsUpdated() {
                this.updateFlag = Oi._UpdateFlagSeed++,
                this._isIdentity = !1,
                this._isIdentity3x2 = !1,
                this._isIdentityDirty = !0,
                this._isIdentity3x2Dirty = !0
            }
            _updateIdentityStatus(e, t=!1, i=!1, s=!0) {
                this._isIdentity = e,
                this._isIdentity3x2 = e || i,
                this._isIdentityDirty = !this._isIdentity && t,
                this._isIdentity3x2Dirty = !this._isIdentity3x2 && s
            }
            constructor() {
                this._isIdentity = !1,
                this._isIdentityDirty = !0,
                this._isIdentity3x2 = !0,
                this._isIdentity3x2Dirty = !0,
                this.updateFlag = -1,
                Ot.MatrixTrackPrecisionChange && Ot.MatrixTrackedMatrices.push(this),
                this._m = new Ot.MatrixCurrentType(16),
                this.markAsUpdated()
            }
            isIdentity() {
                if (this._isIdentityDirty) {
                    this._isIdentityDirty = !1;
                    const e = this._m;
                    this._isIdentity = 1 === e[0] && 0 === e[1] && 0 === e[2] && 0 === e[3] && 0 === e[4] && 1 === e[5] && 0 === e[6] && 0 === e[7] && 0 === e[8] && 0 === e[9] && 1 === e[10] && 0 === e[11] && 0 === e[12] && 0 === e[13] && 0 === e[14] && 1 === e[15]
                }
                return this._isIdentity
            }
            isIdentityAs3x2() {
                return this._isIdentity3x2Dirty && (this._isIdentity3x2Dirty = !1,
                1 !== this._m[0] || 1 !== this._m[5] || 1 !== this._m[15] || 0 !== this._m[1] || 0 !== this._m[2] || 0 !== this._m[3] || 0 !== this._m[4] || 0 !== this._m[6] || 0 !== this._m[7] || 0 !== this._m[8] || 0 !== this._m[9] || 0 !== this._m[10] || 0 !== this._m[11] || 0 !== this._m[12] || 0 !== this._m[13] || 0 !== this._m[14] ? this._isIdentity3x2 = !1 : this._isIdentity3x2 = !0),
                this._isIdentity3x2
            }
            determinant() {
                if (!0 === this._isIdentity)
                    return 1;
                const e = this._m
                  , t = e[0]
                  , i = e[1]
                  , s = e[2]
                  , r = e[3]
                  , n = e[4]
                  , a = e[5]
                  , o = e[6]
                  , h = e[7]
                  , l = e[8]
                  , c = e[9]
                  , u = e[10]
                  , d = e[11]
                  , f = e[12]
                  , _ = e[13]
                  , p = e[14]
                  , m = e[15]
                  , g = u * m - p * d
                  , v = c * m - _ * d
                  , y = c * p - _ * u
                  , b = l * m - f * d
                  , x = l * p - u * f
                  , T = l * _ - f * c;
                return t * +(a * g - o * v + h * y) + i * -(n * g - o * b + h * x) + s * +(n * v - a * b + h * T) + r * -(n * y - a * x + o * T)
            }
            toString() {
                return `{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}\n${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}\n${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}\n${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`
            }
            toArray(e=null, t=0) {
                if (!e)
                    return this._m;
                const i = this._m;
                for (let s = 0; s < 16; s++)
                    e[t + s] = i[s];
                return this
            }
            asArray() {
                return this._m
            }
            fromArray(e, t=0) {
                return Oi.FromArrayToRef(e, t, this)
            }
            copyFromFloats(...e) {
                return Oi.FromArrayToRef(e, 0, this)
            }
            set(...e) {
                const t = this._m;
                for (let i = 0; i < 16; i++)
                    t[i] = e[i];
                return this.markAsUpdated(),
                this
            }
            setAll(e) {
                const t = this._m;
                for (let i = 0; i < 16; i++)
                    t[i] = e;
                return this.markAsUpdated(),
                this
            }
            invert() {
                return this.invertToRef(this),
                this
            }
            reset() {
                return Oi.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this),
                this._updateIdentityStatus(!1),
                this
            }
            add(e) {
                const t = new this.constructor;
                return this.addToRef(e, t),
                t
            }
            addToRef(e, t) {
                const i = this._m
                  , s = t._m
                  , r = e.m;
                for (let e = 0; e < 16; e++)
                    s[e] = i[e] + r[e];
                return t.markAsUpdated(),
                t
            }
            addToSelf(e) {
                const t = this._m
                  , i = e.m;
                for (let e = 0; e < 16; e++)
                    t[e] += i[e];
                return this.markAsUpdated(),
                this
            }
            addInPlace(e) {
                const t = this._m
                  , i = e.m;
                for (let e = 0; e < 16; e++)
                    t[e] += i[e];
                return this.markAsUpdated(),
                this
            }
            addInPlaceFromFloats(...e) {
                const t = this._m;
                for (let i = 0; i < 16; i++)
                    t[i] += e[i];
                return this.markAsUpdated(),
                this
            }
            subtract(e) {
                const t = this._m
                  , i = e.m;
                for (let e = 0; e < 16; e++)
                    t[e] -= i[e];
                return this.markAsUpdated(),
                this
            }
            subtractToRef(e, t) {
                const i = this._m
                  , s = e.m
                  , r = t._m;
                for (let e = 0; e < 16; e++)
                    r[e] = i[e] - s[e];
                return t.markAsUpdated(),
                t
            }
            subtractInPlace(e) {
                const t = this._m
                  , i = e.m;
                for (let e = 0; e < 16; e++)
                    t[e] -= i[e];
                return this.markAsUpdated(),
                this
            }
            subtractFromFloats(...e) {
                return this.subtractFromFloatsToRef(...e, new this.constructor)
            }
            subtractFromFloatsToRef(...e) {
                const t = e.pop()
                  , i = this._m
                  , s = t._m
                  , r = e;
                for (let e = 0; e < 16; e++)
                    s[e] = i[e] - r[e];
                return t.markAsUpdated(),
                t
            }
            invertToRef(e) {
                if (!0 === this._isIdentity)
                    return Oi.IdentityToRef(e),
                    e;
                const t = this._m
                  , i = t[0]
                  , s = t[1]
                  , r = t[2]
                  , n = t[3]
                  , a = t[4]
                  , o = t[5]
                  , h = t[6]
                  , l = t[7]
                  , c = t[8]
                  , u = t[9]
                  , d = t[10]
                  , f = t[11]
                  , _ = t[12]
                  , p = t[13]
                  , m = t[14]
                  , g = t[15]
                  , v = d * g - m * f
                  , y = u * g - p * f
                  , b = u * m - p * d
                  , x = c * g - _ * f
                  , T = c * m - d * _
                  , E = c * p - _ * u
                  , M = +(o * v - h * y + l * b)
                  , S = -(a * v - h * x + l * T)
                  , A = +(a * y - o * x + l * E)
                  , I = -(a * b - o * T + h * E)
                  , R = i * M + s * S + r * A + n * I;
                if (0 === R)
                    return e.copyFrom(this),
                    e;
                const C = 1 / R
                  , P = h * g - m * l
                  , D = o * g - p * l
                  , w = o * m - p * h
                  , F = a * g - _ * l
                  , O = a * m - _ * h
                  , L = a * p - _ * o
                  , B = h * f - d * l
                  , N = o * f - u * l
                  , U = o * d - u * h
                  , k = a * f - c * l
                  , V = a * d - c * h
                  , G = a * u - c * o
                  , z = -(s * v - r * y + n * b)
                  , W = +(i * v - r * x + n * T)
                  , X = -(i * y - s * x + n * E)
                  , H = +(i * b - s * T + r * E)
                  , K = +(s * P - r * D + n * w)
                  , Y = -(i * P - r * F + n * O)
                  , j = +(i * D - s * F + n * L)
                  , q = -(i * w - s * O + r * L)
                  , Z = -(s * B - r * N + n * U)
                  , Q = +(i * B - r * k + n * V)
                  , $ = -(i * N - s * k + n * G)
                  , J = +(i * U - s * V + r * G);
                return Oi.FromValuesToRef(M * C, z * C, K * C, Z * C, S * C, W * C, Y * C, Q * C, A * C, X * C, j * C, $ * C, I * C, H * C, q * C, J * C, e),
                e
            }
            addAtIndex(e, t) {
                return this._m[e] += t,
                this.markAsUpdated(),
                this
            }
            multiplyAtIndex(e, t) {
                return this._m[e] *= t,
                this.markAsUpdated(),
                this
            }
            setTranslationFromFloats(e, t, i) {
                return this._m[12] = e,
                this._m[13] = t,
                this._m[14] = i,
                this.markAsUpdated(),
                this
            }
            addTranslationFromFloats(e, t, i) {
                return this._m[12] += e,
                this._m[13] += t,
                this._m[14] += i,
                this.markAsUpdated(),
                this
            }
            setTranslation(e) {
                return this.setTranslationFromFloats(e._x, e._y, e._z)
            }
            getTranslation() {
                return new Di(this._m[12],this._m[13],this._m[14])
            }
            getTranslationToRef(e) {
                return e.x = this._m[12],
                e.y = this._m[13],
                e.z = this._m[14],
                e
            }
            removeRotationAndScaling() {
                const e = this.m;
                return Oi.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e[12], e[13], e[14], e[15], this),
                this._updateIdentityStatus(0 === e[12] && 0 === e[13] && 0 === e[14] && 1 === e[15]),
                this
            }
            copyFrom(e) {
                e.copyToArray(this._m);
                const t = e;
                return this.updateFlag = t.updateFlag,
                this._updateIdentityStatus(t._isIdentity, t._isIdentityDirty, t._isIdentity3x2, t._isIdentity3x2Dirty),
                this
            }
            copyToArray(e, t=0) {
                const i = this._m;
                return e[t] = i[0],
                e[t + 1] = i[1],
                e[t + 2] = i[2],
                e[t + 3] = i[3],
                e[t + 4] = i[4],
                e[t + 5] = i[5],
                e[t + 6] = i[6],
                e[t + 7] = i[7],
                e[t + 8] = i[8],
                e[t + 9] = i[9],
                e[t + 10] = i[10],
                e[t + 11] = i[11],
                e[t + 12] = i[12],
                e[t + 13] = i[13],
                e[t + 14] = i[14],
                e[t + 15] = i[15],
                this
            }
            multiply(e) {
                const t = new this.constructor;
                return this.multiplyToRef(e, t),
                t
            }
            multiplyInPlace(e) {
                const t = this._m
                  , i = e.m;
                for (let e = 0; e < 16; e++)
                    t[e] *= i[e];
                return this.markAsUpdated(),
                this
            }
            multiplyByFloats(...e) {
                const t = this._m;
                for (let i = 0; i < 16; i++)
                    t[i] = e[i];
                return this.markAsUpdated(),
                this
            }
            multiplyByFloatsToRef(...e) {
                const t = e.pop()
                  , i = this._m
                  , s = t._m
                  , r = e;
                for (let e = 0; e < 16; e++)
                    s[e] = i[e] * r[e];
                return t.markAsUpdated(),
                t
            }
            multiplyToRef(e, t) {
                return this._isIdentity ? (t.copyFrom(e),
                t) : e._isIdentity ? (t.copyFrom(this),
                t) : (this.multiplyToArray(e, t._m, 0),
                t.markAsUpdated(),
                t)
            }
            multiplyToArray(e, t, i) {
                const s = this._m
                  , r = e.m
                  , n = s[0]
                  , a = s[1]
                  , o = s[2]
                  , h = s[3]
                  , l = s[4]
                  , c = s[5]
                  , u = s[6]
                  , d = s[7]
                  , f = s[8]
                  , _ = s[9]
                  , p = s[10]
                  , m = s[11]
                  , g = s[12]
                  , v = s[13]
                  , y = s[14]
                  , b = s[15]
                  , x = r[0]
                  , T = r[1]
                  , E = r[2]
                  , M = r[3]
                  , S = r[4]
                  , A = r[5]
                  , I = r[6]
                  , R = r[7]
                  , C = r[8]
                  , P = r[9]
                  , D = r[10]
                  , w = r[11]
                  , F = r[12]
                  , O = r[13]
                  , L = r[14]
                  , B = r[15];
                return t[i] = n * x + a * S + o * C + h * F,
                t[i + 1] = n * T + a * A + o * P + h * O,
                t[i + 2] = n * E + a * I + o * D + h * L,
                t[i + 3] = n * M + a * R + o * w + h * B,
                t[i + 4] = l * x + c * S + u * C + d * F,
                t[i + 5] = l * T + c * A + u * P + d * O,
                t[i + 6] = l * E + c * I + u * D + d * L,
                t[i + 7] = l * M + c * R + u * w + d * B,
                t[i + 8] = f * x + _ * S + p * C + m * F,
                t[i + 9] = f * T + _ * A + p * P + m * O,
                t[i + 10] = f * E + _ * I + p * D + m * L,
                t[i + 11] = f * M + _ * R + p * w + m * B,
                t[i + 12] = g * x + v * S + y * C + b * F,
                t[i + 13] = g * T + v * A + y * P + b * O,
                t[i + 14] = g * E + v * I + y * D + b * L,
                t[i + 15] = g * M + v * R + y * w + b * B,
                this
            }
            divide(e) {
                return this.divideToRef(e, new this.constructor)
            }
            divideToRef(e, t) {
                const i = this._m
                  , s = e.m
                  , r = t._m;
                for (let e = 0; e < 16; e++)
                    r[e] = i[e] / s[e];
                return t.markAsUpdated(),
                t
            }
            divideInPlace(e) {
                const t = this._m
                  , i = e.m;
                for (let e = 0; e < 16; e++)
                    t[e] /= i[e];
                return this.markAsUpdated(),
                this
            }
            minimizeInPlace(e) {
                const t = this._m
                  , i = e.m;
                for (let e = 0; e < 16; e++)
                    t[e] = Math.min(t[e], i[e]);
                return this.markAsUpdated(),
                this
            }
            minimizeInPlaceFromFloats(...e) {
                const t = this._m;
                for (let i = 0; i < 16; i++)
                    t[i] = Math.min(t[i], e[i]);
                return this.markAsUpdated(),
                this
            }
            maximizeInPlace(e) {
                const t = this._m
                  , i = e.m;
                for (let e = 0; e < 16; e++)
                    t[e] = Math.min(t[e], i[e]);
                return this.markAsUpdated(),
                this
            }
            maximizeInPlaceFromFloats(...e) {
                const t = this._m;
                for (let i = 0; i < 16; i++)
                    t[i] = Math.min(t[i], e[i]);
                return this.markAsUpdated(),
                this
            }
            negate() {
                return this.negateToRef(new this.constructor)
            }
            negateInPlace() {
                const e = this._m;
                for (let t = 0; t < 16; t++)
                    e[t] = -e[t];
                return this.markAsUpdated(),
                this
            }
            negateToRef(e) {
                const t = this._m
                  , i = e._m;
                for (let e = 0; e < 16; e++)
                    i[e] = -t[e];
                return e.markAsUpdated(),
                e
            }
            equals(e) {
                const t = e;
                if (!t)
                    return !1;
                if ((this._isIdentity || t._isIdentity) && !this._isIdentityDirty && !t._isIdentityDirty)
                    return this._isIdentity && t._isIdentity;
                const i = this.m
                  , s = t.m;
                return i[0] === s[0] && i[1] === s[1] && i[2] === s[2] && i[3] === s[3] && i[4] === s[4] && i[5] === s[5] && i[6] === s[6] && i[7] === s[7] && i[8] === s[8] && i[9] === s[9] && i[10] === s[10] && i[11] === s[11] && i[12] === s[12] && i[13] === s[13] && i[14] === s[14] && i[15] === s[15]
            }
            equalsWithEpsilon(e, t=0) {
                const i = this._m
                  , s = e.m;
                for (let e = 0; e < 16; e++)
                    if (!pe(i[e], s[e], t))
                        return !1;
                return !0
            }
            equalsToFloats(...e) {
                const t = this._m;
                for (let i = 0; i < 16; i++)
                    if (t[i] != e[i])
                        return !1;
                return !0
            }
            floor() {
                return this.floorToRef(new this.constructor)
            }
            floorToRef(e) {
                const t = this._m
                  , i = e._m;
                for (let e = 0; e < 16; e++)
                    i[e] = Math.floor(t[e]);
                return e.markAsUpdated(),
                e
            }
            fract() {
                return this.fractToRef(new this.constructor)
            }
            fractToRef(e) {
                const t = this._m
                  , i = e._m;
                for (let e = 0; e < 16; e++)
                    i[e] = t[e] - Math.floor(t[e]);
                return e.markAsUpdated(),
                e
            }
            clone() {
                const e = new this.constructor;
                return e.copyFrom(this),
                e
            }
            getClassName() {
                return "Matrix"
            }
            getHashCode() {
                let e = Ci(this._m[0]);
                for (let t = 1; t < 16; t++)
                    e = 397 * e ^ Ci(this._m[t]);
                return e
            }
            decomposeToTransformNode(e) {
                return e.rotationQuaternion = e.rotationQuaternion || new Fi,
                this.decompose(e.scaling, e.rotationQuaternion, e.position)
            }
            decompose(e, t, i, s, r=!0) {
                if (this._isIdentity)
                    return i && i.setAll(0),
                    e && e.setAll(1),
                    t && t.copyFromFloats(0, 0, 0, 1),
                    !0;
                const n = this._m;
                if (i && i.copyFromFloats(n[12], n[13], n[14]),
                (e = e || Li.Vector3[0]).x = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]),
                e.y = Math.sqrt(n[4] * n[4] + n[5] * n[5] + n[6] * n[6]),
                e.z = Math.sqrt(n[8] * n[8] + n[9] * n[9] + n[10] * n[10]),
                s) {
                    const t = (r ? s.absoluteScaling.x : s.scaling.x) < 0 ? -1 : 1
                      , i = (r ? s.absoluteScaling.y : s.scaling.y) < 0 ? -1 : 1
                      , n = (r ? s.absoluteScaling.z : s.scaling.z) < 0 ? -1 : 1;
                    e.x *= t,
                    e.y *= i,
                    e.z *= n
                } else
                    this.determinant() <= 0 && (e.y *= -1);
                if (0 === e._x || 0 === e._y || 0 === e._z)
                    return t && t.copyFromFloats(0, 0, 0, 1),
                    !1;
                if (t) {
                    const i = 1 / e._x
                      , s = 1 / e._y
                      , r = 1 / e._z;
                    Oi.FromValuesToRef(n[0] * i, n[1] * i, n[2] * i, 0, n[4] * s, n[5] * s, n[6] * s, 0, n[8] * r, n[9] * r, n[10] * r, 0, 0, 0, 0, 1, Li.Matrix[0]),
                    Fi.FromRotationMatrixToRef(Li.Matrix[0], t)
                }
                return !0
            }
            getRow(e) {
                if (e < 0 || e > 3)
                    return null;
                const t = 4 * e;
                return new wi(this._m[t + 0],this._m[t + 1],this._m[t + 2],this._m[t + 3])
            }
            getRowToRef(e, t) {
                if (e >= 0 && e <= 3) {
                    const i = 4 * e;
                    t.x = this._m[i + 0],
                    t.y = this._m[i + 1],
                    t.z = this._m[i + 2],
                    t.w = this._m[i + 3]
                }
                return t
            }
            setRow(e, t) {
                return this.setRowFromFloats(e, t.x, t.y, t.z, t.w)
            }
            transpose() {
                const e = new this.constructor;
                return Oi.TransposeToRef(this, e),
                e
            }
            transposeToRef(e) {
                return Oi.TransposeToRef(this, e),
                e
            }
            setRowFromFloats(e, t, i, s, r) {
                if (e < 0 || e > 3)
                    return this;
                const n = 4 * e;
                return this._m[n + 0] = t,
                this._m[n + 1] = i,
                this._m[n + 2] = s,
                this._m[n + 3] = r,
                this.markAsUpdated(),
                this
            }
            scale(e) {
                const t = new this.constructor;
                return this.scaleToRef(e, t),
                t
            }
            scaleToRef(e, t) {
                for (let i = 0; i < 16; i++)
                    t._m[i] = this._m[i] * e;
                return t.markAsUpdated(),
                t
            }
            scaleAndAddToRef(e, t) {
                for (let i = 0; i < 16; i++)
                    t._m[i] += this._m[i] * e;
                return t.markAsUpdated(),
                t
            }
            scaleInPlace(e) {
                const t = this._m;
                for (let i = 0; i < 16; i++)
                    t[i] *= e;
                return this.markAsUpdated(),
                this
            }
            toNormalMatrix(e) {
                const t = Li.Matrix[0];
                this.invertToRef(t),
                t.transposeToRef(e);
                const i = e._m;
                return Oi.FromValuesToRef(i[0], i[1], i[2], 0, i[4], i[5], i[6], 0, i[8], i[9], i[10], 0, 0, 0, 0, 1, e),
                e
            }
            getRotationMatrix() {
                const e = new this.constructor;
                return this.getRotationMatrixToRef(e),
                e
            }
            getRotationMatrixToRef(e) {
                const t = Li.Vector3[0];
                if (!this.decompose(t))
                    return Oi.IdentityToRef(e),
                    e;
                const i = this._m
                  , s = 1 / t._x
                  , r = 1 / t._y
                  , n = 1 / t._z;
                return Oi.FromValuesToRef(i[0] * s, i[1] * s, i[2] * s, 0, i[4] * r, i[5] * r, i[6] * r, 0, i[8] * n, i[9] * n, i[10] * n, 0, 0, 0, 0, 1, e),
                e
            }
            toggleModelMatrixHandInPlace() {
                const e = this._m;
                return e[2] *= -1,
                e[6] *= -1,
                e[8] *= -1,
                e[9] *= -1,
                e[14] *= -1,
                this.markAsUpdated(),
                this
            }
            toggleProjectionMatrixHandInPlace() {
                const e = this._m;
                return e[8] *= -1,
                e[9] *= -1,
                e[10] *= -1,
                e[11] *= -1,
                this.markAsUpdated(),
                this
            }
            static FromArray(e, t=0) {
                const i = new Oi;
                return Oi.FromArrayToRef(e, t, i),
                i
            }
            static FromArrayToRef(e, t, i) {
                for (let s = 0; s < 16; s++)
                    i._m[s] = e[s + t];
                return i.markAsUpdated(),
                i
            }
            static FromFloat32ArrayToRefScaled(e, t, i, s) {
                for (let r = 0; r < 16; r++)
                    s._m[r] = e[r + t] * i;
                return s.markAsUpdated(),
                s
            }
            static get IdentityReadOnly() {
                return Oi._IdentityReadOnly
            }
            static FromValuesToRef(e, t, i, s, r, n, a, o, h, l, c, u, d, f, _, p, m) {
                const g = m._m;
                g[0] = e,
                g[1] = t,
                g[2] = i,
                g[3] = s,
                g[4] = r,
                g[5] = n,
                g[6] = a,
                g[7] = o,
                g[8] = h,
                g[9] = l,
                g[10] = c,
                g[11] = u,
                g[12] = d,
                g[13] = f,
                g[14] = _,
                g[15] = p,
                m.markAsUpdated()
            }
            static FromValues(e, t, i, s, r, n, a, o, h, l, c, u, d, f, _, p) {
                const m = new Oi
                  , g = m._m;
                return g[0] = e,
                g[1] = t,
                g[2] = i,
                g[3] = s,
                g[4] = r,
                g[5] = n,
                g[6] = a,
                g[7] = o,
                g[8] = h,
                g[9] = l,
                g[10] = c,
                g[11] = u,
                g[12] = d,
                g[13] = f,
                g[14] = _,
                g[15] = p,
                m.markAsUpdated(),
                m
            }
            static Compose(e, t, i) {
                const s = new Oi;
                return Oi.ComposeToRef(e, t, i, s),
                s
            }
            static ComposeToRef(e, t, i, s) {
                const r = s._m
                  , n = t._x
                  , a = t._y
                  , o = t._z
                  , h = t._w
                  , l = n + n
                  , c = a + a
                  , u = o + o
                  , d = n * l
                  , f = n * c
                  , _ = n * u
                  , p = a * c
                  , m = a * u
                  , g = o * u
                  , v = h * l
                  , y = h * c
                  , b = h * u
                  , x = e._x
                  , T = e._y
                  , E = e._z;
                return r[0] = (1 - (p + g)) * x,
                r[1] = (f + b) * x,
                r[2] = (_ - y) * x,
                r[3] = 0,
                r[4] = (f - b) * T,
                r[5] = (1 - (d + g)) * T,
                r[6] = (m + v) * T,
                r[7] = 0,
                r[8] = (_ + y) * E,
                r[9] = (m - v) * E,
                r[10] = (1 - (d + p)) * E,
                r[11] = 0,
                r[12] = i._x,
                r[13] = i._y,
                r[14] = i._z,
                r[15] = 1,
                s.markAsUpdated(),
                s
            }
            static Identity() {
                const e = Oi.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
                return e._updateIdentityStatus(!0),
                e
            }
            static IdentityToRef(e) {
                return Oi.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, e),
                e._updateIdentityStatus(!0),
                e
            }
            static Zero() {
                const e = Oi.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
                return e._updateIdentityStatus(!1),
                e
            }
            static RotationX(e) {
                const t = new Oi;
                return Oi.RotationXToRef(e, t),
                t
            }
            static Invert(e) {
                const t = new e.constructor;
                return e.invertToRef(t),
                t
            }
            static RotationXToRef(e, t) {
                const i = Math.sin(e)
                  , s = Math.cos(e);
                return Oi.FromValuesToRef(1, 0, 0, 0, 0, s, i, 0, 0, -i, s, 0, 0, 0, 0, 1, t),
                t._updateIdentityStatus(1 === s && 0 === i),
                t
            }
            static RotationY(e) {
                const t = new Oi;
                return Oi.RotationYToRef(e, t),
                t
            }
            static RotationYToRef(e, t) {
                const i = Math.sin(e)
                  , s = Math.cos(e);
                return Oi.FromValuesToRef(s, 0, -i, 0, 0, 1, 0, 0, i, 0, s, 0, 0, 0, 0, 1, t),
                t._updateIdentityStatus(1 === s && 0 === i),
                t
            }
            static RotationZ(e) {
                const t = new Oi;
                return Oi.RotationZToRef(e, t),
                t
            }
            static RotationZToRef(e, t) {
                const i = Math.sin(e)
                  , s = Math.cos(e);
                return Oi.FromValuesToRef(s, i, 0, 0, -i, s, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, t),
                t._updateIdentityStatus(1 === s && 0 === i),
                t
            }
            static RotationAxis(e, t) {
                const i = new Oi;
                return Oi.RotationAxisToRef(e, t, i),
                i
            }
            static RotationAxisToRef(e, t, i) {
                const s = Math.sin(-t)
                  , r = Math.cos(-t)
                  , n = 1 - r;
                e.normalize();
                const a = i._m;
                return a[0] = e._x * e._x * n + r,
                a[1] = e._x * e._y * n - e._z * s,
                a[2] = e._x * e._z * n + e._y * s,
                a[3] = 0,
                a[4] = e._y * e._x * n + e._z * s,
                a[5] = e._y * e._y * n + r,
                a[6] = e._y * e._z * n - e._x * s,
                a[7] = 0,
                a[8] = e._z * e._x * n - e._y * s,
                a[9] = e._z * e._y * n + e._x * s,
                a[10] = e._z * e._z * n + r,
                a[11] = 0,
                a[12] = 0,
                a[13] = 0,
                a[14] = 0,
                a[15] = 1,
                i.markAsUpdated(),
                i
            }
            static RotationAlignToRef(e, t, i, s=!1) {
                const r = Di.Dot(t, e)
                  , n = i._m;
                if (r < -.999)
                    n[0] = -1,
                    n[1] = 0,
                    n[2] = 0,
                    n[3] = 0,
                    n[4] = 0,
                    n[5] = s ? 1 : -1,
                    n[6] = 0,
                    n[7] = 0,
                    n[8] = 0,
                    n[9] = 0,
                    n[10] = s ? -1 : 1,
                    n[11] = 0;
                else {
                    const i = Di.Cross(t, e)
                      , s = 1 / (1 + r);
                    n[0] = i._x * i._x * s + r,
                    n[1] = i._y * i._x * s - i._z,
                    n[2] = i._z * i._x * s + i._y,
                    n[3] = 0,
                    n[4] = i._x * i._y * s + i._z,
                    n[5] = i._y * i._y * s + r,
                    n[6] = i._z * i._y * s - i._x,
                    n[7] = 0,
                    n[8] = i._x * i._z * s - i._y,
                    n[9] = i._y * i._z * s + i._x,
                    n[10] = i._z * i._z * s + r,
                    n[11] = 0
                }
                return n[12] = 0,
                n[13] = 0,
                n[14] = 0,
                n[15] = 1,
                i.markAsUpdated(),
                i
            }
            static RotationYawPitchRoll(e, t, i) {
                const s = new Oi;
                return Oi.RotationYawPitchRollToRef(e, t, i, s),
                s
            }
            static RotationYawPitchRollToRef(e, t, i, s) {
                return Fi.RotationYawPitchRollToRef(e, t, i, Li.Quaternion[0]),
                Li.Quaternion[0].toRotationMatrix(s),
                s
            }
            static Scaling(e, t, i) {
                const s = new Oi;
                return Oi.ScalingToRef(e, t, i, s),
                s
            }
            static ScalingToRef(e, t, i, s) {
                return Oi.FromValuesToRef(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1, s),
                s._updateIdentityStatus(1 === e && 1 === t && 1 === i),
                s
            }
            static Translation(e, t, i) {
                const s = new Oi;
                return Oi.TranslationToRef(e, t, i, s),
                s
            }
            static TranslationToRef(e, t, i, s) {
                return Oi.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, i, 1, s),
                s._updateIdentityStatus(0 === e && 0 === t && 0 === i),
                s
            }
            static Lerp(e, t, i) {
                const s = new e.constructor;
                return Oi.LerpToRef(e, t, i, s),
                s
            }
            static LerpToRef(e, t, i, s) {
                const r = s._m
                  , n = e.m
                  , a = t.m;
                for (let e = 0; e < 16; e++)
                    r[e] = n[e] * (1 - i) + a[e] * i;
                return s.markAsUpdated(),
                s
            }
            static DecomposeLerp(e, t, i) {
                const s = new e.constructor;
                return Oi.DecomposeLerpToRef(e, t, i, s),
                s
            }
            static DecomposeLerpToRef(e, t, i, s) {
                const r = Li.Vector3[0]
                  , n = Li.Quaternion[0]
                  , a = Li.Vector3[1];
                e.decompose(r, n, a);
                const o = Li.Vector3[2]
                  , h = Li.Quaternion[1]
                  , l = Li.Vector3[3];
                t.decompose(o, h, l);
                const c = Li.Vector3[4];
                Di.LerpToRef(r, o, i, c);
                const u = Li.Quaternion[2];
                Fi.SlerpToRef(n, h, i, u);
                const d = Li.Vector3[5];
                return Di.LerpToRef(a, l, i, d),
                Oi.ComposeToRef(c, u, d, s),
                s
            }
            static LookAtLH(e, t, i) {
                const s = new Oi;
                return Oi.LookAtLHToRef(e, t, i, s),
                s
            }
            static LookAtLHToRef(e, t, i, s) {
                const r = Li.Vector3[0]
                  , n = Li.Vector3[1]
                  , a = Li.Vector3[2];
                t.subtractToRef(e, a),
                a.normalize(),
                Di.CrossToRef(i, a, r);
                const o = r.lengthSquared();
                0 === o ? r.x = 1 : r.normalizeFromLength(Math.sqrt(o)),
                Di.CrossToRef(a, r, n),
                n.normalize();
                const h = -Di.Dot(r, e)
                  , l = -Di.Dot(n, e)
                  , c = -Di.Dot(a, e);
                return Oi.FromValuesToRef(r._x, n._x, a._x, 0, r._y, n._y, a._y, 0, r._z, n._z, a._z, 0, h, l, c, 1, s),
                s
            }
            static LookAtRH(e, t, i) {
                const s = new Oi;
                return Oi.LookAtRHToRef(e, t, i, s),
                s
            }
            static LookAtRHToRef(e, t, i, s) {
                const r = Li.Vector3[0]
                  , n = Li.Vector3[1]
                  , a = Li.Vector3[2];
                e.subtractToRef(t, a),
                a.normalize(),
                Di.CrossToRef(i, a, r);
                const o = r.lengthSquared();
                0 === o ? r.x = 1 : r.normalizeFromLength(Math.sqrt(o)),
                Di.CrossToRef(a, r, n),
                n.normalize();
                const h = -Di.Dot(r, e)
                  , l = -Di.Dot(n, e)
                  , c = -Di.Dot(a, e);
                return Oi.FromValuesToRef(r._x, n._x, a._x, 0, r._y, n._y, a._y, 0, r._z, n._z, a._z, 0, h, l, c, 1, s),
                s
            }
            static LookDirectionLH(e, t) {
                const i = new Oi;
                return Oi.LookDirectionLHToRef(e, t, i),
                i
            }
            static LookDirectionLHToRef(e, t, i) {
                const s = Li.Vector3[0];
                s.copyFrom(e),
                s.scaleInPlace(-1);
                const r = Li.Vector3[1];
                return Di.CrossToRef(t, s, r),
                Oi.FromValuesToRef(r._x, r._y, r._z, 0, t._x, t._y, t._z, 0, s._x, s._y, s._z, 0, 0, 0, 0, 1, i),
                i
            }
            static LookDirectionRH(e, t) {
                const i = new Oi;
                return Oi.LookDirectionRHToRef(e, t, i),
                i
            }
            static LookDirectionRHToRef(e, t, i) {
                const s = Li.Vector3[2];
                return Di.CrossToRef(t, e, s),
                Oi.FromValuesToRef(s._x, s._y, s._z, 0, t._x, t._y, t._z, 0, e._x, e._y, e._z, 0, 0, 0, 0, 1, i),
                i
            }
            static OrthoLH(e, t, i, s, r) {
                const n = new Oi;
                return Oi.OrthoLHToRef(e, t, i, s, n, r),
                n
            }
            static OrthoLHToRef(e, t, i, s, r, n) {
                const a = 2 / e
                  , o = 2 / t
                  , h = 2 / (s - i)
                  , l = -(s + i) / (s - i);
                return Oi.FromValuesToRef(a, 0, 0, 0, 0, o, 0, 0, 0, 0, h, 0, 0, 0, l, 1, r),
                n && r.multiplyToRef(Ni, r),
                r._updateIdentityStatus(1 === a && 1 === o && 1 === h && 0 === l),
                r
            }
            static OrthoOffCenterLH(e, t, i, s, r, n, a) {
                const o = new Oi;
                return Oi.OrthoOffCenterLHToRef(e, t, i, s, r, n, o, a),
                o
            }
            static OrthoOffCenterLHToRef(e, t, i, s, r, n, a, o) {
                const h = 2 / (t - e)
                  , l = 2 / (s - i)
                  , c = 2 / (n - r)
                  , u = -(n + r) / (n - r)
                  , d = (e + t) / (e - t)
                  , f = (s + i) / (i - s);
                return Oi.FromValuesToRef(h, 0, 0, 0, 0, l, 0, 0, 0, 0, c, 0, d, f, u, 1, a),
                o && a.multiplyToRef(Ni, a),
                a.markAsUpdated(),
                a
            }
            static ObliqueOffCenterLHToRef(e, t, i, s, r, n, a, o, h, l, c) {
                const u = -a * Math.cos(o)
                  , d = -a * Math.sin(o);
                return Oi.TranslationToRef(0, 0, -h, Li.Matrix[1]),
                Oi.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, u, d, 1, 0, 0, 0, 0, 1, Li.Matrix[0]),
                Li.Matrix[1].multiplyToRef(Li.Matrix[0], Li.Matrix[0]),
                Oi.TranslationToRef(0, 0, h, Li.Matrix[1]),
                Li.Matrix[0].multiplyToRef(Li.Matrix[1], Li.Matrix[0]),
                Oi.OrthoOffCenterLHToRef(e, t, i, s, r, n, l, c),
                Li.Matrix[0].multiplyToRef(l, l),
                l
            }
            static OrthoOffCenterRH(e, t, i, s, r, n, a) {
                const o = new Oi;
                return Oi.OrthoOffCenterRHToRef(e, t, i, s, r, n, o, a),
                o
            }
            static OrthoOffCenterRHToRef(e, t, i, s, r, n, a, o) {
                return Oi.OrthoOffCenterLHToRef(e, t, i, s, r, n, a, o),
                a._m[10] *= -1,
                a
            }
            static ObliqueOffCenterRHToRef(e, t, i, s, r, n, a, o, h, l, c) {
                const u = a * Math.cos(o)
                  , d = a * Math.sin(o);
                return Oi.TranslationToRef(0, 0, h, Li.Matrix[1]),
                Oi.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, u, d, 1, 0, 0, 0, 0, 1, Li.Matrix[0]),
                Li.Matrix[1].multiplyToRef(Li.Matrix[0], Li.Matrix[0]),
                Oi.TranslationToRef(0, 0, -h, Li.Matrix[1]),
                Li.Matrix[0].multiplyToRef(Li.Matrix[1], Li.Matrix[0]),
                Oi.OrthoOffCenterRHToRef(e, t, i, s, r, n, l, c),
                Li.Matrix[0].multiplyToRef(l, l),
                l
            }
            static PerspectiveLH(e, t, i, s, r, n=0) {
                const a = new Oi
                  , o = 2 * i / e
                  , h = 2 * i / t
                  , l = (s + i) / (s - i)
                  , c = -2 * s * i / (s - i)
                  , u = Math.tan(n);
                return Oi.FromValuesToRef(o, 0, 0, 0, 0, h, 0, u, 0, 0, l, 1, 0, 0, c, 0, a),
                r && a.multiplyToRef(Ni, a),
                a._updateIdentityStatus(!1),
                a
            }
            static PerspectiveFovLH(e, t, i, s, r, n=0, a=!1) {
                const o = new Oi;
                return Oi.PerspectiveFovLHToRef(e, t, i, s, o, !0, r, n, a),
                o
            }
            static PerspectiveFovLHToRef(e, t, i, s, r, n=!0, a, o=0, h=!1) {
                const l = i
                  , c = s
                  , u = 1 / Math.tan(.5 * e)
                  , d = n ? u / t : u
                  , f = n ? u : u * t
                  , _ = h && 0 === l ? -1 : 0 !== c ? (c + l) / (c - l) : 1
                  , p = h && 0 === l ? 2 * c : 0 !== c ? -2 * c * l / (c - l) : -2 * l
                  , m = Math.tan(o);
                return Oi.FromValuesToRef(d, 0, 0, 0, 0, f, 0, m, 0, 0, _, 1, 0, 0, p, 0, r),
                a && r.multiplyToRef(Ni, r),
                r._updateIdentityStatus(!1),
                r
            }
            static PerspectiveFovReverseLHToRef(e, t, i, s, r, n=!0, a, o=0) {
                const h = 1 / Math.tan(.5 * e)
                  , l = n ? h / t : h
                  , c = n ? h : h * t
                  , u = Math.tan(o);
                return Oi.FromValuesToRef(l, 0, 0, 0, 0, c, 0, u, 0, 0, -i, 1, 0, 0, 1, 0, r),
                a && r.multiplyToRef(Ni, r),
                r._updateIdentityStatus(!1),
                r
            }
            static PerspectiveFovRH(e, t, i, s, r, n=0, a=!1) {
                const o = new Oi;
                return Oi.PerspectiveFovRHToRef(e, t, i, s, o, !0, r, n, a),
                o
            }
            static PerspectiveFovRHToRef(e, t, i, s, r, n=!0, a, o=0, h=!1) {
                const l = i
                  , c = s
                  , u = 1 / Math.tan(.5 * e)
                  , d = n ? u / t : u
                  , f = n ? u : u * t
                  , _ = h && 0 === l ? 1 : 0 !== c ? -(c + l) / (c - l) : -1
                  , p = h && 0 === l ? 2 * c : 0 !== c ? -2 * c * l / (c - l) : -2 * l
                  , m = Math.tan(o);
                return Oi.FromValuesToRef(d, 0, 0, 0, 0, f, 0, m, 0, 0, _, -1, 0, 0, p, 0, r),
                a && r.multiplyToRef(Ni, r),
                r._updateIdentityStatus(!1),
                r
            }
            static PerspectiveFovReverseRHToRef(e, t, i, s, r, n=!0, a, o=0) {
                const h = 1 / Math.tan(.5 * e)
                  , l = n ? h / t : h
                  , c = n ? h : h * t
                  , u = Math.tan(o);
                return Oi.FromValuesToRef(l, 0, 0, 0, 0, c, 0, u, 0, 0, -i, -1, 0, 0, -1, 0, r),
                a && r.multiplyToRef(Ni, r),
                r._updateIdentityStatus(!1),
                r
            }
            static GetFinalMatrix(e, t, i, s, r, n) {
                const a = e.width
                  , o = e.height
                  , h = e.x
                  , l = e.y
                  , c = Oi.FromValues(a / 2, 0, 0, 0, 0, -o / 2, 0, 0, 0, 0, n - r, 0, h + a / 2, o / 2 + l, r, 1)
                  , u = new t.constructor;
                return t.multiplyToRef(i, u),
                u.multiplyToRef(s, u),
                u.multiplyToRef(c, u)
            }
            static GetAsMatrix2x2(e) {
                const t = e.m
                  , i = [t[0], t[1], t[4], t[5]];
                return Ot.MatrixUse64Bits ? i : new Float32Array(i)
            }
            static GetAsMatrix3x3(e) {
                const t = e.m
                  , i = [t[0], t[1], t[2], t[4], t[5], t[6], t[8], t[9], t[10]];
                return Ot.MatrixUse64Bits ? i : new Float32Array(i)
            }
            static Transpose(e) {
                const t = new e.constructor;
                return Oi.TransposeToRef(e, t),
                t
            }
            static TransposeToRef(e, t) {
                const i = e.m
                  , s = i[0]
                  , r = i[4]
                  , n = i[8]
                  , a = i[12]
                  , o = i[1]
                  , h = i[5]
                  , l = i[9]
                  , c = i[13]
                  , u = i[2]
                  , d = i[6]
                  , f = i[10]
                  , _ = i[14]
                  , p = i[3]
                  , m = i[7]
                  , g = i[11]
                  , v = i[15]
                  , y = t._m;
                return y[0] = s,
                y[1] = r,
                y[2] = n,
                y[3] = a,
                y[4] = o,
                y[5] = h,
                y[6] = l,
                y[7] = c,
                y[8] = u,
                y[9] = d,
                y[10] = f,
                y[11] = _,
                y[12] = p,
                y[13] = m,
                y[14] = g,
                y[15] = v,
                t.markAsUpdated(),
                t._updateIdentityStatus(e._isIdentity, e._isIdentityDirty),
                t
            }
            static Reflection(e) {
                const t = new Oi;
                return Oi.ReflectionToRef(e, t),
                t
            }
            static ReflectionToRef(e, t) {
                e.normalize();
                const i = e.normal.x
                  , s = e.normal.y
                  , r = e.normal.z
                  , n = -2 * i
                  , a = -2 * s
                  , o = -2 * r;
                return Oi.FromValuesToRef(n * i + 1, a * i, o * i, 0, n * s, a * s + 1, o * s, 0, n * r, a * r, o * r + 1, 0, n * e.d, a * e.d, o * e.d, 1, t),
                t
            }
            static FromXYZAxesToRef(e, t, i, s) {
                return Oi.FromValuesToRef(e._x, e._y, e._z, 0, t._x, t._y, t._z, 0, i._x, i._y, i._z, 0, 0, 0, 0, 1, s),
                s
            }
            static FromQuaternionToRef(e, t) {
                const i = e._x * e._x
                  , s = e._y * e._y
                  , r = e._z * e._z
                  , n = e._x * e._y
                  , a = e._z * e._w
                  , o = e._z * e._x
                  , h = e._y * e._w
                  , l = e._y * e._z
                  , c = e._x * e._w;
                return t._m[0] = 1 - 2 * (s + r),
                t._m[1] = 2 * (n + a),
                t._m[2] = 2 * (o - h),
                t._m[3] = 0,
                t._m[4] = 2 * (n - a),
                t._m[5] = 1 - 2 * (r + i),
                t._m[6] = 2 * (l + c),
                t._m[7] = 0,
                t._m[8] = 2 * (o + h),
                t._m[9] = 2 * (l - c),
                t._m[10] = 1 - 2 * (s + i),
                t._m[11] = 0,
                t._m[12] = 0,
                t._m[13] = 0,
                t._m[14] = 0,
                t._m[15] = 1,
                t.markAsUpdated(),
                t
            }
        }
        Oi._UpdateFlagSeed = 0,
        Oi._IdentityReadOnly = Oi.Identity(),
        Object.defineProperties(Oi.prototype, {
            dimension: {
                value: [4, 4]
            },
            rank: {
                value: 2
            }
        });
        class Li {
        }
        Li.Vector3 = Me.BuildTuple(11, Di.Zero),
        Li.Matrix = Me.BuildTuple(2, Oi.Identity),
        Li.Quaternion = Me.BuildTuple(3, Fi.Zero);
        class Bi {
        }
        Bi.Vector2 = Me.BuildTuple(3, Pi.Zero),
        Bi.Vector3 = Me.BuildTuple(13, Di.Zero),
        Bi.Vector4 = Me.BuildTuple(3, wi.Zero),
        Bi.Quaternion = Me.BuildTuple(2, Fi.Zero),
        Bi.Matrix = Me.BuildTuple(8, Oi.Identity),
        Ie("BABYLON.Vector2", Pi),
        Ie("BABYLON.Vector3", Di),
        Ie("BABYLON.Vector4", wi),
        Ie("BABYLON.Matrix", Oi);
        const Ni = Oi.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, .5, 0, 0, 0, .5, 1)
          , Ui = function(e, t, i, s={}) {
            const r = e();
            ui && ui.HasTags(t) && ui.AddTagsTo(r, ui.GetTags(t, !0));
            const n = vi(r)
              , a = {};
            for (const e in n) {
                const o = n[e]
                  , h = t[e]
                  , l = o.type;
                if (null != h && ("uniqueId" !== e || ki.AllowLoadingUniqueId))
                    switch (l) {
                    case 0:
                    case 6:
                    case 11:
                        r[e] = h;
                        break;
                    case 1:
                        s.cloneTexturesOnlyOnce && a[h.uniqueId] ? r[e] = a[h.uniqueId] : (r[e] = i || h.isRenderTarget ? h : h.clone(),
                        a[h.uniqueId] = r[e]);
                        break;
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 7:
                    case 10:
                    case 12:
                        r[e] = i ? h : h.clone()
                    }
            }
            return r
        };
        class ki {
            static AppendSerializedAnimations(e, t) {
                if (e.animations) {
                    t.animations = [];
                    for (let i = 0; i < e.animations.length; i++) {
                        const s = e.animations[i];
                        t.animations.push(s.serialize())
                    }
                }
            }
            static Serialize(e, t) {
                t || (t = {}),
                ui && (t.tags = ui.GetTags(e));
                const i = vi(e);
                for (const s in i) {
                    const r = i[s]
                      , n = r.sourceName || s
                      , a = r.type
                      , o = e[s];
                    if (null != o && ("uniqueId" !== s || ki.AllowLoadingUniqueId))
                        switch (a) {
                        case 0:
                            t[n] = o;
                            break;
                        case 1:
                        case 3:
                        case 7:
                        case 9:
                            t[n] = o.serialize();
                            break;
                        case 2:
                        case 4:
                        case 5:
                        case 8:
                        case 10:
                        case 12:
                            t[n] = o.asArray();
                            break;
                        case 6:
                        case 11:
                            t[n] = o.id
                        }
                }
                return t
            }
            static ParseProperties(e, t, i, s) {
                s || (s = "");
                const r = vi(t);
                for (const n in r) {
                    const a = r[n]
                      , o = e[a.sourceName || n]
                      , h = a.type;
                    if (null != o && ("uniqueId" !== n || ki.AllowLoadingUniqueId)) {
                        const e = t;
                        switch (h) {
                        case 0:
                            e[n] = o;
                            break;
                        case 1:
                            i && (e[n] = ki._TextureParser(o, i, s));
                            break;
                        case 2:
                            e[n] = Fe.FromArray(o);
                            break;
                        case 3:
                            e[n] = ki._FresnelParametersParser(o);
                            break;
                        case 4:
                            e[n] = Pi.FromArray(o);
                            break;
                        case 5:
                            e[n] = Di.FromArray(o);
                            break;
                        case 6:
                            i && (e[n] = i.getLastMeshById(o));
                            break;
                        case 7:
                            e[n] = ki._ColorCurvesParser(o);
                            break;
                        case 8:
                            e[n] = Oe.FromArray(o);
                            break;
                        case 9:
                            e[n] = ki._ImageProcessingConfigurationParser(o);
                            break;
                        case 10:
                            e[n] = Fi.FromArray(o);
                            break;
                        case 11:
                            i && (e[n] = i.getCameraById(o));
                            break;
                        case 12:
                            e[n] = Oi.FromArray(o)
                        }
                    }
                }
            }
            static Parse(e, t, i, s=null) {
                const r = e();
                return ui && ui.AddTagsTo(r, t.tags),
                ki.ParseProperties(t, r, i, s),
                r
            }
            static Clone(e, t, i={}) {
                return Ui(e, t, !1, i)
            }
            static Instanciate(e, t) {
                return Ui(e, t, !0)
            }
        }
        ki.AllowLoadingUniqueId = !1,
        ki._ImageProcessingConfigurationParser = e => {
            throw je("ImageProcessingConfiguration")
        }
        ,
        ki._FresnelParametersParser = e => {
            throw je("FresnelParameters")
        }
        ,
        ki._ColorCurvesParser = e => {
            throw je("ColorCurves")
        }
        ,
        ki._TextureParser = (e, t, i) => {
            throw je("Texture")
        }
        ;
        class Vi {
            constructor() {
                this._doNotSerialize = !1,
                this._isDisposed = !1,
                this._sceneRootNodesIndex = -1,
                this._isEnabled = !0,
                this._isParentEnabled = !0,
                this._isReady = !0,
                this._onEnabledStateChangedObservable = new Ue,
                this._onClonedObservable = new Ue
            }
        }
        class Gi {
            static AddNodeConstructor(e, t) {
                this._NodeConstructors[e] = t
            }
            static Construct(e, t, i, s) {
                const r = this._NodeConstructors[e];
                return r ? r(t, i, s) : null
            }
            set accessibilityTag(e) {
                this._accessibilityTag = e,
                this.onAccessibilityTagChangedObservable.notifyObservers(e)
            }
            get accessibilityTag() {
                return this._accessibilityTag
            }
            get doNotSerialize() {
                return !!this._nodeDataStorage._doNotSerialize || !!this._parentNode && this._parentNode.doNotSerialize
            }
            set doNotSerialize(e) {
                this._nodeDataStorage._doNotSerialize = e
            }
            isDisposed() {
                return this._nodeDataStorage._isDisposed
            }
            set parent(e) {
                if (this._parentNode === e)
                    return;
                const t = this._parentNode;
                if (this._parentNode && void 0 !== this._parentNode._children && null !== this._parentNode._children) {
                    const t = this._parentNode._children.indexOf(this);
                    -1 !== t && this._parentNode._children.splice(t, 1),
                    e || this._nodeDataStorage._isDisposed || this._addToSceneRootNodes()
                }
                this._parentNode = e,
                this._parentNode && (void 0 !== this._parentNode._children && null !== this._parentNode._children || (this._parentNode._children = new Array),
                this._parentNode._children.push(this),
                t || this._removeFromSceneRootNodes()),
                this._syncParentEnabledState()
            }
            get parent() {
                return this._parentNode
            }
            _serializeAsParent(e) {
                e.parentId = this.uniqueId
            }
            _addToSceneRootNodes() {
                -1 === this._nodeDataStorage._sceneRootNodesIndex && (this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length,
                this._scene.rootNodes.push(this))
            }
            _removeFromSceneRootNodes() {
                if (-1 !== this._nodeDataStorage._sceneRootNodesIndex) {
                    const e = this._scene.rootNodes
                      , t = e.length - 1;
                    e[this._nodeDataStorage._sceneRootNodesIndex] = e[t],
                    e[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex,
                    this._scene.rootNodes.pop(),
                    this._nodeDataStorage._sceneRootNodesIndex = -1
                }
            }
            get animationPropertiesOverride() {
                return this._animationPropertiesOverride ? this._animationPropertiesOverride : this._scene.animationPropertiesOverride
            }
            set animationPropertiesOverride(e) {
                this._animationPropertiesOverride = e
            }
            getClassName() {
                return "Node"
            }
            set onDispose(e) {
                this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver),
                this._onDisposeObserver = this.onDisposeObservable.add(e)
            }
            get onEnabledStateChangedObservable() {
                return this._nodeDataStorage._onEnabledStateChangedObservable
            }
            get onClonedObservable() {
                return this._nodeDataStorage._onClonedObservable
            }
            constructor(e, t=null) {
                this._isDirty = !1,
                this._nodeDataStorage = new Vi,
                this.state = "",
                this.metadata = null,
                this.reservedDataStore = null,
                this._accessibilityTag = null,
                this.onAccessibilityTagChangedObservable = new Ue,
                this._parentContainer = null,
                this.animations = [],
                this._ranges = {},
                this.onReady = null,
                this._currentRenderId = -1,
                this._parentUpdateId = -1,
                this._childUpdateId = -1,
                this._waitingParentId = null,
                this._waitingParentInstanceIndex = null,
                this._waitingParsedUniqueId = null,
                this._cache = {},
                this._parentNode = null,
                this._children = null,
                this._worldMatrix = Oi.Identity(),
                this._worldMatrixDeterminant = 0,
                this._worldMatrixDeterminantIsDirty = !0,
                this._animationPropertiesOverride = null,
                this._isNode = !0,
                this.onDisposeObservable = new Ue,
                this._onDisposeObserver = null,
                this._behaviors = new Array,
                this.name = e,
                this.id = e,
                this._scene = t || Ze.LastCreatedScene,
                this.uniqueId = this._scene.getUniqueId(),
                this._initCache()
            }
            getScene() {
                return this._scene
            }
            getEngine() {
                return this._scene.getEngine()
            }
            addBehavior(e, t=!1) {
                return -1 !== this._behaviors.indexOf(e) || (e.init(),
                this._scene.isLoading && !t ? this._scene.onDataLoadedObservable.addOnce(( () => {
                    e.attach(this)
                }
                )) : e.attach(this),
                this._behaviors.push(e)),
                this
            }
            removeBehavior(e) {
                const t = this._behaviors.indexOf(e);
                return -1 === t || (this._behaviors[t].detach(),
                this._behaviors.splice(t, 1)),
                this
            }
            get behaviors() {
                return this._behaviors
            }
            getBehaviorByName(e) {
                for (const t of this._behaviors)
                    if (t.name === e)
                        return t;
                return null
            }
            getWorldMatrix() {
                return this._currentRenderId !== this._scene.getRenderId() && this.computeWorldMatrix(),
                this._worldMatrix
            }
            _getWorldMatrixDeterminant() {
                return this._worldMatrixDeterminantIsDirty && (this._worldMatrixDeterminantIsDirty = !1,
                this._worldMatrixDeterminant = this._worldMatrix.determinant()),
                this._worldMatrixDeterminant
            }
            get worldMatrixFromCache() {
                return this._worldMatrix
            }
            _initCache() {
                this._cache = {},
                this._cache.parent = void 0
            }
            updateCache(e) {
                !e && this.isSynchronized() || (this._cache.parent = this.parent,
                this._updateCache())
            }
            _getActionManagerForTrigger(e, t=!0) {
                return this.parent ? this.parent._getActionManagerForTrigger(e, !1) : null
            }
            _updateCache(e) {}
            _isSynchronized() {
                return !0
            }
            _markSyncedWithParent() {
                this._parentNode && (this._parentUpdateId = this._parentNode._childUpdateId)
            }
            isSynchronizedWithParent() {
                return !this._parentNode || !this._parentNode._isDirty && this._parentUpdateId === this._parentNode._childUpdateId && this._parentNode.isSynchronized()
            }
            isSynchronized() {
                return this._cache.parent !== this._parentNode ? (this._cache.parent = this._parentNode,
                !1) : !(this._parentNode && !this.isSynchronizedWithParent()) && this._isSynchronized()
            }
            isReady(e=!1) {
                return this._nodeDataStorage._isReady
            }
            markAsDirty(e) {
                return this._currentRenderId = Number.MAX_VALUE,
                this._isDirty = !0,
                this
            }
            isEnabled(e=!0) {
                return !1 === e ? this._nodeDataStorage._isEnabled : !!this._nodeDataStorage._isEnabled && this._nodeDataStorage._isParentEnabled
            }
            _syncParentEnabledState() {
                this._nodeDataStorage._isParentEnabled = !this._parentNode || this._parentNode.isEnabled(),
                this._children && this._children.forEach((e => {
                    e._syncParentEnabledState()
                }
                ))
            }
            setEnabled(e) {
                this._nodeDataStorage._isEnabled !== e && (this._nodeDataStorage._isEnabled = e,
                this._syncParentEnabledState(),
                this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(e))
            }
            isDescendantOf(e) {
                return !!this.parent && (this.parent === e || this.parent.isDescendantOf(e))
            }
            _getDescendants(e, t=!1, i) {
                if (this._children)
                    for (let s = 0; s < this._children.length; s++) {
                        const r = this._children[s];
                        i && !i(r) || e.push(r),
                        t || r._getDescendants(e, !1, i)
                    }
            }
            getDescendants(e, t) {
                const i = [];
                return this._getDescendants(i, e, t),
                i
            }
            getChildMeshes(e, t) {
                const i = [];
                return this._getDescendants(i, e, (e => (!t || t(e)) && void 0 !== e.cullingStrategy)),
                i
            }
            getChildren(e, t=!0) {
                return this.getDescendants(t, e)
            }
            _setReady(e) {
                e !== this._nodeDataStorage._isReady && (e ? (this.onReady && this.onReady(this),
                this._nodeDataStorage._isReady = !0) : this._nodeDataStorage._isReady = !1)
            }
            getAnimationByName(e) {
                for (let t = 0; t < this.animations.length; t++) {
                    const i = this.animations[t];
                    if (i.name === e)
                        return i
                }
                return null
            }
            createAnimationRange(e, t, i) {
                if (!this._ranges[e]) {
                    this._ranges[e] = Gi._AnimationRangeFactory(e, t, i);
                    for (let s = 0, r = this.animations.length; s < r; s++)
                        this.animations[s] && this.animations[s].createRange(e, t, i)
                }
            }
            deleteAnimationRange(e, t=!0) {
                for (let i = 0, s = this.animations.length; i < s; i++)
                    this.animations[i] && this.animations[i].deleteRange(e, t);
                this._ranges[e] = null
            }
            getAnimationRange(e) {
                return this._ranges[e] || null
            }
            clone(e, t, i) {
                const s = ki.Clone(( () => new Gi(e,this.getScene())), this);
                if (t && (s.parent = t),
                !i) {
                    const t = this.getDescendants(!0);
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i];
                        r.clone(e + "." + r.name, s)
                    }
                }
                return s
            }
            getAnimationRanges() {
                const e = [];
                let t;
                for (t in this._ranges)
                    e.push(this._ranges[t]);
                return e
            }
            beginAnimation(e, t, i, s) {
                const r = this.getAnimationRange(e);
                return r ? this._scene.beginAnimation(this, r.from, r.to, t, i, s) : null
            }
            serializeAnimationRanges() {
                const e = [];
                for (const t in this._ranges) {
                    const i = this._ranges[t];
                    if (!i)
                        continue;
                    const s = {};
                    s.name = t,
                    s.from = i.from,
                    s.to = i.to,
                    e.push(s)
                }
                return e
            }
            computeWorldMatrix(e) {
                return this._worldMatrix || (this._worldMatrix = Oi.Identity()),
                this._worldMatrix
            }
            dispose(e, t=!1) {
                if (this._nodeDataStorage._isDisposed = !0,
                !e) {
                    const i = this.getDescendants(!0);
                    for (const s of i)
                        s.dispose(e, t)
                }
                this.parent ? this.parent = null : this._removeFromSceneRootNodes(),
                this.onDisposeObservable.notifyObservers(this),
                this.onDisposeObservable.clear(),
                this.onEnabledStateChangedObservable.clear(),
                this.onClonedObservable.clear();
                for (const e of this._behaviors)
                    e.detach();
                this._behaviors.length = 0,
                this.metadata = null
            }
            static ParseAnimationRanges(e, t, i) {
                if (t.ranges)
                    for (let i = 0; i < t.ranges.length; i++) {
                        const s = t.ranges[i];
                        e.createAnimationRange(s.name, s.from, s.to)
                    }
            }
            getHierarchyBoundingVectors(e=!0, t=null) {
                let i, s;
                this.getScene().incrementRenderId(),
                this.computeWorldMatrix(!0);
                const r = this;
                if (r.getBoundingInfo && r.subMeshes) {
                    const e = r.getBoundingInfo();
                    i = e.boundingBox.minimumWorld.clone(),
                    s = e.boundingBox.maximumWorld.clone()
                } else
                    i = new Di(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),
                    s = new Di(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);
                if (e) {
                    const e = this.getDescendants(!1);
                    for (const r of e) {
                        const e = r;
                        if (e.computeWorldMatrix(!0),
                        t && !t(e))
                            continue;
                        if (!e.getBoundingInfo || 0 === e.getTotalVertices())
                            continue;
                        const n = e.getBoundingInfo().boundingBox
                          , a = n.minimumWorld
                          , o = n.maximumWorld;
                        Di.CheckExtends(a, i, s),
                        Di.CheckExtends(o, i, s)
                    }
                }
                return {
                    min: i,
                    max: s
                }
            }
        }
        Gi._AnimationRangeFactory = (e, t, i) => {
            throw je("AnimationRange")
        }
        ,
        Gi._NodeConstructors = {},
        pi([xi()], Gi.prototype, "name", void 0),
        pi([xi()], Gi.prototype, "id", void 0),
        pi([xi()], Gi.prototype, "uniqueId", void 0),
        pi([xi()], Gi.prototype, "state", void 0),
        pi([xi()], Gi.prototype, "metadata", void 0);
        class zi {
            constructor(e, t, i, s) {
                this.x = e,
                this.y = t,
                this.width = i,
                this.height = s
            }
            toGlobal(e, t) {
                return new zi(this.x * e,this.y * t,this.width * e,this.height * t)
            }
            toGlobalToRef(e, t, i) {
                return i.x = this.x * e,
                i.y = this.y * t,
                i.width = this.width * e,
                i.height = this.height * t,
                this
            }
            clone() {
                return new zi(this.x,this.y,this.width,this.height)
            }
        }
        class Wi {
            constructor(e, t, i, s) {
                this.normal = new Di(e,t,i),
                this.d = s
            }
            asArray() {
                return [this.normal.x, this.normal.y, this.normal.z, this.d]
            }
            clone() {
                return new Wi(this.normal.x,this.normal.y,this.normal.z,this.d)
            }
            getClassName() {
                return "Plane"
            }
            getHashCode() {
                let e = this.normal.getHashCode();
                return e = 397 * e ^ this.d,
                e
            }
            normalize() {
                const e = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);
                let t = 0;
                return 0 !== e && (t = 1 / e),
                this.normal.x *= t,
                this.normal.y *= t,
                this.normal.z *= t,
                this.d *= t,
                this
            }
            transform(e) {
                const t = Wi._TmpMatrix;
                e.invertToRef(t);
                const i = t.m
                  , s = this.normal.x
                  , r = this.normal.y
                  , n = this.normal.z
                  , a = this.d
                  , o = s * i[0] + r * i[1] + n * i[2] + a * i[3]
                  , h = s * i[4] + r * i[5] + n * i[6] + a * i[7]
                  , l = s * i[8] + r * i[9] + n * i[10] + a * i[11]
                  , c = s * i[12] + r * i[13] + n * i[14] + a * i[15];
                return new Wi(o,h,l,c)
            }
            dotCoordinate(e) {
                return this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z + this.d
            }
            copyFromPoints(e, t, i) {
                const s = t.x - e.x
                  , r = t.y - e.y
                  , n = t.z - e.z
                  , a = i.x - e.x
                  , o = i.y - e.y
                  , h = i.z - e.z
                  , l = r * h - n * o
                  , c = n * a - s * h
                  , u = s * o - r * a
                  , d = Math.sqrt(l * l + c * c + u * u);
                let f;
                return f = 0 !== d ? 1 / d : 0,
                this.normal.x = l * f,
                this.normal.y = c * f,
                this.normal.z = u * f,
                this.d = -(this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z),
                this
            }
            isFrontFacingTo(e, t) {
                return Di.Dot(this.normal, e) <= t
            }
            signedDistanceTo(e) {
                return Di.Dot(e, this.normal) + this.d
            }
            static FromArray(e) {
                return new Wi(e[0],e[1],e[2],e[3])
            }
            static FromPoints(e, t, i) {
                const s = new Wi(0,0,0,0);
                return s.copyFromPoints(e, t, i),
                s
            }
            static FromPositionAndNormal(e, t) {
                const i = new Wi(0,0,0,0);
                return this.FromPositionAndNormalToRef(e, t, i)
            }
            static FromPositionAndNormalToRef(e, t, i) {
                return i.normal.copyFrom(t),
                i.normal.normalize(),
                i.d = -e.dot(i.normal),
                i
            }
            static SignedDistanceToPlaneFromPositionAndNormal(e, t, i) {
                const s = -(t.x * e.x + t.y * e.y + t.z * e.z);
                return Di.Dot(i, t) + s
            }
        }
        Wi._TmpMatrix = Oi.Identity();
        class Xi {
            static GetPlanes(e) {
                const t = [];
                for (let e = 0; e < 6; e++)
                    t.push(new Wi(0,0,0,0));
                return Xi.GetPlanesToRef(e, t),
                t
            }
            static GetNearPlaneToRef(e, t) {
                const i = e.m;
                t.normal.x = i[3] + i[2],
                t.normal.y = i[7] + i[6],
                t.normal.z = i[11] + i[10],
                t.d = i[15] + i[14],
                t.normalize()
            }
            static GetFarPlaneToRef(e, t) {
                const i = e.m;
                t.normal.x = i[3] - i[2],
                t.normal.y = i[7] - i[6],
                t.normal.z = i[11] - i[10],
                t.d = i[15] - i[14],
                t.normalize()
            }
            static GetLeftPlaneToRef(e, t) {
                const i = e.m;
                t.normal.x = i[3] + i[0],
                t.normal.y = i[7] + i[4],
                t.normal.z = i[11] + i[8],
                t.d = i[15] + i[12],
                t.normalize()
            }
            static GetRightPlaneToRef(e, t) {
                const i = e.m;
                t.normal.x = i[3] - i[0],
                t.normal.y = i[7] - i[4],
                t.normal.z = i[11] - i[8],
                t.d = i[15] - i[12],
                t.normalize()
            }
            static GetTopPlaneToRef(e, t) {
                const i = e.m;
                t.normal.x = i[3] - i[1],
                t.normal.y = i[7] - i[5],
                t.normal.z = i[11] - i[9],
                t.d = i[15] - i[13],
                t.normalize()
            }
            static GetBottomPlaneToRef(e, t) {
                const i = e.m;
                t.normal.x = i[3] + i[1],
                t.normal.y = i[7] + i[5],
                t.normal.z = i[11] + i[9],
                t.d = i[15] + i[13],
                t.normalize()
            }
            static GetPlanesToRef(e, t) {
                Xi.GetNearPlaneToRef(e, t[0]),
                Xi.GetFarPlaneToRef(e, t[1]),
                Xi.GetLeftPlaneToRef(e, t[2]),
                Xi.GetRightPlaneToRef(e, t[3]),
                Xi.GetTopPlaneToRef(e, t[4]),
                Xi.GetBottomPlaneToRef(e, t[5])
            }
            static IsPointInFrustum(e, t) {
                for (let i = 0; i < 6; i++)
                    if (t[i].dotCoordinate(e) < 0)
                        return !1;
                return !0
            }
        }
        class Hi extends Gi {
            get position() {
                return this._position
            }
            set position(e) {
                this._position = e
            }
            set upVector(e) {
                this._upVector = e
            }
            get upVector() {
                return this._upVector
            }
            get screenArea() {
                let e = 0
                  , t = 0;
                if (this.mode === Hi.PERSPECTIVE_CAMERA)
                    this.fovMode === Hi.FOVMODE_VERTICAL_FIXED ? (t = 2 * this.minZ * Math.tan(this.fov / 2),
                    e = this.getEngine().getAspectRatio(this) * t) : (e = 2 * this.minZ * Math.tan(this.fov / 2),
                    t = e / this.getEngine().getAspectRatio(this));
                else {
                    const i = this.getEngine().getRenderWidth() / 2
                      , s = this.getEngine().getRenderHeight() / 2;
                    e = (this.orthoRight ?? i) - (this.orthoLeft ?? -i),
                    t = (this.orthoTop ?? s) - (this.orthoBottom ?? -s)
                }
                return e * t
            }
            set orthoLeft(e) {
                this._orthoLeft = e;
                for (const t of this._rigCameras)
                    t.orthoLeft = e
            }
            get orthoLeft() {
                return this._orthoLeft
            }
            set orthoRight(e) {
                this._orthoRight = e;
                for (const t of this._rigCameras)
                    t.orthoRight = e
            }
            get orthoRight() {
                return this._orthoRight
            }
            set orthoBottom(e) {
                this._orthoBottom = e;
                for (const t of this._rigCameras)
                    t.orthoBottom = e
            }
            get orthoBottom() {
                return this._orthoBottom
            }
            set orthoTop(e) {
                this._orthoTop = e;
                for (const t of this._rigCameras)
                    t.orthoTop = e
            }
            get orthoTop() {
                return this._orthoTop
            }
            set mode(e) {
                this._mode = e;
                for (const t of this._rigCameras)
                    t.mode = e
            }
            get mode() {
                return this._mode
            }
            get hasMoved() {
                return this._hasMoved
            }
            constructor(e, t, i, s=!0) {
                super(e, i),
                this._position = Di.Zero(),
                this._upVector = Di.Up(),
                this.oblique = null,
                this._orthoLeft = null,
                this._orthoRight = null,
                this._orthoBottom = null,
                this._orthoTop = null,
                this.fov = .8,
                this.projectionPlaneTilt = 0,
                this.minZ = 1,
                this.maxZ = 1e4,
                this.inertia = .9,
                this._mode = Hi.PERSPECTIVE_CAMERA,
                this.isIntermediate = !1,
                this.viewport = new zi(0,0,1,1),
                this.layerMask = 268435455,
                this.fovMode = Hi.FOVMODE_VERTICAL_FIXED,
                this.cameraRigMode = Hi.RIG_MODE_NONE,
                this.customRenderTargets = [],
                this.outputRenderTarget = null,
                this.onViewMatrixChangedObservable = new Ue,
                this.onProjectionMatrixChangedObservable = new Ue,
                this.onAfterCheckInputsObservable = new Ue,
                this.onRestoreStateObservable = new Ue,
                this.isRigCamera = !1,
                this._hasMoved = !1,
                this._rigCameras = new Array,
                this._skipRendering = !1,
                this._projectionMatrix = new Oi,
                this._postProcesses = new Array,
                this._activeMeshes = new Ii(256),
                this._globalPosition = Di.Zero(),
                this._computedViewMatrix = Oi.Identity(),
                this._doNotComputeProjectionMatrix = !1,
                this._transformMatrix = Oi.Zero(),
                this._refreshFrustumPlanes = !0,
                this._absoluteRotation = Fi.Identity(),
                this._isCamera = !0,
                this._isLeftCamera = !1,
                this._isRightCamera = !1,
                this.getScene().addCamera(this),
                s && !this.getScene().activeCamera && (this.getScene().activeCamera = this),
                this.position = t,
                this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${e}`)
            }
            storeState() {
                return this._stateStored = !0,
                this._storedFov = this.fov,
                this
            }
            _restoreStateValues() {
                return !!this._stateStored && (this.fov = this._storedFov,
                !0)
            }
            restoreState() {
                return !!this._restoreStateValues() && (this.onRestoreStateObservable.notifyObservers(this),
                !0)
            }
            getClassName() {
                return "Camera"
            }
            toString(e) {
                let t = "Name: " + this.name;
                if (t += ", type: " + this.getClassName(),
                this.animations)
                    for (let i = 0; i < this.animations.length; i++)
                        t += ", animation[0]: " + this.animations[i].toString(e);
                return t
            }
            applyVerticalCorrection() {
                const e = this.absoluteRotation.toEulerAngles();
                this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -e.x : e.x
            }
            get globalPosition() {
                return this._globalPosition
            }
            getActiveMeshes() {
                return this._activeMeshes
            }
            isActiveMesh(e) {
                return -1 !== this._activeMeshes.indexOf(e)
            }
            isReady(e=!1) {
                if (e)
                    for (const e of this._postProcesses)
                        if (e && !e.isReady())
                            return !1;
                return super.isReady(e)
            }
            _initCache() {
                super._initCache(),
                this._cache.position = new Di(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),
                this._cache.upVector = new Di(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),
                this._cache.mode = void 0,
                this._cache.minZ = void 0,
                this._cache.maxZ = void 0,
                this._cache.fov = void 0,
                this._cache.fovMode = void 0,
                this._cache.aspectRatio = void 0,
                this._cache.orthoLeft = void 0,
                this._cache.orthoRight = void 0,
                this._cache.orthoBottom = void 0,
                this._cache.orthoTop = void 0,
                this._cache.obliqueAngle = void 0,
                this._cache.obliqueLength = void 0,
                this._cache.obliqueOffset = void 0,
                this._cache.renderWidth = void 0,
                this._cache.renderHeight = void 0
            }
            _updateCache(e) {
                e || super._updateCache(),
                this._cache.position.copyFrom(this.position),
                this._cache.upVector.copyFrom(this.upVector)
            }
            _isSynchronized() {
                return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix()
            }
            _isSynchronizedViewMatrix() {
                return !!super._isSynchronized() && this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent()
            }
            _isSynchronizedProjectionMatrix() {
                let e = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
                if (!e)
                    return !1;
                const t = this.getEngine();
                return this.mode === Hi.PERSPECTIVE_CAMERA ? e = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === t.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt : (e = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === t.getRenderWidth() && this._cache.renderHeight === t.getRenderHeight(),
                this.oblique && (e = e && this._cache.obliqueAngle === this.oblique.angle && this._cache.obliqueLength === this.oblique.length && this._cache.obliqueOffset === this.oblique.offset)),
                e
            }
            attachControl(e, t) {}
            detachControl(e) {}
            update() {
                this._hasMoved = !1,
                this._checkInputs(),
                this.cameraRigMode !== Hi.RIG_MODE_NONE && this._updateRigCameras(),
                this.getViewMatrix(),
                this.getProjectionMatrix()
            }
            _checkInputs() {
                this.onAfterCheckInputsObservable.notifyObservers(this)
            }
            get rigCameras() {
                return this._rigCameras
            }
            get rigPostProcess() {
                return this._rigPostProcess
            }
            _getFirstPostProcess() {
                for (let e = 0; e < this._postProcesses.length; e++)
                    if (null !== this._postProcesses[e])
                        return this._postProcesses[e];
                return null
            }
            _cascadePostProcessesToRigCams() {
                const e = this._getFirstPostProcess();
                e && e.markTextureDirty();
                for (let e = 0, t = this._rigCameras.length; e < t; e++) {
                    const t = this._rigCameras[e]
                      , i = t._rigPostProcess;
                    i ? ("pass" === i.getEffectName() && (t.isIntermediate = 0 === this._postProcesses.length),
                    t._postProcesses = this._postProcesses.slice(0).concat(i),
                    i.markTextureDirty()) : t._postProcesses = this._postProcesses.slice(0)
                }
            }
            attachPostProcess(e, t=null) {
                return !e.isReusable() && this._postProcesses.indexOf(e) > -1 ? (We.Error("You're trying to reuse a post process not defined as reusable."),
                0) : (null == t || t < 0 ? this._postProcesses.push(e) : null === this._postProcesses[t] ? this._postProcesses[t] = e : this._postProcesses.splice(t, 0, e),
                this._cascadePostProcessesToRigCams(),
                this._scene.prePassRenderer && this._scene.prePassRenderer.markAsDirty(),
                this._postProcesses.indexOf(e))
            }
            detachPostProcess(e) {
                const t = this._postProcesses.indexOf(e);
                -1 !== t && (this._postProcesses[t] = null),
                this._scene.prePassRenderer && this._scene.prePassRenderer.markAsDirty(),
                this._cascadePostProcessesToRigCams()
            }
            getWorldMatrix() {
                return this._isSynchronizedViewMatrix() || this.getViewMatrix(),
                this._worldMatrix
            }
            _getViewMatrix() {
                return Oi.Identity()
            }
            getViewMatrix(e) {
                return !e && this._isSynchronizedViewMatrix() || (this._hasMoved = !0,
                this.updateCache(),
                this._computedViewMatrix = this._getViewMatrix(),
                this._currentRenderId = this.getScene().getRenderId(),
                this._childUpdateId++,
                this._refreshFrustumPlanes = !0,
                this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix && this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix),
                this.parent && this.parent.onViewMatrixChangedObservable && this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent),
                this.onViewMatrixChangedObservable.notifyObservers(this),
                this._computedViewMatrix.invertToRef(this._worldMatrix)),
                this._computedViewMatrix
            }
            freezeProjectionMatrix(e) {
                this._doNotComputeProjectionMatrix = !0,
                void 0 !== e && (this._projectionMatrix = e)
            }
            unfreezeProjectionMatrix() {
                this._doNotComputeProjectionMatrix = !1
            }
            getProjectionMatrix(e) {
                if (this._doNotComputeProjectionMatrix || !e && this._isSynchronizedProjectionMatrix())
                    return this._projectionMatrix;
                this._cache.mode = this.mode,
                this._cache.minZ = this.minZ,
                this._cache.maxZ = this.maxZ,
                this._refreshFrustumPlanes = !0;
                const t = this.getEngine()
                  , i = this.getScene()
                  , s = t.useReverseDepthBuffer;
                if (this.mode === Hi.PERSPECTIVE_CAMERA) {
                    let e;
                    this._cache.fov = this.fov,
                    this._cache.fovMode = this.fovMode,
                    this._cache.aspectRatio = t.getAspectRatio(this),
                    this._cache.projectionPlaneTilt = this.projectionPlaneTilt,
                    this.minZ <= 0 && (this.minZ = .1),
                    e = i.useRightHandedSystem ? Oi.PerspectiveFovRHToRef : Oi.PerspectiveFovLHToRef,
                    e(this.fov, t.getAspectRatio(this), s ? this.maxZ : this.minZ, s ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === Hi.FOVMODE_VERTICAL_FIXED, t.isNDCHalfZRange, this.projectionPlaneTilt, s)
                } else {
                    const e = t.getRenderWidth() / 2
                      , r = t.getRenderHeight() / 2;
                    i.useRightHandedSystem ? this.oblique ? Oi.ObliqueOffCenterRHToRef(this.orthoLeft ?? -e, this.orthoRight ?? e, this.orthoBottom ?? -r, this.orthoTop ?? r, s ? this.maxZ : this.minZ, s ? this.minZ : this.maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, t.isNDCHalfZRange) : Oi.OrthoOffCenterRHToRef(this.orthoLeft ?? -e, this.orthoRight ?? e, this.orthoBottom ?? -r, this.orthoTop ?? r, s ? this.maxZ : this.minZ, s ? this.minZ : this.maxZ, this._projectionMatrix, t.isNDCHalfZRange) : this.oblique ? Oi.ObliqueOffCenterLHToRef(this.orthoLeft ?? -e, this.orthoRight ?? e, this.orthoBottom ?? -r, this.orthoTop ?? r, s ? this.maxZ : this.minZ, s ? this.minZ : this.maxZ, this.oblique.length, this.oblique.angle, this._computeObliqueDistance(this.oblique.offset), this._projectionMatrix, t.isNDCHalfZRange) : Oi.OrthoOffCenterLHToRef(this.orthoLeft ?? -e, this.orthoRight ?? e, this.orthoBottom ?? -r, this.orthoTop ?? r, s ? this.maxZ : this.minZ, s ? this.minZ : this.maxZ, this._projectionMatrix, t.isNDCHalfZRange),
                    this._cache.orthoLeft = this.orthoLeft,
                    this._cache.orthoRight = this.orthoRight,
                    this._cache.orthoBottom = this.orthoBottom,
                    this._cache.orthoTop = this.orthoTop,
                    this._cache.obliqueAngle = this.oblique?.angle,
                    this._cache.obliqueLength = this.oblique?.length,
                    this._cache.obliqueOffset = this.oblique?.offset,
                    this._cache.renderWidth = t.getRenderWidth(),
                    this._cache.renderHeight = t.getRenderHeight()
                }
                return this.onProjectionMatrixChangedObservable.notifyObservers(this),
                this._projectionMatrix
            }
            getTransformationMatrix() {
                return this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix),
                this._transformMatrix
            }
            _computeObliqueDistance(e) {
                return (this.radius || (this.target ? Di.Distance(this.position, this.target) : this.position.length())) + e
            }
            _updateFrustumPlanes() {
                this._refreshFrustumPlanes && (this.getTransformationMatrix(),
                this._frustumPlanes ? Xi.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = Xi.GetPlanes(this._transformMatrix),
                this._refreshFrustumPlanes = !1)
            }
            isInFrustum(e, t=!1) {
                if (this._updateFrustumPlanes(),
                t && this.rigCameras.length > 0) {
                    let t = !1;
                    return this.rigCameras.forEach((i => {
                        i._updateFrustumPlanes(),
                        t = t || e.isInFrustum(i._frustumPlanes)
                    }
                    )),
                    t
                }
                return e.isInFrustum(this._frustumPlanes)
            }
            isCompletelyInFrustum(e) {
                return this._updateFrustumPlanes(),
                e.isCompletelyInFrustum(this._frustumPlanes)
            }
            getForwardRay(e=100, t, i) {
                throw je("Ray")
            }
            getForwardRayToRef(e, t=100, i, s) {
                throw je("Ray")
            }
            dispose(e, t=!1) {
                for (this.onViewMatrixChangedObservable.clear(),
                this.onProjectionMatrixChangedObservable.clear(),
                this.onAfterCheckInputsObservable.clear(),
                this.onRestoreStateObservable.clear(),
                this.inputs && this.inputs.clear(),
                this.getScene().stopAnimation(this),
                this.getScene().removeCamera(this); this._rigCameras.length > 0; ) {
                    const e = this._rigCameras.pop();
                    e && e.dispose()
                }
                if (this._parentContainer) {
                    const e = this._parentContainer.cameras.indexOf(this);
                    e > -1 && this._parentContainer.cameras.splice(e, 1),
                    this._parentContainer = null
                }
                if (this._rigPostProcess)
                    this._rigPostProcess.dispose(this),
                    this._rigPostProcess = null,
                    this._postProcesses.length = 0;
                else if (this.cameraRigMode !== Hi.RIG_MODE_NONE)
                    this._rigPostProcess = null,
                    this._postProcesses.length = 0;
                else {
                    let e = this._postProcesses.length;
                    for (; --e >= 0; ) {
                        const t = this._postProcesses[e];
                        t && t.dispose(this)
                    }
                }
                let i = this.customRenderTargets.length;
                for (; --i >= 0; )
                    this.customRenderTargets[i].dispose();
                this.customRenderTargets.length = 0,
                this._activeMeshes.dispose(),
                this.getScene().getEngine().releaseRenderPassId(this.renderPassId),
                super.dispose(e, t)
            }
            get isLeftCamera() {
                return this._isLeftCamera
            }
            get isRightCamera() {
                return this._isRightCamera
            }
            get leftCamera() {
                return this._rigCameras.length < 1 ? null : this._rigCameras[0]
            }
            get rightCamera() {
                return this._rigCameras.length < 2 ? null : this._rigCameras[1]
            }
            getLeftTarget() {
                return this._rigCameras.length < 1 ? null : this._rigCameras[0].getTarget()
            }
            getRightTarget() {
                return this._rigCameras.length < 2 ? null : this._rigCameras[1].getTarget()
            }
            setCameraRigMode(e, t) {
                if (this.cameraRigMode !== e) {
                    for (; this._rigCameras.length > 0; ) {
                        const e = this._rigCameras.pop();
                        e && e.dispose()
                    }
                    if (this.cameraRigMode = e,
                    this._cameraRigParams = {},
                    this._cameraRigParams.interaxialDistance = t.interaxialDistance || .0637,
                    this._cameraRigParams.stereoHalfAngle = hi.ToRadians(this._cameraRigParams.interaxialDistance / .0637),
                    this.cameraRigMode !== Hi.RIG_MODE_NONE) {
                        const e = this.createRigCamera(this.name + "_L", 0);
                        e && (e._isLeftCamera = !0);
                        const t = this.createRigCamera(this.name + "_R", 1);
                        t && (t._isRightCamera = !0),
                        e && t && (this._rigCameras.push(e),
                        this._rigCameras.push(t))
                    }
                    this._setRigMode(t),
                    this._cascadePostProcessesToRigCams(),
                    this.update()
                }
            }
            _setRigMode(e) {}
            _getVRProjectionMatrix() {
                return Oi.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, !0, this.getEngine().isNDCHalfZRange),
                this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix),
                this._projectionMatrix
            }
            setCameraRigParameter(e, t) {
                this._cameraRigParams || (this._cameraRigParams = {}),
                this._cameraRigParams[e] = t,
                "interaxialDistance" === e && (this._cameraRigParams.stereoHalfAngle = hi.ToRadians(t / .0637))
            }
            createRigCamera(e, t) {
                return null
            }
            _updateRigCameras() {
                for (let e = 0; e < this._rigCameras.length; e++)
                    this._rigCameras[e].minZ = this.minZ,
                    this._rigCameras[e].maxZ = this.maxZ,
                    this._rigCameras[e].fov = this.fov,
                    this._rigCameras[e].upVector.copyFrom(this.upVector);
                this.cameraRigMode === Hi.RIG_MODE_STEREOSCOPIC_ANAGLYPH && (this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport)
            }
            _setupInputs() {}
            serialize() {
                const e = ki.Serialize(this);
                return e.uniqueId = this.uniqueId,
                e.type = this.getClassName(),
                this.parent && this.parent._serializeAsParent(e),
                this.inputs && this.inputs.serialize(e),
                ki.AppendSerializedAnimations(this, e),
                e.ranges = this.serializeAnimationRanges(),
                e.isEnabled = this.isEnabled(),
                e
            }
            clone(e, t=null) {
                const i = ki.Clone(Hi.GetConstructorFromName(this.getClassName(), e, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
                return i.name = e,
                i.parent = t,
                this.onClonedObservable.notifyObservers(i),
                i
            }
            getDirection(e) {
                const t = Di.Zero();
                return this.getDirectionToRef(e, t),
                t
            }
            get absoluteRotation() {
                return this.getWorldMatrix().decompose(void 0, this._absoluteRotation),
                this._absoluteRotation
            }
            getDirectionToRef(e, t) {
                Di.TransformNormalToRef(e, this.getWorldMatrix(), t)
            }
            static GetConstructorFromName(e, t, i, s=0, r=!0) {
                return Gi.Construct(e, t, i, {
                    interaxial_distance: s,
                    isStereoscopicSideBySide: r
                }) || ( () => Hi._CreateDefaultParsedCamera(t, i))
            }
            computeWorldMatrix() {
                return this.getWorldMatrix()
            }
            static Parse(e, t) {
                const i = e.type
                  , s = Hi.GetConstructorFromName(i, e.name, t, e.interaxial_distance, e.isStereoscopicSideBySide)
                  , r = ki.Parse(s, e, t);
                if (void 0 !== e.parentId && (r._waitingParentId = e.parentId),
                void 0 !== e.parentInstanceIndex && (r._waitingParentInstanceIndex = e.parentInstanceIndex),
                r.inputs && (r.inputs.parse(e),
                r._setupInputs()),
                e.upVector && (r.upVector = Di.FromArray(e.upVector)),
                r.setPosition && (r.position.copyFromFloats(0, 0, 0),
                r.setPosition(Di.FromArray(e.position))),
                e.target && r.setTarget && r.setTarget(Di.FromArray(e.target)),
                e.cameraRigMode) {
                    const t = e.interaxial_distance ? {
                        interaxialDistance: e.interaxial_distance
                    } : {};
                    r.setCameraRigMode(e.cameraRigMode, t)
                }
                if (e.animations) {
                    for (let t = 0; t < e.animations.length; t++) {
                        const i = e.animations[t]
                          , s = Re("BABYLON.Animation");
                        s && r.animations.push(s.Parse(i))
                    }
                    Gi.ParseAnimationRanges(r, e, t)
                }
                return e.autoAnimate && t.beginAnimation(r, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1),
                void 0 !== e.isEnabled && r.setEnabled(e.isEnabled),
                r
            }
            _calculateHandednessMultiplier() {
                let e = this.getScene().useRightHandedSystem ? -1 : 1;
                return this.parent && this.parent._getWorldMatrixDeterminant() < 0 && (e *= -1),
                e
            }
        }
        Hi._CreateDefaultParsedCamera = (e, t) => {
            throw je("UniversalCamera")
        }
        ,
        Hi.PERSPECTIVE_CAMERA = 0,
        Hi.ORTHOGRAPHIC_CAMERA = 1,
        Hi.FOVMODE_VERTICAL_FIXED = 0,
        Hi.FOVMODE_HORIZONTAL_FIXED = 1,
        Hi.RIG_MODE_NONE = 0,
        Hi.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10,
        Hi.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11,
        Hi.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12,
        Hi.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13,
        Hi.RIG_MODE_STEREOSCOPIC_INTERLACED = 14,
        Hi.RIG_MODE_VR = 20,
        Hi.RIG_MODE_CUSTOM = 22,
        Hi.ForceAttachControlToAlwaysPreventDefault = !1,
        pi([Si("position")], Hi.prototype, "_position", void 0),
        pi([Si("upVector")], Hi.prototype, "_upVector", void 0),
        pi([xi()], Hi.prototype, "orthoLeft", null),
        pi([xi()], Hi.prototype, "orthoRight", null),
        pi([xi()], Hi.prototype, "orthoBottom", null),
        pi([xi()], Hi.prototype, "orthoTop", null),
        pi([xi()], Hi.prototype, "fov", void 0),
        pi([xi()], Hi.prototype, "projectionPlaneTilt", void 0),
        pi([xi()], Hi.prototype, "minZ", void 0),
        pi([xi()], Hi.prototype, "maxZ", void 0),
        pi([xi()], Hi.prototype, "inertia", void 0),
        pi([xi()], Hi.prototype, "mode", null),
        pi([xi()], Hi.prototype, "layerMask", void 0),
        pi([xi()], Hi.prototype, "fovMode", void 0),
        pi([xi()], Hi.prototype, "cameraRigMode", void 0),
        pi([xi()], Hi.prototype, "interaxialDistance", void 0),
        pi([xi()], Hi.prototype, "isStereoscopicSideBySide", void 0);
        class Ki {
            constructor() {
                this._count = 0,
                this._data = {}
            }
            copyFrom(e) {
                this.clear(),
                e.forEach(( (e, t) => this.add(e, t)))
            }
            get(e) {
                const t = this._data[e];
                if (void 0 !== t)
                    return t
            }
            getOrAddWithFactory(e, t) {
                let i = this.get(e);
                return void 0 !== i || (i = t(e),
                i && this.add(e, i)),
                i
            }
            getOrAdd(e, t) {
                const i = this.get(e);
                return void 0 !== i ? i : (this.add(e, t),
                t)
            }
            contains(e) {
                return void 0 !== this._data[e]
            }
            add(e, t) {
                return void 0 === this._data[e] && (this._data[e] = t,
                ++this._count,
                !0)
            }
            set(e, t) {
                return void 0 !== this._data[e] && (this._data[e] = t,
                !0)
            }
            getAndRemove(e) {
                const t = this.get(e);
                return void 0 !== t ? (delete this._data[e],
                --this._count,
                t) : null
            }
            remove(e) {
                return !!this.contains(e) && (delete this._data[e],
                --this._count,
                !0)
            }
            clear() {
                this._data = {},
                this._count = 0
            }
            get count() {
                return this._count
            }
            forEach(e) {
                for (const t in this._data)
                    e(t, this._data[t])
            }
            first(e) {
                for (const t in this._data) {
                    const i = e(t, this._data[t]);
                    if (i)
                        return i
                }
                return null
            }
        }
        class Yi {
            constructor() {
                this.rootNodes = [],
                this.cameras = [],
                this.lights = [],
                this.meshes = [],
                this.skeletons = [],
                this.particleSystems = [],
                this.animations = [],
                this.animationGroups = [],
                this.multiMaterials = [],
                this.materials = [],
                this.morphTargetManagers = [],
                this.geometries = [],
                this.transformNodes = [],
                this.actionManagers = [],
                this.textures = [],
                this._environmentTexture = null,
                this.postProcesses = []
            }
            static AddParser(e, t) {
                this._BabylonFileParsers[e] = t
            }
            static GetParser(e) {
                return this._BabylonFileParsers[e] ? this._BabylonFileParsers[e] : null
            }
            static AddIndividualParser(e, t) {
                this._IndividualBabylonFileParsers[e] = t
            }
            static GetIndividualParser(e) {
                return this._IndividualBabylonFileParsers[e] ? this._IndividualBabylonFileParsers[e] : null
            }
            static Parse(e, t, i, s) {
                for (const r in this._BabylonFileParsers)
                    Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, r) && this._BabylonFileParsers[r](e, t, i, s)
            }
            get environmentTexture() {
                return this._environmentTexture
            }
            set environmentTexture(e) {
                this._environmentTexture = e
            }
            getNodes() {
                let e = [];
                return e = e.concat(this.meshes),
                e = e.concat(this.lights),
                e = e.concat(this.cameras),
                e = e.concat(this.transformNodes),
                this.skeletons.forEach((t => e = e.concat(t.bones))),
                e
            }
        }
        function ji(e) {
            e.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative")
        }
        Yi._BabylonFileParsers = {},
        Yi._IndividualBabylonFileParsers = {};
        class qi {
            constructor() {
                this._dirty = !0,
                this._tempColor = new Oe(0,0,0,0),
                this._globalCurve = new Oe(0,0,0,0),
                this._highlightsCurve = new Oe(0,0,0,0),
                this._midtonesCurve = new Oe(0,0,0,0),
                this._shadowsCurve = new Oe(0,0,0,0),
                this._positiveCurve = new Oe(0,0,0,0),
                this._negativeCurve = new Oe(0,0,0,0),
                this._globalHue = 30,
                this._globalDensity = 0,
                this._globalSaturation = 0,
                this._globalExposure = 0,
                this._highlightsHue = 30,
                this._highlightsDensity = 0,
                this._highlightsSaturation = 0,
                this._highlightsExposure = 0,
                this._midtonesHue = 30,
                this._midtonesDensity = 0,
                this._midtonesSaturation = 0,
                this._midtonesExposure = 0,
                this._shadowsHue = 30,
                this._shadowsDensity = 0,
                this._shadowsSaturation = 0,
                this._shadowsExposure = 0
            }
            get globalHue() {
                return this._globalHue
            }
            set globalHue(e) {
                this._globalHue = e,
                this._dirty = !0
            }
            get globalDensity() {
                return this._globalDensity
            }
            set globalDensity(e) {
                this._globalDensity = e,
                this._dirty = !0
            }
            get globalSaturation() {
                return this._globalSaturation
            }
            set globalSaturation(e) {
                this._globalSaturation = e,
                this._dirty = !0
            }
            get globalExposure() {
                return this._globalExposure
            }
            set globalExposure(e) {
                this._globalExposure = e,
                this._dirty = !0
            }
            get highlightsHue() {
                return this._highlightsHue
            }
            set highlightsHue(e) {
                this._highlightsHue = e,
                this._dirty = !0
            }
            get highlightsDensity() {
                return this._highlightsDensity
            }
            set highlightsDensity(e) {
                this._highlightsDensity = e,
                this._dirty = !0
            }
            get highlightsSaturation() {
                return this._highlightsSaturation
            }
            set highlightsSaturation(e) {
                this._highlightsSaturation = e,
                this._dirty = !0
            }
            get highlightsExposure() {
                return this._highlightsExposure
            }
            set highlightsExposure(e) {
                this._highlightsExposure = e,
                this._dirty = !0
            }
            get midtonesHue() {
                return this._midtonesHue
            }
            set midtonesHue(e) {
                this._midtonesHue = e,
                this._dirty = !0
            }
            get midtonesDensity() {
                return this._midtonesDensity
            }
            set midtonesDensity(e) {
                this._midtonesDensity = e,
                this._dirty = !0
            }
            get midtonesSaturation() {
                return this._midtonesSaturation
            }
            set midtonesSaturation(e) {
                this._midtonesSaturation = e,
                this._dirty = !0
            }
            get midtonesExposure() {
                return this._midtonesExposure
            }
            set midtonesExposure(e) {
                this._midtonesExposure = e,
                this._dirty = !0
            }
            get shadowsHue() {
                return this._shadowsHue
            }
            set shadowsHue(e) {
                this._shadowsHue = e,
                this._dirty = !0
            }
            get shadowsDensity() {
                return this._shadowsDensity
            }
            set shadowsDensity(e) {
                this._shadowsDensity = e,
                this._dirty = !0
            }
            get shadowsSaturation() {
                return this._shadowsSaturation
            }
            set shadowsSaturation(e) {
                this._shadowsSaturation = e,
                this._dirty = !0
            }
            get shadowsExposure() {
                return this._shadowsExposure
            }
            set shadowsExposure(e) {
                this._shadowsExposure = e,
                this._dirty = !0
            }
            getClassName() {
                return "ColorCurves"
            }
            static Bind(e, t, i="vCameraColorCurvePositive", s="vCameraColorCurveNeutral", r="vCameraColorCurveNegative") {
                e._dirty && (e._dirty = !1,
                e._getColorGradingDataToRef(e._globalHue, e._globalDensity, e._globalSaturation, e._globalExposure, e._globalCurve),
                e._getColorGradingDataToRef(e._highlightsHue, e._highlightsDensity, e._highlightsSaturation, e._highlightsExposure, e._tempColor),
                e._tempColor.multiplyToRef(e._globalCurve, e._highlightsCurve),
                e._getColorGradingDataToRef(e._midtonesHue, e._midtonesDensity, e._midtonesSaturation, e._midtonesExposure, e._tempColor),
                e._tempColor.multiplyToRef(e._globalCurve, e._midtonesCurve),
                e._getColorGradingDataToRef(e._shadowsHue, e._shadowsDensity, e._shadowsSaturation, e._shadowsExposure, e._tempColor),
                e._tempColor.multiplyToRef(e._globalCurve, e._shadowsCurve),
                e._highlightsCurve.subtractToRef(e._midtonesCurve, e._positiveCurve),
                e._midtonesCurve.subtractToRef(e._shadowsCurve, e._negativeCurve)),
                t && (t.setFloat4(i, e._positiveCurve.r, e._positiveCurve.g, e._positiveCurve.b, e._positiveCurve.a),
                t.setFloat4(s, e._midtonesCurve.r, e._midtonesCurve.g, e._midtonesCurve.b, e._midtonesCurve.a),
                t.setFloat4(r, e._negativeCurve.r, e._negativeCurve.g, e._negativeCurve.b, e._negativeCurve.a))
            }
            _getColorGradingDataToRef(e, t, i, s, r) {
                null != e && (e = qi._Clamp(e, 0, 360),
                t = qi._Clamp(t, -100, 100),
                i = qi._Clamp(i, -100, 100),
                s = qi._Clamp(s, -100, 100),
                t = qi._ApplyColorGradingSliderNonlinear(t),
                t *= .5,
                s = qi._ApplyColorGradingSliderNonlinear(s),
                t < 0 && (t *= -1,
                e = (e + 180) % 360),
                qi._FromHSBToRef(e, t, 50 + .25 * s, r),
                r.scaleToRef(2, r),
                r.a = 1 + .01 * i)
            }
            static _ApplyColorGradingSliderNonlinear(e) {
                e /= 100;
                let t = Math.abs(e);
                return t = Math.pow(t, 2),
                e < 0 && (t *= -1),
                t *= 100,
                t
            }
            static _FromHSBToRef(e, t, i, s) {
                let r = qi._Clamp(e, 0, 360);
                const n = qi._Clamp(t / 100, 0, 1)
                  , a = qi._Clamp(i / 100, 0, 1);
                if (0 === n)
                    s.r = a,
                    s.g = a,
                    s.b = a;
                else {
                    r /= 60;
                    const e = Math.floor(r)
                      , t = r - e
                      , i = a * (1 - n)
                      , o = a * (1 - n * t)
                      , h = a * (1 - n * (1 - t));
                    switch (e) {
                    case 0:
                        s.r = a,
                        s.g = h,
                        s.b = i;
                        break;
                    case 1:
                        s.r = o,
                        s.g = a,
                        s.b = i;
                        break;
                    case 2:
                        s.r = i,
                        s.g = a,
                        s.b = h;
                        break;
                    case 3:
                        s.r = i,
                        s.g = o,
                        s.b = a;
                        break;
                    case 4:
                        s.r = h,
                        s.g = i,
                        s.b = a;
                        break;
                    default:
                        s.r = a,
                        s.g = i,
                        s.b = o
                    }
                }
                s.a = 1
            }
            static _Clamp(e, t, i) {
                return Math.min(Math.max(e, t), i)
            }
            clone() {
                return ki.Clone(( () => new qi), this)
            }
            serialize() {
                return ki.Serialize(this)
            }
            static Parse(e) {
                return ki.Parse(( () => new qi), e, null, null)
            }
        }
        qi.PrepareUniforms = ji,
        pi([xi()], qi.prototype, "_globalHue", void 0),
        pi([xi()], qi.prototype, "_globalDensity", void 0),
        pi([xi()], qi.prototype, "_globalSaturation", void 0),
        pi([xi()], qi.prototype, "_globalExposure", void 0),
        pi([xi()], qi.prototype, "_highlightsHue", void 0),
        pi([xi()], qi.prototype, "_highlightsDensity", void 0),
        pi([xi()], qi.prototype, "_highlightsSaturation", void 0),
        pi([xi()], qi.prototype, "_highlightsExposure", void 0),
        pi([xi()], qi.prototype, "_midtonesHue", void 0),
        pi([xi()], qi.prototype, "_midtonesDensity", void 0),
        pi([xi()], qi.prototype, "_midtonesSaturation", void 0),
        pi([xi()], qi.prototype, "_midtonesExposure", void 0),
        ki._ColorCurvesParser = qi.Parse;
        class Zi {
            constructor() {
                this.colorCurves = new qi,
                this._colorCurvesEnabled = !1,
                this._colorGradingEnabled = !1,
                this._colorGradingWithGreenDepth = !0,
                this._colorGradingBGR = !0,
                this._exposure = 1,
                this._toneMappingEnabled = !1,
                this._toneMappingType = Zi.TONEMAPPING_STANDARD,
                this._contrast = 1,
                this.vignetteStretch = 0,
                this.vignetteCenterX = 0,
                this.vignetteCenterY = 0,
                this.vignetteWeight = 1.5,
                this.vignetteColor = new Oe(0,0,0,0),
                this.vignetteCameraFov = .5,
                this._vignetteBlendMode = Zi.VIGNETTEMODE_MULTIPLY,
                this._vignetteEnabled = !1,
                this._ditheringEnabled = !1,
                this._ditheringIntensity = 1 / 255,
                this._skipFinalColorClamp = !1,
                this._applyByPostProcess = !1,
                this._isEnabled = !0,
                this.onUpdateParameters = new Ue
            }
            get colorCurvesEnabled() {
                return this._colorCurvesEnabled
            }
            set colorCurvesEnabled(e) {
                this._colorCurvesEnabled !== e && (this._colorCurvesEnabled = e,
                this._updateParameters())
            }
            get colorGradingTexture() {
                return this._colorGradingTexture
            }
            set colorGradingTexture(e) {
                this._colorGradingTexture !== e && (this._colorGradingTexture = e,
                this._updateParameters())
            }
            get colorGradingEnabled() {
                return this._colorGradingEnabled
            }
            set colorGradingEnabled(e) {
                this._colorGradingEnabled !== e && (this._colorGradingEnabled = e,
                this._updateParameters())
            }
            get colorGradingWithGreenDepth() {
                return this._colorGradingWithGreenDepth
            }
            set colorGradingWithGreenDepth(e) {
                this._colorGradingWithGreenDepth !== e && (this._colorGradingWithGreenDepth = e,
                this._updateParameters())
            }
            get colorGradingBGR() {
                return this._colorGradingBGR
            }
            set colorGradingBGR(e) {
                this._colorGradingBGR !== e && (this._colorGradingBGR = e,
                this._updateParameters())
            }
            get exposure() {
                return this._exposure
            }
            set exposure(e) {
                this._exposure !== e && (this._exposure = e,
                this._updateParameters())
            }
            get toneMappingEnabled() {
                return this._toneMappingEnabled
            }
            set toneMappingEnabled(e) {
                this._toneMappingEnabled !== e && (this._toneMappingEnabled = e,
                this._updateParameters())
            }
            get toneMappingType() {
                return this._toneMappingType
            }
            set toneMappingType(e) {
                this._toneMappingType !== e && (this._toneMappingType = e,
                this._updateParameters())
            }
            get contrast() {
                return this._contrast
            }
            set contrast(e) {
                this._contrast !== e && (this._contrast = e,
                this._updateParameters())
            }
            get vignetteCentreY() {
                return this.vignetteCenterY
            }
            set vignetteCentreY(e) {
                this.vignetteCenterY = e
            }
            get vignetteCentreX() {
                return this.vignetteCenterX
            }
            set vignetteCentreX(e) {
                this.vignetteCenterX = e
            }
            get vignetteBlendMode() {
                return this._vignetteBlendMode
            }
            set vignetteBlendMode(e) {
                this._vignetteBlendMode !== e && (this._vignetteBlendMode = e,
                this._updateParameters())
            }
            get vignetteEnabled() {
                return this._vignetteEnabled
            }
            set vignetteEnabled(e) {
                this._vignetteEnabled !== e && (this._vignetteEnabled = e,
                this._updateParameters())
            }
            get ditheringEnabled() {
                return this._ditheringEnabled
            }
            set ditheringEnabled(e) {
                this._ditheringEnabled !== e && (this._ditheringEnabled = e,
                this._updateParameters())
            }
            get ditheringIntensity() {
                return this._ditheringIntensity
            }
            set ditheringIntensity(e) {
                this._ditheringIntensity !== e && (this._ditheringIntensity = e,
                this._updateParameters())
            }
            get skipFinalColorClamp() {
                return this._skipFinalColorClamp
            }
            set skipFinalColorClamp(e) {
                this._skipFinalColorClamp !== e && (this._skipFinalColorClamp = e,
                this._updateParameters())
            }
            get applyByPostProcess() {
                return this._applyByPostProcess
            }
            set applyByPostProcess(e) {
                this._applyByPostProcess !== e && (this._applyByPostProcess = e,
                this._updateParameters())
            }
            get isEnabled() {
                return this._isEnabled
            }
            set isEnabled(e) {
                this._isEnabled !== e && (this._isEnabled = e,
                this._updateParameters())
            }
            _updateParameters() {
                this.onUpdateParameters.notifyObservers(this)
            }
            getClassName() {
                return "ImageProcessingConfiguration"
            }
            prepareDefines(e, t=!1) {
                if (t !== this.applyByPostProcess || !this._isEnabled)
                    return e.VIGNETTE = !1,
                    e.TONEMAPPING = !1,
                    e.TONEMAPPING_ACES = !1,
                    e.CONTRAST = !1,
                    e.EXPOSURE = !1,
                    e.COLORCURVES = !1,
                    e.COLORGRADING = !1,
                    e.COLORGRADING3D = !1,
                    e.DITHER = !1,
                    e.IMAGEPROCESSING = !1,
                    e.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp,
                    void (e.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled);
                e.VIGNETTE = this.vignetteEnabled,
                e.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === Zi._VIGNETTEMODE_MULTIPLY,
                e.VIGNETTEBLENDMODEOPAQUE = !e.VIGNETTEBLENDMODEMULTIPLY,
                e.TONEMAPPING = this.toneMappingEnabled,
                this._toneMappingType === Zi.TONEMAPPING_ACES ? e.TONEMAPPING_ACES = !0 : e.TONEMAPPING_ACES = !1,
                e.CONTRAST = 1 !== this.contrast,
                e.EXPOSURE = 1 !== this.exposure,
                e.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves,
                e.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture,
                e.COLORGRADING ? e.COLORGRADING3D = this.colorGradingTexture.is3D : e.COLORGRADING3D = !1,
                e.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth,
                e.SAMPLER3DBGRMAP = this.colorGradingBGR,
                e.DITHER = this._ditheringEnabled,
                e.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess,
                e.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp,
                e.IMAGEPROCESSING = e.VIGNETTE || e.TONEMAPPING || e.CONTRAST || e.EXPOSURE || e.COLORCURVES || e.COLORGRADING || e.DITHER
            }
            isReady() {
                return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady()
            }
            bind(e, t) {
                if (this._colorCurvesEnabled && this.colorCurves && qi.Bind(this.colorCurves, e),
                this._vignetteEnabled || this._ditheringEnabled) {
                    const i = 1 / e.getEngine().getRenderWidth()
                      , s = 1 / e.getEngine().getRenderHeight();
                    if (e.setFloat2("vInverseScreenSize", i, s),
                    this._ditheringEnabled && e.setFloat("ditherIntensity", .5 * this._ditheringIntensity),
                    this._vignetteEnabled) {
                        const r = null != t ? t : s / i;
                        let n = Math.tan(.5 * this.vignetteCameraFov)
                          , a = n * r;
                        const o = Math.sqrt(a * n);
                        a = oi(a, o, this.vignetteStretch),
                        n = oi(n, o, this.vignetteStretch),
                        e.setFloat4("vignetteSettings1", a, n, -a * this.vignetteCenterX, -n * this.vignetteCenterY);
                        const h = -2 * this.vignetteWeight;
                        e.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, h)
                    }
                }
                if (e.setFloat("exposureLinear", this.exposure),
                e.setFloat("contrast", this.contrast),
                this.colorGradingTexture) {
                    e.setTexture("txColorTransform", this.colorGradingTexture);
                    const t = this.colorGradingTexture.getSize().height;
                    e.setFloat4("colorTransformSettings", (t - 1) / t, .5 / t, t, this.colorGradingTexture.level)
                }
            }
            clone() {
                return ki.Clone(( () => new Zi), this)
            }
            serialize() {
                return ki.Serialize(this)
            }
            static Parse(e) {
                const t = ki.Parse(( () => new Zi), e, null, null);
                return void 0 !== e.vignetteCentreX && (t.vignetteCenterX = e.vignetteCentreX),
                void 0 !== e.vignetteCentreY && (t.vignetteCenterY = e.vignetteCentreY),
                t
            }
            static get VIGNETTEMODE_MULTIPLY() {
                return this._VIGNETTEMODE_MULTIPLY
            }
            static get VIGNETTEMODE_OPAQUE() {
                return this._VIGNETTEMODE_OPAQUE
            }
        }
        var Qi, $i, Ji, es, ts, is, ss, rs;
        Zi.TONEMAPPING_STANDARD = 0,
        Zi.TONEMAPPING_ACES = 1,
        Zi.PrepareUniforms = function(e, t) {
            t.EXPOSURE && e.push("exposureLinear"),
            t.CONTRAST && e.push("contrast"),
            t.COLORGRADING && e.push("colorTransformSettings"),
            (t.VIGNETTE || t.DITHER) && e.push("vInverseScreenSize"),
            t.VIGNETTE && (e.push("vignetteSettings1"),
            e.push("vignetteSettings2")),
            t.COLORCURVES && ji(e),
            t.DITHER && e.push("ditherIntensity")
        }
        ,
        Zi.PrepareSamplers = function(e, t) {
            t.COLORGRADING && e.push("txColorTransform")
        }
        ,
        Zi._VIGNETTEMODE_MULTIPLY = 0,
        Zi._VIGNETTEMODE_OPAQUE = 1,
        pi([yi(7, undefined)], Zi.prototype, "colorCurves", void 0),
        pi([xi()], Zi.prototype, "_colorCurvesEnabled", void 0),
        pi([Ti("colorGradingTexture")], Zi.prototype, "_colorGradingTexture", void 0),
        pi([xi()], Zi.prototype, "_colorGradingEnabled", void 0),
        pi([xi()], Zi.prototype, "_colorGradingWithGreenDepth", void 0),
        pi([xi()], Zi.prototype, "_colorGradingBGR", void 0),
        pi([xi()], Zi.prototype, "_exposure", void 0),
        pi([xi()], Zi.prototype, "_toneMappingEnabled", void 0),
        pi([xi()], Zi.prototype, "_toneMappingType", void 0),
        pi([xi()], Zi.prototype, "_contrast", void 0),
        pi([xi()], Zi.prototype, "vignetteStretch", void 0),
        pi([xi()], Zi.prototype, "vignetteCenterX", void 0),
        pi([xi()], Zi.prototype, "vignetteCenterY", void 0),
        pi([xi()], Zi.prototype, "vignetteWeight", void 0),
        pi([yi(8, void 0)], Zi.prototype, "vignetteColor", void 0),
        pi([xi()], Zi.prototype, "vignetteCameraFov", void 0),
        pi([xi()], Zi.prototype, "_vignetteBlendMode", void 0),
        pi([xi()], Zi.prototype, "_vignetteEnabled", void 0),
        pi([xi()], Zi.prototype, "_ditheringEnabled", void 0),
        pi([xi()], Zi.prototype, "_ditheringIntensity", void 0),
        pi([xi()], Zi.prototype, "_skipFinalColorClamp", void 0),
        pi([xi()], Zi.prototype, "_applyByPostProcess", void 0),
        pi([xi()], Zi.prototype, "_isEnabled", void 0),
        ki._ImageProcessingConfigurationParser = Zi.Parse,
        kt.prototype.createUniformBuffer = function(e, t) {
            const i = this._gl.createBuffer();
            if (!i)
                throw new Error("Unable to create uniform buffer");
            const s = new wt(i);
            return this.bindUniformBuffer(s),
            e instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, e, this._gl.STATIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(e), this._gl.STATIC_DRAW),
            this.bindUniformBuffer(null),
            s.references = 1,
            s
        }
        ,
        kt.prototype.createDynamicUniformBuffer = function(e, t) {
            const i = this._gl.createBuffer();
            if (!i)
                throw new Error("Unable to create dynamic uniform buffer");
            const s = new wt(i);
            return this.bindUniformBuffer(s),
            e instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, e, this._gl.DYNAMIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(e), this._gl.DYNAMIC_DRAW),
            this.bindUniformBuffer(null),
            s.references = 1,
            s
        }
        ,
        kt.prototype.updateUniformBuffer = function(e, t, i, s) {
            this.bindUniformBuffer(e),
            void 0 === i && (i = 0),
            void 0 === s ? t instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, i, t) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, i, new Float32Array(t)) : t instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, t.subarray(i, i + s)) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(t).subarray(i, i + s)),
            this.bindUniformBuffer(null)
        }
        ,
        kt.prototype.bindUniformBuffer = function(e) {
            this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, e ? e.underlyingResource : null)
        }
        ,
        kt.prototype.bindUniformBufferBase = function(e, t, i) {
            this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, t, e ? e.underlyingResource : null)
        }
        ,
        kt.prototype.bindUniformBlock = function(e, t, i) {
            const s = e.program
              , r = this._gl.getUniformBlockIndex(s, t);
            4294967295 !== r && this._gl.uniformBlockBinding(s, r, i)
        }
        ;
        class ns {
            constructor(e, t, i, s, r=!1) {
                this._valueCache = {},
                this._engine = e,
                this._noUBO = !e.supportsUniformBuffers || r,
                this._dynamic = i,
                this._name = s ?? "no-name",
                this._data = t || [],
                this._uniformLocations = {},
                this._uniformSizes = {},
                this._uniformArraySizes = {},
                this._uniformLocationPointer = 0,
                this._needSync = !1,
                this._engine._features.trackUbosInFrame && (this._buffers = [],
                this._bufferIndex = -1,
                this._createBufferOnWrite = !1,
                this._currentFrameId = 0),
                this._noUBO ? (this.updateMatrix3x3 = this._updateMatrix3x3ForEffect,
                this.updateMatrix2x2 = this._updateMatrix2x2ForEffect,
                this.updateFloat = this._updateFloatForEffect,
                this.updateFloat2 = this._updateFloat2ForEffect,
                this.updateFloat3 = this._updateFloat3ForEffect,
                this.updateFloat4 = this._updateFloat4ForEffect,
                this.updateFloatArray = this._updateFloatArrayForEffect,
                this.updateArray = this._updateArrayForEffect,
                this.updateIntArray = this._updateIntArrayForEffect,
                this.updateUIntArray = this._updateUIntArrayForEffect,
                this.updateMatrix = this._updateMatrixForEffect,
                this.updateMatrices = this._updateMatricesForEffect,
                this.updateVector3 = this._updateVector3ForEffect,
                this.updateVector4 = this._updateVector4ForEffect,
                this.updateColor3 = this._updateColor3ForEffect,
                this.updateColor4 = this._updateColor4ForEffect,
                this.updateDirectColor4 = this._updateDirectColor4ForEffect,
                this.updateInt = this._updateIntForEffect,
                this.updateInt2 = this._updateInt2ForEffect,
                this.updateInt3 = this._updateInt3ForEffect,
                this.updateInt4 = this._updateInt4ForEffect,
                this.updateUInt = this._updateUIntForEffect,
                this.updateUInt2 = this._updateUInt2ForEffect,
                this.updateUInt3 = this._updateUInt3ForEffect,
                this.updateUInt4 = this._updateUInt4ForEffect) : (this._engine._uniformBuffers.push(this),
                this.updateMatrix3x3 = this._updateMatrix3x3ForUniform,
                this.updateMatrix2x2 = this._updateMatrix2x2ForUniform,
                this.updateFloat = this._updateFloatForUniform,
                this.updateFloat2 = this._updateFloat2ForUniform,
                this.updateFloat3 = this._updateFloat3ForUniform,
                this.updateFloat4 = this._updateFloat4ForUniform,
                this.updateFloatArray = this._updateFloatArrayForUniform,
                this.updateArray = this._updateArrayForUniform,
                this.updateIntArray = this._updateIntArrayForUniform,
                this.updateUIntArray = this._updateUIntArrayForUniform,
                this.updateMatrix = this._updateMatrixForUniform,
                this.updateMatrices = this._updateMatricesForUniform,
                this.updateVector3 = this._updateVector3ForUniform,
                this.updateVector4 = this._updateVector4ForUniform,
                this.updateColor3 = this._updateColor3ForUniform,
                this.updateColor4 = this._updateColor4ForUniform,
                this.updateDirectColor4 = this._updateDirectColor4ForUniform,
                this.updateInt = this._updateIntForUniform,
                this.updateInt2 = this._updateInt2ForUniform,
                this.updateInt3 = this._updateInt3ForUniform,
                this.updateInt4 = this._updateInt4ForUniform,
                this.updateUInt = this._updateUIntForUniform,
                this.updateUInt2 = this._updateUInt2ForUniform,
                this.updateUInt3 = this._updateUInt3ForUniform,
                this.updateUInt4 = this._updateUInt4ForUniform)
            }
            get useUbo() {
                return !this._noUBO
            }
            get isSync() {
                return !this._needSync
            }
            isDynamic() {
                return void 0 !== this._dynamic
            }
            getData() {
                return this._bufferData
            }
            getBuffer() {
                return this._buffer
            }
            _fillAlignment(e) {
                let t;
                if (t = e <= 2 ? e : 4,
                this._uniformLocationPointer % t != 0) {
                    const e = this._uniformLocationPointer;
                    this._uniformLocationPointer += t - this._uniformLocationPointer % t;
                    const i = this._uniformLocationPointer - e;
                    for (let e = 0; e < i; e++)
                        this._data.push(0)
                }
            }
            addUniform(e, t, i=0) {
                if (this._noUBO)
                    return;
                if (void 0 !== this._uniformLocations[e])
                    return;
                let s;
                if (i > 0) {
                    if (t instanceof Array)
                        throw "addUniform should not be use with Array in UBO: " + e;
                    this._fillAlignment(4),
                    this._uniformArraySizes[e] = {
                        strideSize: t,
                        arraySize: i
                    },
                    16 == t ? t *= i : t = t * i + (4 - t) * i,
                    s = [];
                    for (let e = 0; e < t; e++)
                        s.push(0)
                } else {
                    if (t instanceof Array)
                        s = t,
                        t = s.length;
                    else {
                        s = [];
                        for (let e = 0; e < t; e++)
                            s.push(0)
                    }
                    this._fillAlignment(t)
                }
                this._uniformSizes[e] = t,
                this._uniformLocations[e] = this._uniformLocationPointer,
                this._uniformLocationPointer += t;
                for (let e = 0; e < t; e++)
                    this._data.push(s[e]);
                this._needSync = !0
            }
            addMatrix(e, t) {
                this.addUniform(e, Array.prototype.slice.call(t.asArray()))
            }
            addFloat2(e, t, i) {
                const s = [t, i];
                this.addUniform(e, s)
            }
            addFloat3(e, t, i, s) {
                const r = [t, i, s];
                this.addUniform(e, r)
            }
            addColor3(e, t) {
                const i = [t.r, t.g, t.b];
                this.addUniform(e, i)
            }
            addColor4(e, t, i) {
                const s = [t.r, t.g, t.b, i];
                this.addUniform(e, s)
            }
            addVector3(e, t) {
                const i = [t.x, t.y, t.z];
                this.addUniform(e, i)
            }
            addMatrix3x3(e) {
                this.addUniform(e, 12)
            }
            addMatrix2x2(e) {
                this.addUniform(e, 8)
            }
            create() {
                this._noUBO || this._buffer || (this._fillAlignment(4),
                this._bufferData = new Float32Array(this._data),
                this._rebuild(),
                this._needSync = !0)
            }
            _getNames() {
                const e = [];
                let t = 0;
                for (const i in this._uniformLocations)
                    if (e.push(i),
                    10 == ++t)
                        break;
                return e.join(",")
            }
            _rebuild() {
                !this._noUBO && this._bufferData && (this._dynamic ? this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData, this._name + "_UniformList:" + this._getNames()) : this._buffer = this._engine.createUniformBuffer(this._bufferData, this._name + "_UniformList:" + this._getNames()),
                this._engine._features.trackUbosInFrame && (this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]),
                this._bufferIndex = this._buffers.length - 1,
                this._createBufferOnWrite = !1))
            }
            _rebuildAfterContextLost() {
                this._engine._features.trackUbosInFrame && (this._buffers = [],
                this._currentFrameId = 0),
                this._rebuild()
            }
            get _numBuffers() {
                return this._buffers.length
            }
            get _indexBuffer() {
                return this._bufferIndex
            }
            get name() {
                return this._name
            }
            get currentEffect() {
                return this._currentEffect
            }
            _buffersEqual(e, t) {
                for (let i = 0; i < e.length; ++i)
                    if (e[i] !== t[i])
                        return !1;
                return !0
            }
            _copyBuffer(e, t) {
                for (let i = 0; i < e.length; ++i)
                    t[i] = e[i]
            }
            update() {
                if (!this._noUBO)
                    if (this.bindUniformBuffer(),
                    this._buffer)
                        if (this._dynamic || this._needSync) {
                            if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {
                                if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1]))
                                    return this._needSync = !1,
                                    void (this._createBufferOnWrite = this._engine._features.trackUbosInFrame);
                                this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1])
                            }
                            this._engine.updateUniformBuffer(this._buffer, this._bufferData),
                            this._engine._features._collectUbosUpdatedInFrame && (ns._UpdatedUbosInFrame[this._name] || (ns._UpdatedUbosInFrame[this._name] = 0),
                            ns._UpdatedUbosInFrame[this._name]++),
                            this._needSync = !1,
                            this._createBufferOnWrite = this._engine._features.trackUbosInFrame
                        } else
                            this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
                    else
                        this.create()
            }
            _createNewBuffer() {
                this._bufferIndex + 1 < this._buffers.length ? (this._bufferIndex++,
                this._buffer = this._buffers[this._bufferIndex][0],
                this._createBufferOnWrite = !1,
                this._needSync = !0) : this._rebuild()
            }
            _checkNewFrame() {
                this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId && (this._currentFrameId = this._engine.frameId,
                this._createBufferOnWrite = !1,
                this._buffers && this._buffers.length > 0 ? (this._needSync = 0 !== this._bufferIndex,
                this._bufferIndex = 0,
                this._buffer = this._buffers[this._bufferIndex][0]) : this._bufferIndex = -1)
            }
            updateUniform(e, t, i) {
                this._checkNewFrame();
                let s = this._uniformLocations[e];
                if (void 0 === s) {
                    if (this._buffer)
                        return void We.Error("Cannot add an uniform after UBO has been created. uniformName=" + e);
                    this.addUniform(e, i),
                    s = this._uniformLocations[e]
                }
                if (this._buffer || this.create(),
                this._dynamic)
                    for (let e = 0; e < i; e++)
                        this._bufferData[s + e] = t[e];
                else {
                    let e = !1;
                    for (let r = 0; r < i; r++)
                        (16 === i && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[s + r] !== Math.fround(t[r])) && (e = !0,
                        this._createBufferOnWrite && this._createNewBuffer(),
                        this._bufferData[s + r] = t[r]);
                    this._needSync = this._needSync || e
                }
            }
            updateUniformArray(e, t, i) {
                this._checkNewFrame();
                const s = this._uniformLocations[e];
                if (void 0 === s)
                    return void We.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.");
                this._buffer || this.create();
                const r = this._uniformArraySizes[e];
                if (this._dynamic)
                    for (let e = 0; e < i; e++)
                        this._bufferData[s + e] = t[e];
                else {
                    let e = !1
                      , n = 0
                      , a = 0;
                    for (let o = 0; o < i; o++)
                        if (this._bufferData[s + 4 * a + n] !== hi.FloatRound(t[o]) && (e = !0,
                        this._createBufferOnWrite && this._createNewBuffer(),
                        this._bufferData[s + 4 * a + n] = t[o]),
                        n++,
                        n === r.strideSize) {
                            for (; n < 4; n++)
                                this._bufferData[s + 4 * a + n] = 0;
                            n = 0,
                            a++
                        }
                    this._needSync = this._needSync || e
                }
            }
            _cacheMatrix(e, t) {
                this._checkNewFrame();
                const i = this._valueCache[e]
                  , s = t.updateFlag;
                return (void 0 === i || i !== s) && (this._valueCache[e] = s,
                !0)
            }
            _updateMatrix3x3ForUniform(e, t) {
                for (let e = 0; e < 3; e++)
                    ns._TempBuffer[4 * e] = t[3 * e],
                    ns._TempBuffer[4 * e + 1] = t[3 * e + 1],
                    ns._TempBuffer[4 * e + 2] = t[3 * e + 2],
                    ns._TempBuffer[4 * e + 3] = 0;
                this.updateUniform(e, ns._TempBuffer, 12)
            }
            _updateMatrix3x3ForEffect(e, t) {
                this._currentEffect.setMatrix3x3(e, t)
            }
            _updateMatrix2x2ForEffect(e, t) {
                this._currentEffect.setMatrix2x2(e, t)
            }
            _updateMatrix2x2ForUniform(e, t) {
                for (let e = 0; e < 2; e++)
                    ns._TempBuffer[4 * e] = t[2 * e],
                    ns._TempBuffer[4 * e + 1] = t[2 * e + 1],
                    ns._TempBuffer[4 * e + 2] = 0,
                    ns._TempBuffer[4 * e + 3] = 0;
                this.updateUniform(e, ns._TempBuffer, 8)
            }
            _updateFloatForEffect(e, t) {
                this._currentEffect.setFloat(e, t)
            }
            _updateFloatForUniform(e, t) {
                ns._TempBuffer[0] = t,
                this.updateUniform(e, ns._TempBuffer, 1)
            }
            _updateFloat2ForEffect(e, t, i, s="") {
                this._currentEffect.setFloat2(e + s, t, i)
            }
            _updateFloat2ForUniform(e, t, i) {
                ns._TempBuffer[0] = t,
                ns._TempBuffer[1] = i,
                this.updateUniform(e, ns._TempBuffer, 2)
            }
            _updateFloat3ForEffect(e, t, i, s, r="") {
                this._currentEffect.setFloat3(e + r, t, i, s)
            }
            _updateFloat3ForUniform(e, t, i, s) {
                ns._TempBuffer[0] = t,
                ns._TempBuffer[1] = i,
                ns._TempBuffer[2] = s,
                this.updateUniform(e, ns._TempBuffer, 3)
            }
            _updateFloat4ForEffect(e, t, i, s, r, n="") {
                this._currentEffect.setFloat4(e + n, t, i, s, r)
            }
            _updateFloat4ForUniform(e, t, i, s, r) {
                ns._TempBuffer[0] = t,
                ns._TempBuffer[1] = i,
                ns._TempBuffer[2] = s,
                ns._TempBuffer[3] = r,
                this.updateUniform(e, ns._TempBuffer, 4)
            }
            _updateFloatArrayForEffect(e, t) {
                this._currentEffect.setFloatArray(e, t)
            }
            _updateFloatArrayForUniform(e, t) {
                this.updateUniformArray(e, t, t.length)
            }
            _updateArrayForEffect(e, t) {
                this._currentEffect.setArray(e, t)
            }
            _updateArrayForUniform(e, t) {
                this.updateUniformArray(e, t, t.length)
            }
            _updateIntArrayForEffect(e, t) {
                this._currentEffect.setIntArray(e, t)
            }
            _updateIntArrayForUniform(e, t) {
                ns._TempBufferInt32View.set(t),
                this.updateUniformArray(e, ns._TempBuffer, t.length)
            }
            _updateUIntArrayForEffect(e, t) {
                this._currentEffect.setUIntArray(e, t)
            }
            _updateUIntArrayForUniform(e, t) {
                ns._TempBufferUInt32View.set(t),
                this.updateUniformArray(e, ns._TempBuffer, t.length)
            }
            _updateMatrixForEffect(e, t) {
                this._currentEffect.setMatrix(e, t)
            }
            _updateMatrixForUniform(e, t) {
                this._cacheMatrix(e, t) && this.updateUniform(e, t.asArray(), 16)
            }
            _updateMatricesForEffect(e, t) {
                this._currentEffect.setMatrices(e, t)
            }
            _updateMatricesForUniform(e, t) {
                this.updateUniform(e, t, t.length)
            }
            _updateVector3ForEffect(e, t) {
                this._currentEffect.setVector3(e, t)
            }
            _updateVector3ForUniform(e, t) {
                ns._TempBuffer[0] = t.x,
                ns._TempBuffer[1] = t.y,
                ns._TempBuffer[2] = t.z,
                this.updateUniform(e, ns._TempBuffer, 3)
            }
            _updateVector4ForEffect(e, t) {
                this._currentEffect.setVector4(e, t)
            }
            _updateVector4ForUniform(e, t) {
                ns._TempBuffer[0] = t.x,
                ns._TempBuffer[1] = t.y,
                ns._TempBuffer[2] = t.z,
                ns._TempBuffer[3] = t.w,
                this.updateUniform(e, ns._TempBuffer, 4)
            }
            _updateColor3ForEffect(e, t, i="") {
                this._currentEffect.setColor3(e + i, t)
            }
            _updateColor3ForUniform(e, t) {
                ns._TempBuffer[0] = t.r,
                ns._TempBuffer[1] = t.g,
                ns._TempBuffer[2] = t.b,
                this.updateUniform(e, ns._TempBuffer, 3)
            }
            _updateColor4ForEffect(e, t, i, s="") {
                this._currentEffect.setColor4(e + s, t, i)
            }
            _updateDirectColor4ForEffect(e, t, i="") {
                this._currentEffect.setDirectColor4(e + i, t)
            }
            _updateColor4ForUniform(e, t, i) {
                ns._TempBuffer[0] = t.r,
                ns._TempBuffer[1] = t.g,
                ns._TempBuffer[2] = t.b,
                ns._TempBuffer[3] = i,
                this.updateUniform(e, ns._TempBuffer, 4)
            }
            _updateDirectColor4ForUniform(e, t) {
                ns._TempBuffer[0] = t.r,
                ns._TempBuffer[1] = t.g,
                ns._TempBuffer[2] = t.b,
                ns._TempBuffer[3] = t.a,
                this.updateUniform(e, ns._TempBuffer, 4)
            }
            _updateIntForEffect(e, t, i="") {
                this._currentEffect.setInt(e + i, t)
            }
            _updateIntForUniform(e, t) {
                ns._TempBufferInt32View[0] = t,
                this.updateUniform(e, ns._TempBuffer, 1)
            }
            _updateInt2ForEffect(e, t, i, s="") {
                this._currentEffect.setInt2(e + s, t, i)
            }
            _updateInt2ForUniform(e, t, i) {
                ns._TempBufferInt32View[0] = t,
                ns._TempBufferInt32View[1] = i,
                this.updateUniform(e, ns._TempBuffer, 2)
            }
            _updateInt3ForEffect(e, t, i, s, r="") {
                this._currentEffect.setInt3(e + r, t, i, s)
            }
            _updateInt3ForUniform(e, t, i, s) {
                ns._TempBufferInt32View[0] = t,
                ns._TempBufferInt32View[1] = i,
                ns._TempBufferInt32View[2] = s,
                this.updateUniform(e, ns._TempBuffer, 3)
            }
            _updateInt4ForEffect(e, t, i, s, r, n="") {
                this._currentEffect.setInt4(e + n, t, i, s, r)
            }
            _updateInt4ForUniform(e, t, i, s, r) {
                ns._TempBufferInt32View[0] = t,
                ns._TempBufferInt32View[1] = i,
                ns._TempBufferInt32View[2] = s,
                ns._TempBufferInt32View[3] = r,
                this.updateUniform(e, ns._TempBuffer, 4)
            }
            _updateUIntForEffect(e, t, i="") {
                this._currentEffect.setUInt(e + i, t)
            }
            _updateUIntForUniform(e, t) {
                ns._TempBufferUInt32View[0] = t,
                this.updateUniform(e, ns._TempBuffer, 1)
            }
            _updateUInt2ForEffect(e, t, i, s="") {
                this._currentEffect.setUInt2(e + s, t, i)
            }
            _updateUInt2ForUniform(e, t, i) {
                ns._TempBufferUInt32View[0] = t,
                ns._TempBufferUInt32View[1] = i,
                this.updateUniform(e, ns._TempBuffer, 2)
            }
            _updateUInt3ForEffect(e, t, i, s, r="") {
                this._currentEffect.setUInt3(e + r, t, i, s)
            }
            _updateUInt3ForUniform(e, t, i, s) {
                ns._TempBufferUInt32View[0] = t,
                ns._TempBufferUInt32View[1] = i,
                ns._TempBufferUInt32View[2] = s,
                this.updateUniform(e, ns._TempBuffer, 3)
            }
            _updateUInt4ForEffect(e, t, i, s, r, n="") {
                this._currentEffect.setUInt4(e + n, t, i, s, r)
            }
            _updateUInt4ForUniform(e, t, i, s, r) {
                ns._TempBufferUInt32View[0] = t,
                ns._TempBufferUInt32View[1] = i,
                ns._TempBufferUInt32View[2] = s,
                ns._TempBufferUInt32View[3] = r,
                this.updateUniform(e, ns._TempBuffer, 4)
            }
            setTexture(e, t) {
                this._currentEffect.setTexture(e, t)
            }
            bindTexture(e, t) {
                this._currentEffect._bindTexture(e, t)
            }
            updateUniformDirectly(e, t) {
                this.updateUniform(e, t, t.length),
                this.update()
            }
            bindToEffect(e, t) {
                this._currentEffect = e,
                this._currentEffectName = t
            }
            bindUniformBuffer() {
                !this._noUBO && this._buffer && this._currentEffect && this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName)
            }
            unbindEffect() {
                this._currentEffect = void 0,
                this._currentEffectName = void 0
            }
            setDataBuffer(e) {
                if (!this._buffers)
                    return this._buffer === e;
                for (let t = 0; t < this._buffers.length; ++t)
                    if (this._buffers[t][0] === e)
                        return this._bufferIndex = t,
                        this._buffer = e,
                        this._createBufferOnWrite = !1,
                        this._currentEffect = void 0,
                        !0;
                return !1
            }
            dispose() {
                if (this._noUBO)
                    return;
                const e = this._engine._uniformBuffers
                  , t = e.indexOf(this);
                if (-1 !== t && (e[t] = e[e.length - 1],
                e.pop()),
                this._engine._features.trackUbosInFrame && this._buffers)
                    for (let e = 0; e < this._buffers.length; ++e) {
                        const t = this._buffers[e][0];
                        this._engine._releaseBuffer(t)
                    }
                else
                    this._buffer && this._engine._releaseBuffer(this._buffer) && (this._buffer = null)
            }
        }
        ns._UpdatedUbosInFrame = {},
        ns._MAX_UNIFORM_SIZE = 256,
        ns._TempBuffer = new Float32Array(ns._MAX_UNIFORM_SIZE),
        ns._TempBufferInt32View = new Int32Array(ns._TempBuffer.buffer),
        ns._TempBufferUInt32View = new Uint32Array(ns._TempBuffer.buffer);
        class as {
            get isDisposed() {
                return this._isDisposed
            }
            constructor(e, t, i, s=0, r=!1, n=!1, a=!1, o, h) {
                this._isAlreadyOwned = !1,
                this._isDisposed = !1,
                e && e.getScene ? this._engine = e.getScene().getEngine() : this._engine = e,
                this._updatable = i,
                this._instanced = n,
                this._divisor = o || 1,
                this._label = h,
                t instanceof Dt ? (this._data = null,
                this._buffer = t) : (this._data = t,
                this._buffer = null),
                this.byteStride = a ? s : s * Float32Array.BYTES_PER_ELEMENT,
                r || this.create()
            }
            createVertexBuffer(e, t, i, s, r, n=!1, a) {
                const o = n ? t : t * Float32Array.BYTES_PER_ELEMENT
                  , h = s ? n ? s : s * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
                return new os(this._engine,this,e,this._updatable,!0,h,void 0 === r ? this._instanced : r,o,i,void 0,void 0,!0,this._divisor || a)
            }
            isUpdatable() {
                return this._updatable
            }
            getData() {
                return this._data
            }
            getBuffer() {
                return this._buffer
            }
            getStrideSize() {
                return this.byteStride / Float32Array.BYTES_PER_ELEMENT
            }
            create(e=null) {
                !e && this._buffer || (e = e || this._data) && (this._buffer ? this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e),
                this._data = e) : this._updatable ? (this._buffer = this._engine.createDynamicVertexBuffer(e, this._label),
                this._data = e) : this._buffer = this._engine.createVertexBuffer(e, void 0, this._label))
            }
            _rebuild() {
                if (this._data)
                    this._buffer = null,
                    this.create(this._data);
                else {
                    if (!this._buffer)
                        return;
                    if (this._buffer.capacity > 0)
                        return void (this._updatable ? this._buffer = this._engine.createDynamicVertexBuffer(this._buffer.capacity, this._label) : this._buffer = this._engine.createVertexBuffer(this._buffer.capacity, void 0, this._label));
                    We.Warn(`Missing data for buffer "${this._label}" ${this._buffer ? "(uniqueId: " + this._buffer.uniqueId + ")" : ""}. Buffer reconstruction failed.`),
                    this._buffer = null
                }
            }
            update(e) {
                this.create(e)
            }
            updateDirectly(e, t, i, s=!1) {
                this._buffer && this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e, s ? t : t * Float32Array.BYTES_PER_ELEMENT, i ? i * this.byteStride : void 0),
                this._data = 0 === t && void 0 === i ? e : null)
            }
            _increaseReferences() {
                this._buffer && (this._isAlreadyOwned ? this._buffer.references++ : this._isAlreadyOwned = !0)
            }
            dispose() {
                this._buffer && this._engine._releaseBuffer(this._buffer) && (this._isDisposed = !0,
                this._data = null,
                this._buffer = null)
            }
        }
        class os {
            get isDisposed() {
                return this._isDisposed
            }
            get instanceDivisor() {
                return this._instanceDivisor
            }
            set instanceDivisor(e) {
                const t = 0 != e;
                this._instanceDivisor = e,
                t !== this._instanced && (this._instanced = t,
                this._computeHashCode())
            }
            get _maxVerticesCount() {
                const e = this.getData();
                return e ? Array.isArray(e) ? e.length / (this.byteStride / 4) - this.byteOffset / 4 : (e.byteLength - this.byteOffset) / this.byteStride : 0
            }
            constructor(e, t, i, s, r, n, a, o, h, l, c=!1, u=!1, d=1, f=!1) {
                this._isDisposed = !1;
                let _ = !1;
                if (this.engine = e,
                "object" == typeof s && null !== s ? (_ = s.updatable ?? !1,
                r = s.postponeInternalCreation,
                n = s.stride,
                a = s.instanced,
                o = s.offset,
                h = s.size,
                l = s.type,
                c = s.normalized ?? !1,
                u = s.useBytes ?? !1,
                d = s.divisor ?? 1,
                f = s.takeBufferOwnership ?? !1,
                this._label = s.label) : _ = !!s,
                t instanceof as ? (this._buffer = t,
                this._ownsBuffer = f) : (this._buffer = new as(e,t,_,n,r,a,u,d,this._label),
                this._ownsBuffer = !0),
                this.uniqueId = os._Counter++,
                this._kind = i,
                void 0 === l) {
                    const e = this.getData();
                    this.type = e ? os.GetDataType(e) : os.FLOAT
                } else
                    this.type = l;
                const p = os.GetTypeByteLength(this.type);
                u ? (this._size = h || (n ? n / p : os.DeduceStride(i)),
                this.byteStride = n || this._buffer.byteStride || this._size * p,
                this.byteOffset = o || 0) : (this._size = h || n || os.DeduceStride(i),
                this.byteStride = n ? n * p : this._buffer.byteStride || this._size * p,
                this.byteOffset = (o || 0) * p),
                this.normalized = c,
                this._instanced = void 0 !== a && a,
                this._instanceDivisor = a ? d : 0,
                this._alignBuffer(),
                this._computeHashCode()
            }
            _computeHashCode() {
                this.hashCode = (this.type - 5120 | 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (this.byteStride << 12)
            }
            _rebuild() {
                this._buffer?._rebuild()
            }
            getKind() {
                return this._kind
            }
            isUpdatable() {
                return this._buffer.isUpdatable()
            }
            getData() {
                return this._buffer.getData()
            }
            getFloatData(e, t) {
                const i = this.getData();
                return i ? os.GetFloatData(i, this._size, this.type, this.byteOffset, this.byteStride, this.normalized, e, t) : null
            }
            getBuffer() {
                return this._buffer.getBuffer()
            }
            getWrapperBuffer() {
                return this._buffer
            }
            getStrideSize() {
                return this.byteStride / os.GetTypeByteLength(this.type)
            }
            getOffset() {
                return this.byteOffset / os.GetTypeByteLength(this.type)
            }
            getSize(e=!1) {
                return e ? this._size * os.GetTypeByteLength(this.type) : this._size
            }
            getIsInstanced() {
                return this._instanced
            }
            getInstanceDivisor() {
                return this._instanceDivisor
            }
            create(e) {
                this._buffer.create(e),
                this._alignBuffer()
            }
            update(e) {
                this._buffer.update(e),
                this._alignBuffer()
            }
            updateDirectly(e, t, i=!1) {
                this._buffer.updateDirectly(e, t, void 0, i),
                this._alignBuffer()
            }
            dispose() {
                this._ownsBuffer && this._buffer.dispose(),
                this._isDisposed = !0
            }
            forEach(e, t) {
                os.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, e, this.normalized, t)
            }
            _alignBuffer() {}
            static DeduceStride(e) {
                switch (e) {
                case os.UVKind:
                case os.UV2Kind:
                case os.UV3Kind:
                case os.UV4Kind:
                case os.UV5Kind:
                case os.UV6Kind:
                    return 2;
                case os.NormalKind:
                case os.PositionKind:
                    return 3;
                case os.ColorKind:
                case os.ColorInstanceKind:
                case os.MatricesIndicesKind:
                case os.MatricesIndicesExtraKind:
                case os.MatricesWeightsKind:
                case os.MatricesWeightsExtraKind:
                case os.TangentKind:
                    return 4;
                default:
                    throw new Error("Invalid kind '" + e + "'")
                }
            }
            static GetDataType(e) {
                return e instanceof Int8Array ? os.BYTE : e instanceof Uint8Array ? os.UNSIGNED_BYTE : e instanceof Int16Array ? os.SHORT : e instanceof Uint16Array ? os.UNSIGNED_SHORT : e instanceof Int32Array ? os.INT : e instanceof Uint32Array ? os.UNSIGNED_INT : os.FLOAT
            }
            static GetTypeByteLength(e) {
                switch (e) {
                case os.BYTE:
                case os.UNSIGNED_BYTE:
                    return 1;
                case os.SHORT:
                case os.UNSIGNED_SHORT:
                    return 2;
                case os.INT:
                case os.UNSIGNED_INT:
                case os.FLOAT:
                    return 4;
                default:
                    throw new Error(`Invalid type '${e}'`)
                }
            }
            static ForEach(e, t, i, s, r, n, a, o) {
                if (e instanceof Array) {
                    let r = t / 4;
                    const a = i / 4;
                    for (let t = 0; t < n; t += s) {
                        for (let i = 0; i < s; i++)
                            o(e[r + i], t + i);
                        r += a
                    }
                } else {
                    const h = e instanceof ArrayBuffer ? new DataView(e) : new DataView(e.buffer,e.byteOffset,e.byteLength)
                      , l = os.GetTypeByteLength(r);
                    for (let e = 0; e < n; e += s) {
                        let n = t;
                        for (let t = 0; t < s; t++)
                            o(os._GetFloatValue(h, r, n, a), e + t),
                            n += l;
                        t += i
                    }
                }
            }
            static _GetFloatValue(e, t, i, s) {
                switch (t) {
                case os.BYTE:
                    {
                        let t = e.getInt8(i);
                        return s && (t = Math.max(t / 127, -1)),
                        t
                    }
                case os.UNSIGNED_BYTE:
                    {
                        let t = e.getUint8(i);
                        return s && (t /= 255),
                        t
                    }
                case os.SHORT:
                    {
                        let t = e.getInt16(i, !0);
                        return s && (t = Math.max(t / 32767, -1)),
                        t
                    }
                case os.UNSIGNED_SHORT:
                    {
                        let t = e.getUint16(i, !0);
                        return s && (t /= 65535),
                        t
                    }
                case os.INT:
                    return e.getInt32(i, !0);
                case os.UNSIGNED_INT:
                    return e.getUint32(i, !0);
                case os.FLOAT:
                    return e.getFloat32(i, !0);
                default:
                    throw new Error(`Invalid component type ${t}`)
                }
            }
            static GetFloatData(e, t, i, s, r, n, a, o) {
                const h = t * os.GetTypeByteLength(i)
                  , l = a * t;
                if (i !== os.FLOAT || r !== h) {
                    const a = new Float32Array(l);
                    return os.ForEach(e, s, r, t, i, l, n, ( (e, t) => a[t] = e)),
                    a
                }
                if (!(e instanceof Array || e instanceof Float32Array) || 0 !== s || e.length !== l) {
                    if (e instanceof Array) {
                        const t = s / 4;
                        return e.slice(t, t + l)
                    }
                    if (e instanceof ArrayBuffer)
                        return new Float32Array(e,s,l);
                    {
                        let t = e.byteOffset + s;
                        if (o) {
                            const i = new Float32Array(l)
                              , s = new Float32Array(e.buffer,t,l);
                            return i.set(s),
                            i
                        }
                        const i = t % 4;
                        return i && (t = Math.max(0, t - i)),
                        new Float32Array(e.buffer,t,l)
                    }
                }
                return o ? e.slice() : e
            }
        }
        os._Counter = 0,
        os.BYTE = 5120,
        os.UNSIGNED_BYTE = 5121,
        os.SHORT = 5122,
        os.UNSIGNED_SHORT = 5123,
        os.INT = 5124,
        os.UNSIGNED_INT = 5125,
        os.FLOAT = 5126,
        os.PositionKind = "position",
        os.NormalKind = "normal",
        os.TangentKind = "tangent",
        os.UVKind = "uv",
        os.UV2Kind = "uv2",
        os.UV3Kind = "uv3",
        os.UV4Kind = "uv4",
        os.UV5Kind = "uv5",
        os.UV6Kind = "uv6",
        os.ColorKind = "color",
        os.ColorInstanceKind = "instanceColor",
        os.MatricesIndicesKind = "matricesIndices",
        os.MatricesWeightsKind = "matricesWeights",
        os.MatricesIndicesExtraKind = "matricesIndicesExtra",
        os.MatricesWeightsExtraKind = "matricesWeightsExtra";
        class hs {
            constructor() {
                this.hit = !1,
                this.distance = 0,
                this.pickedPoint = null,
                this.pickedMesh = null,
                this.bu = 0,
                this.bv = 0,
                this.faceId = -1,
                this.subMeshFaceId = -1,
                this.subMeshId = 0,
                this.pickedSprite = null,
                this.thinInstanceIndex = -1,
                this.ray = null,
                this.originMesh = null,
                this.aimTransform = null,
                this.gripTransform = null
            }
            getNormal(e=!1, t=!0) {
                if (!this.pickedMesh || t && !this.pickedMesh.isVerticesDataPresent(os.NormalKind))
                    return null;
                let i, s = this.pickedMesh.getIndices();
                0 === s?.length && (s = null);
                const r = Bi.Vector3[0]
                  , n = Bi.Vector3[1]
                  , a = Bi.Vector3[2];
                if (t) {
                    const e = this.pickedMesh.getVerticesData(os.NormalKind);
                    let t = s ? Di.FromArrayToRef(e, 3 * s[3 * this.faceId], r) : r.copyFromFloats(e[3 * this.faceId * 3], e[3 * this.faceId * 3 + 1], e[3 * this.faceId * 3 + 2])
                      , o = s ? Di.FromArrayToRef(e, 3 * s[3 * this.faceId + 1], n) : n.copyFromFloats(e[3 * (3 * this.faceId + 1)], e[3 * (3 * this.faceId + 1) + 1], e[3 * (3 * this.faceId + 1) + 2])
                      , h = s ? Di.FromArrayToRef(e, 3 * s[3 * this.faceId + 2], a) : a.copyFromFloats(e[3 * (3 * this.faceId + 2)], e[3 * (3 * this.faceId + 2) + 1], e[3 * (3 * this.faceId + 2) + 2]);
                    t = t.scale(this.bu),
                    o = o.scale(this.bv),
                    h = h.scale(1 - this.bu - this.bv),
                    i = new Di(t.x + o.x + h.x,t.y + o.y + h.y,t.z + o.z + h.z)
                } else {
                    const e = this.pickedMesh.getVerticesData(os.PositionKind)
                      , t = s ? Di.FromArrayToRef(e, 3 * s[3 * this.faceId], r) : r.copyFromFloats(e[3 * this.faceId * 3], e[3 * this.faceId * 3 + 1], e[3 * this.faceId * 3 + 2])
                      , o = s ? Di.FromArrayToRef(e, 3 * s[3 * this.faceId + 1], n) : n.copyFromFloats(e[3 * (3 * this.faceId + 1)], e[3 * (3 * this.faceId + 1) + 1], e[3 * (3 * this.faceId + 1) + 2])
                      , h = s ? Di.FromArrayToRef(e, 3 * s[3 * this.faceId + 2], a) : a.copyFromFloats(e[3 * (3 * this.faceId + 2)], e[3 * (3 * this.faceId + 2) + 1], e[3 * (3 * this.faceId + 2) + 2])
                      , l = t.subtract(o)
                      , c = h.subtract(o);
                    i = Di.Cross(l, c)
                }
                const o = (e, t) => {
                    let i = e.getWorldMatrix();
                    e.nonUniformScaling && (Bi.Matrix[0].copyFrom(i),
                    i = Bi.Matrix[0],
                    i.setTranslationFromFloats(0, 0, 0),
                    i.invert(),
                    i.transposeToRef(Bi.Matrix[1]),
                    i = Bi.Matrix[1]),
                    Di.TransformNormalToRef(t, i, t)
                }
                ;
                if (e && o(this.pickedMesh, i),
                this.ray) {
                    const t = Bi.Vector3[0].copyFrom(i);
                    e || o(this.pickedMesh, t),
                    Di.Dot(t, this.ray.direction) > 0 && i.negateInPlace()
                }
                return i.normalize(),
                i
            }
            getTextureCoordinates(e=os.UVKind) {
                if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(e))
                    return null;
                const t = this.pickedMesh.getIndices();
                if (!t)
                    return null;
                const i = this.pickedMesh.getVerticesData(e);
                if (!i)
                    return null;
                let s = Pi.FromArray(i, 2 * t[3 * this.faceId])
                  , r = Pi.FromArray(i, 2 * t[3 * this.faceId + 1])
                  , n = Pi.FromArray(i, 2 * t[3 * this.faceId + 2]);
                return s = s.scale(this.bu),
                r = r.scale(this.bv),
                n = n.scale(1 - this.bu - this.bv),
                new Pi(s.x + r.x + n.x,s.y + r.y + n.y)
            }
        }
        class ls {
            constructor(e, t, i, s, r, n) {
                this.source = e,
                this.pointerX = t,
                this.pointerY = i,
                this.meshUnderPointer = s,
                this.sourceEvent = r,
                this.additionalData = n
            }
            static CreateNew(e, t, i) {
                const s = e.getScene();
                return new ls(e,s.pointerX,s.pointerY,s.meshUnderPointer || e,t,i)
            }
            static CreateNewFromSprite(e, t, i, s) {
                return new ls(e,t.pointerX,t.pointerY,t.meshUnderPointer,i,s)
            }
            static CreateNewFromScene(e, t) {
                return new ls(null,e.pointerX,e.pointerY,e.meshUnderPointer,t)
            }
            static CreateNewFromPrimitive(e, t, i, s) {
                return new ls(e,t.x,t.y,null,i,s)
            }
        }
        class cs {
            constructor(e) {
                this._vertexBuffers = {},
                this._scene = e
            }
            _prepareBuffers() {
                if (this._vertexBuffers[os.PositionKind])
                    return;
                const e = [];
                e.push(1, 1),
                e.push(-1, 1),
                e.push(-1, -1),
                e.push(1, -1),
                this._vertexBuffers[os.PositionKind] = new os(this._scene.getEngine(),e,os.PositionKind,!1,!1,2),
                this._buildIndexBuffer()
            }
            _buildIndexBuffer() {
                const e = [];
                e.push(0),
                e.push(1),
                e.push(2),
                e.push(0),
                e.push(2),
                e.push(3),
                this._indexBuffer = this._scene.getEngine().createIndexBuffer(e)
            }
            _rebuild() {
                const e = this._vertexBuffers[os.PositionKind];
                e && (e._rebuild(),
                this._buildIndexBuffer())
            }
            _prepareFrame(e=null, t=null) {
                const i = this._scene.activeCamera;
                return !(!i || !(t = t || i._postProcesses.filter((e => null != e))) || 0 === t.length || !this._scene.postProcessesEnabled || (t[0].activate(i, e, null != t),
                0))
            }
            directRender(e, t=null, i=!1, s=0, r=0, n=!1) {
                const a = this._scene.getEngine();
                for (let o = 0; o < e.length; o++) {
                    o < e.length - 1 ? e[o + 1].activate(this._scene.activeCamera, t?.texture) : (t ? a.bindFramebuffer(t, s, void 0, void 0, i, r) : n || a.restoreDefaultFramebuffer(),
                    a._debugInsertMarker?.(`post process ${e[o].name} output`));
                    const h = e[o]
                      , l = h.apply();
                    l && (h.onBeforeRenderObservable.notifyObservers(l),
                    this._prepareBuffers(),
                    a.bindBuffers(this._vertexBuffers, this._indexBuffer, l),
                    a.drawElementsType(0, 0, 6),
                    h.onAfterRenderObservable.notifyObservers(l))
                }
                a.setDepthBuffer(!0),
                a.setDepthWrite(!0)
            }
            _finalizeFrame(e, t, i, s, r=!1) {
                const n = this._scene.activeCamera;
                if (!n)
                    return;
                if (0 === (s = s || n._postProcesses.filter((e => null != e))).length || !this._scene.postProcessesEnabled)
                    return;
                const a = this._scene.getEngine();
                for (let o = 0, h = s.length; o < h; o++) {
                    const l = s[o];
                    if (o < h - 1 ? l._outputTexture = s[o + 1].activate(n, t?.texture) : (t ? (a.bindFramebuffer(t, i, void 0, void 0, r),
                    l._outputTexture = t) : (a.restoreDefaultFramebuffer(),
                    l._outputTexture = null),
                    a._debugInsertMarker?.(`post process ${s[o].name} output`)),
                    e)
                        break;
                    const c = l.apply();
                    c && (l.onBeforeRenderObservable.notifyObservers(c),
                    this._prepareBuffers(),
                    a.bindBuffers(this._vertexBuffers, this._indexBuffer, c),
                    a.drawElementsType(0, 0, 6),
                    l.onAfterRenderObservable.notifyObservers(c))
                }
                a.setDepthBuffer(!0),
                a.setDepthWrite(!0),
                a.setAlphaMode(0)
            }
            dispose() {
                const e = this._vertexBuffers[os.PositionKind];
                e && (e.dispose(),
                this._vertexBuffers[os.PositionKind] = null),
                this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer),
                this._indexBuffer = null)
            }
        }
        class us {
            set opaqueSortCompareFn(e) {
                this._opaqueSortCompareFn = e || us.PainterSortCompare,
                this._renderOpaque = this._renderOpaqueSorted
            }
            set alphaTestSortCompareFn(e) {
                this._alphaTestSortCompareFn = e || us.PainterSortCompare,
                this._renderAlphaTest = this._renderAlphaTestSorted
            }
            set transparentSortCompareFn(e) {
                this._transparentSortCompareFn = e || us.defaultTransparentSortCompare,
                this._renderTransparent = this._renderTransparentSorted
            }
            constructor(e, t, i=null, s=null, r=null) {
                this.index = e,
                this._opaqueSubMeshes = new Ii(256),
                this._transparentSubMeshes = new Ii(256),
                this._alphaTestSubMeshes = new Ii(256),
                this._depthOnlySubMeshes = new Ii(256),
                this._particleSystems = new Ii(256),
                this._spriteManagers = new Ii(256),
                this._empty = !0,
                this._edgesRenderers = new Ri(16),
                this._scene = t,
                this.opaqueSortCompareFn = i,
                this.alphaTestSortCompareFn = s,
                this.transparentSortCompareFn = r
            }
            render(e, t, i, s) {
                if (e)
                    return void e(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);
                const r = this._scene.getEngine();
                0 !== this._depthOnlySubMeshes.length && (r.setColorWrite(!1),
                this._renderAlphaTest(this._depthOnlySubMeshes),
                r.setColorWrite(!0)),
                0 !== this._opaqueSubMeshes.length && this._renderOpaque(this._opaqueSubMeshes),
                0 !== this._alphaTestSubMeshes.length && this._renderAlphaTest(this._alphaTestSubMeshes);
                const n = r.getStencilBuffer();
                if (r.setStencilBuffer(!1),
                t && this._renderSprites(),
                i && this._renderParticles(s),
                this.onBeforeTransparentRendering && this.onBeforeTransparentRendering(),
                0 !== this._transparentSubMeshes.length || this._scene.useOrderIndependentTransparency) {
                    if (r.setStencilBuffer(n),
                    this._scene.useOrderIndependentTransparency) {
                        const e = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);
                        e.length && this._renderTransparent(e)
                    } else
                        this._renderTransparent(this._transparentSubMeshes);
                    r.setAlphaMode(0)
                }
                if (r.setStencilBuffer(!1),
                this._edgesRenderers.length) {
                    for (let e = 0; e < this._edgesRenderers.length; e++)
                        this._edgesRenderers.data[e].render();
                    r.setAlphaMode(0)
                }
                r.setStencilBuffer(n)
            }
            _renderOpaqueSorted(e) {
                us._RenderSorted(e, this._opaqueSortCompareFn, this._scene.activeCamera, !1)
            }
            _renderAlphaTestSorted(e) {
                us._RenderSorted(e, this._alphaTestSortCompareFn, this._scene.activeCamera, !1)
            }
            _renderTransparentSorted(e) {
                us._RenderSorted(e, this._transparentSortCompareFn, this._scene.activeCamera, !0)
            }
            static _RenderSorted(e, t, i, s) {
                let r, n = 0;
                const a = i ? i.globalPosition : us._ZeroVector;
                if (s)
                    for (; n < e.length; n++)
                        r = e.data[n],
                        r._alphaIndex = r.getMesh().alphaIndex,
                        r._distanceToCamera = Di.Distance(r.getBoundingInfo().boundingSphere.centerWorld, a);
                const o = e.length === e.data.length ? e.data : e.data.slice(0, e.length);
                t && o.sort(t);
                const h = o[0].getMesh().getScene();
                for (n = 0; n < o.length; n++)
                    if (r = o[n],
                    !h._activeMeshesFrozenButKeepClipping || r.isInFrustum(h._frustumPlanes)) {
                        if (s) {
                            const e = r.getMaterial();
                            if (e && e.needDepthPrePass) {
                                const t = e.getScene().getEngine();
                                t.setColorWrite(!1),
                                t.setAlphaMode(0),
                                r.render(!1),
                                t.setColorWrite(!0)
                            }
                        }
                        r.render(s)
                    }
            }
            static defaultTransparentSortCompare(e, t) {
                return e._alphaIndex > t._alphaIndex ? 1 : e._alphaIndex < t._alphaIndex ? -1 : us.backToFrontSortCompare(e, t)
            }
            static backToFrontSortCompare(e, t) {
                return e._distanceToCamera < t._distanceToCamera ? 1 : e._distanceToCamera > t._distanceToCamera ? -1 : 0
            }
            static frontToBackSortCompare(e, t) {
                return e._distanceToCamera < t._distanceToCamera ? -1 : e._distanceToCamera > t._distanceToCamera ? 1 : 0
            }
            static PainterSortCompare(e, t) {
                const i = e.getMesh()
                  , s = t.getMesh();
                return i.material && s.material ? i.material.uniqueId - s.material.uniqueId : i.uniqueId - s.uniqueId
            }
            prepare() {
                this._opaqueSubMeshes.reset(),
                this._transparentSubMeshes.reset(),
                this._alphaTestSubMeshes.reset(),
                this._depthOnlySubMeshes.reset(),
                this._particleSystems.reset(),
                this.prepareSprites(),
                this._edgesRenderers.reset(),
                this._empty = !0
            }
            prepareSprites() {
                this._spriteManagers.reset()
            }
            dispose() {
                this._opaqueSubMeshes.dispose(),
                this._transparentSubMeshes.dispose(),
                this._alphaTestSubMeshes.dispose(),
                this._depthOnlySubMeshes.dispose(),
                this._particleSystems.dispose(),
                this._spriteManagers.dispose(),
                this._edgesRenderers.dispose()
            }
            dispatch(e, t, i) {
                void 0 === t && (t = e.getMesh()),
                void 0 === i && (i = e.getMaterial()),
                null != i && (i.needAlphaBlendingForMesh(t) ? this._transparentSubMeshes.push(e) : i.needAlphaTesting() ? (i.needDepthPrePass && this._depthOnlySubMeshes.push(e),
                this._alphaTestSubMeshes.push(e)) : (i.needDepthPrePass && this._depthOnlySubMeshes.push(e),
                this._opaqueSubMeshes.push(e)),
                t._renderingGroup = this,
                t._edgesRenderer && t._edgesRenderer.isEnabled && this._edgesRenderers.pushNoDuplicate(t._edgesRenderer),
                this._empty = !1)
            }
            dispatchSprites(e) {
                this._spriteManagers.push(e),
                this._empty = !1
            }
            dispatchParticles(e) {
                this._particleSystems.push(e),
                this._empty = !1
            }
            _renderParticles(e) {
                if (0 === this._particleSystems.length)
                    return;
                const t = this._scene.activeCamera;
                this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
                for (let i = 0; i < this._particleSystems.length; i++) {
                    const s = this._particleSystems.data[i];
                    if (0 === (t && t.layerMask & s.layerMask))
                        continue;
                    const r = s.emitter;
                    r.position && e && -1 === e.indexOf(r) || this._scene._activeParticles.addCount(s.render(), !1)
                }
                this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)
            }
            _renderSprites() {
                if (!this._scene.spritesEnabled || 0 === this._spriteManagers.length)
                    return;
                const e = this._scene.activeCamera;
                this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);
                for (let t = 0; t < this._spriteManagers.length; t++) {
                    const i = this._spriteManagers.data[t];
                    0 !== (e && e.layerMask & i.layerMask) && i.render()
                }
                this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene)
            }
        }
        us._ZeroVector = Di.Zero();
        class ds {
        }
        class fs {
            get maintainStateBetweenFrames() {
                return this._maintainStateBetweenFrames
            }
            set maintainStateBetweenFrames(e) {
                e !== this._maintainStateBetweenFrames && (this._maintainStateBetweenFrames = e,
                this._maintainStateBetweenFrames || this.restoreDispachedFlags())
            }
            restoreDispachedFlags() {
                for (const e of this._scene.meshes)
                    if (e.subMeshes)
                        for (const t of e.subMeshes)
                            t._wasDispatched = !1;
                if (this._scene.spriteManagers)
                    for (const e of this._scene.spriteManagers)
                        e._wasDispatched = !1;
                for (const e of this._scene.particleSystems)
                    e._wasDispatched = !1
            }
            constructor(e) {
                this._useSceneAutoClearSetup = !1,
                this._renderingGroups = new Array,
                this._autoClearDepthStencil = {},
                this._customOpaqueSortCompareFn = {},
                this._customAlphaTestSortCompareFn = {},
                this._customTransparentSortCompareFn = {},
                this._renderingGroupInfo = new ds,
                this._maintainStateBetweenFrames = !1,
                this._scene = e;
                for (let e = fs.MIN_RENDERINGGROUPS; e < fs.MAX_RENDERINGGROUPS; e++)
                    this._autoClearDepthStencil[e] = {
                        autoClear: !0,
                        depth: !0,
                        stencil: !0
                    }
            }
            getRenderingGroup(e) {
                const t = e || 0;
                return this._prepareRenderingGroup(t),
                this._renderingGroups[t]
            }
            _clearDepthStencilBuffer(e=!0, t=!0) {
                this._depthStencilBufferAlreadyCleaned || (this._scene.getEngine().clear(null, !1, e, t),
                this._depthStencilBufferAlreadyCleaned = !0)
            }
            render(e, t, i, s) {
                const r = this._renderingGroupInfo;
                if (r.scene = this._scene,
                r.camera = this._scene.activeCamera,
                this._scene.spriteManagers && s)
                    for (let e = 0; e < this._scene.spriteManagers.length; e++) {
                        const t = this._scene.spriteManagers[e];
                        this.dispatchSprites(t)
                    }
                for (let n = fs.MIN_RENDERINGGROUPS; n < fs.MAX_RENDERINGGROUPS; n++) {
                    this._depthStencilBufferAlreadyCleaned = n === fs.MIN_RENDERINGGROUPS;
                    const a = this._renderingGroups[n];
                    if (!a || a._empty)
                        continue;
                    const o = 1 << n;
                    if (r.renderingGroupId = n,
                    this._scene.onBeforeRenderingGroupObservable.notifyObservers(r, o),
                    fs.AUTOCLEAR) {
                        const e = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(n) : this._autoClearDepthStencil[n];
                        e && e.autoClear && this._clearDepthStencilBuffer(e.depth, e.stencil)
                    }
                    for (const e of this._scene._beforeRenderingGroupDrawStage)
                        e.action(n);
                    a.render(e, s, i, t);
                    for (const e of this._scene._afterRenderingGroupDrawStage)
                        e.action(n);
                    this._scene.onAfterRenderingGroupObservable.notifyObservers(r, o)
                }
            }
            reset() {
                if (!this.maintainStateBetweenFrames)
                    for (let e = fs.MIN_RENDERINGGROUPS; e < fs.MAX_RENDERINGGROUPS; e++) {
                        const t = this._renderingGroups[e];
                        t && t.prepare()
                    }
            }
            resetSprites() {
                if (!this.maintainStateBetweenFrames)
                    for (let e = fs.MIN_RENDERINGGROUPS; e < fs.MAX_RENDERINGGROUPS; e++) {
                        const t = this._renderingGroups[e];
                        t && t.prepareSprites()
                    }
            }
            dispose() {
                this.freeRenderingGroups(),
                this._renderingGroups.length = 0,
                this._renderingGroupInfo = null
            }
            freeRenderingGroups() {
                for (let e = fs.MIN_RENDERINGGROUPS; e < fs.MAX_RENDERINGGROUPS; e++) {
                    const t = this._renderingGroups[e];
                    t && t.dispose()
                }
            }
            _prepareRenderingGroup(e) {
                void 0 === this._renderingGroups[e] && (this._renderingGroups[e] = new us(e,this._scene,this._customOpaqueSortCompareFn[e],this._customAlphaTestSortCompareFn[e],this._customTransparentSortCompareFn[e]))
            }
            dispatchSprites(e) {
                this.maintainStateBetweenFrames && e._wasDispatched || (e._wasDispatched = !0,
                this.getRenderingGroup(e.renderingGroupId).dispatchSprites(e))
            }
            dispatchParticles(e) {
                this.maintainStateBetweenFrames && e._wasDispatched || (e._wasDispatched = !0,
                this.getRenderingGroup(e.renderingGroupId).dispatchParticles(e))
            }
            dispatch(e, t, i) {
                void 0 === t && (t = e.getMesh()),
                this.maintainStateBetweenFrames && e._wasDispatched || (e._wasDispatched = !0,
                this.getRenderingGroup(t.renderingGroupId).dispatch(e, t, i))
            }
            setRenderingOrder(e, t=null, i=null, s=null) {
                if (this._customOpaqueSortCompareFn[e] = t,
                this._customAlphaTestSortCompareFn[e] = i,
                this._customTransparentSortCompareFn[e] = s,
                this._renderingGroups[e]) {
                    const t = this._renderingGroups[e];
                    t.opaqueSortCompareFn = this._customOpaqueSortCompareFn[e],
                    t.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[e],
                    t.transparentSortCompareFn = this._customTransparentSortCompareFn[e]
                }
            }
            setRenderingAutoClearDepthStencil(e, t, i=!0, s=!0) {
                this._autoClearDepthStencil[e] = {
                    autoClear: t,
                    depth: i,
                    stencil: s
                }
            }
            getAutoClearDepthStencilSetup(e) {
                return this._autoClearDepthStencil[e]
            }
        }
        fs.MAX_RENDERINGGROUPS = 4,
        fs.MIN_RENDERINGGROUPS = 0,
        fs.AUTOCLEAR = !0;
        class _s {
        }
        _s.NAME_EFFECTLAYER = "EffectLayer",
        _s.NAME_LAYER = "Layer",
        _s.NAME_LENSFLARESYSTEM = "LensFlareSystem",
        _s.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer",
        _s.NAME_PARTICLESYSTEM = "ParticleSystem",
        _s.NAME_GAMEPAD = "Gamepad",
        _s.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue",
        _s.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer",
        _s.NAME_PREPASSRENDERER = "PrePassRenderer",
        _s.NAME_DEPTHRENDERER = "DepthRenderer",
        _s.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer",
        _s.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager",
        _s.NAME_SPRITE = "Sprite",
        _s.NAME_SUBSURFACE = "SubSurface",
        _s.NAME_OUTLINERENDERER = "Outline",
        _s.NAME_PROCEDURALTEXTURE = "ProceduralTexture",
        _s.NAME_SHADOWGENERATOR = "ShadowGenerator",
        _s.NAME_OCTREE = "Octree",
        _s.NAME_PHYSICSENGINE = "PhysicsEngine",
        _s.NAME_AUDIO = "Audio",
        _s.NAME_FLUIDRENDERER = "FluidRenderer",
        _s.STEP_ISREADYFORMESH_EFFECTLAYER = 0,
        _s.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0,
        _s.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0,
        _s.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0,
        _s.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1,
        _s.STEP_BEFORECAMERADRAW_PREPASS = 0,
        _s.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1,
        _s.STEP_BEFORECAMERADRAW_LAYER = 2,
        _s.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0,
        _s.STEP_BEFORERENDERTARGETDRAW_LAYER = 1,
        _s.STEP_BEFORERENDERINGMESH_PREPASS = 0,
        _s.STEP_BEFORERENDERINGMESH_OUTLINE = 1,
        _s.STEP_AFTERRENDERINGMESH_PREPASS = 0,
        _s.STEP_AFTERRENDERINGMESH_OUTLINE = 1,
        _s.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0,
        _s.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1,
        _s.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0,
        _s.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1,
        _s.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0,
        _s.STEP_BEFORECLEAR_PREPASS = 1,
        _s.STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0,
        _s.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0,
        _s.STEP_AFTERRENDERTARGETDRAW_LAYER = 1,
        _s.STEP_AFTERCAMERADRAW_PREPASS = 0,
        _s.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1,
        _s.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2,
        _s.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3,
        _s.STEP_AFTERCAMERADRAW_LAYER = 4,
        _s.STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5,
        _s.STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0,
        _s.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0,
        _s.STEP_AFTERRENDER_AUDIO = 0,
        _s.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0,
        _s.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1,
        _s.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2,
        _s.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3,
        _s.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0,
        _s.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1,
        _s.STEP_POINTERMOVE_SPRITE = 0,
        _s.STEP_POINTERDOWN_SPRITE = 0,
        _s.STEP_POINTERUP_SPRITE = 0;
        class ps extends Array {
            constructor(e) {
                super(...e)
            }
            static Create() {
                return Object.create(ps.prototype)
            }
            registerStep(e, t, i) {
                let s = 0
                  , r = Number.MAX_VALUE;
                for (; s < this.length && (r = this[s].index,
                !(e < r)); s++)
                    ;
                this.splice(s, 0, {
                    index: e,
                    component: t,
                    action: i.bind(t)
                })
            }
            clear() {
                this.length = 0
            }
        }
        class ms {
        }
        ms.POINTERDOWN = 1,
        ms.POINTERUP = 2,
        ms.POINTERMOVE = 4,
        ms.POINTERWHEEL = 8,
        ms.POINTERPICK = 16,
        ms.POINTERTAP = 32,
        ms.POINTERDOUBLETAP = 64;
        class gs {
            constructor(e, t) {
                this.type = e,
                this.event = t
            }
        }
        class vs extends gs {
            constructor(e, t, i, s) {
                super(e, t),
                this.ray = null,
                this.originalPickingInfo = null,
                this.skipOnPointerObservable = !1,
                this.localPosition = new Pi(i,s)
            }
        }
        class ys extends gs {
            get pickInfo() {
                return this._pickInfo || this._generatePickInfo(),
                this._pickInfo
            }
            constructor(e, t, i, s=null) {
                super(e, t),
                this._pickInfo = i,
                this._inputManager = s
            }
            _generatePickInfo() {
                this._inputManager && (this._pickInfo = this._inputManager._pickMove(this.event),
                this._inputManager._setRayOnPointerInfo(this._pickInfo, this.event),
                this._inputManager = null)
            }
        }
        class bs {
            constructor() {
                this.hoverCursor = "",
                this.actions = [],
                this.isRecursive = !1
            }
            static get HasTriggers() {
                for (const e in bs.Triggers)
                    if (Object.prototype.hasOwnProperty.call(bs.Triggers, e))
                        return !0;
                return !1
            }
            static get HasPickTriggers() {
                for (const e in bs.Triggers)
                    if (Object.prototype.hasOwnProperty.call(bs.Triggers, e)) {
                        const t = parseInt(e);
                        if (t >= 1 && t <= 7)
                            return !0
                    }
                return !1
            }
            static HasSpecificTrigger(e) {
                for (const t in bs.Triggers)
                    if (Object.prototype.hasOwnProperty.call(bs.Triggers, t) && parseInt(t) === e)
                        return !0;
                return !1
            }
        }
        bs.Triggers = {};
        class xs {
        }
        xs.KEYDOWN = 1,
        xs.KEYUP = 2;
        class Ts {
            constructor(e, t) {
                this.type = e,
                this.event = t
            }
        }
        class Es extends Ts {
            get skipOnPointerObservable() {
                return this.skipOnKeyboardObservable
            }
            set skipOnPointerObservable(e) {
                this.skipOnKeyboardObservable = e
            }
            constructor(e, t) {
                super(e, t),
                this.type = e,
                this.event = t,
                this.skipOnKeyboardObservable = !1
            }
        }
        !function(e) {
            e[e.Generic = 0] = "Generic",
            e[e.Keyboard = 1] = "Keyboard",
            e[e.Mouse = 2] = "Mouse",
            e[e.Touch = 3] = "Touch",
            e[e.DualShock = 4] = "DualShock",
            e[e.Xbox = 5] = "Xbox",
            e[e.Switch = 6] = "Switch",
            e[e.DualSense = 7] = "DualSense"
        }(Qi || (Qi = {})),
        function(e) {
            e[e.Horizontal = 0] = "Horizontal",
            e[e.Vertical = 1] = "Vertical",
            e[e.LeftClick = 2] = "LeftClick",
            e[e.MiddleClick = 3] = "MiddleClick",
            e[e.RightClick = 4] = "RightClick",
            e[e.BrowserBack = 5] = "BrowserBack",
            e[e.BrowserForward = 6] = "BrowserForward",
            e[e.MouseWheelX = 7] = "MouseWheelX",
            e[e.MouseWheelY = 8] = "MouseWheelY",
            e[e.MouseWheelZ = 9] = "MouseWheelZ",
            e[e.Move = 12] = "Move"
        }($i || ($i = {})),
        function(e) {
            e[e.Horizontal = 0] = "Horizontal",
            e[e.Vertical = 1] = "Vertical",
            e[e.LeftClick = 2] = "LeftClick",
            e[e.MiddleClick = 3] = "MiddleClick",
            e[e.RightClick = 4] = "RightClick",
            e[e.BrowserBack = 5] = "BrowserBack",
            e[e.BrowserForward = 6] = "BrowserForward",
            e[e.MouseWheelX = 7] = "MouseWheelX",
            e[e.MouseWheelY = 8] = "MouseWheelY",
            e[e.MouseWheelZ = 9] = "MouseWheelZ",
            e[e.DeltaHorizontal = 10] = "DeltaHorizontal",
            e[e.DeltaVertical = 11] = "DeltaVertical"
        }(Ji || (Ji = {})),
        function(e) {
            e[e.Cross = 0] = "Cross",
            e[e.Circle = 1] = "Circle",
            e[e.Square = 2] = "Square",
            e[e.Triangle = 3] = "Triangle",
            e[e.L1 = 4] = "L1",
            e[e.R1 = 5] = "R1",
            e[e.L2 = 6] = "L2",
            e[e.R2 = 7] = "R2",
            e[e.Share = 8] = "Share",
            e[e.Options = 9] = "Options",
            e[e.L3 = 10] = "L3",
            e[e.R3 = 11] = "R3",
            e[e.DPadUp = 12] = "DPadUp",
            e[e.DPadDown = 13] = "DPadDown",
            e[e.DPadLeft = 14] = "DPadLeft",
            e[e.DPadRight = 15] = "DPadRight",
            e[e.Home = 16] = "Home",
            e[e.TouchPad = 17] = "TouchPad",
            e[e.LStickXAxis = 18] = "LStickXAxis",
            e[e.LStickYAxis = 19] = "LStickYAxis",
            e[e.RStickXAxis = 20] = "RStickXAxis",
            e[e.RStickYAxis = 21] = "RStickYAxis"
        }(es || (es = {})),
        function(e) {
            e[e.Cross = 0] = "Cross",
            e[e.Circle = 1] = "Circle",
            e[e.Square = 2] = "Square",
            e[e.Triangle = 3] = "Triangle",
            e[e.L1 = 4] = "L1",
            e[e.R1 = 5] = "R1",
            e[e.L2 = 6] = "L2",
            e[e.R2 = 7] = "R2",
            e[e.Create = 8] = "Create",
            e[e.Options = 9] = "Options",
            e[e.L3 = 10] = "L3",
            e[e.R3 = 11] = "R3",
            e[e.DPadUp = 12] = "DPadUp",
            e[e.DPadDown = 13] = "DPadDown",
            e[e.DPadLeft = 14] = "DPadLeft",
            e[e.DPadRight = 15] = "DPadRight",
            e[e.Home = 16] = "Home",
            e[e.TouchPad = 17] = "TouchPad",
            e[e.LStickXAxis = 18] = "LStickXAxis",
            e[e.LStickYAxis = 19] = "LStickYAxis",
            e[e.RStickXAxis = 20] = "RStickXAxis",
            e[e.RStickYAxis = 21] = "RStickYAxis"
        }(ts || (ts = {})),
        function(e) {
            e[e.A = 0] = "A",
            e[e.B = 1] = "B",
            e[e.X = 2] = "X",
            e[e.Y = 3] = "Y",
            e[e.LB = 4] = "LB",
            e[e.RB = 5] = "RB",
            e[e.LT = 6] = "LT",
            e[e.RT = 7] = "RT",
            e[e.Back = 8] = "Back",
            e[e.Start = 9] = "Start",
            e[e.LS = 10] = "LS",
            e[e.RS = 11] = "RS",
            e[e.DPadUp = 12] = "DPadUp",
            e[e.DPadDown = 13] = "DPadDown",
            e[e.DPadLeft = 14] = "DPadLeft",
            e[e.DPadRight = 15] = "DPadRight",
            e[e.Home = 16] = "Home",
            e[e.LStickXAxis = 17] = "LStickXAxis",
            e[e.LStickYAxis = 18] = "LStickYAxis",
            e[e.RStickXAxis = 19] = "RStickXAxis",
            e[e.RStickYAxis = 20] = "RStickYAxis"
        }(is || (is = {})),
        function(e) {
            e[e.B = 0] = "B",
            e[e.A = 1] = "A",
            e[e.Y = 2] = "Y",
            e[e.X = 3] = "X",
            e[e.L = 4] = "L",
            e[e.R = 5] = "R",
            e[e.ZL = 6] = "ZL",
            e[e.ZR = 7] = "ZR",
            e[e.Minus = 8] = "Minus",
            e[e.Plus = 9] = "Plus",
            e[e.LS = 10] = "LS",
            e[e.RS = 11] = "RS",
            e[e.DPadUp = 12] = "DPadUp",
            e[e.DPadDown = 13] = "DPadDown",
            e[e.DPadLeft = 14] = "DPadLeft",
            e[e.DPadRight = 15] = "DPadRight",
            e[e.Home = 16] = "Home",
            e[e.Capture = 17] = "Capture",
            e[e.LStickXAxis = 18] = "LStickXAxis",
            e[e.LStickYAxis = 19] = "LStickYAxis",
            e[e.RStickXAxis = 20] = "RStickXAxis",
            e[e.RStickYAxis = 21] = "RStickYAxis"
        }(ss || (ss = {})),
        function(e) {
            e[e.PointerMove = 0] = "PointerMove",
            e[e.PointerDown = 1] = "PointerDown",
            e[e.PointerUp = 2] = "PointerUp"
        }(rs || (rs = {}));
        class Ms {
        }
        Ms.DOM_DELTA_PIXEL = 0,
        Ms.DOM_DELTA_LINE = 1,
        Ms.DOM_DELTA_PAGE = 2;
        class Ss {
            static CreateDeviceEvent(e, t, i, s, r, n, a) {
                switch (e) {
                case Qi.Keyboard:
                    return this._CreateKeyboardEvent(i, s, r, n);
                case Qi.Mouse:
                    if (i === $i.MouseWheelX || i === $i.MouseWheelY || i === $i.MouseWheelZ)
                        return this._CreateWheelEvent(e, t, i, s, r, n);
                case Qi.Touch:
                    return this._CreatePointerEvent(e, t, i, s, r, n, a);
                default:
                    throw `Unable to generate event for device ${Qi[e]}`
                }
            }
            static _CreatePointerEvent(e, t, i, s, r, n, a) {
                const o = this._CreateMouseEvent(e, t, i, s, r, n);
                e === Qi.Mouse ? (o.deviceType = Qi.Mouse,
                o.pointerId = 1,
                o.pointerType = "mouse") : (o.deviceType = Qi.Touch,
                o.pointerId = a ?? t,
                o.pointerType = "touch");
                let h = 0;
                return h += r.pollInput(e, t, $i.LeftClick),
                h += 2 * r.pollInput(e, t, $i.RightClick),
                h += 4 * r.pollInput(e, t, $i.MiddleClick),
                o.buttons = h,
                i === $i.Move ? o.type = "pointermove" : i >= $i.LeftClick && i <= $i.RightClick && (o.type = 1 === s ? "pointerdown" : "pointerup",
                o.button = i - 2),
                o
            }
            static _CreateWheelEvent(e, t, i, s, r, n) {
                const a = this._CreateMouseEvent(e, t, i, s, r, n);
                switch (a.pointerId = 1,
                a.type = "wheel",
                a.deltaMode = Ms.DOM_DELTA_PIXEL,
                a.deltaX = 0,
                a.deltaY = 0,
                a.deltaZ = 0,
                i) {
                case $i.MouseWheelX:
                    a.deltaX = s;
                    break;
                case $i.MouseWheelY:
                    a.deltaY = s;
                    break;
                case $i.MouseWheelZ:
                    a.deltaZ = s
                }
                return a
            }
            static _CreateMouseEvent(e, t, i, s, r, n) {
                const a = this._CreateEvent(n)
                  , o = r.pollInput(e, t, $i.Horizontal)
                  , h = r.pollInput(e, t, $i.Vertical);
                return n ? (a.movementX = 0,
                a.movementY = 0,
                a.offsetX = a.movementX - n.getBoundingClientRect().x,
                a.offsetY = a.movementY - n.getBoundingClientRect().y) : (a.movementX = r.pollInput(e, t, Ji.DeltaHorizontal),
                a.movementY = r.pollInput(e, t, Ji.DeltaVertical),
                a.offsetX = 0,
                a.offsetY = 0),
                this._CheckNonCharacterKeys(a, r),
                a.clientX = o,
                a.clientY = h,
                a.x = o,
                a.y = h,
                a.deviceType = e,
                a.deviceSlot = t,
                a.inputIndex = i,
                a
            }
            static _CreateKeyboardEvent(e, t, i, s) {
                const r = this._CreateEvent(s);
                return this._CheckNonCharacterKeys(r, i),
                r.deviceType = Qi.Keyboard,
                r.deviceSlot = 0,
                r.inputIndex = e,
                r.type = 1 === t ? "keydown" : "keyup",
                r.key = String.fromCharCode(e),
                r.keyCode = e,
                r
            }
            static _CheckNonCharacterKeys(e, t) {
                const i = t.isDeviceAvailable(Qi.Keyboard)
                  , s = i && 1 === t.pollInput(Qi.Keyboard, 0, 18)
                  , r = i && 1 === t.pollInput(Qi.Keyboard, 0, 17)
                  , n = i && (1 === t.pollInput(Qi.Keyboard, 0, 91) || 1 === t.pollInput(Qi.Keyboard, 0, 92) || 1 === t.pollInput(Qi.Keyboard, 0, 93))
                  , a = i && 1 === t.pollInput(Qi.Keyboard, 0, 16);
                e.altKey = s,
                e.ctrlKey = r,
                e.metaKey = n,
                e.shiftKey = a
            }
            static _CreateEvent(e) {
                const t = {
                    preventDefault: () => {}
                };
                return t.target = e,
                t
            }
        }
        class As {
            constructor(e, t, i) {
                this._nativeInput = _native.DeviceInputSystem ? new _native.DeviceInputSystem(e,t,( (e, t, s, r) => {
                    const n = Ss.CreateDeviceEvent(e, t, s, r, this);
                    i(e, t, n)
                }
                )) : this._createDummyNativeInput()
            }
            pollInput(e, t, i) {
                return this._nativeInput.pollInput(e, t, i)
            }
            isDeviceAvailable(e) {
                return e === Qi.Mouse || e === Qi.Touch
            }
            dispose() {
                this._nativeInput.dispose()
            }
            _createDummyNativeInput() {
                return {
                    pollInput: () => 0,
                    isDeviceAvailable: () => !1,
                    dispose: () => {}
                }
            }
        }
        const Is = Object.keys($i).length / 2;
        class Rs {
            constructor(e, t, i, s) {
                this._inputs = [],
                this._keyboardActive = !1,
                this._pointerActive = !1,
                this._usingSafari = hi.IsSafari(),
                this._usingMacOS = Ve() && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform),
                this._keyboardDownEvent = e => {}
                ,
                this._keyboardUpEvent = e => {}
                ,
                this._keyboardBlurEvent = e => {}
                ,
                this._pointerMoveEvent = e => {}
                ,
                this._pointerDownEvent = e => {}
                ,
                this._pointerUpEvent = e => {}
                ,
                this._pointerCancelEvent = e => {}
                ,
                this._pointerWheelEvent = e => {}
                ,
                this._pointerBlurEvent = e => {}
                ,
                this._pointerMacOSChromeOutEvent = e => {}
                ,
                this._eventsAttached = !1,
                this._mouseId = -1,
                this._isUsingFirefox = Ve() && navigator.userAgent && -1 !== navigator.userAgent.indexOf("Firefox"),
                this._isUsingChromium = Ve() && navigator.userAgent && -1 !== navigator.userAgent.indexOf("Chrome"),
                this._maxTouchPoints = 0,
                this._pointerInputClearObserver = null,
                this._gamepadConnectedEvent = e => {}
                ,
                this._gamepadDisconnectedEvent = e => {}
                ,
                this._eventPrefix = hi.GetPointerPrefix(e),
                this._engine = e,
                this._onDeviceConnected = t,
                this._onDeviceDisconnected = i,
                this._onInputChanged = s,
                this._mouseId = this._isUsingFirefox ? 0 : 1,
                this._enableEvents(),
                this._usingMacOS && (this._metaKeys = []),
                this._engine._onEngineViewChanged || (this._engine._onEngineViewChanged = () => {
                    this._enableEvents()
                }
                )
            }
            pollInput(e, t, i) {
                const s = this._inputs[e][t];
                if (!s)
                    throw `Unable to find device ${Qi[e]}`;
                e >= Qi.DualShock && e <= Qi.DualSense && this._updateDevice(e, t, i);
                const r = s[i];
                if (void 0 === r)
                    throw `Unable to find input ${i} for device ${Qi[e]} in slot ${t}`;
                return i === $i.Move && hi.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data."),
                r
            }
            isDeviceAvailable(e) {
                return void 0 !== this._inputs[e]
            }
            dispose() {
                this._onDeviceConnected = () => {}
                ,
                this._onDeviceDisconnected = () => {}
                ,
                this._onInputChanged = () => {}
                ,
                delete this._engine._onEngineViewChanged,
                this._elementToAttachTo && this._disableEvents()
            }
            _enableEvents() {
                const e = this?._engine.getInputElement();
                if (e && (!this._eventsAttached || this._elementToAttachTo !== e)) {
                    if (this._disableEvents(),
                    this._inputs)
                        for (const e of this._inputs)
                            if (e)
                                for (const t in e) {
                                    const i = e[+t];
                                    if (i)
                                        for (let e = 0; e < i.length; e++)
                                            i[e] = 0
                                }
                    this._elementToAttachTo = e,
                    this._elementToAttachTo.tabIndex = -1 !== this._elementToAttachTo.tabIndex ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex,
                    this._handleKeyActions(),
                    this._handlePointerActions(),
                    this._handleGamepadActions(),
                    this._eventsAttached = !0,
                    this._checkForConnectedDevices()
                }
            }
            _disableEvents() {
                this._elementToAttachTo && (this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent),
                this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent),
                this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent),
                this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent),
                this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent),
                this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent),
                this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent),
                this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent),
                this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent),
                this._usingMacOS && this._isUsingChromium && this._elementToAttachTo.removeEventListener("lostpointercapture", this._pointerMacOSChromeOutEvent),
                window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent),
                window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent)),
                this._pointerInputClearObserver && this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver),
                this._eventsAttached = !1
            }
            _checkForConnectedDevices() {
                if (navigator.getGamepads) {
                    const e = navigator.getGamepads();
                    for (const t of e)
                        t && this._addGamePad(t)
                }
                "function" == typeof matchMedia && matchMedia("(pointer:fine)").matches && this._addPointerDevice(Qi.Mouse, 0, 0, 0)
            }
            _addGamePad(e) {
                const t = this._getGamepadDeviceType(e.id)
                  , i = e.index;
                this._gamepads = this._gamepads || new Array(e.index + 1),
                this._registerDevice(t, i, e.buttons.length + e.axes.length),
                this._gamepads[i] = t
            }
            _addPointerDevice(e, t, i, s) {
                this._pointerActive || (this._pointerActive = !0),
                this._registerDevice(e, t, Is);
                const r = this._inputs[e][t];
                r[0] = i,
                r[1] = s
            }
            _registerDevice(e, t, i) {
                if (void 0 === t)
                    throw `Unable to register device ${Qi[e]} to undefined slot.`;
                if (this._inputs[e] || (this._inputs[e] = {}),
                !this._inputs[e][t]) {
                    const s = new Array(i);
                    s.fill(0),
                    this._inputs[e][t] = s,
                    this._onDeviceConnected(e, t)
                }
            }
            _unregisterDevice(e, t) {
                this._inputs[e][t] && (delete this._inputs[e][t],
                this._onDeviceDisconnected(e, t))
            }
            _handleKeyActions() {
                this._keyboardDownEvent = e => {
                    this._keyboardActive || (this._keyboardActive = !0,
                    this._registerDevice(Qi.Keyboard, 0, 255));
                    const t = this._inputs[Qi.Keyboard][0];
                    if (t) {
                        t[e.keyCode] = 1;
                        const i = e;
                        i.inputIndex = e.keyCode,
                        this._usingMacOS && e.metaKey && "Meta" !== e.key && (this._metaKeys.includes(e.keyCode) || this._metaKeys.push(e.keyCode)),
                        this._onInputChanged(Qi.Keyboard, 0, i)
                    }
                }
                ,
                this._keyboardUpEvent = e => {
                    this._keyboardActive || (this._keyboardActive = !0,
                    this._registerDevice(Qi.Keyboard, 0, 255));
                    const t = this._inputs[Qi.Keyboard][0];
                    if (t) {
                        t[e.keyCode] = 0;
                        const i = e;
                        if (i.inputIndex = e.keyCode,
                        this._usingMacOS && "Meta" === e.key && this._metaKeys.length > 0) {
                            for (const e of this._metaKeys) {
                                const i = Ss.CreateDeviceEvent(Qi.Keyboard, 0, e, 0, this, this._elementToAttachTo);
                                t[e] = 0,
                                this._onInputChanged(Qi.Keyboard, 0, i)
                            }
                            this._metaKeys.splice(0, this._metaKeys.length)
                        }
                        this._onInputChanged(Qi.Keyboard, 0, i)
                    }
                }
                ,
                this._keyboardBlurEvent = () => {
                    if (this._keyboardActive) {
                        const e = this._inputs[Qi.Keyboard][0];
                        for (let t = 0; t < e.length; t++)
                            if (0 !== e[t]) {
                                e[t] = 0;
                                const i = Ss.CreateDeviceEvent(Qi.Keyboard, 0, t, 0, this, this._elementToAttachTo);
                                this._onInputChanged(Qi.Keyboard, 0, i)
                            }
                        this._usingMacOS && this._metaKeys.splice(0, this._metaKeys.length)
                    }
                }
                ,
                this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent),
                this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent),
                this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent)
            }
            _handlePointerActions() {
                this._maxTouchPoints = Ve() && navigator.maxTouchPoints || 2,
                this._activeTouchIds || (this._activeTouchIds = new Array(this._maxTouchPoints));
                for (let e = 0; e < this._maxTouchPoints; e++)
                    this._activeTouchIds[e] = -1;
                this._pointerMoveEvent = e => {
                    const t = this._getPointerType(e);
                    let i = t === Qi.Mouse ? 0 : this._activeTouchIds.indexOf(e.pointerId);
                    if (t === Qi.Touch && -1 === i) {
                        const s = this._activeTouchIds.indexOf(-1);
                        if (!(s >= 0))
                            return void hi.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
                        i = s,
                        this._activeTouchIds[s] = e.pointerId,
                        this._onDeviceConnected(t, i)
                    }
                    this._inputs[t] || (this._inputs[t] = {}),
                    this._inputs[t][i] || this._addPointerDevice(t, i, e.clientX, e.clientY);
                    const s = this._inputs[t][i];
                    if (s) {
                        const r = e;
                        r.inputIndex = $i.Move,
                        s[$i.Horizontal] = e.clientX,
                        s[$i.Vertical] = e.clientY,
                        t === Qi.Touch && 0 === s[$i.LeftClick] && (s[$i.LeftClick] = 1),
                        void 0 === e.pointerId && (e.pointerId = this._mouseId),
                        this._onInputChanged(t, i, r),
                        this._usingSafari || -1 === e.button || (r.inputIndex = e.button + 2,
                        s[e.button + 2] = s[e.button + 2] ? 0 : 1,
                        this._onInputChanged(t, i, r))
                    }
                }
                ,
                this._pointerDownEvent = e => {
                    const t = this._getPointerType(e);
                    let i = t === Qi.Mouse ? 0 : e.pointerId;
                    if (t === Qi.Touch) {
                        const t = this._activeTouchIds.indexOf(-1);
                        if (!(t >= 0))
                            return void hi.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
                        i = t,
                        this._activeTouchIds[t] = e.pointerId
                    }
                    this._inputs[t] || (this._inputs[t] = {}),
                    this._inputs[t][i] ? t === Qi.Touch && this._onDeviceConnected(t, i) : this._addPointerDevice(t, i, e.clientX, e.clientY);
                    const s = this._inputs[t][i];
                    if (s) {
                        const r = s[$i.Horizontal]
                          , n = s[$i.Vertical];
                        if (t === Qi.Mouse) {
                            if (void 0 === e.pointerId && (e.pointerId = this._mouseId),
                            !document.pointerLockElement)
                                try {
                                    this._elementToAttachTo.setPointerCapture(this._mouseId)
                                } catch (e) {}
                        } else if (e.pointerId && !document.pointerLockElement)
                            try {
                                this._elementToAttachTo.setPointerCapture(e.pointerId)
                            } catch (e) {}
                        s[$i.Horizontal] = e.clientX,
                        s[$i.Vertical] = e.clientY,
                        s[e.button + 2] = 1;
                        const a = e;
                        a.inputIndex = e.button + 2,
                        this._onInputChanged(t, i, a),
                        r === e.clientX && n === e.clientY || (a.inputIndex = $i.Move,
                        this._onInputChanged(t, i, a))
                    }
                }
                ,
                this._pointerUpEvent = e => {
                    const t = this._getPointerType(e)
                      , i = t === Qi.Mouse ? 0 : this._activeTouchIds.indexOf(e.pointerId);
                    if (t === Qi.Touch) {
                        if (-1 === i)
                            return;
                        this._activeTouchIds[i] = -1
                    }
                    const s = this._inputs[t]?.[i];
                    if (s && 0 !== s[e.button + 2]) {
                        const r = s[$i.Horizontal]
                          , n = s[$i.Vertical];
                        s[$i.Horizontal] = e.clientX,
                        s[$i.Vertical] = e.clientY,
                        s[e.button + 2] = 0;
                        const a = e;
                        void 0 === e.pointerId && (e.pointerId = this._mouseId),
                        r === e.clientX && n === e.clientY || (a.inputIndex = $i.Move,
                        this._onInputChanged(t, i, a)),
                        a.inputIndex = e.button + 2,
                        t === Qi.Mouse && this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId) ? this._elementToAttachTo.releasePointerCapture(this._mouseId) : e.pointerId && this._elementToAttachTo.hasPointerCapture?.(e.pointerId) && this._elementToAttachTo.releasePointerCapture(e.pointerId),
                        this._onInputChanged(t, i, a),
                        t === Qi.Touch && this._onDeviceDisconnected(t, i)
                    }
                }
                ,
                this._pointerCancelEvent = e => {
                    if ("mouse" === e.pointerType) {
                        const e = this._inputs[Qi.Mouse][0];
                        this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId) && this._elementToAttachTo.releasePointerCapture(this._mouseId);
                        for (let t = $i.LeftClick; t <= $i.BrowserForward; t++)
                            if (1 === e[t]) {
                                e[t] = 0;
                                const i = Ss.CreateDeviceEvent(Qi.Mouse, 0, t, 0, this, this._elementToAttachTo);
                                this._onInputChanged(Qi.Mouse, 0, i)
                            }
                    } else {
                        const t = this._activeTouchIds.indexOf(e.pointerId);
                        if (-1 === t)
                            return;
                        this._elementToAttachTo.hasPointerCapture?.(e.pointerId) && this._elementToAttachTo.releasePointerCapture(e.pointerId),
                        this._inputs[Qi.Touch][t][$i.LeftClick] = 0;
                        const i = Ss.CreateDeviceEvent(Qi.Touch, t, $i.LeftClick, 0, this, this._elementToAttachTo, e.pointerId);
                        this._onInputChanged(Qi.Touch, t, i),
                        this._activeTouchIds[t] = -1,
                        this._onDeviceDisconnected(Qi.Touch, t)
                    }
                }
                ,
                this._wheelEventName = "onwheel"in document.createElement("div") ? "wheel" : void 0 !== document.onmousewheel ? "mousewheel" : "DOMMouseScroll";
                let e = !1;
                const t = function() {};
                try {
                    const i = Object.defineProperty({}, "passive", {
                        get: function() {
                            e = !0
                        }
                    });
                    this._elementToAttachTo.addEventListener("test", t, i),
                    this._elementToAttachTo.removeEventListener("test", t, i)
                } catch (e) {}
                this._pointerBlurEvent = () => {
                    if (this.isDeviceAvailable(Qi.Mouse)) {
                        const e = this._inputs[Qi.Mouse][0];
                        this._mouseId >= 0 && this._elementToAttachTo.hasPointerCapture?.(this._mouseId) && this._elementToAttachTo.releasePointerCapture(this._mouseId);
                        for (let t = $i.LeftClick; t <= $i.BrowserForward; t++)
                            if (1 === e[t]) {
                                e[t] = 0;
                                const i = Ss.CreateDeviceEvent(Qi.Mouse, 0, t, 0, this, this._elementToAttachTo);
                                this._onInputChanged(Qi.Mouse, 0, i)
                            }
                    }
                    if (this.isDeviceAvailable(Qi.Touch)) {
                        const e = this._inputs[Qi.Touch];
                        for (let t = 0; t < this._activeTouchIds.length; t++) {
                            const i = this._activeTouchIds[t];
                            if (this._elementToAttachTo.hasPointerCapture?.(i) && this._elementToAttachTo.releasePointerCapture(i),
                            -1 !== i && 1 === e[t]?.[$i.LeftClick]) {
                                e[t][$i.LeftClick] = 0;
                                const s = Ss.CreateDeviceEvent(Qi.Touch, t, $i.LeftClick, 0, this, this._elementToAttachTo, i);
                                this._onInputChanged(Qi.Touch, t, s),
                                this._activeTouchIds[t] = -1,
                                this._onDeviceDisconnected(Qi.Touch, t)
                            }
                        }
                    }
                }
                ,
                this._pointerWheelEvent = e => {
                    const t = Qi.Mouse;
                    this._inputs[t] || (this._inputs[t] = []),
                    this._inputs[t][0] || (this._pointerActive = !0,
                    this._registerDevice(t, 0, Is));
                    const i = this._inputs[t][0];
                    if (i) {
                        i[$i.MouseWheelX] = e.deltaX || 0,
                        i[$i.MouseWheelY] = e.deltaY || e.wheelDelta || 0,
                        i[$i.MouseWheelZ] = e.deltaZ || 0;
                        const s = e;
                        void 0 === e.pointerId && (e.pointerId = this._mouseId),
                        0 !== i[$i.MouseWheelX] && (s.inputIndex = $i.MouseWheelX,
                        this._onInputChanged(t, 0, s)),
                        0 !== i[$i.MouseWheelY] && (s.inputIndex = $i.MouseWheelY,
                        this._onInputChanged(t, 0, s)),
                        0 !== i[$i.MouseWheelZ] && (s.inputIndex = $i.MouseWheelZ,
                        this._onInputChanged(t, 0, s))
                    }
                }
                ,
                this._usingMacOS && this._isUsingChromium && (this._pointerMacOSChromeOutEvent = e => {
                    e.buttons > 1 && this._pointerCancelEvent(e)
                }
                ,
                this._elementToAttachTo.addEventListener("lostpointercapture", this._pointerMacOSChromeOutEvent)),
                this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent),
                this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent),
                this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent),
                this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent),
                this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent),
                this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, !!e && {
                    passive: !1
                }),
                this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(( () => {
                    if (this.isDeviceAvailable(Qi.Mouse)) {
                        const e = this._inputs[Qi.Mouse][0];
                        e[$i.MouseWheelX] = 0,
                        e[$i.MouseWheelY] = 0,
                        e[$i.MouseWheelZ] = 0
                    }
                }
                ))
            }
            _handleGamepadActions() {
                this._gamepadConnectedEvent = e => {
                    this._addGamePad(e.gamepad)
                }
                ,
                this._gamepadDisconnectedEvent = e => {
                    if (this._gamepads) {
                        const t = this._getGamepadDeviceType(e.gamepad.id)
                          , i = e.gamepad.index;
                        this._unregisterDevice(t, i),
                        delete this._gamepads[i]
                    }
                }
                ,
                window.addEventListener("gamepadconnected", this._gamepadConnectedEvent),
                window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent)
            }
            _updateDevice(e, t, i) {
                const s = navigator.getGamepads()[t];
                if (s && e === this._gamepads[t]) {
                    const r = this._inputs[e][t];
                    i >= s.buttons.length ? r[i] = s.axes[i - s.buttons.length].valueOf() : r[i] = s.buttons[i].value
                }
            }
            _getGamepadDeviceType(e) {
                return -1 !== e.indexOf("054c") ? -1 !== e.indexOf("0ce6") ? Qi.DualSense : Qi.DualShock : -1 !== e.indexOf("Xbox One") || -1 !== e.search("Xbox 360") || -1 !== e.search("xinput") ? Qi.Xbox : -1 !== e.indexOf("057e") ? Qi.Switch : Qi.Generic
            }
            _getPointerType(e) {
                let t = Qi.Mouse;
                return ("touch" === e.pointerType || "pen" === e.pointerType || e.touches) && (t = Qi.Touch),
                t
            }
        }
        class Cs {
            constructor(e, t, i=0) {
                this.deviceType = t,
                this.deviceSlot = i,
                this.onInputChangedObservable = new Ue,
                this._deviceInputSystem = e
            }
            getInput(e) {
                return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, e)
            }
        }
        class Ps {
            constructor(e) {
                this._registeredManagers = new Array,
                this._refCount = 0,
                this.registerManager = e => {
                    for (let t = 0; t < this._devices.length; t++) {
                        const i = this._devices[t];
                        for (const s in i) {
                            const i = +s;
                            e._addDevice(new Cs(this._deviceInputSystem,t,i))
                        }
                    }
                    this._registeredManagers.push(e)
                }
                ,
                this.unregisterManager = e => {
                    const t = this._registeredManagers.indexOf(e);
                    t > -1 && this._registeredManagers.splice(t, 1)
                }
                ;
                const t = Object.keys(Qi).length / 2;
                this._devices = new Array(t);
                const i = (e, t) => {
                    this._devices[e] || (this._devices[e] = new Array),
                    this._devices[e][t] || (this._devices[e][t] = t);
                    for (const i of this._registeredManagers) {
                        const s = new Cs(this._deviceInputSystem,e,t);
                        i._addDevice(s)
                    }
                }
                  , s = (e, t) => {
                    this._devices[e]?.[t] && delete this._devices[e][t];
                    for (const i of this._registeredManagers)
                        i._removeDevice(e, t)
                }
                  , r = (e, t, i) => {
                    if (i)
                        for (const s of this._registeredManagers)
                            s._onInputChanged(e, t, i)
                }
                ;
                "undefined" != typeof _native ? this._deviceInputSystem = new As(i,s,r) : this._deviceInputSystem = new Rs(e,i,s,r)
            }
            dispose() {
                this._deviceInputSystem.dispose()
            }
        }
        class Ds {
            getDeviceSource(e, t) {
                if (void 0 === t) {
                    if (void 0 === this._firstDevice[e])
                        return null;
                    t = this._firstDevice[e]
                }
                return this._devices[e] && void 0 !== this._devices[e][t] ? this._devices[e][t] : null
            }
            getDeviceSources(e) {
                return this._devices[e] ? this._devices[e].filter((e => !!e)) : []
            }
            constructor(e) {
                const t = Object.keys(Qi).length / 2;
                this._devices = new Array(t),
                this._firstDevice = new Array(t),
                this._engine = e,
                this._engine._deviceSourceManager || (this._engine._deviceSourceManager = new Ps(e)),
                this._engine._deviceSourceManager._refCount++,
                this.onDeviceConnectedObservable = new Ue((e => {
                    for (const t of this._devices)
                        if (t)
                            for (const i of t)
                                i && this.onDeviceConnectedObservable.notifyObserver(e, i)
                }
                )),
                this.onDeviceDisconnectedObservable = new Ue,
                this._engine._deviceSourceManager.registerManager(this),
                this._onDisposeObserver = e.onDisposeObservable.add(( () => {
                    this.dispose()
                }
                ))
            }
            dispose() {
                this.onDeviceConnectedObservable.clear(),
                this.onDeviceDisconnectedObservable.clear(),
                this._engine._deviceSourceManager && (this._engine._deviceSourceManager.unregisterManager(this),
                --this._engine._deviceSourceManager._refCount < 1 && (this._engine._deviceSourceManager.dispose(),
                delete this._engine._deviceSourceManager)),
                this._engine.onDisposeObservable.remove(this._onDisposeObserver)
            }
            _addDevice(e) {
                this._devices[e.deviceType] || (this._devices[e.deviceType] = new Array),
                this._devices[e.deviceType][e.deviceSlot] || (this._devices[e.deviceType][e.deviceSlot] = e,
                this._updateFirstDevices(e.deviceType)),
                this.onDeviceConnectedObservable.notifyObservers(e)
            }
            _removeDevice(e, t) {
                const i = this._devices[e]?.[t];
                this.onDeviceDisconnectedObservable.notifyObservers(i),
                this._devices[e]?.[t] && delete this._devices[e][t],
                this._updateFirstDevices(e)
            }
            _onInputChanged(e, t, i) {
                this._devices[e]?.[t]?.onInputChangedObservable.notifyObservers(i)
            }
            _updateFirstDevices(e) {
                switch (e) {
                case Qi.Keyboard:
                case Qi.Mouse:
                    this._firstDevice[e] = 0;
                    break;
                case Qi.Touch:
                case Qi.DualSense:
                case Qi.DualShock:
                case Qi.Xbox:
                case Qi.Switch:
                case Qi.Generic:
                    {
                        delete this._firstDevice[e];
                        const t = this._devices[e];
                        if (t)
                            for (let i = 0; i < t.length; i++)
                                if (t[i]) {
                                    this._firstDevice[e] = i;
                                    break
                                }
                        break
                    }
                }
            }
        }
        class ws {
            constructor() {
                this._singleClick = !1,
                this._doubleClick = !1,
                this._hasSwiped = !1,
                this._ignore = !1
            }
            get singleClick() {
                return this._singleClick
            }
            get doubleClick() {
                return this._doubleClick
            }
            get hasSwiped() {
                return this._hasSwiped
            }
            get ignore() {
                return this._ignore
            }
            set singleClick(e) {
                this._singleClick = e
            }
            set doubleClick(e) {
                this._doubleClick = e
            }
            set hasSwiped(e) {
                this._hasSwiped = e
            }
            set ignore(e) {
                this._ignore = e
            }
        }
        class Fs {
            constructor(e) {
                this._alreadyAttached = !1,
                this._meshPickProceed = !1,
                this._currentPickResult = null,
                this._previousPickResult = null,
                this._totalPointersPressed = 0,
                this._doubleClickOccured = !1,
                this._isSwiping = !1,
                this._swipeButtonPressed = -1,
                this._skipPointerTap = !1,
                this._isMultiTouchGesture = !1,
                this._pointerX = 0,
                this._pointerY = 0,
                this._startingPointerPosition = new Pi(0,0),
                this._previousStartingPointerPosition = new Pi(0,0),
                this._startingPointerTime = 0,
                this._previousStartingPointerTime = 0,
                this._pointerCaptures = {},
                this._meshUnderPointerId = {},
                this._movePointerInfo = null,
                this._cameraObserverCount = 0,
                this._delayedClicks = [null, null, null, null, null],
                this._deviceSourceManager = null,
                this._scene = e || Ze.LastCreatedScene,
                this._scene
            }
            get meshUnderPointer() {
                return this._movePointerInfo && (this._movePointerInfo._generatePickInfo(),
                this._movePointerInfo = null),
                this._pointerOverMesh
            }
            getMeshUnderPointerByPointerId(e) {
                return this._meshUnderPointerId[e] || null
            }
            get unTranslatedPointer() {
                return new Pi(this._unTranslatedPointerX,this._unTranslatedPointerY)
            }
            get pointerX() {
                return this._pointerX
            }
            set pointerX(e) {
                this._pointerX = e
            }
            get pointerY() {
                return this._pointerY
            }
            set pointerY(e) {
                this._pointerY = e
            }
            _updatePointerPosition(e) {
                const t = this._scene.getEngine().getInputElementClientRect();
                t && (this._pointerX = e.clientX - t.left,
                this._pointerY = e.clientY - t.top,
                this._unTranslatedPointerX = this._pointerX,
                this._unTranslatedPointerY = this._pointerY)
            }
            _processPointerMove(e, t) {
                const i = this._scene
                  , s = i.getEngine()
                  , r = s.getInputElement();
                r && (r.tabIndex = s.canvasTabIndex,
                i.doNotHandleCursors || (r.style.cursor = i.defaultCursor)),
                this._setCursorAndPointerOverMesh(e, t, i);
                for (const s of i._pointerMoveStage) {
                    e = e || this._pickMove(t);
                    const i = !!e?.pickedMesh;
                    e = s.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, i, r)
                }
                const n = t.inputIndex >= $i.MouseWheelX && t.inputIndex <= $i.MouseWheelZ ? ms.POINTERWHEEL : ms.POINTERMOVE;
                let a;
                i.onPointerMove && (e = e || this._pickMove(t),
                i.onPointerMove(t, e, n)),
                e ? (a = new ys(n,t,e),
                this._setRayOnPointerInfo(e, t)) : (a = new ys(n,t,null,this),
                this._movePointerInfo = a),
                i.onPointerObservable.hasObservers() && i.onPointerObservable.notifyObservers(a, n)
            }
            _setRayOnPointerInfo(e, t) {
                const i = this._scene;
                e && i._pickingAvailable && (e.ray || (e.ray = i.createPickingRay(t.offsetX, t.offsetY, Oi.Identity(), i.activeCamera)))
            }
            _addCameraPointerObserver(e, t) {
                return this._cameraObserverCount++,
                this._scene.onPointerObservable.add(e, t)
            }
            _removeCameraPointerObserver(e) {
                return this._cameraObserverCount--,
                this._scene.onPointerObservable.remove(e)
            }
            _checkForPicking() {
                return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick)
            }
            _checkPrePointerObservable(e, t, i) {
                const s = this._scene
                  , r = new vs(i,t,this._unTranslatedPointerX,this._unTranslatedPointerY);
                return e && (r.originalPickingInfo = e,
                r.ray = e.ray,
                "xr-near" === t.pointerType && e.originMesh && (r.nearInteractionPickingInfo = e)),
                s.onPrePointerObservable.notifyObservers(r, i),
                !!r.skipOnPointerObservable
            }
            _pickMove(e) {
                const t = this._scene
                  , i = t.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, t.pointerMovePredicate, t.pointerMoveFastCheck, t.cameraToUseForPointers, t.pointerMoveTrianglePredicate);
                return this._setCursorAndPointerOverMesh(i, e, t),
                i
            }
            _setCursorAndPointerOverMesh(e, t, i) {
                const s = i.getEngine().getInputElement();
                if (e?.pickedMesh) {
                    if (this.setPointerOverMesh(e.pickedMesh, t.pointerId, e, t),
                    !i.doNotHandleCursors && s && this._pointerOverMesh) {
                        const e = this._pointerOverMesh._getActionManagerForTrigger();
                        e && e.hasPointerTriggers && (s.style.cursor = e.hoverCursor || i.hoverCursor)
                    }
                } else
                    this.setPointerOverMesh(null, t.pointerId, e, t)
            }
            simulatePointerMove(e, t) {
                const i = new PointerEvent("pointermove",t);
                i.inputIndex = $i.Move,
                this._checkPrePointerObservable(e, i, ms.POINTERMOVE) || this._processPointerMove(e, i)
            }
            simulatePointerDown(e, t) {
                const i = new PointerEvent("pointerdown",t);
                i.inputIndex = i.button + 2,
                this._checkPrePointerObservable(e, i, ms.POINTERDOWN) || this._processPointerDown(e, i)
            }
            _processPointerDown(e, t) {
                const i = this._scene;
                if (e?.pickedMesh) {
                    this._pickedDownMesh = e.pickedMesh;
                    const s = e.pickedMesh._getActionManagerForTrigger();
                    if (s) {
                        if (s.hasPickTriggers)
                            switch (s.processTrigger(5, ls.CreateNew(e.pickedMesh, t, e)),
                            t.button) {
                            case 0:
                                s.processTrigger(2, ls.CreateNew(e.pickedMesh, t, e));
                                break;
                            case 1:
                                s.processTrigger(4, ls.CreateNew(e.pickedMesh, t, e));
                                break;
                            case 2:
                                s.processTrigger(3, ls.CreateNew(e.pickedMesh, t, e))
                            }
                        s.hasSpecificTrigger(8) && window.setTimeout(( () => {
                            const e = i.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, (e => e.isPickable && e.isVisible && e.isReady() && e.actionManager && e.actionManager.hasSpecificTrigger(8) && e === this._pickedDownMesh), !1, i.cameraToUseForPointers);
                            e?.pickedMesh && s && 0 !== this._totalPointersPressed && Date.now() - this._startingPointerTime > Fs.LongPressDelay && !this._isPointerSwiping() && (this._startingPointerTime = 0,
                            s.processTrigger(8, ls.CreateNew(e.pickedMesh, t)))
                        }
                        ), Fs.LongPressDelay)
                    }
                } else
                    for (const s of i._pointerDownStage)
                        e = s.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t, !1);
                let s;
                const r = ms.POINTERDOWN;
                e ? (i.onPointerDown && i.onPointerDown(t, e, r),
                s = new ys(r,t,e),
                this._setRayOnPointerInfo(e, t)) : s = new ys(r,t,null,this),
                i.onPointerObservable.hasObservers() && i.onPointerObservable.notifyObservers(s, r)
            }
            _isPointerSwiping() {
                return this._isSwiping
            }
            simulatePointerUp(e, t, i) {
                const s = new PointerEvent("pointerup",t);
                s.inputIndex = $i.Move;
                const r = new ws;
                i ? r.doubleClick = !0 : r.singleClick = !0,
                this._checkPrePointerObservable(e, s, ms.POINTERUP) || this._processPointerUp(e, s, r)
            }
            _processPointerUp(e, t, i) {
                const s = this._scene;
                if (e?.pickedMesh) {
                    if (this._pickedUpMesh = e.pickedMesh,
                    this._pickedDownMesh === this._pickedUpMesh && (s.onPointerPick && s.onPointerPick(t, e),
                    i.singleClick && !i.ignore && s.onPointerObservable.observers.length > this._cameraObserverCount)) {
                        const i = ms.POINTERPICK
                          , r = new ys(i,t,e);
                        this._setRayOnPointerInfo(e, t),
                        s.onPointerObservable.notifyObservers(r, i)
                    }
                    const r = e.pickedMesh._getActionManagerForTrigger();
                    if (r && !i.ignore) {
                        r.processTrigger(7, ls.CreateNew(e.pickedMesh, t, e)),
                        !i.hasSwiped && i.singleClick && r.processTrigger(1, ls.CreateNew(e.pickedMesh, t, e));
                        const s = e.pickedMesh._getActionManagerForTrigger(6);
                        i.doubleClick && s && s.processTrigger(6, ls.CreateNew(e.pickedMesh, t, e))
                    }
                } else if (!i.ignore)
                    for (const r of s._pointerUpStage)
                        e = r.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t, i.doubleClick);
                if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
                    const e = this._pickedDownMesh._getActionManagerForTrigger(16);
                    e && e.processTrigger(16, ls.CreateNew(this._pickedDownMesh, t))
                }
                if (!i.ignore) {
                    const r = new ys(ms.POINTERUP,t,e);
                    if (this._setRayOnPointerInfo(e, t),
                    s.onPointerObservable.notifyObservers(r, ms.POINTERUP),
                    s.onPointerUp && s.onPointerUp(t, e, ms.POINTERUP),
                    !i.hasSwiped && !this._skipPointerTap && !this._isMultiTouchGesture) {
                        let r = 0;
                        if (i.singleClick ? r = ms.POINTERTAP : i.doubleClick && (r = ms.POINTERDOUBLETAP),
                        r) {
                            const i = new ys(r,t,e);
                            s.onPointerObservable.hasObservers() && s.onPointerObservable.hasSpecificMask(r) && s.onPointerObservable.notifyObservers(i, r)
                        }
                    }
                }
            }
            isPointerCaptured(e=0) {
                return this._pointerCaptures[e]
            }
            attachControl(e=!0, t=!0, i=!0, s=null) {
                const r = this._scene
                  , n = r.getEngine();
                s || (s = n.getInputElement()),
                this._alreadyAttached && this.detachControl(),
                s && (this._alreadyAttachedTo = s),
                this._deviceSourceManager = new Ds(n),
                this._initActionManager = e => {
                    if (!this._meshPickProceed) {
                        const t = r.skipPointerUpPicking || 0 === r._registeredActions && !this._checkForPicking() && !r.onPointerUp ? null : r.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, r.pointerUpPredicate, r.pointerUpFastCheck, r.cameraToUseForPointers, r.pointerUpTrianglePredicate);
                        this._currentPickResult = t,
                        t && (e = t.hit && t.pickedMesh ? t.pickedMesh._getActionManagerForTrigger() : null),
                        this._meshPickProceed = !0
                    }
                    return e
                }
                ,
                this._delayedSimpleClick = (e, t, i) => {
                    if ((Date.now() - this._previousStartingPointerTime > Fs.DoubleClickDelay && !this._doubleClickOccured || e !== this._previousButtonPressed) && (this._doubleClickOccured = !1,
                    t.singleClick = !0,
                    t.ignore = !1,
                    this._delayedClicks[e])) {
                        const t = this._delayedClicks[e].evt
                          , i = ms.POINTERTAP
                          , s = new ys(i,t,this._currentPickResult);
                        r.onPointerObservable.hasObservers() && r.onPointerObservable.hasSpecificMask(i) && r.onPointerObservable.notifyObservers(s, i),
                        this._delayedClicks[e] = null
                    }
                }
                ,
                this._initClickEvent = (e, t, i, s) => {
                    const r = new ws;
                    this._currentPickResult = null;
                    let n = null
                      , a = e.hasSpecificMask(ms.POINTERPICK) || t.hasSpecificMask(ms.POINTERPICK) || e.hasSpecificMask(ms.POINTERTAP) || t.hasSpecificMask(ms.POINTERTAP) || e.hasSpecificMask(ms.POINTERDOUBLETAP) || t.hasSpecificMask(ms.POINTERDOUBLETAP);
                    !a && bs && (n = this._initActionManager(n, r),
                    n && (a = n.hasPickTriggers));
                    let o = !1;
                    if (a) {
                        const a = i.button;
                        if (r.hasSwiped = this._isPointerSwiping(),
                        !r.hasSwiped) {
                            let h = !Fs.ExclusiveDoubleClickMode;
                            if (h || (h = !e.hasSpecificMask(ms.POINTERDOUBLETAP) && !t.hasSpecificMask(ms.POINTERDOUBLETAP),
                            h && !bs.HasSpecificTrigger(6) && (n = this._initActionManager(n, r),
                            n && (h = !n.hasSpecificTrigger(6)))),
                            h)
                                (Date.now() - this._previousStartingPointerTime > Fs.DoubleClickDelay || a !== this._previousButtonPressed) && (r.singleClick = !0,
                                s(r, this._currentPickResult),
                                o = !0);
                            else {
                                const e = {
                                    evt: i,
                                    clickInfo: r,
                                    timeoutId: window.setTimeout(this._delayedSimpleClick.bind(this, a, r, s), Fs.DoubleClickDelay)
                                };
                                this._delayedClicks[a] = e
                            }
                            let l = e.hasSpecificMask(ms.POINTERDOUBLETAP) || t.hasSpecificMask(ms.POINTERDOUBLETAP);
                            !l && bs.HasSpecificTrigger(6) && (n = this._initActionManager(n, r),
                            n && (l = n.hasSpecificTrigger(6))),
                            l && (a === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < Fs.DoubleClickDelay && !this._doubleClickOccured ? (r.hasSwiped || this._isPointerSwiping() ? (this._doubleClickOccured = !1,
                            this._previousStartingPointerTime = this._startingPointerTime,
                            this._previousStartingPointerPosition.x = this._startingPointerPosition.x,
                            this._previousStartingPointerPosition.y = this._startingPointerPosition.y,
                            this._previousButtonPressed = a,
                            Fs.ExclusiveDoubleClickMode ? (this._delayedClicks[a] && (clearTimeout(this._delayedClicks[a]?.timeoutId),
                            this._delayedClicks[a] = null),
                            s(r, this._previousPickResult)) : s(r, this._currentPickResult)) : (this._previousStartingPointerTime = 0,
                            this._doubleClickOccured = !0,
                            r.doubleClick = !0,
                            r.ignore = !1,
                            Fs.ExclusiveDoubleClickMode && this._delayedClicks[a] && (clearTimeout(this._delayedClicks[a]?.timeoutId),
                            this._delayedClicks[a] = null),
                            s(r, this._currentPickResult)),
                            o = !0) : (this._doubleClickOccured = !1,
                            this._previousStartingPointerTime = this._startingPointerTime,
                            this._previousStartingPointerPosition.x = this._startingPointerPosition.x,
                            this._previousStartingPointerPosition.y = this._startingPointerPosition.y,
                            this._previousButtonPressed = a))
                        }
                    }
                    o || s(r, this._currentPickResult)
                }
                ,
                this._onPointerMove = e => {
                    if (this._updatePointerPosition(e),
                    this._isSwiping || -1 === this._swipeButtonPressed || (this._isSwiping = Math.abs(this._startingPointerPosition.x - this._pointerX) > Fs.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > Fs.DragMovementThreshold),
                    n.isPointerLock && n._verifyPointerLock(),
                    this._checkPrePointerObservable(null, e, e.inputIndex >= $i.MouseWheelX && e.inputIndex <= $i.MouseWheelZ ? ms.POINTERWHEEL : ms.POINTERMOVE))
                        return;
                    if (!r.cameraToUseForPointers && !r.activeCamera)
                        return;
                    if (r.skipPointerMovePicking)
                        return void this._processPointerMove(new hs, e);
                    r.pointerMovePredicate || (r.pointerMovePredicate = e => e.isPickable && e.isVisible && e.isReady() && e.isEnabled() && (e.enablePointerMoveEvents || r.constantlyUpdateMeshUnderPointer || null !== e._getActionManagerForTrigger()) && (!r.cameraToUseForPointers || !!(r.cameraToUseForPointers.layerMask & e.layerMask)));
                    const t = r._registeredActions > 0 || r.constantlyUpdateMeshUnderPointer ? this._pickMove(e) : null;
                    this._processPointerMove(t, e)
                }
                ,
                this._onPointerDown = e => {
                    if (this._totalPointersPressed++,
                    this._pickedDownMesh = null,
                    this._meshPickProceed = !1,
                    Fs.ExclusiveDoubleClickMode)
                        for (let t = 0; t < this._delayedClicks.length; t++)
                            if (this._delayedClicks[t])
                                if (e.button === t)
                                    clearTimeout(this._delayedClicks[t]?.timeoutId);
                                else {
                                    const e = this._delayedClicks[t].clickInfo;
                                    this._doubleClickOccured = !1,
                                    e.singleClick = !0,
                                    e.ignore = !1;
                                    const i = this._delayedClicks[t].evt
                                      , s = ms.POINTERTAP
                                      , n = new ys(s,i,this._currentPickResult);
                                    r.onPointerObservable.hasObservers() && r.onPointerObservable.hasSpecificMask(s) && r.onPointerObservable.notifyObservers(n, s),
                                    this._delayedClicks[t] = null
                                }
                    if (this._updatePointerPosition(e),
                    -1 === this._swipeButtonPressed && (this._swipeButtonPressed = e.button),
                    r.preventDefaultOnPointerDown && s && (e.preventDefault(),
                    s.focus()),
                    this._startingPointerPosition.x = this._pointerX,
                    this._startingPointerPosition.y = this._pointerY,
                    this._startingPointerTime = Date.now(),
                    this._checkPrePointerObservable(null, e, ms.POINTERDOWN))
                        return;
                    if (!r.cameraToUseForPointers && !r.activeCamera)
                        return;
                    let t;
                    this._pointerCaptures[e.pointerId] = !0,
                    r.pointerDownPredicate || (r.pointerDownPredicate = e => e.isPickable && e.isVisible && e.isReady() && e.isEnabled() && (!r.cameraToUseForPointers || !!(r.cameraToUseForPointers.layerMask & e.layerMask))),
                    this._pickedDownMesh = null,
                    t = r.skipPointerDownPicking || 0 === r._registeredActions && !this._checkForPicking() && !r.onPointerDown ? new hs : r.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, r.pointerDownPredicate, r.pointerDownFastCheck, r.cameraToUseForPointers, r.pointerDownTrianglePredicate),
                    this._processPointerDown(t, e)
                }
                ,
                this._onPointerUp = e => {
                    0 !== this._totalPointersPressed && (this._totalPointersPressed--,
                    this._pickedUpMesh = null,
                    this._meshPickProceed = !1,
                    this._updatePointerPosition(e),
                    r.preventDefaultOnPointerUp && s && (e.preventDefault(),
                    s.focus()),
                    this._initClickEvent(r.onPrePointerObservable, r.onPointerObservable, e, ( (t, i) => {
                        if (r.onPrePointerObservable.hasObservers() && (this._skipPointerTap = !1,
                        !t.ignore)) {
                            if (this._checkPrePointerObservable(null, e, ms.POINTERUP))
                                return this._swipeButtonPressed === e.button && (this._isSwiping = !1,
                                this._swipeButtonPressed = -1),
                                void (0 === e.buttons && (this._pointerCaptures[e.pointerId] = !1));
                            t.hasSwiped || (t.singleClick && r.onPrePointerObservable.hasSpecificMask(ms.POINTERTAP) && this._checkPrePointerObservable(null, e, ms.POINTERTAP) && (this._skipPointerTap = !0),
                            t.doubleClick && r.onPrePointerObservable.hasSpecificMask(ms.POINTERDOUBLETAP) && this._checkPrePointerObservable(null, e, ms.POINTERDOUBLETAP) && (this._skipPointerTap = !0))
                        }
                        this._pointerCaptures[e.pointerId] ? (0 === e.buttons && (this._pointerCaptures[e.pointerId] = !1),
                        (r.cameraToUseForPointers || r.activeCamera) && (r.pointerUpPredicate || (r.pointerUpPredicate = e => e.isPickable && e.isVisible && e.isReady() && e.isEnabled() && (!r.cameraToUseForPointers || !!(r.cameraToUseForPointers.layerMask & e.layerMask))),
                        !this._meshPickProceed && (bs && bs.HasTriggers || this._checkForPicking() || r.onPointerUp) && this._initActionManager(null, t),
                        i || (i = this._currentPickResult),
                        this._processPointerUp(i, e, t),
                        this._previousPickResult = this._currentPickResult,
                        this._swipeButtonPressed === e.button && (this._isSwiping = !1,
                        this._swipeButtonPressed = -1))) : this._swipeButtonPressed === e.button && (this._isSwiping = !1,
                        this._swipeButtonPressed = -1)
                    }
                    )))
                }
                ,
                this._onKeyDown = e => {
                    const t = xs.KEYDOWN;
                    if (r.onPreKeyboardObservable.hasObservers()) {
                        const i = new Es(t,e);
                        if (r.onPreKeyboardObservable.notifyObservers(i, t),
                        i.skipOnKeyboardObservable)
                            return
                    }
                    if (r.onKeyboardObservable.hasObservers()) {
                        const i = new Ts(t,e);
                        r.onKeyboardObservable.notifyObservers(i, t)
                    }
                    r.actionManager && r.actionManager.processTrigger(14, ls.CreateNewFromScene(r, e))
                }
                ,
                this._onKeyUp = e => {
                    const t = xs.KEYUP;
                    if (r.onPreKeyboardObservable.hasObservers()) {
                        const i = new Es(t,e);
                        if (r.onPreKeyboardObservable.notifyObservers(i, t),
                        i.skipOnKeyboardObservable)
                            return
                    }
                    if (r.onKeyboardObservable.hasObservers()) {
                        const i = new Ts(t,e);
                        r.onKeyboardObservable.notifyObservers(i, t)
                    }
                    r.actionManager && r.actionManager.processTrigger(15, ls.CreateNewFromScene(r, e))
                }
                ,
                this._deviceSourceManager.onDeviceConnectedObservable.add((s => {
                    s.deviceType === Qi.Mouse ? s.onInputChangedObservable.add((r => {
                        r.inputIndex === $i.LeftClick || r.inputIndex === $i.MiddleClick || r.inputIndex === $i.RightClick || r.inputIndex === $i.BrowserBack || r.inputIndex === $i.BrowserForward ? t && 1 === s.getInput(r.inputIndex) ? this._onPointerDown(r) : e && 0 === s.getInput(r.inputIndex) && this._onPointerUp(r) : i && (r.inputIndex === $i.Move ? this._onPointerMove(r) : r.inputIndex !== $i.MouseWheelX && r.inputIndex !== $i.MouseWheelY && r.inputIndex !== $i.MouseWheelZ || this._onPointerMove(r))
                    }
                    )) : s.deviceType === Qi.Touch ? s.onInputChangedObservable.add((r => {
                        r.inputIndex === $i.LeftClick && (t && 1 === s.getInput(r.inputIndex) ? (this._onPointerDown(r),
                        this._totalPointersPressed > 1 && (this._isMultiTouchGesture = !0)) : e && 0 === s.getInput(r.inputIndex) && (this._onPointerUp(r),
                        0 === this._totalPointersPressed && (this._isMultiTouchGesture = !1))),
                        i && r.inputIndex === $i.Move && this._onPointerMove(r)
                    }
                    )) : s.deviceType === Qi.Keyboard && s.onInputChangedObservable.add((e => {
                        "keydown" === e.type ? this._onKeyDown(e) : "keyup" === e.type && this._onKeyUp(e)
                    }
                    ))
                }
                )),
                this._alreadyAttached = !0
            }
            detachControl() {
                this._alreadyAttached && (this._deviceSourceManager.dispose(),
                this._deviceSourceManager = null,
                this._alreadyAttachedTo && !this._scene.doNotHandleCursors && (this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor),
                this._alreadyAttached = !1,
                this._alreadyAttachedTo = null)
            }
            setPointerOverMesh(e, t=0, i, s) {
                if (!(this._meshUnderPointerId[t] !== e || e && e._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting))
                    return;
                const r = this._meshUnderPointerId[t];
                let n;
                r && (n = r._getActionManagerForTrigger(10),
                n && n.processTrigger(10, ls.CreateNew(r, s, {
                    pointerId: t
                }))),
                e ? (this._meshUnderPointerId[t] = e,
                this._pointerOverMesh = e,
                n = e._getActionManagerForTrigger(9),
                n && n.processTrigger(9, ls.CreateNew(e, s, {
                    pointerId: t,
                    pickResult: i
                }))) : (delete this._meshUnderPointerId[t],
                this._pointerOverMesh = null)
            }
            getPointerOverMesh() {
                return this.meshUnderPointer
            }
            _invalidateMesh(e) {
                this._pointerOverMesh === e && (this._pointerOverMesh = null),
                this._pickedDownMesh === e && (this._pickedDownMesh = null),
                this._pickedUpMesh === e && (this._pickedUpMesh = null);
                for (const t in this._meshUnderPointerId)
                    this._meshUnderPointerId[t] === e && delete this._meshUnderPointerId[t]
            }
        }
        Fs.DragMovementThreshold = 10,
        Fs.LongPressDelay = 500,
        Fs.DoubleClickDelay = 300,
        Fs.ExclusiveDoubleClickMode = !1;
        class Os {
            get min() {
                return this._min
            }
            get max() {
                return this._max
            }
            get average() {
                return this._average
            }
            get lastSecAverage() {
                return this._lastSecAverage
            }
            get current() {
                return this._current
            }
            get total() {
                return this._totalAccumulated
            }
            get count() {
                return this._totalValueCount
            }
            constructor() {
                this._startMonitoringTime = 0,
                this._min = 0,
                this._max = 0,
                this._average = 0,
                this._lastSecAverage = 0,
                this._current = 0,
                this._totalValueCount = 0,
                this._totalAccumulated = 0,
                this._lastSecAccumulated = 0,
                this._lastSecTime = 0,
                this._lastSecValueCount = 0
            }
            fetchNewFrame() {
                this._totalValueCount++,
                this._current = 0,
                this._lastSecValueCount++
            }
            addCount(e, t) {
                Os.Enabled && (this._current += e,
                t && this._fetchResult())
            }
            beginMonitoring() {
                Os.Enabled && (this._startMonitoringTime = Ke.Now)
            }
            endMonitoring(e=!0) {
                if (!Os.Enabled)
                    return;
                e && this.fetchNewFrame();
                const t = Ke.Now;
                this._current = t - this._startMonitoringTime,
                e && this._fetchResult()
            }
            endFrame() {
                this._fetchResult()
            }
            _fetchResult() {
                this._totalAccumulated += this._current,
                this._lastSecAccumulated += this._current,
                this._min = Math.min(this._min, this._current),
                this._max = Math.max(this._max, this._current),
                this._average = this._totalAccumulated / this._totalValueCount;
                const e = Ke.Now;
                e - this._lastSecTime > 1e3 && (this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount,
                this._lastSecTime = e,
                this._lastSecAccumulated = 0,
                this._lastSecValueCount = 0)
            }
        }
        Os.Enabled = !0;
        class Ls {
            static get UniqueId() {
                const e = this._UniqueIdCounter;
                return this._UniqueIdCounter++,
                e
            }
        }
        Ls._UniqueIdCounter = 1;
        class Bs {
            static CompareLightsPriority(e, t) {
                return e.shadowEnabled !== t.shadowEnabled ? (t.shadowEnabled ? 1 : 0) - (e.shadowEnabled ? 1 : 0) : t.renderPriority - e.renderPriority
            }
        }
        Bs.FALLOFF_DEFAULT = 0,
        Bs.FALLOFF_PHYSICAL = 1,
        Bs.FALLOFF_GLTF = 2,
        Bs.FALLOFF_STANDARD = 3,
        Bs.LIGHTMAP_DEFAULT = 0,
        Bs.LIGHTMAP_SPECULAR = 1,
        Bs.LIGHTMAP_SHADOWSONLY = 2,
        Bs.INTENSITYMODE_AUTOMATIC = 0,
        Bs.INTENSITYMODE_LUMINOUSPOWER = 1,
        Bs.INTENSITYMODE_LUMINOUSINTENSITY = 2,
        Bs.INTENSITYMODE_ILLUMINANCE = 3,
        Bs.INTENSITYMODE_LUMINANCE = 4,
        Bs.LIGHTTYPEID_POINTLIGHT = 0,
        Bs.LIGHTTYPEID_DIRECTIONALLIGHT = 1,
        Bs.LIGHTTYPEID_SPOTLIGHT = 2,
        Bs.LIGHTTYPEID_HEMISPHERICLIGHT = 3;
        class Ns {
            constructor() {
                this.pointerDownFastCheck = !1,
                this.pointerUpFastCheck = !1,
                this.pointerMoveFastCheck = !1,
                this.skipPointerMovePicking = !1,
                this.skipPointerDownPicking = !1,
                this.skipPointerUpPicking = !1
            }
        }
        var Us;
        !function(e) {
            e[e.BackwardCompatible = 0] = "BackwardCompatible",
            e[e.Intermediate = 1] = "Intermediate",
            e[e.Aggressive = 2] = "Aggressive"
        }(Us || (Us = {}));
        class ks extends Yi {
            static DefaultMaterialFactory(e) {
                throw je("StandardMaterial")
            }
            static CollisionCoordinatorFactory() {
                throw je("DefaultCollisionCoordinator")
            }
            get environmentTexture() {
                return this._environmentTexture
            }
            set environmentTexture(e) {
                this._environmentTexture !== e && (this._environmentTexture = e,
                this.markAllMaterialsAsDirty(1))
            }
            get imageProcessingConfiguration() {
                return this._imageProcessingConfiguration
            }
            get performancePriority() {
                return this._performancePriority
            }
            set performancePriority(e) {
                if (e !== this._performancePriority) {
                    switch (this._performancePriority = e,
                    e) {
                    case Us.BackwardCompatible:
                        this.skipFrustumClipping = !1,
                        this._renderingManager.maintainStateBetweenFrames = !1,
                        this.skipPointerMovePicking = !1,
                        this.autoClear = !0;
                        break;
                    case Us.Intermediate:
                        this.skipFrustumClipping = !1,
                        this._renderingManager.maintainStateBetweenFrames = !1,
                        this.skipPointerMovePicking = !0,
                        this.autoClear = !1;
                        break;
                    case Us.Aggressive:
                        this.skipFrustumClipping = !0,
                        this._renderingManager.maintainStateBetweenFrames = !0,
                        this.skipPointerMovePicking = !0,
                        this.autoClear = !1
                    }
                    this.onScenePerformancePriorityChangedObservable.notifyObservers(e)
                }
            }
            set forceWireframe(e) {
                this._forceWireframe !== e && (this._forceWireframe = e,
                this.markAllMaterialsAsDirty(16))
            }
            get forceWireframe() {
                return this._forceWireframe
            }
            set skipFrustumClipping(e) {
                this._skipFrustumClipping !== e && (this._skipFrustumClipping = e)
            }
            get skipFrustumClipping() {
                return this._skipFrustumClipping
            }
            set forcePointsCloud(e) {
                this._forcePointsCloud !== e && (this._forcePointsCloud = e,
                this.markAllMaterialsAsDirty(16))
            }
            get forcePointsCloud() {
                return this._forcePointsCloud
            }
            get animationPropertiesOverride() {
                return this._animationPropertiesOverride
            }
            set animationPropertiesOverride(e) {
                this._animationPropertiesOverride = e
            }
            set onDispose(e) {
                this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver),
                this._onDisposeObserver = this.onDisposeObservable.add(e)
            }
            set beforeRender(e) {
                this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver),
                e && (this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e))
            }
            set afterRender(e) {
                this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver),
                e && (this._onAfterRenderObserver = this.onAfterRenderObservable.add(e))
            }
            set beforeCameraRender(e) {
                this._onBeforeCameraRenderObserver && this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver),
                this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(e)
            }
            set afterCameraRender(e) {
                this._onAfterCameraRenderObserver && this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver),
                this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(e)
            }
            get pointerDownPredicate() {
                return this._pointerPickingConfiguration.pointerDownPredicate
            }
            set pointerDownPredicate(e) {
                this._pointerPickingConfiguration.pointerDownPredicate = e
            }
            get pointerUpPredicate() {
                return this._pointerPickingConfiguration.pointerUpPredicate
            }
            set pointerUpPredicate(e) {
                this._pointerPickingConfiguration.pointerUpPredicate = e
            }
            get pointerMovePredicate() {
                return this._pointerPickingConfiguration.pointerMovePredicate
            }
            set pointerMovePredicate(e) {
                this._pointerPickingConfiguration.pointerMovePredicate = e
            }
            get pointerDownFastCheck() {
                return this._pointerPickingConfiguration.pointerDownFastCheck
            }
            set pointerDownFastCheck(e) {
                this._pointerPickingConfiguration.pointerDownFastCheck = e
            }
            get pointerUpFastCheck() {
                return this._pointerPickingConfiguration.pointerUpFastCheck
            }
            set pointerUpFastCheck(e) {
                this._pointerPickingConfiguration.pointerUpFastCheck = e
            }
            get pointerMoveFastCheck() {
                return this._pointerPickingConfiguration.pointerMoveFastCheck
            }
            set pointerMoveFastCheck(e) {
                this._pointerPickingConfiguration.pointerMoveFastCheck = e
            }
            get skipPointerMovePicking() {
                return this._pointerPickingConfiguration.skipPointerMovePicking
            }
            set skipPointerMovePicking(e) {
                this._pointerPickingConfiguration.skipPointerMovePicking = e
            }
            get skipPointerDownPicking() {
                return this._pointerPickingConfiguration.skipPointerDownPicking
            }
            set skipPointerDownPicking(e) {
                this._pointerPickingConfiguration.skipPointerDownPicking = e
            }
            get skipPointerUpPicking() {
                return this._pointerPickingConfiguration.skipPointerUpPicking
            }
            set skipPointerUpPicking(e) {
                this._pointerPickingConfiguration.skipPointerUpPicking = e
            }
            get unTranslatedPointer() {
                return this._inputManager.unTranslatedPointer
            }
            static get DragMovementThreshold() {
                return Fs.DragMovementThreshold
            }
            static set DragMovementThreshold(e) {
                Fs.DragMovementThreshold = e
            }
            static get LongPressDelay() {
                return Fs.LongPressDelay
            }
            static set LongPressDelay(e) {
                Fs.LongPressDelay = e
            }
            static get DoubleClickDelay() {
                return Fs.DoubleClickDelay
            }
            static set DoubleClickDelay(e) {
                Fs.DoubleClickDelay = e
            }
            static get ExclusiveDoubleClickMode() {
                return Fs.ExclusiveDoubleClickMode
            }
            static set ExclusiveDoubleClickMode(e) {
                Fs.ExclusiveDoubleClickMode = e
            }
            bindEyePosition(e, t="vEyePosition", i=!1) {
                const s = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : this.activeCamera.globalPosition
                  , r = this.useRightHandedSystem === (null != this._mirroredCameraPosition);
                return Bi.Vector4[0].set(s.x, s.y, s.z, r ? -1 : 1),
                e && (i ? e.setFloat3(t, Bi.Vector4[0].x, Bi.Vector4[0].y, Bi.Vector4[0].z) : e.setVector4(t, Bi.Vector4[0])),
                Bi.Vector4[0]
            }
            finalizeSceneUbo() {
                const e = this.getSceneUniformBuffer()
                  , t = this.bindEyePosition(null);
                return e.updateFloat4("vEyePosition", t.x, t.y, t.z, t.w),
                e.update(),
                e
            }
            set useRightHandedSystem(e) {
                this._useRightHandedSystem !== e && (this._useRightHandedSystem = e,
                this.markAllMaterialsAsDirty(16))
            }
            get useRightHandedSystem() {
                return this._useRightHandedSystem
            }
            setStepId(e) {
                this._currentStepId = e
            }
            getStepId() {
                return this._currentStepId
            }
            getInternalStep() {
                return this._currentInternalStep
            }
            set fogEnabled(e) {
                this._fogEnabled !== e && (this._fogEnabled = e,
                this.markAllMaterialsAsDirty(16))
            }
            get fogEnabled() {
                return this._fogEnabled
            }
            set fogMode(e) {
                this._fogMode !== e && (this._fogMode = e,
                this.markAllMaterialsAsDirty(16))
            }
            get fogMode() {
                return this._fogMode
            }
            get prePass() {
                return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled
            }
            set shadowsEnabled(e) {
                this._shadowsEnabled !== e && (this._shadowsEnabled = e,
                this.markAllMaterialsAsDirty(2))
            }
            get shadowsEnabled() {
                return this._shadowsEnabled
            }
            set lightsEnabled(e) {
                this._lightsEnabled !== e && (this._lightsEnabled = e,
                this.markAllMaterialsAsDirty(2))
            }
            get lightsEnabled() {
                return this._lightsEnabled
            }
            get activeCameras() {
                return this._activeCameras
            }
            set activeCameras(e) {
                this._unObserveActiveCameras && (this._unObserveActiveCameras(),
                this._unObserveActiveCameras = null),
                e && (this._unObserveActiveCameras = function(e, t) {
                    const i = Se.map((i => function(e, t, i) {
                        const s = e[t];
                        if ("function" != typeof s)
                            return null;
                        const r = function() {
                            const s = e.length
                              , n = r.previous.apply(e, arguments);
                            return i(t, s),
                            n
                        };
                        return s.next = r,
                        r.previous = s,
                        e[t] = r,
                        () => {
                            const i = r.previous;
                            if (!i)
                                return;
                            const s = r.next;
                            s ? (i.next = s,
                            s.previous = i) : (i.next = void 0,
                            e[t] = i),
                            r.next = void 0,
                            r.previous = void 0
                        }
                    }(e, i, t)));
                    return () => {
                        i.forEach((e => {
                            e?.()
                        }
                        ))
                    }
                }(e, ( () => {
                    this.onActiveCamerasChanged.notifyObservers(this)
                }
                ))),
                this._activeCameras = e
            }
            get activeCamera() {
                return this._activeCamera
            }
            set activeCamera(e) {
                e !== this._activeCamera && (this._activeCamera = e,
                this.onActiveCameraChanged.notifyObservers(this))
            }
            get defaultMaterial() {
                return this._defaultMaterial || (this._defaultMaterial = ks.DefaultMaterialFactory(this)),
                this._defaultMaterial
            }
            set defaultMaterial(e) {
                this._defaultMaterial = e
            }
            set texturesEnabled(e) {
                this._texturesEnabled !== e && (this._texturesEnabled = e,
                this.markAllMaterialsAsDirty(1))
            }
            get texturesEnabled() {
                return this._texturesEnabled
            }
            set skeletonsEnabled(e) {
                this._skeletonsEnabled !== e && (this._skeletonsEnabled = e,
                this.markAllMaterialsAsDirty(8))
            }
            get skeletonsEnabled() {
                return this._skeletonsEnabled
            }
            get collisionCoordinator() {
                return this._collisionCoordinator || (this._collisionCoordinator = ks.CollisionCoordinatorFactory(),
                this._collisionCoordinator.init(this)),
                this._collisionCoordinator
            }
            get renderingManager() {
                return this._renderingManager
            }
            get frustumPlanes() {
                return this._frustumPlanes
            }
            _registerTransientComponents() {
                if (this._transientComponents.length > 0) {
                    for (const e of this._transientComponents)
                        e.register();
                    this._transientComponents.length = 0
                }
            }
            _addComponent(e) {
                this._components.push(e),
                this._transientComponents.push(e);
                const t = e;
                t.addFromContainer && t.serialize && this._serializableComponents.push(t)
            }
            _getComponent(e) {
                for (const t of this._components)
                    if (t.name === e)
                        return t;
                return null
            }
            constructor(e, t) {
                super(),
                this._inputManager = new Fs(this),
                this.cameraToUseForPointers = null,
                this._isScene = !0,
                this._blockEntityCollection = !1,
                this.autoClear = !0,
                this.autoClearDepthAndStencil = !0,
                this.clearColor = new Oe(.2,.2,.3,1),
                this.ambientColor = new Fe(0,0,0),
                this.environmentIntensity = 1,
                this._performancePriority = Us.BackwardCompatible,
                this.onScenePerformancePriorityChangedObservable = new Ue,
                this._forceWireframe = !1,
                this._skipFrustumClipping = !1,
                this._forcePointsCloud = !1,
                this.animationsEnabled = !0,
                this._animationPropertiesOverride = null,
                this.useConstantAnimationDeltaTime = !1,
                this.constantlyUpdateMeshUnderPointer = !1,
                this.hoverCursor = "pointer",
                this.defaultCursor = "",
                this.doNotHandleCursors = !1,
                this.preventDefaultOnPointerDown = !0,
                this.preventDefaultOnPointerUp = !0,
                this.metadata = null,
                this.reservedDataStore = null,
                this.disableOfflineSupportExceptionRules = [],
                this.onDisposeObservable = new Ue,
                this._onDisposeObserver = null,
                this.onBeforeRenderObservable = new Ue,
                this._onBeforeRenderObserver = null,
                this.onAfterRenderObservable = new Ue,
                this.onAfterRenderCameraObservable = new Ue,
                this._onAfterRenderObserver = null,
                this.onBeforeAnimationsObservable = new Ue,
                this.onAfterAnimationsObservable = new Ue,
                this.onBeforeDrawPhaseObservable = new Ue,
                this.onAfterDrawPhaseObservable = new Ue,
                this.onReadyObservable = new Ue,
                this.onBeforeCameraRenderObservable = new Ue,
                this._onBeforeCameraRenderObserver = null,
                this.onAfterCameraRenderObservable = new Ue,
                this._onAfterCameraRenderObserver = null,
                this.onBeforeActiveMeshesEvaluationObservable = new Ue,
                this.onAfterActiveMeshesEvaluationObservable = new Ue,
                this.onBeforeParticlesRenderingObservable = new Ue,
                this.onAfterParticlesRenderingObservable = new Ue,
                this.onDataLoadedObservable = new Ue,
                this.onNewCameraAddedObservable = new Ue,
                this.onCameraRemovedObservable = new Ue,
                this.onNewLightAddedObservable = new Ue,
                this.onLightRemovedObservable = new Ue,
                this.onNewGeometryAddedObservable = new Ue,
                this.onGeometryRemovedObservable = new Ue,
                this.onNewTransformNodeAddedObservable = new Ue,
                this.onTransformNodeRemovedObservable = new Ue,
                this.onNewMeshAddedObservable = new Ue,
                this.onMeshRemovedObservable = new Ue,
                this.onNewSkeletonAddedObservable = new Ue,
                this.onSkeletonRemovedObservable = new Ue,
                this.onNewMaterialAddedObservable = new Ue,
                this.onNewMultiMaterialAddedObservable = new Ue,
                this.onMaterialRemovedObservable = new Ue,
                this.onMultiMaterialRemovedObservable = new Ue,
                this.onNewTextureAddedObservable = new Ue,
                this.onTextureRemovedObservable = new Ue,
                this.onBeforeRenderTargetsRenderObservable = new Ue,
                this.onAfterRenderTargetsRenderObservable = new Ue,
                this.onBeforeStepObservable = new Ue,
                this.onAfterStepObservable = new Ue,
                this.onActiveCameraChanged = new Ue,
                this.onActiveCamerasChanged = new Ue,
                this.onBeforeRenderingGroupObservable = new Ue,
                this.onAfterRenderingGroupObservable = new Ue,
                this.onMeshImportedObservable = new Ue,
                this.onAnimationFileImportedObservable = new Ue,
                this._registeredForLateAnimationBindings = new Ri(256),
                this._pointerPickingConfiguration = new Ns,
                this.onPrePointerObservable = new Ue,
                this.onPointerObservable = new Ue,
                this.onPreKeyboardObservable = new Ue,
                this.onKeyboardObservable = new Ue,
                this._useRightHandedSystem = !1,
                this._timeAccumulator = 0,
                this._currentStepId = 0,
                this._currentInternalStep = 0,
                this._fogEnabled = !0,
                this._fogMode = ks.FOGMODE_NONE,
                this.fogColor = new Fe(.2,.2,.3),
                this.fogDensity = .1,
                this.fogStart = 0,
                this.fogEnd = 1e3,
                this.needsPreviousWorldMatrices = !1,
                this._shadowsEnabled = !0,
                this._lightsEnabled = !0,
                this._unObserveActiveCameras = null,
                this._texturesEnabled = !0,
                this.physicsEnabled = !0,
                this.particlesEnabled = !0,
                this.spritesEnabled = !0,
                this._skeletonsEnabled = !0,
                this.lensFlaresEnabled = !0,
                this.collisionsEnabled = !0,
                this.gravity = new Di(0,-9.807,0),
                this.postProcessesEnabled = !0,
                this.renderTargetsEnabled = !0,
                this.dumpNextRenderTargets = !1,
                this.customRenderTargets = [],
                this.importedMeshesFiles = [],
                this.probesEnabled = !0,
                this._meshesForIntersections = new Ri(256),
                this.proceduralTexturesEnabled = !0,
                this._totalVertices = new Os,
                this._activeIndices = new Os,
                this._activeParticles = new Os,
                this._activeBones = new Os,
                this._animationTime = 0,
                this.animationTimeScale = 1,
                this._renderId = 0,
                this._frameId = 0,
                this._executeWhenReadyTimeoutId = null,
                this._intermediateRendering = !1,
                this._defaultFrameBufferCleared = !1,
                this._viewUpdateFlag = -1,
                this._projectionUpdateFlag = -1,
                this._toBeDisposed = new Array(256),
                this._activeRequests = new Array,
                this._pendingData = new Array,
                this._isDisposed = !1,
                this.dispatchAllSubMeshesOfActiveMeshes = !1,
                this._activeMeshes = new Ii(256),
                this._processedMaterials = new Ii(256),
                this._renderTargets = new Ri(256),
                this._materialsRenderTargets = new Ri(256),
                this._activeParticleSystems = new Ii(256),
                this._activeSkeletons = new Ri(32),
                this._softwareSkinnedMeshes = new Ri(32),
                this._activeAnimatables = new Array,
                this._transformMatrix = Oi.Zero(),
                this.requireLightSorting = !1,
                this._components = [],
                this._serializableComponents = [],
                this._transientComponents = [],
                this._beforeCameraUpdateStage = ps.Create(),
                this._beforeClearStage = ps.Create(),
                this._beforeRenderTargetClearStage = ps.Create(),
                this._gatherRenderTargetsStage = ps.Create(),
                this._gatherActiveCameraRenderTargetsStage = ps.Create(),
                this._isReadyForMeshStage = ps.Create(),
                this._beforeEvaluateActiveMeshStage = ps.Create(),
                this._evaluateSubMeshStage = ps.Create(),
                this._preActiveMeshStage = ps.Create(),
                this._cameraDrawRenderTargetStage = ps.Create(),
                this._beforeCameraDrawStage = ps.Create(),
                this._beforeRenderTargetDrawStage = ps.Create(),
                this._beforeRenderingGroupDrawStage = ps.Create(),
                this._beforeRenderingMeshStage = ps.Create(),
                this._afterRenderingMeshStage = ps.Create(),
                this._afterRenderingGroupDrawStage = ps.Create(),
                this._afterCameraDrawStage = ps.Create(),
                this._afterCameraPostProcessStage = ps.Create(),
                this._afterRenderTargetDrawStage = ps.Create(),
                this._afterRenderTargetPostProcessStage = ps.Create(),
                this._afterRenderStage = ps.Create(),
                this._pointerMoveStage = ps.Create(),
                this._pointerDownStage = ps.Create(),
                this._pointerUpStage = ps.Create(),
                this._geometriesByUniqueId = null,
                this._defaultMeshCandidates = {
                    data: [],
                    length: 0
                },
                this._defaultSubMeshCandidates = {
                    data: [],
                    length: 0
                },
                this._preventFreeActiveMeshesAndRenderingGroups = !1,
                this._activeMeshesFrozen = !1,
                this._activeMeshesFrozenButKeepClipping = !1,
                this._skipEvaluateActiveMeshesCompletely = !1,
                this._allowPostProcessClearColor = !0,
                this.getDeterministicFrameTime = () => this._engine.getTimeStep(),
                this._registeredActions = 0,
                this._blockMaterialDirtyMechanism = !1,
                this._perfCollector = null,
                this.activeCameras = [];
                const i = {
                    useGeometryUniqueIdsMap: !0,
                    useMaterialMeshMap: !0,
                    useClonedMeshMap: !0,
                    virtual: !1,
                    ...t
                };
                e = this._engine = e || Ze.LastCreatedEngine,
                i.virtual ? e._virtualScenes.push(this) : (Ze._LastCreatedScene = this,
                e.scenes.push(this)),
                this._uid = null,
                this._renderingManager = new fs(this),
                cs && (this.postProcessManager = new cs(this)),
                ke() && this.attachControl(),
                this._createUbo(),
                Zi && (this._imageProcessingConfiguration = new Zi),
                this.setDefaultCandidateProviders(),
                i.useGeometryUniqueIdsMap && (this._geometriesByUniqueId = {}),
                this.useMaterialMeshMap = i.useMaterialMeshMap,
                this.useClonedMeshMap = i.useClonedMeshMap,
                t && t.virtual || e.onNewSceneAddedObservable.notifyObservers(this)
            }
            getClassName() {
                return "Scene"
            }
            _getDefaultMeshCandidates() {
                return this._defaultMeshCandidates.data = this.meshes,
                this._defaultMeshCandidates.length = this.meshes.length,
                this._defaultMeshCandidates
            }
            _getDefaultSubMeshCandidates(e) {
                return this._defaultSubMeshCandidates.data = e.subMeshes,
                this._defaultSubMeshCandidates.length = e.subMeshes.length,
                this._defaultSubMeshCandidates
            }
            setDefaultCandidateProviders() {
                this.getActiveMeshCandidates = () => this._getDefaultMeshCandidates(),
                this.getActiveSubMeshCandidates = e => this._getDefaultSubMeshCandidates(e),
                this.getIntersectingSubMeshCandidates = (e, t) => this._getDefaultSubMeshCandidates(e),
                this.getCollidingSubMeshCandidates = (e, t) => this._getDefaultSubMeshCandidates(e)
            }
            get meshUnderPointer() {
                return this._inputManager.meshUnderPointer
            }
            get pointerX() {
                return this._inputManager.pointerX
            }
            set pointerX(e) {
                this._inputManager.pointerX = e
            }
            get pointerY() {
                return this._inputManager.pointerY
            }
            set pointerY(e) {
                this._inputManager.pointerY = e
            }
            getCachedMaterial() {
                return this._cachedMaterial
            }
            getCachedEffect() {
                return this._cachedEffect
            }
            getCachedVisibility() {
                return this._cachedVisibility
            }
            isCachedMaterialInvalid(e, t, i=1) {
                return this._cachedEffect !== t || this._cachedMaterial !== e || this._cachedVisibility !== i
            }
            getEngine() {
                return this._engine
            }
            getTotalVertices() {
                return this._totalVertices.current
            }
            get totalVerticesPerfCounter() {
                return this._totalVertices
            }
            getActiveIndices() {
                return this._activeIndices.current
            }
            get totalActiveIndicesPerfCounter() {
                return this._activeIndices
            }
            getActiveParticles() {
                return this._activeParticles.current
            }
            get activeParticlesPerfCounter() {
                return this._activeParticles
            }
            getActiveBones() {
                return this._activeBones.current
            }
            get activeBonesPerfCounter() {
                return this._activeBones
            }
            getActiveMeshes() {
                return this._activeMeshes
            }
            getAnimationRatio() {
                return void 0 !== this._animationRatio ? this._animationRatio : 1
            }
            getRenderId() {
                return this._renderId
            }
            getFrameId() {
                return this._frameId
            }
            incrementRenderId() {
                this._renderId++
            }
            _createUbo() {
                this.setSceneUniformBuffer(this.createSceneUniformBuffer())
            }
            simulatePointerMove(e, t) {
                return this._inputManager.simulatePointerMove(e, t),
                this
            }
            simulatePointerDown(e, t) {
                return this._inputManager.simulatePointerDown(e, t),
                this
            }
            simulatePointerUp(e, t, i) {
                return this._inputManager.simulatePointerUp(e, t, i),
                this
            }
            isPointerCaptured(e=0) {
                return this._inputManager.isPointerCaptured(e)
            }
            attachControl(e=!0, t=!0, i=!0) {
                this._inputManager.attachControl(e, t, i)
            }
            detachControl() {
                this._inputManager.detachControl()
            }
            isReady(e=!0) {
                if (this._isDisposed)
                    return !1;
                let t;
                const i = this.getEngine()
                  , s = i.currentRenderPassId;
                i.currentRenderPassId = this.activeCamera?.renderPassId ?? s;
                let r = !0;
                for (this._pendingData.length > 0 && (r = !1),
                this.prePassRenderer?.update(),
                this.useOrderIndependentTransparency && this.depthPeelingRenderer && r && (r = this.depthPeelingRenderer.isReady()),
                e && (this._processedMaterials.reset(),
                this._materialsRenderTargets.reset()),
                t = 0; t < this.meshes.length; t++) {
                    const s = this.meshes[t];
                    if (!s.subMeshes || 0 === s.subMeshes.length)
                        continue;
                    if (!s.isReady(!0)) {
                        r = !1;
                        continue
                    }
                    const n = s.hasThinInstances || "InstancedMesh" === s.getClassName() || "InstancedLinesMesh" === s.getClassName() || i.getCaps().instancedArrays && s.instances.length > 0;
                    for (const e of this._isReadyForMeshStage)
                        e.action(s, n) || (r = !1);
                    if (!e)
                        continue;
                    const a = s.material || this.defaultMaterial;
                    if (a)
                        if (a._storeEffectOnSubMeshes)
                            for (const e of s.subMeshes) {
                                const t = e.getMaterial();
                                t && t.hasRenderTargetTextures && null != t.getRenderTargetTextures && -1 === this._processedMaterials.indexOf(t) && (this._processedMaterials.push(t),
                                this._materialsRenderTargets.concatWithNoDuplicate(t.getRenderTargetTextures()))
                            }
                        else
                            a.hasRenderTargetTextures && null != a.getRenderTargetTextures && -1 === this._processedMaterials.indexOf(a) && (this._processedMaterials.push(a),
                            this._materialsRenderTargets.concatWithNoDuplicate(a.getRenderTargetTextures()))
                }
                if (e)
                    for (t = 0; t < this._materialsRenderTargets.length; ++t)
                        this._materialsRenderTargets.data[t].isReadyForRendering() || (r = !1);
                for (t = 0; t < this.geometries.length; t++)
                    2 === this.geometries[t].delayLoadState && (r = !1);
                if (this.activeCameras && this.activeCameras.length > 0)
                    for (const e of this.activeCameras)
                        e.isReady(!0) || (r = !1);
                else
                    this.activeCamera && (this.activeCamera.isReady(!0) || (r = !1));
                for (const e of this.particleSystems)
                    e.isReady() || (r = !1);
                if (this.layers)
                    for (const e of this.layers)
                        e.isReady() || (r = !1);
                return i.areAllEffectsReady() || (r = !1),
                i.currentRenderPassId = s,
                r
            }
            resetCachedMaterial() {
                this._cachedMaterial = null,
                this._cachedEffect = null,
                this._cachedVisibility = null
            }
            registerBeforeRender(e) {
                this.onBeforeRenderObservable.add(e)
            }
            unregisterBeforeRender(e) {
                this.onBeforeRenderObservable.removeCallback(e)
            }
            registerAfterRender(e) {
                this.onAfterRenderObservable.add(e)
            }
            unregisterAfterRender(e) {
                this.onAfterRenderObservable.removeCallback(e)
            }
            _executeOnceBeforeRender(e) {
                const t = () => {
                    e(),
                    setTimeout(( () => {
                        this.unregisterBeforeRender(t)
                    }
                    ))
                }
                ;
                this.registerBeforeRender(t)
            }
            executeOnceBeforeRender(e, t) {
                void 0 !== t ? setTimeout(( () => {
                    this._executeOnceBeforeRender(e)
                }
                ), t) : this._executeOnceBeforeRender(e)
            }
            addPendingData(e) {
                this._pendingData.push(e)
            }
            removePendingData(e) {
                const t = this.isLoading
                  , i = this._pendingData.indexOf(e);
                -1 !== i && this._pendingData.splice(i, 1),
                t && !this.isLoading && this.onDataLoadedObservable.notifyObservers(this)
            }
            getWaitingItemsCount() {
                return this._pendingData.length
            }
            get isLoading() {
                return this._pendingData.length > 0
            }
            executeWhenReady(e, t=!1) {
                this.onReadyObservable.addOnce(e),
                null === this._executeWhenReadyTimeoutId && this._checkIsReady(t)
            }
            whenReadyAsync(e=!1) {
                return new Promise((t => {
                    this.executeWhenReady(( () => {
                        t()
                    }
                    ), e)
                }
                ))
            }
            _checkIsReady(e=!1) {
                return this._registerTransientComponents(),
                this.isReady(e) ? (this.onReadyObservable.notifyObservers(this),
                this.onReadyObservable.clear(),
                void (this._executeWhenReadyTimeoutId = null)) : this._isDisposed ? (this.onReadyObservable.clear(),
                void (this._executeWhenReadyTimeoutId = null)) : void (this._executeWhenReadyTimeoutId = setTimeout(( () => {
                    this.incrementRenderId(),
                    this._checkIsReady(e)
                }
                ), 100))
            }
            get animatables() {
                return this._activeAnimatables
            }
            resetLastAnimationTimeFrame() {
                this._animationTimeLast = Ke.Now
            }
            getViewMatrix() {
                return this._viewMatrix
            }
            getProjectionMatrix() {
                return this._projectionMatrix
            }
            getTransformMatrix() {
                return this._transformMatrix
            }
            setTransformMatrix(e, t, i, s) {
                i || s || !this._multiviewSceneUbo || (this._multiviewSceneUbo.dispose(),
                this._multiviewSceneUbo = null),
                this._viewUpdateFlag === e.updateFlag && this._projectionUpdateFlag === t.updateFlag || (this._viewUpdateFlag = e.updateFlag,
                this._projectionUpdateFlag = t.updateFlag,
                this._viewMatrix = e,
                this._projectionMatrix = t,
                this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix),
                this._frustumPlanes ? Xi.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = Xi.GetPlanes(this._transformMatrix),
                this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo ? this._updateMultiviewUbo(i, s) : this._sceneUbo.useUbo && (this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix),
                this._sceneUbo.updateMatrix("view", this._viewMatrix),
                this._sceneUbo.updateMatrix("projection", this._projectionMatrix)))
            }
            getSceneUniformBuffer() {
                return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo
            }
            createSceneUniformBuffer(e) {
                const t = new ns(this._engine,void 0,!1,e ?? "scene");
                return t.addUniform("viewProjection", 16),
                t.addUniform("view", 16),
                t.addUniform("projection", 16),
                t.addUniform("vEyePosition", 4),
                t
            }
            setSceneUniformBuffer(e) {
                this._sceneUbo = e,
                this._viewUpdateFlag = -1,
                this._projectionUpdateFlag = -1
            }
            getUniqueId() {
                return Ls.UniqueId
            }
            addMesh(e, t=!1) {
                this._blockEntityCollection || (this.meshes.push(e),
                e._resyncLightSources(),
                e.parent || e._addToSceneRootNodes(),
                this.onNewMeshAddedObservable.notifyObservers(e),
                t && e.getChildMeshes().forEach((e => {
                    this.addMesh(e)
                }
                )))
            }
            removeMesh(e, t=!1) {
                const i = this.meshes.indexOf(e);
                return -1 !== i && (this.meshes[i] = this.meshes[this.meshes.length - 1],
                this.meshes.pop(),
                e.parent || e._removeFromSceneRootNodes()),
                this._inputManager._invalidateMesh(e),
                this.onMeshRemovedObservable.notifyObservers(e),
                t && e.getChildMeshes().forEach((e => {
                    this.removeMesh(e)
                }
                )),
                i
            }
            addTransformNode(e) {
                this._blockEntityCollection || e.getScene() === this && -1 !== e._indexInSceneTransformNodesArray || (e._indexInSceneTransformNodesArray = this.transformNodes.length,
                this.transformNodes.push(e),
                e.parent || e._addToSceneRootNodes(),
                this.onNewTransformNodeAddedObservable.notifyObservers(e))
            }
            removeTransformNode(e) {
                const t = e._indexInSceneTransformNodesArray;
                if (-1 !== t) {
                    if (t !== this.transformNodes.length - 1) {
                        const e = this.transformNodes[this.transformNodes.length - 1];
                        this.transformNodes[t] = e,
                        e._indexInSceneTransformNodesArray = t
                    }
                    e._indexInSceneTransformNodesArray = -1,
                    this.transformNodes.pop(),
                    e.parent || e._removeFromSceneRootNodes()
                }
                return this.onTransformNodeRemovedObservable.notifyObservers(e),
                t
            }
            removeSkeleton(e) {
                const t = this.skeletons.indexOf(e);
                return -1 !== t && (this.skeletons.splice(t, 1),
                this.onSkeletonRemovedObservable.notifyObservers(e),
                this._executeActiveContainerCleanup(this._activeSkeletons)),
                t
            }
            removeMorphTargetManager(e) {
                const t = this.morphTargetManagers.indexOf(e);
                return -1 !== t && this.morphTargetManagers.splice(t, 1),
                t
            }
            removeLight(e) {
                const t = this.lights.indexOf(e);
                if (-1 !== t) {
                    for (const t of this.meshes)
                        t._removeLightSource(e, !1);
                    this.lights.splice(t, 1),
                    this.sortLightsByPriority(),
                    e.parent || e._removeFromSceneRootNodes()
                }
                return this.onLightRemovedObservable.notifyObservers(e),
                t
            }
            removeCamera(e) {
                const t = this.cameras.indexOf(e);
                if (-1 !== t && (this.cameras.splice(t, 1),
                e.parent || e._removeFromSceneRootNodes()),
                this.activeCameras) {
                    const t = this.activeCameras.indexOf(e);
                    -1 !== t && this.activeCameras.splice(t, 1)
                }
                return this.activeCamera === e && (this.cameras.length > 0 ? this.activeCamera = this.cameras[0] : this.activeCamera = null),
                this.onCameraRemovedObservable.notifyObservers(e),
                t
            }
            removeParticleSystem(e) {
                const t = this.particleSystems.indexOf(e);
                return -1 !== t && (this.particleSystems.splice(t, 1),
                this._executeActiveContainerCleanup(this._activeParticleSystems)),
                t
            }
            removeAnimation(e) {
                const t = this.animations.indexOf(e);
                return -1 !== t && this.animations.splice(t, 1),
                t
            }
            stopAnimation(e, t, i) {}
            removeAnimationGroup(e) {
                const t = this.animationGroups.indexOf(e);
                return -1 !== t && this.animationGroups.splice(t, 1),
                t
            }
            removeMultiMaterial(e) {
                const t = this.multiMaterials.indexOf(e);
                return -1 !== t && this.multiMaterials.splice(t, 1),
                this.onMultiMaterialRemovedObservable.notifyObservers(e),
                t
            }
            removeMaterial(e) {
                const t = e._indexInSceneMaterialArray;
                if (-1 !== t && t < this.materials.length) {
                    if (t !== this.materials.length - 1) {
                        const e = this.materials[this.materials.length - 1];
                        this.materials[t] = e,
                        e._indexInSceneMaterialArray = t
                    }
                    e._indexInSceneMaterialArray = -1,
                    this.materials.pop()
                }
                return this.onMaterialRemovedObservable.notifyObservers(e),
                t
            }
            removeActionManager(e) {
                const t = this.actionManagers.indexOf(e);
                return -1 !== t && this.actionManagers.splice(t, 1),
                t
            }
            removeTexture(e) {
                const t = this.textures.indexOf(e);
                return -1 !== t && this.textures.splice(t, 1),
                this.onTextureRemovedObservable.notifyObservers(e),
                t
            }
            addLight(e) {
                if (!this._blockEntityCollection) {
                    this.lights.push(e),
                    this.sortLightsByPriority(),
                    e.parent || e._addToSceneRootNodes();
                    for (const t of this.meshes)
                        -1 === t.lightSources.indexOf(e) && (t.lightSources.push(e),
                        t._resyncLightSources());
                    this.onNewLightAddedObservable.notifyObservers(e)
                }
            }
            sortLightsByPriority() {
                this.requireLightSorting && this.lights.sort(Bs.CompareLightsPriority)
            }
            addCamera(e) {
                this._blockEntityCollection || (this.cameras.push(e),
                this.onNewCameraAddedObservable.notifyObservers(e),
                e.parent || e._addToSceneRootNodes())
            }
            addSkeleton(e) {
                this._blockEntityCollection || (this.skeletons.push(e),
                this.onNewSkeletonAddedObservable.notifyObservers(e))
            }
            addParticleSystem(e) {
                this._blockEntityCollection || this.particleSystems.push(e)
            }
            addAnimation(e) {
                this._blockEntityCollection || this.animations.push(e)
            }
            addAnimationGroup(e) {
                this._blockEntityCollection || this.animationGroups.push(e)
            }
            addMultiMaterial(e) {
                this._blockEntityCollection || (this.multiMaterials.push(e),
                this.onNewMultiMaterialAddedObservable.notifyObservers(e))
            }
            addMaterial(e) {
                this._blockEntityCollection || e.getScene() === this && -1 !== e._indexInSceneMaterialArray || (e._indexInSceneMaterialArray = this.materials.length,
                this.materials.push(e),
                this.onNewMaterialAddedObservable.notifyObservers(e))
            }
            addMorphTargetManager(e) {
                this._blockEntityCollection || this.morphTargetManagers.push(e)
            }
            addGeometry(e) {
                this._blockEntityCollection || (this._geometriesByUniqueId && (this._geometriesByUniqueId[e.uniqueId] = this.geometries.length),
                this.geometries.push(e))
            }
            addActionManager(e) {
                this.actionManagers.push(e)
            }
            addTexture(e) {
                this._blockEntityCollection || (this.textures.push(e),
                this.onNewTextureAddedObservable.notifyObservers(e))
            }
            switchActiveCamera(e, t=!0) {
                this._engine.getInputElement() && (this.activeCamera && this.activeCamera.detachControl(),
                this.activeCamera = e,
                t && e.attachControl())
            }
            setActiveCameraById(e) {
                const t = this.getCameraById(e);
                return t ? (this.activeCamera = t,
                t) : null
            }
            setActiveCameraByName(e) {
                const t = this.getCameraByName(e);
                return t ? (this.activeCamera = t,
                t) : null
            }
            getAnimationGroupByName(e) {
                for (let t = 0; t < this.animationGroups.length; t++)
                    if (this.animationGroups[t].name === e)
                        return this.animationGroups[t];
                return null
            }
            _getMaterial(e, t) {
                for (let e = 0; e < this.materials.length; e++) {
                    const i = this.materials[e];
                    if (t(i))
                        return i
                }
                if (e)
                    for (let e = 0; e < this.multiMaterials.length; e++) {
                        const i = this.multiMaterials[e];
                        if (t(i))
                            return i
                    }
                return null
            }
            getMaterialByUniqueID(e, t=!1) {
                return this._getMaterial(t, (t => t.uniqueId === e))
            }
            getMaterialById(e, t=!1) {
                return this._getMaterial(t, (t => t.id === e))
            }
            getMaterialByName(e, t=!1) {
                return this._getMaterial(t, (t => t.name === e))
            }
            getLastMaterialById(e, t=!1) {
                for (let t = this.materials.length - 1; t >= 0; t--)
                    if (this.materials[t].id === e)
                        return this.materials[t];
                if (t)
                    for (let t = this.multiMaterials.length - 1; t >= 0; t--)
                        if (this.multiMaterials[t].id === e)
                            return this.multiMaterials[t];
                return null
            }
            getTextureByUniqueId(e) {
                for (let t = 0; t < this.textures.length; t++)
                    if (this.textures[t].uniqueId === e)
                        return this.textures[t];
                return null
            }
            getTextureByName(e) {
                for (let t = 0; t < this.textures.length; t++)
                    if (this.textures[t].name === e)
                        return this.textures[t];
                return null
            }
            getCameraById(e) {
                for (let t = 0; t < this.cameras.length; t++)
                    if (this.cameras[t].id === e)
                        return this.cameras[t];
                return null
            }
            getCameraByUniqueId(e) {
                for (let t = 0; t < this.cameras.length; t++)
                    if (this.cameras[t].uniqueId === e)
                        return this.cameras[t];
                return null
            }
            getCameraByName(e) {
                for (let t = 0; t < this.cameras.length; t++)
                    if (this.cameras[t].name === e)
                        return this.cameras[t];
                return null
            }
            getBoneById(e) {
                for (let t = 0; t < this.skeletons.length; t++) {
                    const i = this.skeletons[t];
                    for (let t = 0; t < i.bones.length; t++)
                        if (i.bones[t].id === e)
                            return i.bones[t]
                }
                return null
            }
            getBoneByName(e) {
                for (let t = 0; t < this.skeletons.length; t++) {
                    const i = this.skeletons[t];
                    for (let t = 0; t < i.bones.length; t++)
                        if (i.bones[t].name === e)
                            return i.bones[t]
                }
                return null
            }
            getLightByName(e) {
                for (let t = 0; t < this.lights.length; t++)
                    if (this.lights[t].name === e)
                        return this.lights[t];
                return null
            }
            getLightById(e) {
                for (let t = 0; t < this.lights.length; t++)
                    if (this.lights[t].id === e)
                        return this.lights[t];
                return null
            }
            getLightByUniqueId(e) {
                for (let t = 0; t < this.lights.length; t++)
                    if (this.lights[t].uniqueId === e)
                        return this.lights[t];
                return null
            }
            getParticleSystemById(e) {
                for (let t = 0; t < this.particleSystems.length; t++)
                    if (this.particleSystems[t].id === e)
                        return this.particleSystems[t];
                return null
            }
            getGeometryById(e) {
                for (let t = 0; t < this.geometries.length; t++)
                    if (this.geometries[t].id === e)
                        return this.geometries[t];
                return null
            }
            _getGeometryByUniqueId(e) {
                if (this._geometriesByUniqueId) {
                    const t = this._geometriesByUniqueId[e];
                    if (void 0 !== t)
                        return this.geometries[t]
                } else
                    for (let t = 0; t < this.geometries.length; t++)
                        if (this.geometries[t].uniqueId === e)
                            return this.geometries[t];
                return null
            }
            pushGeometry(e, t) {
                return !(!t && this._getGeometryByUniqueId(e.uniqueId) || (this.addGeometry(e),
                this.onNewGeometryAddedObservable.notifyObservers(e),
                0))
            }
            removeGeometry(e) {
                let t;
                if (this._geometriesByUniqueId) {
                    if (t = this._geometriesByUniqueId[e.uniqueId],
                    void 0 === t)
                        return !1
                } else if (t = this.geometries.indexOf(e),
                t < 0)
                    return !1;
                if (t !== this.geometries.length - 1) {
                    const e = this.geometries[this.geometries.length - 1];
                    e && (this.geometries[t] = e,
                    this._geometriesByUniqueId && (this._geometriesByUniqueId[e.uniqueId] = t))
                }
                return this._geometriesByUniqueId && (this._geometriesByUniqueId[e.uniqueId] = void 0),
                this.geometries.pop(),
                this.onGeometryRemovedObservable.notifyObservers(e),
                !0
            }
            getGeometries() {
                return this.geometries
            }
            getMeshById(e) {
                for (let t = 0; t < this.meshes.length; t++)
                    if (this.meshes[t].id === e)
                        return this.meshes[t];
                return null
            }
            getMeshesById(e) {
                return this.meshes.filter((function(t) {
                    return t.id === e
                }
                ))
            }
            getTransformNodeById(e) {
                for (let t = 0; t < this.transformNodes.length; t++)
                    if (this.transformNodes[t].id === e)
                        return this.transformNodes[t];
                return null
            }
            getTransformNodeByUniqueId(e) {
                for (let t = 0; t < this.transformNodes.length; t++)
                    if (this.transformNodes[t].uniqueId === e)
                        return this.transformNodes[t];
                return null
            }
            getTransformNodesById(e) {
                return this.transformNodes.filter((function(t) {
                    return t.id === e
                }
                ))
            }
            getMeshByUniqueId(e) {
                for (let t = 0; t < this.meshes.length; t++)
                    if (this.meshes[t].uniqueId === e)
                        return this.meshes[t];
                return null
            }
            getLastMeshById(e) {
                for (let t = this.meshes.length - 1; t >= 0; t--)
                    if (this.meshes[t].id === e)
                        return this.meshes[t];
                return null
            }
            getLastTransformNodeById(e) {
                for (let t = this.transformNodes.length - 1; t >= 0; t--)
                    if (this.transformNodes[t].id === e)
                        return this.transformNodes[t];
                return null
            }
            getLastEntryById(e) {
                let t;
                for (t = this.meshes.length - 1; t >= 0; t--)
                    if (this.meshes[t].id === e)
                        return this.meshes[t];
                for (t = this.transformNodes.length - 1; t >= 0; t--)
                    if (this.transformNodes[t].id === e)
                        return this.transformNodes[t];
                for (t = this.cameras.length - 1; t >= 0; t--)
                    if (this.cameras[t].id === e)
                        return this.cameras[t];
                for (t = this.lights.length - 1; t >= 0; t--)
                    if (this.lights[t].id === e)
                        return this.lights[t];
                return null
            }
            getNodeById(e) {
                const t = this.getMeshById(e);
                if (t)
                    return t;
                const i = this.getTransformNodeById(e);
                if (i)
                    return i;
                const s = this.getLightById(e);
                if (s)
                    return s;
                const r = this.getCameraById(e);
                if (r)
                    return r;
                return this.getBoneById(e) || null
            }
            getNodeByName(e) {
                const t = this.getMeshByName(e);
                if (t)
                    return t;
                const i = this.getTransformNodeByName(e);
                if (i)
                    return i;
                const s = this.getLightByName(e);
                if (s)
                    return s;
                const r = this.getCameraByName(e);
                if (r)
                    return r;
                return this.getBoneByName(e) || null
            }
            getMeshByName(e) {
                for (let t = 0; t < this.meshes.length; t++)
                    if (this.meshes[t].name === e)
                        return this.meshes[t];
                return null
            }
            getTransformNodeByName(e) {
                for (let t = 0; t < this.transformNodes.length; t++)
                    if (this.transformNodes[t].name === e)
                        return this.transformNodes[t];
                return null
            }
            getLastSkeletonById(e) {
                for (let t = this.skeletons.length - 1; t >= 0; t--)
                    if (this.skeletons[t].id === e)
                        return this.skeletons[t];
                return null
            }
            getSkeletonByUniqueId(e) {
                for (let t = 0; t < this.skeletons.length; t++)
                    if (this.skeletons[t].uniqueId === e)
                        return this.skeletons[t];
                return null
            }
            getSkeletonById(e) {
                for (let t = 0; t < this.skeletons.length; t++)
                    if (this.skeletons[t].id === e)
                        return this.skeletons[t];
                return null
            }
            getSkeletonByName(e) {
                for (let t = 0; t < this.skeletons.length; t++)
                    if (this.skeletons[t].name === e)
                        return this.skeletons[t];
                return null
            }
            getMorphTargetManagerById(e) {
                for (let t = 0; t < this.morphTargetManagers.length; t++)
                    if (this.morphTargetManagers[t].uniqueId === e)
                        return this.morphTargetManagers[t];
                return null
            }
            getMorphTargetById(e) {
                for (let t = 0; t < this.morphTargetManagers.length; ++t) {
                    const i = this.morphTargetManagers[t];
                    for (let t = 0; t < i.numTargets; ++t) {
                        const s = i.getTarget(t);
                        if (s.id === e)
                            return s
                    }
                }
                return null
            }
            getMorphTargetByName(e) {
                for (let t = 0; t < this.morphTargetManagers.length; ++t) {
                    const i = this.morphTargetManagers[t];
                    for (let t = 0; t < i.numTargets; ++t) {
                        const s = i.getTarget(t);
                        if (s.name === e)
                            return s
                    }
                }
                return null
            }
            getPostProcessByName(e) {
                for (let t = 0; t < this.postProcesses.length; ++t) {
                    const i = this.postProcesses[t];
                    if (i.name === e)
                        return i
                }
                return null
            }
            isActiveMesh(e) {
                return -1 !== this._activeMeshes.indexOf(e)
            }
            get uid() {
                return this._uid || (this._uid = hi.RandomId()),
                this._uid
            }
            addExternalData(e, t) {
                return this._externalData || (this._externalData = new Ki),
                this._externalData.add(e, t)
            }
            getExternalData(e) {
                return this._externalData ? this._externalData.get(e) : null
            }
            getOrAddExternalDataWithFactory(e, t) {
                return this._externalData || (this._externalData = new Ki),
                this._externalData.getOrAddWithFactory(e, t)
            }
            removeExternalData(e) {
                return this._externalData.remove(e)
            }
            _evaluateSubMesh(e, t, i, s) {
                if (s || e.isInFrustum(this._frustumPlanes)) {
                    for (const i of this._evaluateSubMeshStage)
                        i.action(t, e);
                    const i = e.getMaterial();
                    null != i && (i.hasRenderTargetTextures && null != i.getRenderTargetTextures && -1 === this._processedMaterials.indexOf(i) && (this._processedMaterials.push(i),
                    this._materialsRenderTargets.concatWithNoDuplicate(i.getRenderTargetTextures())),
                    this._renderingManager.dispatch(e, t, i))
                }
            }
            freeProcessedMaterials() {
                this._processedMaterials.dispose()
            }
            get blockfreeActiveMeshesAndRenderingGroups() {
                return this._preventFreeActiveMeshesAndRenderingGroups
            }
            set blockfreeActiveMeshesAndRenderingGroups(e) {
                this._preventFreeActiveMeshesAndRenderingGroups !== e && (e && (this.freeActiveMeshes(),
                this.freeRenderingGroups()),
                this._preventFreeActiveMeshesAndRenderingGroups = e)
            }
            freeActiveMeshes() {
                if (!this.blockfreeActiveMeshesAndRenderingGroups && (this._activeMeshes.dispose(),
                this.activeCamera && this.activeCamera._activeMeshes && this.activeCamera._activeMeshes.dispose(),
                this.activeCameras))
                    for (let e = 0; e < this.activeCameras.length; e++) {
                        const t = this.activeCameras[e];
                        t && t._activeMeshes && t._activeMeshes.dispose()
                    }
            }
            freeRenderingGroups() {
                if (!this.blockfreeActiveMeshesAndRenderingGroups && (this._renderingManager && this._renderingManager.freeRenderingGroups(),
                this.textures))
                    for (let e = 0; e < this.textures.length; e++) {
                        const t = this.textures[e];
                        t && t.renderList && t.freeRenderingGroups()
                    }
            }
            _isInIntermediateRendering() {
                return this._intermediateRendering
            }
            freezeActiveMeshes(e=!1, t, i, s=!0, r=!1) {
                return this.executeWhenReady(( () => {
                    if (this.activeCamera) {
                        if (this._frustumPlanes || this.updateTransformMatrix(),
                        this._evaluateActiveMeshes(),
                        this._activeMeshesFrozen = !0,
                        this._activeMeshesFrozenButKeepClipping = r,
                        this._skipEvaluateActiveMeshesCompletely = e,
                        s)
                            for (let e = 0; e < this._activeMeshes.length; e++)
                                this._activeMeshes.data[e]._freeze();
                        t && t()
                    } else
                        i && i("No active camera found")
                }
                )),
                this
            }
            unfreezeActiveMeshes() {
                for (let e = 0; e < this.meshes.length; e++) {
                    const t = this.meshes[e];
                    t._internalAbstractMeshDataInfo && (t._internalAbstractMeshDataInfo._isActive = !1)
                }
                for (let e = 0; e < this._activeMeshes.length; e++)
                    this._activeMeshes.data[e]._unFreeze();
                return this._activeMeshesFrozen = !1,
                this
            }
            _executeActiveContainerCleanup(e) {
                (!this._engine.snapshotRendering || 1 !== this._engine.snapshotRenderingMode) && this._activeMeshesFrozen && this._activeMeshes.length || this.onBeforeRenderObservable.addOnce(( () => e.dispose()))
            }
            _evaluateActiveMeshes() {
                if (this._engine.snapshotRendering && 1 === this._engine.snapshotRenderingMode)
                    return void (this._activeMeshes.length > 0 && (this.activeCamera?._activeMeshes.reset(),
                    this._activeMeshes.reset(),
                    this._renderingManager.reset(),
                    this._processedMaterials.reset(),
                    this._activeParticleSystems.reset(),
                    this._activeSkeletons.reset(),
                    this._softwareSkinnedMeshes.reset()));
                if (this._activeMeshesFrozen && this._activeMeshes.length) {
                    if (!this._skipEvaluateActiveMeshesCompletely) {
                        const e = this._activeMeshes.length;
                        for (let t = 0; t < e; t++)
                            this._activeMeshes.data[t].computeWorldMatrix()
                    }
                    if (this._activeParticleSystems) {
                        const e = this._activeParticleSystems.length;
                        for (let t = 0; t < e; t++)
                            this._activeParticleSystems.data[t].animate()
                    }
                    return void this._renderingManager.resetSprites()
                }
                if (!this.activeCamera)
                    return;
                this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this),
                this.activeCamera._activeMeshes.reset(),
                this._activeMeshes.reset(),
                this._renderingManager.reset(),
                this._processedMaterials.reset(),
                this._activeParticleSystems.reset(),
                this._activeSkeletons.reset(),
                this._softwareSkinnedMeshes.reset(),
                this._materialsRenderTargets.reset();
                for (const e of this._beforeEvaluateActiveMeshStage)
                    e.action();
                const e = this.getActiveMeshCandidates()
                  , t = e.length;
                for (let i = 0; i < t; i++) {
                    const t = e.data[i];
                    if (t._internalAbstractMeshDataInfo._currentLODIsUpToDate = !1,
                    t.isBlocked)
                        continue;
                    if (this._totalVertices.addCount(t.getTotalVertices(), !1),
                    !t.isReady() || !t.isEnabled() || t.scaling.hasAZeroComponent)
                        continue;
                    t.computeWorldMatrix(),
                    t.actionManager && t.actionManager.hasSpecificTriggers2(12, 13) && this._meshesForIntersections.pushNoDuplicate(t);
                    let s = this.customLODSelector ? this.customLODSelector(t, this.activeCamera) : t.getLOD(this.activeCamera);
                    if (t._internalAbstractMeshDataInfo._currentLOD = s,
                    t._internalAbstractMeshDataInfo._currentLODIsUpToDate = !0,
                    null != s && (s !== t && 0 !== s.billboardMode && s.computeWorldMatrix(),
                    t._preActivate(),
                    t.isVisible && t.visibility > 0 && t.layerMask & this.activeCamera.layerMask && (this._skipFrustumClipping || t.alwaysSelectAsActiveMesh || t.isInFrustum(this._frustumPlanes)))) {
                        this._activeMeshes.push(t),
                        this.activeCamera._activeMeshes.push(t),
                        s !== t && s._activate(this._renderId, !1);
                        for (const e of this._preActiveMeshStage)
                            e.action(t);
                        t._activate(this._renderId, !1) && (t.isAnInstance ? t._internalAbstractMeshDataInfo._actAsRegularMesh && (s = t) : s._internalAbstractMeshDataInfo._onlyForInstances = !1,
                        s._internalAbstractMeshDataInfo._isActive = !0,
                        this._activeMesh(t, s)),
                        t._postActivate()
                    }
                }
                if (this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this),
                this.particlesEnabled) {
                    this.onBeforeParticlesRenderingObservable.notifyObservers(this);
                    for (let e = 0; e < this.particleSystems.length; e++) {
                        const t = this.particleSystems[e];
                        if (!t.isStarted() || !t.emitter)
                            continue;
                        const i = t.emitter;
                        i.position && !i.isEnabled() || (this._activeParticleSystems.push(t),
                        t.animate(),
                        this._renderingManager.dispatchParticles(t))
                    }
                    this.onAfterParticlesRenderingObservable.notifyObservers(this)
                }
            }
            _activeMesh(e, t) {
                this._skeletonsEnabled && null !== t.skeleton && void 0 !== t.skeleton && (this._activeSkeletons.pushNoDuplicate(t.skeleton) && (t.skeleton.prepare(),
                this._activeBones.addCount(t.skeleton.bones.length, !1)),
                t.computeBonesUsingShaders || this._softwareSkinnedMeshes.pushNoDuplicate(t));
                let i = e.hasInstances || e.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || t.alwaysSelectAsActiveMesh;
                if (t && t.subMeshes && t.subMeshes.length > 0) {
                    const s = this.getActiveSubMeshCandidates(t)
                      , r = s.length;
                    i = i || 1 === r;
                    for (let n = 0; n < r; n++) {
                        const r = s.data[n];
                        this._evaluateSubMesh(r, t, e, i)
                    }
                }
            }
            updateTransformMatrix(e) {
                const t = this.activeCamera;
                if (t)
                    if (t._renderingMultiview) {
                        const i = t._rigCameras[0]
                          , s = t._rigCameras[1];
                        this.setTransformMatrix(i.getViewMatrix(), i.getProjectionMatrix(e), s.getViewMatrix(), s.getProjectionMatrix(e))
                    } else
                        this.setTransformMatrix(t.getViewMatrix(), t.getProjectionMatrix(e))
            }
            _bindFrameBuffer(e, t=!0) {
                e && e._multiviewTexture ? e._multiviewTexture._bindFrameBuffer() : e && e.outputRenderTarget ? e.outputRenderTarget._bindFrameBuffer() : this._engine._currentFrameBufferIsDefaultFrameBuffer() || this._engine.restoreDefaultFramebuffer(),
                t && this._clearFrameBuffer(e)
            }
            _clearFrameBuffer(e) {
                if (e && e._multiviewTexture)
                    ;
                else if (e && e.outputRenderTarget && !e._renderingMultiview) {
                    const t = e.outputRenderTarget;
                    t.onClearObservable.hasObservers() ? t.onClearObservable.notifyObservers(this._engine) : t.skipInitialClear || e.isRightCamera || (this.autoClear && this._engine.clear(t.clearColor || this.clearColor, !t._cleared, !0, !0),
                    t._cleared = !0)
                } else
                    this._defaultFrameBufferCleared ? this._engine.clear(null, !1, !0, !0) : (this._defaultFrameBufferCleared = !0,
                    this._clear())
            }
            _renderForCamera(e, t, i=!0) {
                if (e && e._skipRendering)
                    return;
                const s = this._engine;
                if (this._activeCamera = e,
                !this.activeCamera)
                    throw new Error("Active camera not set");
                if (s.setViewport(this.activeCamera.viewport),
                this.resetCachedMaterial(),
                this._renderId++,
                !this.prePass && i) {
                    let t = !0;
                    e._renderingMultiview && e.outputRenderTarget && (t = e.outputRenderTarget.skipInitialClear,
                    this.autoClear && (this._defaultFrameBufferCleared = !1,
                    e.outputRenderTarget.skipInitialClear = !1)),
                    this._bindFrameBuffer(this._activeCamera),
                    e._renderingMultiview && e.outputRenderTarget && (e.outputRenderTarget.skipInitialClear = t)
                }
                this.updateTransformMatrix(),
                this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera),
                this._evaluateActiveMeshes();
                for (let e = 0; e < this._softwareSkinnedMeshes.length; e++) {
                    const t = this._softwareSkinnedMeshes.data[e];
                    t.applySkeleton(t.skeleton)
                }
                this.onBeforeRenderTargetsRenderObservable.notifyObservers(this),
                this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets),
                e.customRenderTargets && e.customRenderTargets.length > 0 && this._renderTargets.concatWithNoDuplicate(e.customRenderTargets),
                t && t.customRenderTargets && t.customRenderTargets.length > 0 && this._renderTargets.concatWithNoDuplicate(t.customRenderTargets),
                this.environmentTexture && this.environmentTexture.isRenderTarget && this._renderTargets.pushNoDuplicate(this.environmentTexture);
                for (const e of this._gatherActiveCameraRenderTargetsStage)
                    e.action(this._renderTargets);
                let r = !1;
                if (this.renderTargetsEnabled) {
                    if (this._intermediateRendering = !0,
                    this._renderTargets.length > 0) {
                        hi.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
                        for (let e = 0; e < this._renderTargets.length; e++) {
                            const t = this._renderTargets.data[e];
                            if (t._shouldRender()) {
                                this._renderId++;
                                const e = t.activeCamera && t.activeCamera !== this.activeCamera;
                                t.render(e, this.dumpNextRenderTargets),
                                r = !0
                            }
                        }
                        hi.EndPerformanceCounter("Render targets", this._renderTargets.length > 0),
                        this._renderId++
                    }
                    for (const e of this._cameraDrawRenderTargetStage)
                        r = e.action(this.activeCamera) || r;
                    this._intermediateRendering = !1
                }
                this._engine.currentRenderPassId = e.outputRenderTarget?.renderPassId ?? e.renderPassId ?? 0,
                r && !this.prePass && (this._bindFrameBuffer(this._activeCamera, !1),
                this.updateTransformMatrix()),
                this.onAfterRenderTargetsRenderObservable.notifyObservers(this),
                !this.postProcessManager || e._multiviewTexture || this.prePass || this.postProcessManager._prepareFrame();
                for (const e of this._beforeCameraDrawStage)
                    e.action(this.activeCamera);
                this.onBeforeDrawPhaseObservable.notifyObservers(this),
                s.snapshotRendering && 1 === s.snapshotRenderingMode && this.finalizeSceneUbo(),
                this._renderingManager.render(null, null, !0, !0),
                this.onAfterDrawPhaseObservable.notifyObservers(this);
                for (const e of this._afterCameraDrawStage)
                    e.action(this.activeCamera);
                if (this.postProcessManager && !e._multiviewTexture) {
                    const t = e.outputRenderTarget ? e.outputRenderTarget.renderTarget : void 0;
                    this.postProcessManager._finalizeFrame(e.isIntermediate, t)
                }
                for (const e of this._afterCameraPostProcessStage)
                    e.action(this.activeCamera);
                this._renderTargets.reset(),
                this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera)
            }
            _processSubCameras(e, t=!0) {
                if (0 === e.cameraRigMode || e._renderingMultiview)
                    return e._renderingMultiview && !this._multiviewSceneUbo && this._createMultiviewUbo(),
                    this._renderForCamera(e, void 0, t),
                    void this.onAfterRenderCameraObservable.notifyObservers(e);
                if (e._useMultiviewToSingleView)
                    this._renderMultiviewToSingleView(e);
                else {
                    this.onBeforeCameraRenderObservable.notifyObservers(e);
                    for (let t = 0; t < e._rigCameras.length; t++)
                        this._renderForCamera(e._rigCameras[t], e)
                }
                this._activeCamera = e,
                this.updateTransformMatrix(),
                this.onAfterRenderCameraObservable.notifyObservers(e)
            }
            _checkIntersections() {
                for (let e = 0; e < this._meshesForIntersections.length; e++) {
                    const t = this._meshesForIntersections.data[e];
                    if (t.actionManager)
                        for (let e = 0; t.actionManager && e < t.actionManager.actions.length; e++) {
                            const i = t.actionManager.actions[e];
                            if (12 === i.trigger || 13 === i.trigger) {
                                const e = i.getTriggerParameter()
                                  , s = e.mesh ? e.mesh : e
                                  , r = s.intersectsMesh(t, e.usePreciseIntersection)
                                  , n = t._intersectionsInProgress.indexOf(s);
                                r && -1 === n ? 12 === i.trigger ? (i._executeCurrent(ls.CreateNew(t, void 0, s)),
                                t._intersectionsInProgress.push(s)) : 13 === i.trigger && t._intersectionsInProgress.push(s) : !r && n > -1 && (13 === i.trigger && i._executeCurrent(ls.CreateNew(t, void 0, s)),
                                t.actionManager.hasSpecificTrigger(13, (e => {
                                    const t = e.mesh ? e.mesh : e;
                                    return s === t
                                }
                                )) && 13 !== i.trigger || t._intersectionsInProgress.splice(n, 1))
                            }
                        }
                }
            }
            _advancePhysicsEngineStep(e) {}
            _animate(e) {}
            animate() {
                if (this._engine.isDeterministicLockStep()) {
                    let e = Math.max(ks.MinDeltaTime, Math.min(this._engine.getDeltaTime(), ks.MaxDeltaTime)) + this._timeAccumulator;
                    const t = this._engine.getTimeStep()
                      , i = 1e3 / t / 1e3;
                    let s = 0;
                    const r = this._engine.getLockstepMaxSteps();
                    let n = Math.floor(e / t);
                    for (n = Math.min(n, r); e > 0 && s < n; )
                        this.onBeforeStepObservable.notifyObservers(this),
                        this._animationRatio = t * i,
                        this._animate(t),
                        this.onAfterAnimationsObservable.notifyObservers(this),
                        this.physicsEnabled && this._advancePhysicsEngineStep(t),
                        this.onAfterStepObservable.notifyObservers(this),
                        this._currentStepId++,
                        s++,
                        e -= t;
                    this._timeAccumulator = e < 0 ? 0 : e
                } else {
                    const e = this.useConstantAnimationDeltaTime ? 16 : Math.max(ks.MinDeltaTime, Math.min(this._engine.getDeltaTime(), ks.MaxDeltaTime));
                    this._animationRatio = .06 * e,
                    this._animate(),
                    this.onAfterAnimationsObservable.notifyObservers(this),
                    this.physicsEnabled && this._advancePhysicsEngineStep(e)
                }
            }
            _clear() {
                (this.autoClearDepthAndStencil || this.autoClear) && this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil)
            }
            _checkCameraRenderTarget(e) {
                if (e?.outputRenderTarget && !e?.isRigCamera && (e.outputRenderTarget._cleared = !1),
                e?.rigCameras?.length)
                    for (let t = 0; t < e.rigCameras.length; ++t) {
                        const i = e.rigCameras[t].outputRenderTarget;
                        i && (i._cleared = !1)
                    }
            }
            resetDrawCache(e) {
                if (this.meshes)
                    for (const t of this.meshes)
                        t.resetDrawCache(e)
            }
            render(e=!0, t=!1) {
                if (this.isDisposed)
                    return;
                this.onReadyObservable.hasObservers() && null === this._executeWhenReadyTimeoutId && this._checkIsReady(),
                this._frameId++,
                this._defaultFrameBufferCleared = !1,
                this._checkCameraRenderTarget(this.activeCamera),
                this.activeCameras?.length && this.activeCameras.forEach(this._checkCameraRenderTarget),
                this._registerTransientComponents(),
                this._activeParticles.fetchNewFrame(),
                this._totalVertices.fetchNewFrame(),
                this._activeIndices.fetchNewFrame(),
                this._activeBones.fetchNewFrame(),
                this._meshesForIntersections.reset(),
                this.resetCachedMaterial(),
                this.onBeforeAnimationsObservable.notifyObservers(this),
                this.actionManager && this.actionManager.processTrigger(11),
                t || this.animate();
                for (const e of this._beforeCameraUpdateStage)
                    e.action();
                if (e)
                    if (this.activeCameras && this.activeCameras.length > 0)
                        for (let e = 0; e < this.activeCameras.length; e++) {
                            const t = this.activeCameras[e];
                            if (t.update(),
                            0 !== t.cameraRigMode)
                                for (let e = 0; e < t._rigCameras.length; e++)
                                    t._rigCameras[e].update()
                        }
                    else if (this.activeCamera && (this.activeCamera.update(),
                    0 !== this.activeCamera.cameraRigMode))
                        for (let e = 0; e < this.activeCamera._rigCameras.length; e++)
                            this.activeCamera._rigCameras[e].update();
                this.onBeforeRenderObservable.notifyObservers(this);
                const i = this.getEngine();
                this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
                const s = this.activeCameras?.length ? this.activeCameras[0] : this.activeCamera;
                if (this.renderTargetsEnabled) {
                    hi.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0),
                    this._intermediateRendering = !0;
                    for (let e = 0; e < this.customRenderTargets.length; e++) {
                        const t = this.customRenderTargets[e];
                        if (t._shouldRender()) {
                            if (this._renderId++,
                            this.activeCamera = t.activeCamera || this.activeCamera,
                            !this.activeCamera)
                                throw new Error("Active camera not set");
                            i.setViewport(this.activeCamera.viewport),
                            this.updateTransformMatrix(),
                            t.render(s !== this.activeCamera, this.dumpNextRenderTargets)
                        }
                    }
                    hi.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0),
                    this._intermediateRendering = !1,
                    this._renderId++
                }
                this._engine.currentRenderPassId = s?.renderPassId ?? 0,
                this.activeCamera = s,
                this._activeCamera && 22 !== this._activeCamera.cameraRigMode && !this.prePass && this._bindFrameBuffer(this._activeCamera, !1),
                this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
                for (const e of this._beforeClearStage)
                    e.action();
                this._clearFrameBuffer(this.activeCamera);
                for (const e of this._gatherRenderTargetsStage)
                    e.action(this._renderTargets);
                if (this.activeCameras && this.activeCameras.length > 0)
                    for (let e = 0; e < this.activeCameras.length; e++)
                        this._processSubCameras(this.activeCameras[e], e > 0);
                else {
                    if (!this.activeCamera)
                        throw new Error("No camera defined");
                    this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget)
                }
                this._checkIntersections();
                for (const e of this._afterRenderStage)
                    e.action();
                if (this.afterRender && this.afterRender(),
                this.onAfterRenderObservable.notifyObservers(this),
                this._toBeDisposed.length) {
                    for (let e = 0; e < this._toBeDisposed.length; e++) {
                        const t = this._toBeDisposed[e];
                        t && t.dispose()
                    }
                    this._toBeDisposed.length = 0
                }
                this.dumpNextRenderTargets && (this.dumpNextRenderTargets = !1),
                this._activeBones.addCount(0, !0),
                this._activeIndices.addCount(0, !0),
                this._activeParticles.addCount(0, !0),
                this._engine.restoreDefaultFramebuffer()
            }
            freezeMaterials() {
                for (let e = 0; e < this.materials.length; e++)
                    this.materials[e].freeze()
            }
            unfreezeMaterials() {
                for (let e = 0; e < this.materials.length; e++)
                    this.materials[e].unfreeze()
            }
            dispose() {
                if (this.isDisposed)
                    return;
                this.beforeRender = null,
                this.afterRender = null,
                this.metadata = null,
                this.skeletons.length = 0,
                this.morphTargetManagers.length = 0,
                this._transientComponents.length = 0,
                this._isReadyForMeshStage.clear(),
                this._beforeEvaluateActiveMeshStage.clear(),
                this._evaluateSubMeshStage.clear(),
                this._preActiveMeshStage.clear(),
                this._cameraDrawRenderTargetStage.clear(),
                this._beforeCameraDrawStage.clear(),
                this._beforeRenderTargetDrawStage.clear(),
                this._beforeRenderingGroupDrawStage.clear(),
                this._beforeRenderingMeshStage.clear(),
                this._afterRenderingMeshStage.clear(),
                this._afterRenderingGroupDrawStage.clear(),
                this._afterCameraDrawStage.clear(),
                this._afterRenderTargetDrawStage.clear(),
                this._afterRenderStage.clear(),
                this._beforeCameraUpdateStage.clear(),
                this._beforeClearStage.clear(),
                this._gatherRenderTargetsStage.clear(),
                this._gatherActiveCameraRenderTargetsStage.clear(),
                this._pointerMoveStage.clear(),
                this._pointerDownStage.clear(),
                this._pointerUpStage.clear(),
                this.importedMeshesFiles = [],
                this.stopAllAnimations && (this._activeAnimatables.forEach((e => {
                    e.onAnimationEndObservable.clear(),
                    e.onAnimationEnd = null
                }
                )),
                this.stopAllAnimations()),
                this.resetCachedMaterial(),
                this.activeCamera && (this.activeCamera._activeMeshes.dispose(),
                this.activeCamera = null),
                this.activeCameras = null,
                this._activeMeshes.dispose(),
                this._renderingManager.dispose(),
                this._processedMaterials.dispose(),
                this._activeParticleSystems.dispose(),
                this._activeSkeletons.dispose(),
                this._softwareSkinnedMeshes.dispose(),
                this._renderTargets.dispose(),
                this._materialsRenderTargets.dispose(),
                this._registeredForLateAnimationBindings.dispose(),
                this._meshesForIntersections.dispose(),
                this._toBeDisposed.length = 0;
                const e = this._activeRequests.slice();
                for (const t of e)
                    t.abort();
                this._activeRequests.length = 0;
                try {
                    this.onDisposeObservable.notifyObservers(this)
                } catch (e) {
                    We.Error("An error occurred while calling onDisposeObservable!", e)
                }
                if (this.detachControl(),
                this._engine.getInputElement())
                    for (let e = 0; e < this.cameras.length; e++)
                        this.cameras[e].detachControl();
                this._disposeList(this.animationGroups),
                this._disposeList(this.lights),
                this._disposeList(this.meshes, (e => e.dispose(!0))),
                this._disposeList(this.transformNodes, (e => e.dispose(!0)));
                const t = this.cameras;
                this._disposeList(t),
                this._defaultMaterial && this._defaultMaterial.dispose(),
                this._disposeList(this.multiMaterials),
                this._disposeList(this.materials),
                this._disposeList(this.particleSystems),
                this._disposeList(this.postProcesses),
                this._disposeList(this.textures),
                this._disposeList(this.morphTargetManagers),
                this._sceneUbo.dispose(),
                this._multiviewSceneUbo && this._multiviewSceneUbo.dispose(),
                this.postProcessManager.dispose(),
                this._disposeList(this._components);
                let i = this._engine.scenes.indexOf(this);
                i > -1 && this._engine.scenes.splice(i, 1),
                Ze._LastCreatedScene === this && (this._engine.scenes.length > 0 ? Ze._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1] : Ze._LastCreatedScene = null),
                i = this._engine._virtualScenes.indexOf(this),
                i > -1 && this._engine._virtualScenes.splice(i, 1),
                this._engine.wipeCaches(!0),
                this.onDisposeObservable.clear(),
                this.onBeforeRenderObservable.clear(),
                this.onAfterRenderObservable.clear(),
                this.onBeforeRenderTargetsRenderObservable.clear(),
                this.onAfterRenderTargetsRenderObservable.clear(),
                this.onAfterStepObservable.clear(),
                this.onBeforeStepObservable.clear(),
                this.onBeforeActiveMeshesEvaluationObservable.clear(),
                this.onAfterActiveMeshesEvaluationObservable.clear(),
                this.onBeforeParticlesRenderingObservable.clear(),
                this.onAfterParticlesRenderingObservable.clear(),
                this.onBeforeDrawPhaseObservable.clear(),
                this.onAfterDrawPhaseObservable.clear(),
                this.onBeforeAnimationsObservable.clear(),
                this.onAfterAnimationsObservable.clear(),
                this.onDataLoadedObservable.clear(),
                this.onBeforeRenderingGroupObservable.clear(),
                this.onAfterRenderingGroupObservable.clear(),
                this.onMeshImportedObservable.clear(),
                this.onBeforeCameraRenderObservable.clear(),
                this.onAfterCameraRenderObservable.clear(),
                this.onAfterRenderCameraObservable.clear(),
                this.onReadyObservable.clear(),
                this.onNewCameraAddedObservable.clear(),
                this.onCameraRemovedObservable.clear(),
                this.onNewLightAddedObservable.clear(),
                this.onLightRemovedObservable.clear(),
                this.onNewGeometryAddedObservable.clear(),
                this.onGeometryRemovedObservable.clear(),
                this.onNewTransformNodeAddedObservable.clear(),
                this.onTransformNodeRemovedObservable.clear(),
                this.onNewMeshAddedObservable.clear(),
                this.onMeshRemovedObservable.clear(),
                this.onNewSkeletonAddedObservable.clear(),
                this.onSkeletonRemovedObservable.clear(),
                this.onNewMaterialAddedObservable.clear(),
                this.onNewMultiMaterialAddedObservable.clear(),
                this.onMaterialRemovedObservable.clear(),
                this.onMultiMaterialRemovedObservable.clear(),
                this.onNewTextureAddedObservable.clear(),
                this.onTextureRemovedObservable.clear(),
                this.onPrePointerObservable.clear(),
                this.onPointerObservable.clear(),
                this.onPreKeyboardObservable.clear(),
                this.onKeyboardObservable.clear(),
                this.onActiveCameraChanged.clear(),
                this.onScenePerformancePriorityChangedObservable.clear(),
                this._isDisposed = !0
            }
            _disposeList(e, t) {
                const i = e.slice(0);
                t = t ?? (e => e.dispose());
                for (const e of i)
                    t(e);
                e.length = 0
            }
            get isDisposed() {
                return this._isDisposed
            }
            clearCachedVertexData() {
                for (let e = 0; e < this.meshes.length; e++) {
                    const t = this.meshes[e].geometry;
                    t && t.clearCachedData()
                }
            }
            cleanCachedTextureBuffer() {
                for (const e of this.textures)
                    e._buffer && (e._buffer = null)
            }
            getWorldExtends(e) {
                const t = new Di(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)
                  , i = new Di(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);
                return e = e || ( () => !0),
                this.meshes.filter(e).forEach((e => {
                    if (e.computeWorldMatrix(!0),
                    !e.subMeshes || 0 === e.subMeshes.length || e.infiniteDistance)
                        return;
                    const s = e.getBoundingInfo()
                      , r = s.boundingBox.minimumWorld
                      , n = s.boundingBox.maximumWorld;
                    Di.CheckExtends(r, t, i),
                    Di.CheckExtends(n, t, i)
                }
                )),
                {
                    min: t,
                    max: i
                }
            }
            createPickingRay(e, t, i, s, r=!1) {
                throw je("Ray")
            }
            createPickingRayToRef(e, t, i, s, r, n=!1, a=!1) {
                throw je("Ray")
            }
            createPickingRayInCameraSpace(e, t, i) {
                throw je("Ray")
            }
            createPickingRayInCameraSpaceToRef(e, t, i, s) {
                throw je("Ray")
            }
            get _pickingAvailable() {
                return !1
            }
            pick(e, t, i, s, r, n) {
                const a = je("Ray", !0);
                return a && We.Warn(a),
                new hs
            }
            pickWithBoundingInfo(e, t, i, s, r) {
                const n = je("Ray", !0);
                return n && We.Warn(n),
                new hs
            }
            pickWithRay(e, t, i, s) {
                throw je("Ray")
            }
            multiPick(e, t, i, s, r) {
                throw je("Ray")
            }
            multiPickWithRay(e, t, i) {
                throw je("Ray")
            }
            setPointerOverMesh(e, t, i) {
                this._inputManager.setPointerOverMesh(e, t, i)
            }
            getPointerOverMesh() {
                return this._inputManager.getPointerOverMesh()
            }
            _rebuildGeometries() {
                for (const e of this.geometries)
                    e._rebuild();
                for (const e of this.meshes)
                    e._rebuild();
                this.postProcessManager && this.postProcessManager._rebuild();
                for (const e of this._components)
                    e.rebuild();
                for (const e of this.particleSystems)
                    e.rebuild();
                if (this.spriteManagers)
                    for (const e of this.spriteManagers)
                        e.rebuild()
            }
            _rebuildTextures() {
                for (const e of this.textures)
                    e._rebuild(!0);
                this.markAllMaterialsAsDirty(1)
            }
            _getByTags(e, t, i) {
                if (void 0 === t)
                    return e;
                const s = [];
                for (const r in e) {
                    const n = e[r];
                    ui && ui.MatchesQuery(n, t) && (!i || i(n)) && s.push(n)
                }
                return s
            }
            getMeshesByTags(e, t) {
                return this._getByTags(this.meshes, e, t)
            }
            getCamerasByTags(e, t) {
                return this._getByTags(this.cameras, e, t)
            }
            getLightsByTags(e, t) {
                return this._getByTags(this.lights, e, t)
            }
            getMaterialByTags(e, t) {
                return this._getByTags(this.materials, e, t).concat(this._getByTags(this.multiMaterials, e, t))
            }
            getTransformNodesByTags(e, t) {
                return this._getByTags(this.transformNodes, e, t)
            }
            setRenderingOrder(e, t=null, i=null, s=null) {
                this._renderingManager.setRenderingOrder(e, t, i, s)
            }
            setRenderingAutoClearDepthStencil(e, t, i=!0, s=!0) {
                this._renderingManager.setRenderingAutoClearDepthStencil(e, t, i, s)
            }
            getAutoClearDepthStencilSetup(e) {
                return this._renderingManager.getAutoClearDepthStencilSetup(e)
            }
            _forceBlockMaterialDirtyMechanism(e) {
                this._blockMaterialDirtyMechanism = e
            }
            get blockMaterialDirtyMechanism() {
                return this._blockMaterialDirtyMechanism
            }
            set blockMaterialDirtyMechanism(e) {
                this._blockMaterialDirtyMechanism !== e && (this._blockMaterialDirtyMechanism = e,
                e || this.markAllMaterialsAsDirty(63))
            }
            markAllMaterialsAsDirty(e, t) {
                if (!this._blockMaterialDirtyMechanism)
                    for (const i of this.materials)
                        t && !t(i) || i.markAsDirty(e)
            }
            _loadFile(e, t, i, s, r, n, a) {
                const o = Zt(e, t, i, s ? this.offlineProvider : void 0, r, n, a);
                return this._activeRequests.push(o),
                o.onCompleteObservable.add((e => {
                    this._activeRequests.splice(this._activeRequests.indexOf(e), 1)
                }
                )),
                o
            }
            _loadFileAsync(e, t, i, s, r) {
                return new Promise(( (n, a) => {
                    this._loadFile(e, (e => {
                        n(e)
                    }
                    ), t, i, s, ( (e, t) => {
                        a(t)
                    }
                    ), r)
                }
                ))
            }
            _requestFile(e, t, i, s, r, n, a) {
                const o = Qt(e, t, i, s ? this.offlineProvider : void 0, r, n, a);
                return this._activeRequests.push(o),
                o.onCompleteObservable.add((e => {
                    this._activeRequests.splice(this._activeRequests.indexOf(e), 1)
                }
                )),
                o
            }
            _requestFileAsync(e, t, i, s, r) {
                return new Promise(( (n, a) => {
                    this._requestFile(e, (e => {
                        n(e)
                    }
                    ), t, i, s, (e => {
                        a(e)
                    }
                    ), r)
                }
                ))
            }
            _readFile(e, t, i, s, r) {
                const n = qt(e, t, i, s, r);
                return this._activeRequests.push(n),
                n.onCompleteObservable.add((e => {
                    this._activeRequests.splice(this._activeRequests.indexOf(e), 1)
                }
                )),
                n
            }
            _readFileAsync(e, t, i) {
                return new Promise(( (s, r) => {
                    this._readFile(e, (e => {
                        s(e)
                    }
                    ), t, i, (e => {
                        r(e)
                    }
                    ))
                }
                ))
            }
            getPerfCollector() {
                throw je("performanceViewerSceneExtension")
            }
            setActiveCameraByID(e) {
                return this.setActiveCameraById(e)
            }
            getMaterialByID(e) {
                return this.getMaterialById(e)
            }
            getLastMaterialByID(e) {
                return this.getLastMaterialById(e)
            }
            getTextureByUniqueID(e) {
                return this.getTextureByUniqueId(e)
            }
            getCameraByID(e) {
                return this.getCameraById(e)
            }
            getCameraByUniqueID(e) {
                return this.getCameraByUniqueId(e)
            }
            getBoneByID(e) {
                return this.getBoneById(e)
            }
            getLightByID(e) {
                return this.getLightById(e)
            }
            getLightByUniqueID(e) {
                return this.getLightByUniqueId(e)
            }
            getParticleSystemByID(e) {
                return this.getParticleSystemById(e)
            }
            getGeometryByID(e) {
                return this.getGeometryById(e)
            }
            getMeshByID(e) {
                return this.getMeshById(e)
            }
            getMeshByUniqueID(e) {
                return this.getMeshByUniqueId(e)
            }
            getLastMeshByID(e) {
                return this.getLastMeshById(e)
            }
            getMeshesByID(e) {
                return this.getMeshesById(e)
            }
            getTransformNodeByID(e) {
                return this.getTransformNodeById(e)
            }
            getTransformNodeByUniqueID(e) {
                return this.getTransformNodeByUniqueId(e)
            }
            getTransformNodesByID(e) {
                return this.getTransformNodesById(e)
            }
            getNodeByID(e) {
                return this.getNodeById(e)
            }
            getLastEntryByID(e) {
                return this.getLastEntryById(e)
            }
            getLastSkeletonByID(e) {
                return this.getLastSkeletonById(e)
            }
        }
        ks.FOGMODE_NONE = 0,
        ks.FOGMODE_EXP = 1,
        ks.FOGMODE_EXP2 = 2,
        ks.FOGMODE_LINEAR = 3,
        ks.MinDeltaTime = 1,
        ks.MaxDeltaTime = 1e3;
        class Vs {
            constructor(e, t, i) {
                this.bu = e,
                this.bv = t,
                this.distance = i,
                this.faceId = 0,
                this.subMeshId = 0
            }
        }
        class Gs {
            constructor(e, t, i) {
                this.vectors = Me.BuildArray(8, Di.Zero),
                this.center = Di.Zero(),
                this.centerWorld = Di.Zero(),
                this.extendSize = Di.Zero(),
                this.extendSizeWorld = Di.Zero(),
                this.directions = Me.BuildArray(3, Di.Zero),
                this.vectorsWorld = Me.BuildArray(8, Di.Zero),
                this.minimumWorld = Di.Zero(),
                this.maximumWorld = Di.Zero(),
                this.minimum = Di.Zero(),
                this.maximum = Di.Zero(),
                this._drawWrapperFront = null,
                this._drawWrapperBack = null,
                this.reConstruct(e, t, i)
            }
            reConstruct(e, t, i) {
                const s = e.x
                  , r = e.y
                  , n = e.z
                  , a = t.x
                  , o = t.y
                  , h = t.z
                  , l = this.vectors;
                this.minimum.copyFromFloats(s, r, n),
                this.maximum.copyFromFloats(a, o, h),
                l[0].copyFromFloats(s, r, n),
                l[1].copyFromFloats(a, o, h),
                l[2].copyFromFloats(a, r, n),
                l[3].copyFromFloats(s, o, n),
                l[4].copyFromFloats(s, r, h),
                l[5].copyFromFloats(a, o, n),
                l[6].copyFromFloats(s, o, h),
                l[7].copyFromFloats(a, r, h),
                t.addToRef(e, this.center).scaleInPlace(.5),
                t.subtractToRef(e, this.extendSize).scaleInPlace(.5),
                this._worldMatrix = i || Oi.IdentityReadOnly,
                this._update(this._worldMatrix)
            }
            scale(e) {
                const t = Gs._TmpVector3
                  , i = this.maximum.subtractToRef(this.minimum, t[0])
                  , s = i.length();
                i.normalizeFromLength(s);
                const r = s * e
                  , n = i.scaleInPlace(.5 * r)
                  , a = this.center.subtractToRef(n, t[1])
                  , o = this.center.addToRef(n, t[2]);
                return this.reConstruct(a, o, this._worldMatrix),
                this
            }
            getWorldMatrix() {
                return this._worldMatrix
            }
            _update(e) {
                const t = this.minimumWorld
                  , i = this.maximumWorld
                  , s = this.directions
                  , r = this.vectorsWorld
                  , n = this.vectors;
                if (e.isIdentity()) {
                    t.copyFrom(this.minimum),
                    i.copyFrom(this.maximum);
                    for (let e = 0; e < 8; ++e)
                        r[e].copyFrom(n[e]);
                    this.extendSizeWorld.copyFrom(this.extendSize),
                    this.centerWorld.copyFrom(this.center)
                } else {
                    t.setAll(Number.MAX_VALUE),
                    i.setAll(-Number.MAX_VALUE);
                    for (let s = 0; s < 8; ++s) {
                        const a = r[s];
                        Di.TransformCoordinatesToRef(n[s], e, a),
                        t.minimizeInPlace(a),
                        i.maximizeInPlace(a)
                    }
                    i.subtractToRef(t, this.extendSizeWorld).scaleInPlace(.5),
                    i.addToRef(t, this.centerWorld).scaleInPlace(.5)
                }
                Di.FromArrayToRef(e.m, 0, s[0]),
                Di.FromArrayToRef(e.m, 4, s[1]),
                Di.FromArrayToRef(e.m, 8, s[2]),
                this._worldMatrix = e
            }
            isInFrustum(e) {
                return Gs.IsInFrustum(this.vectorsWorld, e)
            }
            isCompletelyInFrustum(e) {
                return Gs.IsCompletelyInFrustum(this.vectorsWorld, e)
            }
            intersectsPoint(e) {
                const t = this.minimumWorld
                  , i = this.maximumWorld
                  , s = t.x
                  , r = t.y
                  , n = t.z
                  , a = i.x
                  , o = i.y
                  , h = i.z
                  , l = e.x
                  , c = e.y
                  , u = e.z
                  , d = -.001;
                return !(a - l < d || d > l - s || o - c < d || d > c - r || h - u < d || d > u - n)
            }
            intersectsSphere(e) {
                return Gs.IntersectsSphere(this.minimumWorld, this.maximumWorld, e.centerWorld, e.radiusWorld)
            }
            intersectsMinMax(e, t) {
                const i = this.minimumWorld
                  , s = this.maximumWorld
                  , r = i.x
                  , n = i.y
                  , a = i.z
                  , o = s.x
                  , h = s.y
                  , l = s.z
                  , c = e.x
                  , u = e.y
                  , d = e.z
                  , f = t.x
                  , _ = t.y
                  , p = t.z;
                return !(o < c || r > f || h < u || n > _ || l < d || a > p)
            }
            dispose() {
                this._drawWrapperFront?.dispose(),
                this._drawWrapperBack?.dispose()
            }
            static Intersects(e, t) {
                return e.intersectsMinMax(t.minimumWorld, t.maximumWorld)
            }
            static IntersectsSphere(e, t, i, s) {
                const r = Gs._TmpVector3[0];
                return Di.ClampToRef(i, e, t, r),
                Di.DistanceSquared(i, r) <= s * s
            }
            static IsCompletelyInFrustum(e, t) {
                for (let i = 0; i < 6; ++i) {
                    const s = t[i];
                    for (let t = 0; t < 8; ++t)
                        if (s.dotCoordinate(e[t]) < 0)
                            return !1
                }
                return !0
            }
            static IsInFrustum(e, t) {
                for (let i = 0; i < 6; ++i) {
                    let s = !0;
                    const r = t[i];
                    for (let t = 0; t < 8; ++t)
                        if (r.dotCoordinate(e[t]) >= 0) {
                            s = !1;
                            break
                        }
                    if (s)
                        return !1
                }
                return !0
            }
        }
        Gs._TmpVector3 = Me.BuildArray(3, Di.Zero);
        class zs {
            constructor(e, t, i) {
                this.center = Di.Zero(),
                this.centerWorld = Di.Zero(),
                this.minimum = Di.Zero(),
                this.maximum = Di.Zero(),
                this.reConstruct(e, t, i)
            }
            reConstruct(e, t, i) {
                this.minimum.copyFrom(e),
                this.maximum.copyFrom(t);
                const s = Di.Distance(e, t);
                t.addToRef(e, this.center).scaleInPlace(.5),
                this.radius = .5 * s,
                this._update(i || Oi.IdentityReadOnly)
            }
            scale(e) {
                const t = this.radius * e
                  , i = zs._TmpVector3
                  , s = i[0].setAll(t)
                  , r = this.center.subtractToRef(s, i[1])
                  , n = this.center.addToRef(s, i[2]);
                return this.reConstruct(r, n, this._worldMatrix),
                this
            }
            getWorldMatrix() {
                return this._worldMatrix
            }
            _update(e) {
                if (e.isIdentity())
                    this.centerWorld.copyFrom(this.center),
                    this.radiusWorld = this.radius;
                else {
                    Di.TransformCoordinatesToRef(this.center, e, this.centerWorld);
                    const t = zs._TmpVector3[0];
                    Di.TransformNormalFromFloatsToRef(1, 1, 1, e, t),
                    this.radiusWorld = Math.max(Math.abs(t.x), Math.abs(t.y), Math.abs(t.z)) * this.radius
                }
            }
            isInFrustum(e) {
                const t = this.centerWorld
                  , i = this.radiusWorld;
                for (let s = 0; s < 6; s++)
                    if (e[s].dotCoordinate(t) <= -i)
                        return !1;
                return !0
            }
            isCenterInFrustum(e) {
                const t = this.centerWorld;
                for (let i = 0; i < 6; i++)
                    if (e[i].dotCoordinate(t) < 0)
                        return !1;
                return !0
            }
            intersectsPoint(e) {
                const t = Di.DistanceSquared(this.centerWorld, e);
                return !(this.radiusWorld * this.radiusWorld < t)
            }
            static Intersects(e, t) {
                const i = Di.DistanceSquared(e.centerWorld, t.centerWorld)
                  , s = e.radiusWorld + t.radiusWorld;
                return !(s * s < i)
            }
            static CreateFromCenterAndRadius(e, t, i) {
                this._TmpVector3[0].copyFrom(e),
                this._TmpVector3[1].copyFromFloats(0, 0, t),
                this._TmpVector3[2].copyFrom(e),
                this._TmpVector3[0].addInPlace(this._TmpVector3[1]),
                this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);
                const s = new zs(this._TmpVector3[0],this._TmpVector3[2]);
                return s._worldMatrix = i || Oi.Identity(),
                s
            }
        }
        zs._TmpVector3 = Me.BuildArray(3, Di.Zero);
        const Ws = {
            min: 0,
            max: 0
        }
          , Xs = {
            min: 0,
            max: 0
        }
          , Hs = (e, t, i) => {
            const s = Di.Dot(t.centerWorld, e)
              , r = Math.abs(Di.Dot(t.directions[0], e)) * t.extendSize.x + Math.abs(Di.Dot(t.directions[1], e)) * t.extendSize.y + Math.abs(Di.Dot(t.directions[2], e)) * t.extendSize.z;
            i.min = s - r,
            i.max = s + r
        }
          , Ks = (e, t, i) => (Hs(e, t, Ws),
        Hs(e, i, Xs),
        !(Ws.min > Xs.max || Xs.min > Ws.max));
        class Ys {
            constructor(e, t, i) {
                this._isLocked = !1,
                this.boundingBox = new Gs(e,t,i),
                this.boundingSphere = new zs(e,t,i)
            }
            reConstruct(e, t, i) {
                this.boundingBox.reConstruct(e, t, i),
                this.boundingSphere.reConstruct(e, t, i)
            }
            get minimum() {
                return this.boundingBox.minimum
            }
            get maximum() {
                return this.boundingBox.maximum
            }
            get isLocked() {
                return this._isLocked
            }
            set isLocked(e) {
                this._isLocked = e
            }
            update(e) {
                this._isLocked || (this.boundingBox._update(e),
                this.boundingSphere._update(e))
            }
            centerOn(e, t) {
                const i = Ys._TmpVector3[0].copyFrom(e).subtractInPlace(t)
                  , s = Ys._TmpVector3[1].copyFrom(e).addInPlace(t);
                return this.boundingBox.reConstruct(i, s, this.boundingBox.getWorldMatrix()),
                this.boundingSphere.reConstruct(i, s, this.boundingBox.getWorldMatrix()),
                this
            }
            encapsulate(e) {
                const t = Di.Minimize(this.minimum, e)
                  , i = Di.Maximize(this.maximum, e);
                return this.reConstruct(t, i, this.boundingBox.getWorldMatrix()),
                this
            }
            encapsulateBoundingInfo(e) {
                const t = Bi.Matrix[0];
                this.boundingBox.getWorldMatrix().invertToRef(t);
                const i = Bi.Vector3[0];
                return Di.TransformCoordinatesToRef(e.boundingBox.minimumWorld, t, i),
                this.encapsulate(i),
                Di.TransformCoordinatesToRef(e.boundingBox.maximumWorld, t, i),
                this.encapsulate(i),
                this
            }
            scale(e) {
                return this.boundingBox.scale(e),
                this.boundingSphere.scale(e),
                this
            }
            isInFrustum(e, t=0) {
                return !(2 !== t && 3 !== t || !this.boundingSphere.isCenterInFrustum(e)) || !!this.boundingSphere.isInFrustum(e) && (!(1 !== t && 3 !== t) || this.boundingBox.isInFrustum(e))
            }
            get diagonalLength() {
                const e = this.boundingBox;
                return e.maximumWorld.subtractToRef(e.minimumWorld, Ys._TmpVector3[0]).length()
            }
            isCompletelyInFrustum(e) {
                return this.boundingBox.isCompletelyInFrustum(e)
            }
            _checkCollision(e) {
                return e._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld)
            }
            intersectsPoint(e) {
                return !!this.boundingSphere.centerWorld && !!this.boundingSphere.intersectsPoint(e) && !!this.boundingBox.intersectsPoint(e)
            }
            intersects(e, t) {
                if (!zs.Intersects(this.boundingSphere, e.boundingSphere))
                    return !1;
                if (!Gs.Intersects(this.boundingBox, e.boundingBox))
                    return !1;
                if (!t)
                    return !0;
                const i = this.boundingBox
                  , s = e.boundingBox;
                return !!(Ks(i.directions[0], i, s) && Ks(i.directions[1], i, s) && Ks(i.directions[2], i, s) && Ks(s.directions[0], i, s) && Ks(s.directions[1], i, s) && Ks(s.directions[2], i, s) && Ks(Di.Cross(i.directions[0], s.directions[0]), i, s) && Ks(Di.Cross(i.directions[0], s.directions[1]), i, s) && Ks(Di.Cross(i.directions[0], s.directions[2]), i, s) && Ks(Di.Cross(i.directions[1], s.directions[0]), i, s) && Ks(Di.Cross(i.directions[1], s.directions[1]), i, s) && Ks(Di.Cross(i.directions[1], s.directions[2]), i, s) && Ks(Di.Cross(i.directions[2], s.directions[0]), i, s) && Ks(Di.Cross(i.directions[2], s.directions[1]), i, s) && Ks(Di.Cross(i.directions[2], s.directions[2]), i, s))
            }
        }
        Ys._TmpVector3 = Me.BuildArray(2, Di.Zero);
        class js {
            static extractMinAndMaxIndexed(e, t, i, s, r, n) {
                for (let a = i; a < i + s; a++) {
                    const i = 3 * t[a]
                      , s = e[i]
                      , o = e[i + 1]
                      , h = e[i + 2];
                    r.minimizeInPlaceFromFloats(s, o, h),
                    n.maximizeInPlaceFromFloats(s, o, h)
                }
            }
            static extractMinAndMax(e, t, i, s, r, n) {
                for (let a = t, o = t * s; a < t + i; a++,
                o += s) {
                    const t = e[o]
                      , i = e[o + 1]
                      , s = e[o + 2];
                    r.minimizeInPlaceFromFloats(t, i, s),
                    n.maximizeInPlaceFromFloats(t, i, s)
                }
            }
        }
        function qs(e, t, i, s=null, r) {
            const n = new Di(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)
              , a = new Di(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);
            return r || (r = 3),
            js.extractMinAndMax(e, t, i, r, n, a),
            s && (n.x -= n.x * s.x + s.y,
            n.y -= n.y * s.x + s.y,
            n.z -= n.z * s.x + s.y,
            a.x += a.x * s.x + s.y,
            a.y += a.y * s.x + s.y,
            a.z += a.z * s.x + s.y),
            {
                minimum: n,
                maximum: a
            }
        }
        pi([Ai.filter(( (...[e,t]) => !Array.isArray(e) && !Array.isArray(t)))], js, "extractMinAndMaxIndexed", null),
        pi([Ai.filter(( (...[e]) => !Array.isArray(e)))], js, "extractMinAndMax", null);
        class Zs {
            get materialDefines() {
                return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : this._getDrawWrapper()?.defines
            }
            set materialDefines(e) {
                (this._mainDrawWrapperOverride ?? this._getDrawWrapper(void 0, !0)).defines = e
            }
            _getDrawWrapper(e, t=!1) {
                e = e ?? this._engine.currentRenderPassId;
                let i = this._drawWrappers[e];
                return !i && t && (this._drawWrappers[e] = i = new Bt(this._mesh.getScene().getEngine())),
                i
            }
            _removeDrawWrapper(e, t=!0) {
                t && this._drawWrappers[e]?.dispose(),
                this._drawWrappers[e] = void 0
            }
            get effect() {
                return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : this._getDrawWrapper()?.effect ?? null
            }
            get _drawWrapper() {
                return this._mainDrawWrapperOverride ?? this._getDrawWrapper(void 0, !0)
            }
            get _drawWrapperOverride() {
                return this._mainDrawWrapperOverride
            }
            _setMainDrawWrapperOverride(e) {
                this._mainDrawWrapperOverride = e
            }
            setEffect(e, t=null, i, s=!0) {
                const r = this._drawWrapper;
                r.setEffect(e, t, s),
                void 0 !== i && (r.materialContext = i),
                e || (r.defines = null,
                r.materialContext = void 0)
            }
            resetDrawCache(e) {
                if (this._drawWrappers) {
                    if (void 0 !== e)
                        return void this._removeDrawWrapper(e);
                    for (const e of this._drawWrappers)
                        e?.dispose()
                }
                this._drawWrappers = []
            }
            static AddToMesh(e, t, i, s, r, n, a, o=!0) {
                return new Zs(e,t,i,s,r,n,a,o)
            }
            constructor(e, t, i, s, r, n, a, o=!0, h=!0) {
                this.materialIndex = e,
                this.verticesStart = t,
                this.verticesCount = i,
                this.indexStart = s,
                this.indexCount = r,
                this._mainDrawWrapperOverride = null,
                this._linesIndexCount = 0,
                this._linesIndexBuffer = null,
                this._lastColliderWorldVertices = null,
                this._lastColliderTransformMatrix = null,
                this._wasDispatched = !1,
                this._renderId = 0,
                this._alphaIndex = 0,
                this._distanceToCamera = 0,
                this._currentMaterial = null,
                this._mesh = n,
                this._renderingMesh = a || n,
                h && n.subMeshes.push(this),
                this._engine = this._mesh.getScene().getEngine(),
                this.resetDrawCache(),
                this._trianglePlanes = [],
                this._id = n.subMeshes.length - 1,
                o && (this.refreshBoundingInfo(),
                n.computeWorldMatrix(!0))
            }
            get IsGlobal() {
                return 0 === this.verticesStart && this.verticesCount === this._mesh.getTotalVertices() && 0 === this.indexStart && this.indexCount === this._mesh.getTotalIndices()
            }
            getBoundingInfo() {
                return this.IsGlobal || this._mesh.hasThinInstances ? this._mesh.getBoundingInfo() : this._boundingInfo
            }
            setBoundingInfo(e) {
                return this._boundingInfo = e,
                this
            }
            getMesh() {
                return this._mesh
            }
            getRenderingMesh() {
                return this._renderingMesh
            }
            getReplacementMesh() {
                return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null
            }
            getEffectiveMesh() {
                return (this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null) || this._renderingMesh
            }
            getMaterial(e=!0) {
                const t = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId) ?? this._renderingMesh.material;
                if (!t)
                    return e ? this._mesh.getScene().defaultMaterial : null;
                if (this._isMultiMaterial(t)) {
                    const e = t.getSubMaterial(this.materialIndex);
                    return this._currentMaterial !== e && (this._currentMaterial = e,
                    this.resetDrawCache()),
                    e
                }
                return t
            }
            _isMultiMaterial(e) {
                return void 0 !== e.getSubMaterial
            }
            refreshBoundingInfo(e=null) {
                if (this._lastColliderWorldVertices = null,
                this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry)
                    return this;
                if (e || (e = this._renderingMesh.getVerticesData(os.PositionKind)),
                !e)
                    return this._boundingInfo = this._mesh.getBoundingInfo(),
                    this;
                const t = this._renderingMesh.getIndices();
                let i;
                if (0 === this.indexStart && this.indexCount === t.length) {
                    const e = this._renderingMesh.getBoundingInfo();
                    i = {
                        minimum: e.minimum.clone(),
                        maximum: e.maximum.clone()
                    }
                } else
                    i = function(e, t, i, s, r=null) {
                        const n = new Di(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)
                          , a = new Di(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);
                        return js.extractMinAndMaxIndexed(e, t, i, s, n, a),
                        r && (n.x -= n.x * r.x + r.y,
                        n.y -= n.y * r.x + r.y,
                        n.z -= n.z * r.x + r.y,
                        a.x += a.x * r.x + r.y,
                        a.y += a.y * r.x + r.y,
                        a.z += a.z * r.x + r.y),
                        {
                            minimum: n,
                            maximum: a
                        }
                    }(e, t, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
                return this._boundingInfo ? this._boundingInfo.reConstruct(i.minimum, i.maximum) : this._boundingInfo = new Ys(i.minimum,i.maximum),
                this
            }
            _checkCollision(e) {
                return this.getBoundingInfo()._checkCollision(e)
            }
            updateBoundingInfo(e) {
                let t = this.getBoundingInfo();
                return t || (this.refreshBoundingInfo(),
                t = this.getBoundingInfo()),
                t && t.update(e),
                this
            }
            isInFrustum(e) {
                const t = this.getBoundingInfo();
                return !!t && t.isInFrustum(e, this._mesh.cullingStrategy)
            }
            isCompletelyInFrustum(e) {
                const t = this.getBoundingInfo();
                return !!t && t.isCompletelyInFrustum(e)
            }
            render(e) {
                return this._renderingMesh.render(this, e, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0),
                this
            }
            _getLinesIndexBuffer(e, t) {
                if (!this._linesIndexBuffer) {
                    const i = [];
                    for (let t = this.indexStart; t < this.indexStart + this.indexCount; t += 3)
                        i.push(e[t], e[t + 1], e[t + 1], e[t + 2], e[t + 2], e[t]);
                    this._linesIndexBuffer = t.createIndexBuffer(i),
                    this._linesIndexCount = i.length
                }
                return this._linesIndexBuffer
            }
            canIntersects(e) {
                const t = this.getBoundingInfo();
                return !!t && e.intersectsBox(t.boundingBox)
            }
            intersects(e, t, i, s, r) {
                const n = this.getMaterial();
                if (!n)
                    return null;
                let a = 3
                  , o = !1;
                switch (n.fillMode) {
                case 3:
                case 5:
                case 6:
                case 8:
                    return null;
                case 7:
                    a = 1,
                    o = !0
                }
                return 4 === n.fillMode ? i.length ? this._intersectLines(e, t, i, this._mesh.intersectionThreshold, s) : this._intersectUnIndexedLines(e, t, i, this._mesh.intersectionThreshold, s) : !i.length && this._mesh._unIndexed ? this._intersectUnIndexedTriangles(e, t, i, s, r) : this._intersectTriangles(e, t, i, a, o, s, r)
            }
            _intersectLines(e, t, i, s, r) {
                let n = null;
                for (let a = this.indexStart; a < this.indexStart + this.indexCount; a += 2) {
                    const o = t[i[a]]
                      , h = t[i[a + 1]]
                      , l = e.intersectionSegment(o, h, s);
                    if (!(l < 0) && (r || !n || l < n.distance) && (n = new Vs(null,null,l),
                    n.faceId = a / 2,
                    r))
                        break
                }
                return n
            }
            _intersectUnIndexedLines(e, t, i, s, r) {
                let n = null;
                for (let i = this.verticesStart; i < this.verticesStart + this.verticesCount; i += 2) {
                    const a = t[i]
                      , o = t[i + 1]
                      , h = e.intersectionSegment(a, o, s);
                    if (!(h < 0) && (r || !n || h < n.distance) && (n = new Vs(null,null,h),
                    n.faceId = i / 2,
                    r))
                        break
                }
                return n
            }
            _intersectTriangles(e, t, i, s, r, n, a) {
                let o = null
                  , h = -1;
                for (let l = this.indexStart; l < this.indexStart + this.indexCount - (3 - s); l += s) {
                    h++;
                    const s = i[l]
                      , c = i[l + 1]
                      , u = i[l + 2];
                    if (r && 4294967295 === u) {
                        l += 2;
                        continue
                    }
                    const d = t[s]
                      , f = t[c]
                      , _ = t[u];
                    if (!d || !f || !_)
                        continue;
                    if (a && !a(d, f, _, e, s, c, u))
                        continue;
                    const p = e.intersectsTriangle(d, f, _);
                    if (p) {
                        if (p.distance < 0)
                            continue;
                        if ((n || !o || p.distance < o.distance) && (o = p,
                        o.faceId = h,
                        n))
                            break
                    }
                }
                return o
            }
            _intersectUnIndexedTriangles(e, t, i, s, r) {
                let n = null;
                for (let i = this.verticesStart; i < this.verticesStart + this.verticesCount; i += 3) {
                    const a = t[i]
                      , o = t[i + 1]
                      , h = t[i + 2];
                    if (r && !r(a, o, h, e, -1, -1, -1))
                        continue;
                    const l = e.intersectsTriangle(a, o, h);
                    if (l) {
                        if (l.distance < 0)
                            continue;
                        if ((s || !n || l.distance < n.distance) && (n = l,
                        n.faceId = i / 3,
                        s))
                            break
                    }
                }
                return n
            }
            _rebuild() {
                this._linesIndexBuffer && (this._linesIndexBuffer = null)
            }
            clone(e, t) {
                const i = new Zs(this.materialIndex,this.verticesStart,this.verticesCount,this.indexStart,this.indexCount,e,t,!1);
                if (!this.IsGlobal) {
                    const e = this.getBoundingInfo();
                    if (!e)
                        return i;
                    i._boundingInfo = new Ys(e.minimum,e.maximum)
                }
                return i
            }
            dispose() {
                this._linesIndexBuffer && (this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer),
                this._linesIndexBuffer = null);
                const e = this._mesh.subMeshes.indexOf(this);
                this._mesh.subMeshes.splice(e, 1),
                this.resetDrawCache()
            }
            getClassName() {
                return "SubMesh"
            }
            static CreateFromIndices(e, t, i, s, r, n=!0) {
                let a = Number.MAX_VALUE
                  , o = -Number.MAX_VALUE;
                const h = (r || s).getIndices();
                for (let e = t; e < t + i; e++) {
                    const t = h[e];
                    t < a && (a = t),
                    t > o && (o = t)
                }
                return new Zs(e,a,o - a + 1,t,i,s,r,n)
            }
        }
        class Qs {
        }
        class $s {
            constructor() {
                var e;
                this.uniqueId = 0,
                this.metadata = {},
                this._applyTo = (e = this._applyToCoroutine.bind(this),
                (...t) => _i(e(...t), undefined)),
                this.uniqueId = $s._UniqueIDGenerator,
                $s._UniqueIDGenerator++
            }
            set(e, t) {
                switch (e.length || We.Warn(`Setting vertex data kind '${t}' with an empty array`),
                t) {
                case os.PositionKind:
                    this.positions = e;
                    break;
                case os.NormalKind:
                    this.normals = e;
                    break;
                case os.TangentKind:
                    this.tangents = e;
                    break;
                case os.UVKind:
                    this.uvs = e;
                    break;
                case os.UV2Kind:
                    this.uvs2 = e;
                    break;
                case os.UV3Kind:
                    this.uvs3 = e;
                    break;
                case os.UV4Kind:
                    this.uvs4 = e;
                    break;
                case os.UV5Kind:
                    this.uvs5 = e;
                    break;
                case os.UV6Kind:
                    this.uvs6 = e;
                    break;
                case os.ColorKind:
                    this.colors = e;
                    break;
                case os.MatricesIndicesKind:
                    this.matricesIndices = e;
                    break;
                case os.MatricesWeightsKind:
                    this.matricesWeights = e;
                    break;
                case os.MatricesIndicesExtraKind:
                    this.matricesIndicesExtra = e;
                    break;
                case os.MatricesWeightsExtraKind:
                    this.matricesWeightsExtra = e
                }
            }
            applyToMesh(e, t) {
                return this._applyTo(e, t, !1),
                this
            }
            applyToGeometry(e, t) {
                return this._applyTo(e, t, !1),
                this
            }
            updateMesh(e) {
                return this._update(e),
                this
            }
            updateGeometry(e) {
                return this._update(e),
                this
            }
            *_applyToCoroutine(e, t=!1, i) {
                if (this.positions && (e.setVerticesData(os.PositionKind, this.positions, t),
                i && (yield)),
                this.normals && (e.setVerticesData(os.NormalKind, this.normals, t),
                i && (yield)),
                this.tangents && (e.setVerticesData(os.TangentKind, this.tangents, t),
                i && (yield)),
                this.uvs && (e.setVerticesData(os.UVKind, this.uvs, t),
                i && (yield)),
                this.uvs2 && (e.setVerticesData(os.UV2Kind, this.uvs2, t),
                i && (yield)),
                this.uvs3 && (e.setVerticesData(os.UV3Kind, this.uvs3, t),
                i && (yield)),
                this.uvs4 && (e.setVerticesData(os.UV4Kind, this.uvs4, t),
                i && (yield)),
                this.uvs5 && (e.setVerticesData(os.UV5Kind, this.uvs5, t),
                i && (yield)),
                this.uvs6 && (e.setVerticesData(os.UV6Kind, this.uvs6, t),
                i && (yield)),
                this.colors && (e.setVerticesData(os.ColorKind, this.colors, t),
                this.hasVertexAlpha && void 0 !== e.hasVertexAlpha && (e.hasVertexAlpha = !0),
                i && (yield)),
                this.matricesIndices && (e.setVerticesData(os.MatricesIndicesKind, this.matricesIndices, t),
                i && (yield)),
                this.matricesWeights && (e.setVerticesData(os.MatricesWeightsKind, this.matricesWeights, t),
                i && (yield)),
                this.matricesIndicesExtra && (e.setVerticesData(os.MatricesIndicesExtraKind, this.matricesIndicesExtra, t),
                i && (yield)),
                this.matricesWeightsExtra && (e.setVerticesData(os.MatricesWeightsExtraKind, this.matricesWeightsExtra, t),
                i && (yield)),
                this.indices ? (e.setIndices(this.indices, null, t),
                i && (yield)) : e.setIndices([], null),
                e.subMeshes && this.materialInfos && this.materialInfos.length > 1) {
                    const t = e;
                    t.subMeshes = [];
                    for (const e of this.materialInfos)
                        new Zs(e.materialIndex,e.verticesStart,e.verticesCount,e.indexStart,e.indexCount,t)
                }
                return this
            }
            _update(e, t, i) {
                return this.positions && e.updateVerticesData(os.PositionKind, this.positions, t, i),
                this.normals && e.updateVerticesData(os.NormalKind, this.normals, t, i),
                this.tangents && e.updateVerticesData(os.TangentKind, this.tangents, t, i),
                this.uvs && e.updateVerticesData(os.UVKind, this.uvs, t, i),
                this.uvs2 && e.updateVerticesData(os.UV2Kind, this.uvs2, t, i),
                this.uvs3 && e.updateVerticesData(os.UV3Kind, this.uvs3, t, i),
                this.uvs4 && e.updateVerticesData(os.UV4Kind, this.uvs4, t, i),
                this.uvs5 && e.updateVerticesData(os.UV5Kind, this.uvs5, t, i),
                this.uvs6 && e.updateVerticesData(os.UV6Kind, this.uvs6, t, i),
                this.colors && e.updateVerticesData(os.ColorKind, this.colors, t, i),
                this.matricesIndices && e.updateVerticesData(os.MatricesIndicesKind, this.matricesIndices, t, i),
                this.matricesWeights && e.updateVerticesData(os.MatricesWeightsKind, this.matricesWeights, t, i),
                this.matricesIndicesExtra && e.updateVerticesData(os.MatricesIndicesExtraKind, this.matricesIndicesExtra, t, i),
                this.matricesWeightsExtra && e.updateVerticesData(os.MatricesWeightsExtraKind, this.matricesWeightsExtra, t, i),
                this.indices && e.setIndices(this.indices, null),
                this
            }
            static _TransformVector3Coordinates(e, t, i=0, s=e.length) {
                const r = Bi.Vector3[0]
                  , n = Bi.Vector3[1];
                for (let a = i; a < i + s; a += 3)
                    Di.FromArrayToRef(e, a, r),
                    Di.TransformCoordinatesToRef(r, t, n),
                    e[a] = n.x,
                    e[a + 1] = n.y,
                    e[a + 2] = n.z
            }
            static _TransformVector3Normals(e, t, i=0, s=e.length) {
                const r = Bi.Vector3[0]
                  , n = Bi.Vector3[1];
                for (let a = i; a < i + s; a += 3)
                    Di.FromArrayToRef(e, a, r),
                    Di.TransformNormalToRef(r, t, n),
                    e[a] = n.x,
                    e[a + 1] = n.y,
                    e[a + 2] = n.z
            }
            static _TransformVector4Normals(e, t, i=0, s=e.length) {
                const r = Bi.Vector4[0]
                  , n = Bi.Vector4[1];
                for (let a = i; a < i + s; a += 4)
                    wi.FromArrayToRef(e, a, r),
                    wi.TransformNormalToRef(r, t, n),
                    e[a] = n.x,
                    e[a + 1] = n.y,
                    e[a + 2] = n.z,
                    e[a + 3] = n.w
            }
            static _FlipFaces(e, t=0, i=e.length) {
                for (let s = t; s < t + i; s += 3) {
                    const t = e[s + 1];
                    e[s + 1] = e[s + 2],
                    e[s + 2] = t
                }
            }
            transform(e) {
                const t = e.determinant() < 0;
                return this.positions && $s._TransformVector3Coordinates(this.positions, e),
                this.normals && $s._TransformVector3Normals(this.normals, e),
                this.tangents && $s._TransformVector4Normals(this.tangents, e),
                t && this.indices && $s._FlipFaces(this.indices),
                this
            }
            splitBasedOnMaterialID() {
                if (!this.materialInfos || this.materialInfos.length < 2)
                    return [this];
                const e = [];
                for (const t of this.materialInfos) {
                    const i = new $s;
                    if (this.positions && (i.positions = this.positions.slice(3 * t.verticesStart, 3 * (t.verticesCount + t.verticesStart))),
                    this.normals && (i.normals = this.normals.slice(3 * t.verticesStart, 3 * (t.verticesCount + t.verticesStart))),
                    this.tangents && (i.tangents = this.tangents.slice(4 * t.verticesStart, 4 * (t.verticesCount + t.verticesStart))),
                    this.colors && (i.colors = this.colors.slice(4 * t.verticesStart, 4 * (t.verticesCount + t.verticesStart))),
                    this.uvs && (i.uvs = this.uvs.slice(2 * t.verticesStart, 2 * (t.verticesCount + t.verticesStart))),
                    this.uvs2 && (i.uvs2 = this.uvs2.slice(2 * t.verticesStart, 2 * (t.verticesCount + t.verticesStart))),
                    this.uvs3 && (i.uvs3 = this.uvs3.slice(2 * t.verticesStart, 2 * (t.verticesCount + t.verticesStart))),
                    this.uvs4 && (i.uvs4 = this.uvs4.slice(2 * t.verticesStart, 2 * (t.verticesCount + t.verticesStart))),
                    this.uvs5 && (i.uvs5 = this.uvs5.slice(2 * t.verticesStart, 2 * (t.verticesCount + t.verticesStart))),
                    this.uvs6 && (i.uvs6 = this.uvs6.slice(2 * t.verticesStart, 2 * (t.verticesCount + t.verticesStart))),
                    this.matricesIndices && (i.matricesIndices = this.matricesIndices.slice(4 * t.verticesStart, 4 * (t.verticesCount + t.verticesStart))),
                    this.matricesIndicesExtra && (i.matricesIndicesExtra = this.matricesIndicesExtra.slice(4 * t.verticesStart, 4 * (t.verticesCount + t.verticesStart))),
                    this.matricesWeights && (i.matricesWeights = this.matricesWeights.slice(4 * t.verticesStart, 4 * (t.verticesCount + t.verticesStart))),
                    this.matricesWeightsExtra && (i.matricesWeightsExtra = this.matricesWeightsExtra.slice(4 * t.verticesStart, 4 * (t.verticesCount + t.verticesStart))),
                    this.indices) {
                        i.indices = [];
                        for (let e = t.indexStart; e < t.indexStart + t.indexCount; e++)
                            i.indices.push(this.indices[e] - t.verticesStart)
                    }
                    const s = new Qs;
                    s.indexStart = 0,
                    s.indexCount = i.indices ? i.indices.length : 0,
                    s.materialIndex = t.materialIndex,
                    s.verticesStart = 0,
                    s.verticesCount = (i.positions ? i.positions.length : 0) / 3,
                    i.materialInfos = [s],
                    e.push(i)
                }
                return e
            }
            merge(e, t=!1, i=!1, s=!1, r=!1) {
                const n = Array.isArray(e) ? e.map((e => ({
                    vertexData: e
                }))) : [{
                    vertexData: e
                }];
                return _i(this._mergeCoroutine(void 0, n, t, !1, i, s, r))
            }
            *_mergeCoroutine(e, t, i=!1, s, r, n=!1, a=!1) {
                this._validate();
                let o = t.map((e => e.vertexData))
                  , h = this;
                if (a)
                    for (const e of o)
                        e && (e._validate(),
                        !this.normals && e.normals && (this.normals = new Float32Array(this.positions.length)),
                        !this.tangents && e.tangents && (this.tangents = new Float32Array(this.positions.length / 3 * 4)),
                        !this.uvs && e.uvs && (this.uvs = new Float32Array(this.positions.length / 3 * 2)),
                        !this.uvs2 && e.uvs2 && (this.uvs2 = new Float32Array(this.positions.length / 3 * 2)),
                        !this.uvs3 && e.uvs3 && (this.uvs3 = new Float32Array(this.positions.length / 3 * 2)),
                        !this.uvs4 && e.uvs4 && (this.uvs4 = new Float32Array(this.positions.length / 3 * 2)),
                        !this.uvs5 && e.uvs5 && (this.uvs5 = new Float32Array(this.positions.length / 3 * 2)),
                        !this.uvs6 && e.uvs6 && (this.uvs6 = new Float32Array(this.positions.length / 3 * 2)),
                        !this.colors && e.colors && (this.colors = new Float32Array(this.positions.length / 3 * 4),
                        this.colors.fill(1)),
                        !this.matricesIndices && e.matricesIndices && (this.matricesIndices = new Float32Array(this.positions.length / 3 * 4)),
                        !this.matricesWeights && e.matricesWeights && (this.matricesWeights = new Float32Array(this.positions.length / 3 * 4)),
                        !this.matricesIndicesExtra && e.matricesIndicesExtra && (this.matricesIndicesExtra = new Float32Array(this.positions.length / 3 * 4)),
                        !this.matricesWeightsExtra && e.matricesWeightsExtra && (this.matricesWeightsExtra = new Float32Array(this.positions.length / 3 * 4)));
                for (const e of o)
                    if (e)
                        if (a)
                            this.normals && !e.normals && (e.normals = new Float32Array(e.positions.length)),
                            this.tangents && !e.tangents && (e.tangents = new Float32Array(e.positions.length / 3 * 4)),
                            this.uvs && !e.uvs && (e.uvs = new Float32Array(e.positions.length / 3 * 2)),
                            this.uvs2 && !e.uvs2 && (e.uvs2 = new Float32Array(e.positions.length / 3 * 2)),
                            this.uvs3 && !e.uvs3 && (e.uvs3 = new Float32Array(e.positions.length / 3 * 2)),
                            this.uvs4 && !e.uvs4 && (e.uvs4 = new Float32Array(e.positions.length / 3 * 2)),
                            this.uvs5 && !e.uvs5 && (e.uvs5 = new Float32Array(e.positions.length / 3 * 2)),
                            this.uvs6 && !e.uvs6 && (e.uvs6 = new Float32Array(e.positions.length / 3 * 2)),
                            this.colors && !e.colors && (e.colors = new Float32Array(e.positions.length / 3 * 4),
                            e.colors.fill(1)),
                            this.matricesIndices && !e.matricesIndices && (e.matricesIndices = new Float32Array(e.positions.length / 3 * 4)),
                            this.matricesWeights && !e.matricesWeights && (e.matricesWeights = new Float32Array(e.positions.length / 3 * 4)),
                            this.matricesIndicesExtra && !e.matricesIndicesExtra && (e.matricesIndicesExtra = new Float32Array(e.positions.length / 3 * 4)),
                            this.matricesWeightsExtra && !e.matricesWeightsExtra && (e.matricesWeightsExtra = new Float32Array(e.positions.length / 3 * 4));
                        else if (e._validate(),
                        !this.normals != !e.normals || !this.tangents != !e.tangents || !this.uvs != !e.uvs || !this.uvs2 != !e.uvs2 || !this.uvs3 != !e.uvs3 || !this.uvs4 != !e.uvs4 || !this.uvs5 != !e.uvs5 || !this.uvs6 != !e.uvs6 || !this.colors != !e.colors || !this.matricesIndices != !e.matricesIndices || !this.matricesWeights != !e.matricesWeights || !this.matricesIndicesExtra != !e.matricesIndicesExtra || !this.matricesWeightsExtra != !e.matricesWeightsExtra)
                            throw new Error("Cannot merge vertex data that do not have the same set of attributes");
                if (n) {
                    let i = 0
                      , s = 0
                      , r = 0;
                    const n = [];
                    let a = null;
                    const l = [];
                    for (const t of this.splitBasedOnMaterialID())
                        l.push({
                            vertexData: t,
                            transform: e
                        });
                    for (const e of t)
                        if (e.vertexData)
                            for (const t of e.vertexData.splitBasedOnMaterialID())
                                l.push({
                                    vertexData: t,
                                    transform: e.transform
                                });
                    l.sort(( (e, t) => {
                        const i = e.vertexData.materialInfos ? e.vertexData.materialInfos[0].materialIndex : 0
                          , s = t.vertexData.materialInfos ? t.vertexData.materialInfos[0].materialIndex : 0;
                        return i > s ? 1 : i === s ? 0 : -1
                    }
                    ));
                    for (const e of l) {
                        const t = e.vertexData;
                        if (i = t.materialInfos ? t.materialInfos[0].materialIndex : 0,
                        a && a.materialIndex === i)
                            a.indexCount += t.indices.length,
                            a.verticesCount += t.positions.length / 3;
                        else {
                            const e = new Qs;
                            e.materialIndex = i,
                            e.indexStart = s,
                            e.indexCount = t.indices.length,
                            e.verticesStart = r,
                            e.verticesCount = t.positions.length / 3,
                            n.push(e),
                            a = e
                        }
                        s += t.indices.length,
                        r += t.positions.length / 3
                    }
                    const c = l.splice(0, 1)[0];
                    h = c.vertexData,
                    e = c.transform,
                    o = l.map((e => e.vertexData)),
                    t = l,
                    this.materialInfos = n
                }
                const l = o.reduce(( (e, t) => e + (t.indices?.length ?? 0)), h.indices?.length ?? 0);
                let c = r || o.some((e => e.indices === h.indices)) ? h.indices?.slice() : h.indices;
                if (l > 0) {
                    let r = c?.length ?? 0;
                    if (c || (c = new Array(l)),
                    c.length !== l) {
                        if (Array.isArray(c))
                            c.length = l;
                        else {
                            const e = i || c instanceof Uint32Array ? new Uint32Array(l) : new Uint16Array(l);
                            e.set(c),
                            c = e
                        }
                        e && e.determinant() < 0 && $s._FlipFaces(c, 0, r)
                    }
                    let n = h.positions ? h.positions.length / 3 : 0;
                    for (const {vertexData: e, transform: i} of t)
                        if (e.indices) {
                            for (let t = 0; t < e.indices.length; t++)
                                c[r + t] = e.indices[t] + n;
                            i && i.determinant() < 0 && $s._FlipFaces(c, r, e.indices.length),
                            n += e.positions.length / 3,
                            r += e.indices.length,
                            s && (yield)
                        }
                }
                return this.indices = c,
                this.positions = $s._MergeElement(os.PositionKind, h.positions, e, t.map((e => [e.vertexData.positions, e.transform]))),
                s && (yield),
                h.normals && (this.normals = $s._MergeElement(os.NormalKind, h.normals, e, t.map((e => [e.vertexData.normals, e.transform]))),
                s && (yield)),
                h.tangents && (this.tangents = $s._MergeElement(os.TangentKind, h.tangents, e, t.map((e => [e.vertexData.tangents, e.transform]))),
                s && (yield)),
                h.uvs && (this.uvs = $s._MergeElement(os.UVKind, h.uvs, e, t.map((e => [e.vertexData.uvs, e.transform]))),
                s && (yield)),
                h.uvs2 && (this.uvs2 = $s._MergeElement(os.UV2Kind, h.uvs2, e, t.map((e => [e.vertexData.uvs2, e.transform]))),
                s && (yield)),
                h.uvs3 && (this.uvs3 = $s._MergeElement(os.UV3Kind, h.uvs3, e, t.map((e => [e.vertexData.uvs3, e.transform]))),
                s && (yield)),
                h.uvs4 && (this.uvs4 = $s._MergeElement(os.UV4Kind, h.uvs4, e, t.map((e => [e.vertexData.uvs4, e.transform]))),
                s && (yield)),
                h.uvs5 && (this.uvs5 = $s._MergeElement(os.UV5Kind, h.uvs5, e, t.map((e => [e.vertexData.uvs5, e.transform]))),
                s && (yield)),
                h.uvs6 && (this.uvs6 = $s._MergeElement(os.UV6Kind, h.uvs6, e, t.map((e => [e.vertexData.uvs6, e.transform]))),
                s && (yield)),
                h.colors && (this.colors = $s._MergeElement(os.ColorKind, h.colors, e, t.map((e => [e.vertexData.colors, e.transform]))),
                (void 0 !== h.hasVertexAlpha || t.some((e => void 0 !== e.vertexData.hasVertexAlpha))) && (this.hasVertexAlpha = h.hasVertexAlpha || t.some((e => e.vertexData.hasVertexAlpha))),
                s && (yield)),
                h.matricesIndices && (this.matricesIndices = $s._MergeElement(os.MatricesIndicesKind, h.matricesIndices, e, t.map((e => [e.vertexData.matricesIndices, e.transform]))),
                s && (yield)),
                h.matricesWeights && (this.matricesWeights = $s._MergeElement(os.MatricesWeightsKind, h.matricesWeights, e, t.map((e => [e.vertexData.matricesWeights, e.transform]))),
                s && (yield)),
                h.matricesIndicesExtra && (this.matricesIndicesExtra = $s._MergeElement(os.MatricesIndicesExtraKind, h.matricesIndicesExtra, e, t.map((e => [e.vertexData.matricesIndicesExtra, e.transform]))),
                s && (yield)),
                h.matricesWeightsExtra && (this.matricesWeightsExtra = $s._MergeElement(os.MatricesWeightsExtraKind, h.matricesWeightsExtra, e, t.map((e => [e.vertexData.matricesWeightsExtra, e.transform])))),
                this
            }
            static _MergeElement(e, t, i, s) {
                const r = s.filter((e => null !== e[0] && void 0 !== e[0]));
                if (!t && 0 == r.length)
                    return t;
                if (!t)
                    return this._MergeElement(e, r[0][0], r[0][1], r.slice(1));
                const n = r.reduce(( (e, t) => e + t[0].length), t.length)
                  , a = e === os.PositionKind ? $s._TransformVector3Coordinates : e === os.NormalKind ? $s._TransformVector3Normals : e === os.TangentKind ? $s._TransformVector4Normals : () => {}
                ;
                if (t instanceof Float32Array) {
                    const e = new Float32Array(n);
                    e.set(t),
                    i && a(e, i, 0, t.length);
                    let s = t.length;
                    for (const [t,i] of r)
                        e.set(t, s),
                        i && a(e, i, s, t.length),
                        s += t.length;
                    return e
                }
                {
                    const e = new Array(n);
                    for (let i = 0; i < t.length; i++)
                        e[i] = t[i];
                    i && a(e, i, 0, t.length);
                    let s = t.length;
                    for (const [t,i] of r) {
                        for (let i = 0; i < t.length; i++)
                            e[s + i] = t[i];
                        i && a(e, i, s, t.length),
                        s += t.length
                    }
                    return e
                }
            }
            _validate() {
                if (!this.positions)
                    throw new Je("Positions are required",0);
                const e = (e, t) => {
                    const i = os.DeduceStride(e);
                    if (t.length % i != 0)
                        throw new Error("The " + e + "s array count must be a multiple of " + i);
                    return t.length / i
                }
                  , t = e(os.PositionKind, this.positions)
                  , i = (i, s) => {
                    const r = e(i, s);
                    if (r !== t)
                        throw new Error("The " + i + "s element count (" + r + ") does not match the positions count (" + t + ")")
                }
                ;
                this.normals && i(os.NormalKind, this.normals),
                this.tangents && i(os.TangentKind, this.tangents),
                this.uvs && i(os.UVKind, this.uvs),
                this.uvs2 && i(os.UV2Kind, this.uvs2),
                this.uvs3 && i(os.UV3Kind, this.uvs3),
                this.uvs4 && i(os.UV4Kind, this.uvs4),
                this.uvs5 && i(os.UV5Kind, this.uvs5),
                this.uvs6 && i(os.UV6Kind, this.uvs6),
                this.colors && i(os.ColorKind, this.colors),
                this.matricesIndices && i(os.MatricesIndicesKind, this.matricesIndices),
                this.matricesWeights && i(os.MatricesWeightsKind, this.matricesWeights),
                this.matricesIndicesExtra && i(os.MatricesIndicesExtraKind, this.matricesIndicesExtra),
                this.matricesWeightsExtra && i(os.MatricesWeightsExtraKind, this.matricesWeightsExtra)
            }
            clone() {
                const e = this.serialize();
                return $s.Parse(e)
            }
            serialize() {
                const e = {};
                if (this.positions && (e.positions = Array.from(this.positions)),
                this.normals && (e.normals = Array.from(this.normals)),
                this.tangents && (e.tangents = Array.from(this.tangents)),
                this.uvs && (e.uvs = Array.from(this.uvs)),
                this.uvs2 && (e.uvs2 = Array.from(this.uvs2)),
                this.uvs3 && (e.uvs3 = Array.from(this.uvs3)),
                this.uvs4 && (e.uvs4 = Array.from(this.uvs4)),
                this.uvs5 && (e.uvs5 = Array.from(this.uvs5)),
                this.uvs6 && (e.uvs6 = Array.from(this.uvs6)),
                this.colors && (e.colors = Array.from(this.colors),
                e.hasVertexAlpha = this.hasVertexAlpha),
                this.matricesIndices && (e.matricesIndices = Array.from(this.matricesIndices),
                e.matricesIndices._isExpanded = !0),
                this.matricesWeights && (e.matricesWeights = Array.from(this.matricesWeights)),
                this.matricesIndicesExtra && (e.matricesIndicesExtra = Array.from(this.matricesIndicesExtra),
                e.matricesIndicesExtra._isExpanded = !0),
                this.matricesWeightsExtra && (e.matricesWeightsExtra = Array.from(this.matricesWeightsExtra)),
                e.indices = Array.from(this.indices),
                this.materialInfos) {
                    e.materialInfos = [];
                    for (const t of this.materialInfos) {
                        const i = {
                            indexStart: t.indexStart,
                            indexCount: t.indexCount,
                            materialIndex: t.materialIndex,
                            verticesStart: t.verticesStart,
                            verticesCount: t.verticesCount
                        };
                        e.materialInfos.push(i)
                    }
                }
                return e
            }
            static ExtractFromMesh(e, t, i) {
                return $s._ExtractFrom(e, t, i)
            }
            static ExtractFromGeometry(e, t, i) {
                return $s._ExtractFrom(e, t, i)
            }
            static _ExtractFrom(e, t, i) {
                const s = new $s;
                return e.isVerticesDataPresent(os.PositionKind) && (s.positions = e.getVerticesData(os.PositionKind, t, i)),
                e.isVerticesDataPresent(os.NormalKind) && (s.normals = e.getVerticesData(os.NormalKind, t, i)),
                e.isVerticesDataPresent(os.TangentKind) && (s.tangents = e.getVerticesData(os.TangentKind, t, i)),
                e.isVerticesDataPresent(os.UVKind) && (s.uvs = e.getVerticesData(os.UVKind, t, i)),
                e.isVerticesDataPresent(os.UV2Kind) && (s.uvs2 = e.getVerticesData(os.UV2Kind, t, i)),
                e.isVerticesDataPresent(os.UV3Kind) && (s.uvs3 = e.getVerticesData(os.UV3Kind, t, i)),
                e.isVerticesDataPresent(os.UV4Kind) && (s.uvs4 = e.getVerticesData(os.UV4Kind, t, i)),
                e.isVerticesDataPresent(os.UV5Kind) && (s.uvs5 = e.getVerticesData(os.UV5Kind, t, i)),
                e.isVerticesDataPresent(os.UV6Kind) && (s.uvs6 = e.getVerticesData(os.UV6Kind, t, i)),
                e.isVerticesDataPresent(os.ColorKind) && (s.colors = e.getVerticesData(os.ColorKind, t, i)),
                e.isVerticesDataPresent(os.MatricesIndicesKind) && (s.matricesIndices = e.getVerticesData(os.MatricesIndicesKind, t, i)),
                e.isVerticesDataPresent(os.MatricesWeightsKind) && (s.matricesWeights = e.getVerticesData(os.MatricesWeightsKind, t, i)),
                e.isVerticesDataPresent(os.MatricesIndicesExtraKind) && (s.matricesIndicesExtra = e.getVerticesData(os.MatricesIndicesExtraKind, t, i)),
                e.isVerticesDataPresent(os.MatricesWeightsExtraKind) && (s.matricesWeightsExtra = e.getVerticesData(os.MatricesWeightsExtraKind, t, i)),
                s.indices = e.getIndices(t, i),
                s
            }
            static CreateRibbon(e) {
                throw je("ribbonBuilder")
            }
            static CreateBox(e) {
                throw je("boxBuilder")
            }
            static CreateTiledBox(e) {
                throw je("tiledBoxBuilder")
            }
            static CreateTiledPlane(e) {
                throw je("tiledPlaneBuilder")
            }
            static CreateSphere(e) {
                throw je("sphereBuilder")
            }
            static CreateCylinder(e) {
                throw je("cylinderBuilder")
            }
            static CreateTorus(e) {
                throw je("torusBuilder")
            }
            static CreateLineSystem(e) {
                throw je("linesBuilder")
            }
            static CreateDashedLines(e) {
                throw je("linesBuilder")
            }
            static CreateGround(e) {
                throw je("groundBuilder")
            }
            static CreateTiledGround(e) {
                throw je("groundBuilder")
            }
            static CreateGroundFromHeightMap(e) {
                throw je("groundBuilder")
            }
            static CreatePlane(e) {
                throw je("planeBuilder")
            }
            static CreateDisc(e) {
                throw je("discBuilder")
            }
            static CreatePolygon(e, t, i, s, r, n, a) {
                throw je("polygonBuilder")
            }
            static CreateIcoSphere(e) {
                throw je("icoSphereBuilder")
            }
            static CreatePolyhedron(e) {
                throw je("polyhedronBuilder")
            }
            static CreateCapsule(e={
                orientation: Di.Up(),
                subdivisions: 2,
                tessellation: 16,
                height: 1,
                radius: .25,
                capSubdivisions: 6
            }) {
                throw je("capsuleBuilder")
            }
            static CreateTorusKnot(e) {
                throw je("torusKnotBuilder")
            }
            static ComputeNormals(e, t, i, s) {
                let r = 0
                  , n = 0
                  , a = 0
                  , o = 0
                  , h = 0
                  , l = 0
                  , c = 0
                  , u = 0
                  , d = 0
                  , f = 0
                  , _ = 0
                  , p = 0
                  , m = 0
                  , g = 0
                  , v = 0
                  , y = 0
                  , b = 0
                  , x = 0
                  , T = 0
                  , E = 0
                  , M = !1
                  , S = !1
                  , A = !1
                  , I = !1
                  , R = 1
                  , C = 0
                  , P = null;
                s && (M = !!s.facetNormals,
                S = !!s.facetPositions,
                A = !!s.facetPartitioning,
                R = !0 === s.useRightHandedSystem ? -1 : 1,
                C = s.ratio || 0,
                I = !!s.depthSort,
                P = s.distanceTo,
                I && void 0 === P && (P = Di.Zero()));
                let D = 0
                  , w = 0
                  , F = 0
                  , O = 0;
                for (A && s && s.bbSize && (D = s.subDiv.X * C / s.bbSize.x,
                w = s.subDiv.Y * C / s.bbSize.y,
                F = s.subDiv.Z * C / s.bbSize.z,
                O = s.subDiv.max * s.subDiv.max,
                s.facetPartitioning.length = 0),
                r = 0; r < e.length; r++)
                    i[r] = 0;
                const L = t.length / 3 | 0;
                for (r = 0; r < L; r++) {
                    if (p = 3 * t[3 * r],
                    m = p + 1,
                    g = p + 2,
                    v = 3 * t[3 * r + 1],
                    y = v + 1,
                    b = v + 2,
                    x = 3 * t[3 * r + 2],
                    T = x + 1,
                    E = x + 2,
                    n = e[p] - e[v],
                    a = e[m] - e[y],
                    o = e[g] - e[b],
                    h = e[x] - e[v],
                    l = e[T] - e[y],
                    c = e[E] - e[b],
                    u = R * (a * c - o * l),
                    d = R * (o * h - n * c),
                    f = R * (n * l - a * h),
                    _ = Math.sqrt(u * u + d * d + f * f),
                    _ = 0 === _ ? 1 : _,
                    u /= _,
                    d /= _,
                    f /= _,
                    M && s && (s.facetNormals[r].x = u,
                    s.facetNormals[r].y = d,
                    s.facetNormals[r].z = f),
                    S && s && (s.facetPositions[r].x = (e[p] + e[v] + e[x]) / 3,
                    s.facetPositions[r].y = (e[m] + e[y] + e[T]) / 3,
                    s.facetPositions[r].z = (e[g] + e[b] + e[E]) / 3),
                    A && s) {
                        const t = Math.floor((s.facetPositions[r].x - s.bInfo.minimum.x * C) * D)
                          , i = Math.floor((s.facetPositions[r].y - s.bInfo.minimum.y * C) * w)
                          , n = Math.floor((s.facetPositions[r].z - s.bInfo.minimum.z * C) * F)
                          , a = Math.floor((e[p] - s.bInfo.minimum.x * C) * D)
                          , o = Math.floor((e[m] - s.bInfo.minimum.y * C) * w)
                          , h = Math.floor((e[g] - s.bInfo.minimum.z * C) * F)
                          , l = Math.floor((e[v] - s.bInfo.minimum.x * C) * D)
                          , c = Math.floor((e[y] - s.bInfo.minimum.y * C) * w)
                          , u = Math.floor((e[b] - s.bInfo.minimum.z * C) * F)
                          , d = Math.floor((e[x] - s.bInfo.minimum.x * C) * D)
                          , f = Math.floor((e[T] - s.bInfo.minimum.y * C) * w)
                          , _ = Math.floor((e[E] - s.bInfo.minimum.z * C) * F)
                          , M = a + s.subDiv.max * o + O * h
                          , S = l + s.subDiv.max * c + O * u
                          , A = d + s.subDiv.max * f + O * _
                          , I = t + s.subDiv.max * i + O * n;
                        s.facetPartitioning[I] = s.facetPartitioning[I] ? s.facetPartitioning[I] : new Array,
                        s.facetPartitioning[M] = s.facetPartitioning[M] ? s.facetPartitioning[M] : new Array,
                        s.facetPartitioning[S] = s.facetPartitioning[S] ? s.facetPartitioning[S] : new Array,
                        s.facetPartitioning[A] = s.facetPartitioning[A] ? s.facetPartitioning[A] : new Array,
                        s.facetPartitioning[M].push(r),
                        S != M && s.facetPartitioning[S].push(r),
                        A != S && A != M && s.facetPartitioning[A].push(r),
                        I != M && I != S && I != A && s.facetPartitioning[I].push(r)
                    }
                    if (I && s && s.facetPositions) {
                        const e = s.depthSortedFacets[r];
                        e.ind = 3 * r,
                        e.sqDistance = Di.DistanceSquared(s.facetPositions[r], P)
                    }
                    i[p] += u,
                    i[m] += d,
                    i[g] += f,
                    i[v] += u,
                    i[y] += d,
                    i[b] += f,
                    i[x] += u,
                    i[T] += d,
                    i[E] += f
                }
                for (r = 0; r < i.length / 3; r++)
                    u = i[3 * r],
                    d = i[3 * r + 1],
                    f = i[3 * r + 2],
                    _ = Math.sqrt(u * u + d * d + f * f),
                    _ = 0 === _ ? 1 : _,
                    u /= _,
                    d /= _,
                    f /= _,
                    i[3 * r] = u,
                    i[3 * r + 1] = d,
                    i[3 * r + 2] = f
            }
            static _ComputeSides(e, t, i, s, r, n, a) {
                const o = i.length
                  , h = s.length;
                let l, c;
                switch (e = e || $s.DEFAULTSIDE) {
                case $s.FRONTSIDE:
                    break;
                case $s.BACKSIDE:
                    for (l = 0; l < o; l += 3) {
                        const e = i[l];
                        i[l] = i[l + 2],
                        i[l + 2] = e
                    }
                    for (c = 0; c < h; c++)
                        s[c] = -s[c];
                    break;
                case $s.DOUBLESIDE:
                    {
                        const e = t.length
                          , u = e / 3;
                        for (let i = 0; i < e; i++)
                            t[e + i] = t[i];
                        for (l = 0; l < o; l += 3)
                            i[l + o] = i[l + 2] + u,
                            i[l + 1 + o] = i[l + 1] + u,
                            i[l + 2 + o] = i[l] + u;
                        for (c = 0; c < h; c++)
                            s[h + c] = -s[c];
                        const d = r.length;
                        let f = 0;
                        for (f = 0; f < d; f++)
                            r[f + d] = r[f];
                        for (n = n || new wi(0,0,1,1),
                        a = a || new wi(0,0,1,1),
                        f = 0,
                        l = 0; l < d / 2; l++)
                            r[f] = n.x + (n.z - n.x) * r[f],
                            r[f + 1] = n.y + (n.w - n.y) * r[f + 1],
                            r[f + d] = a.x + (a.z - a.x) * r[f + d],
                            r[f + d + 1] = a.y + (a.w - a.y) * r[f + d + 1],
                            f += 2;
                        break
                    }
                }
            }
            static Parse(e) {
                const t = new $s
                  , i = e.positions;
                i && t.set(i, os.PositionKind);
                const s = e.normals;
                s && t.set(s, os.NormalKind);
                const r = e.tangents;
                r && t.set(r, os.TangentKind);
                const n = e.uvs;
                n && t.set(n, os.UVKind);
                const a = e.uvs2;
                a && t.set(a, os.UV2Kind);
                const o = e.uvs3;
                o && t.set(o, os.UV3Kind);
                const h = e.uvs4;
                h && t.set(h, os.UV4Kind);
                const l = e.uvs5;
                l && t.set(l, os.UV5Kind);
                const c = e.uvs6;
                c && t.set(c, os.UV6Kind);
                const u = e.colors;
                u && (t.set(Oe.CheckColors4(u, i.length / 3), os.ColorKind),
                void 0 !== e.hasVertexAlpha && (t.hasVertexAlpha = e.hasVertexAlpha));
                const d = e.matricesIndices;
                d && t.set(d, os.MatricesIndicesKind);
                const f = e.matricesWeights;
                f && t.set(f, os.MatricesWeightsKind);
                const _ = e.indices;
                _ && (t.indices = _);
                const p = e.materialInfos;
                if (p) {
                    t.materialInfos = [];
                    for (const e of p) {
                        const i = new Qs;
                        i.indexCount = e.indexCount,
                        i.indexStart = e.indexStart,
                        i.verticesCount = e.verticesCount,
                        i.verticesStart = e.verticesStart,
                        i.materialIndex = e.materialIndex,
                        t.materialInfos.push(i)
                    }
                }
                return t
            }
            static ImportVertexData(e, t) {
                const i = $s.Parse(e);
                t.setAllVerticesData(i, e.updatable)
            }
        }
        $s.FRONTSIDE = 0,
        $s.BACKSIDE = 1,
        $s.DOUBLESIDE = 2,
        $s.DEFAULTSIDE = 0,
        $s._UniqueIDGenerator = 0,
        pi([Ai.filter(( (...[e]) => !Array.isArray(e)))], $s, "_TransformVector3Coordinates", null),
        pi([Ai.filter(( (...[e]) => !Array.isArray(e)))], $s, "_TransformVector3Normals", null),
        pi([Ai.filter(( (...[e]) => !Array.isArray(e)))], $s, "_TransformVector4Normals", null),
        pi([Ai.filter(( (...[e]) => !Array.isArray(e)))], $s, "_FlipFaces", null);
        class Js {
            static get ForceFullSceneLoadingForIncremental() {
                return Js._ForceFullSceneLoadingForIncremental
            }
            static set ForceFullSceneLoadingForIncremental(e) {
                Js._ForceFullSceneLoadingForIncremental = e
            }
            static get ShowLoadingScreen() {
                return Js._ShowLoadingScreen
            }
            static set ShowLoadingScreen(e) {
                Js._ShowLoadingScreen = e
            }
            static get loggingLevel() {
                return Js._LoggingLevel
            }
            static set loggingLevel(e) {
                Js._LoggingLevel = e
            }
            static get CleanBoneMatrixWeights() {
                return Js._CleanBoneMatrixWeights
            }
            static set CleanBoneMatrixWeights(e) {
                Js._CleanBoneMatrixWeights = e
            }
        }
        Js._ForceFullSceneLoadingForIncremental = !1,
        Js._ShowLoadingScreen = !0,
        Js._CleanBoneMatrixWeights = !1,
        Js._LoggingLevel = 0;
        class er {
        }
        er.UseOpenGLOrientationForUV = !1;
        class tr {
            get boundingBias() {
                return this._boundingBias
            }
            set boundingBias(e) {
                this._boundingBias ? this._boundingBias.copyFrom(e) : this._boundingBias = e.clone(),
                this._updateBoundingInfo(!0, null)
            }
            static CreateGeometryForMesh(e) {
                const t = new tr(tr.RandomId(),e.getScene());
                return t.applyToMesh(e),
                t
            }
            get meshes() {
                return this._meshes
            }
            constructor(e, t, i, s=!1, r=null) {
                this.delayLoadState = 0,
                this._totalVertices = 0,
                this._isDisposed = !1,
                this._indexBufferIsUpdatable = !1,
                this._positionsCache = [],
                this._parentContainer = null,
                this.useBoundingInfoFromGeometry = !1,
                this._scene = t || Ze.LastCreatedScene,
                this._scene && (this.id = e,
                this.uniqueId = this._scene.getUniqueId(),
                this._engine = this._scene.getEngine(),
                this._meshes = [],
                this._vertexBuffers = {},
                this._indices = [],
                this._updatable = s,
                i ? this.setAllVerticesData(i, s) : this._totalVertices = 0,
                this._engine.getCaps().vertexArrayObject && (this._vertexArrayObjects = {}),
                r && (this.applyToMesh(r),
                r.computeWorldMatrix(!0)))
            }
            get extend() {
                return this._extend
            }
            getScene() {
                return this._scene
            }
            getEngine() {
                return this._engine
            }
            isReady() {
                return 1 === this.delayLoadState || 0 === this.delayLoadState
            }
            get doNotSerialize() {
                for (let e = 0; e < this._meshes.length; e++)
                    if (!this._meshes[e].doNotSerialize)
                        return !1;
                return !0
            }
            _rebuild() {
                this._vertexArrayObjects && (this._vertexArrayObjects = {}),
                0 !== this._meshes.length && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable, "Geometry_" + this.id + "_IndexBuffer"));
                const e = new Set;
                for (const t in this._vertexBuffers)
                    e.add(this._vertexBuffers[t].getWrapperBuffer());
                e.forEach((e => {
                    e._rebuild()
                }
                ))
            }
            setAllVerticesData(e, t) {
                e.applyToGeometry(this, t),
                this._notifyUpdate()
            }
            setVerticesData(e, t, i=!1, s) {
                i && Array.isArray(t) && (t = new Float32Array(t));
                const r = new os(this._engine,t,e,{
                    updatable: i,
                    postponeInternalCreation: 0 === this._meshes.length,
                    stride: s,
                    label: "Geometry_" + this.id + "_" + e
                });
                this.setVerticesBuffer(r)
            }
            removeVerticesData(e) {
                this._vertexBuffers[e] && (this._vertexBuffers[e].dispose(),
                delete this._vertexBuffers[e]),
                this._vertexArrayObjects && this._disposeVertexArrayObjects()
            }
            setVerticesBuffer(e, t=null, i=!0) {
                const s = e.getKind();
                this._vertexBuffers[s] && i && this._vertexBuffers[s].dispose(),
                e._buffer && e._buffer._increaseReferences(),
                this._vertexBuffers[s] = e;
                const r = this._meshes
                  , n = r.length;
                if (s === os.PositionKind) {
                    this._totalVertices = t ?? e._maxVerticesCount,
                    this._updateExtend(e.getFloatData(this._totalVertices)),
                    this._resetPointsArrayCache();
                    const i = this._extend && this._extend.minimum || new Di(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)
                      , s = this._extend && this._extend.maximum || new Di(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE);
                    for (let e = 0; e < n; e++) {
                        const t = r[e];
                        t.buildBoundingInfo(i, s),
                        t._createGlobalSubMesh(t.isUnIndexed),
                        t.computeWorldMatrix(!0),
                        t.synchronizeInstances()
                    }
                }
                this._notifyUpdate(s)
            }
            updateVerticesDataDirectly(e, t, i, s=!1) {
                const r = this.getVertexBuffer(e);
                r && (r.updateDirectly(t, i, s),
                this._notifyUpdate(e))
            }
            updateVerticesData(e, t, i=!1) {
                const s = this.getVertexBuffer(e);
                s && (s.update(t),
                e === os.PositionKind && this._updateBoundingInfo(i, t),
                this._notifyUpdate(e))
            }
            _updateBoundingInfo(e, t) {
                if (e && this._updateExtend(t),
                this._resetPointsArrayCache(),
                e) {
                    const e = this._meshes;
                    for (const t of e) {
                        t.hasBoundingInfo ? t.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum) : t.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
                        const e = t.subMeshes;
                        for (const t of e)
                            t.refreshBoundingInfo()
                    }
                }
            }
            _bind(e, t, i, s) {
                if (!e)
                    return;
                void 0 === t && (t = this._indexBuffer);
                const r = this.getVertexBuffers();
                if (!r)
                    return;
                if (t != this._indexBuffer || !this._vertexArrayObjects && !s)
                    return void this._engine.bindBuffers(r, t, e, i);
                const n = s || this._vertexArrayObjects;
                n[e.key] || (n[e.key] = this._engine.recordVertexArrayObject(r, t, e, i)),
                this._engine.bindVertexArrayObject(n[e.key], t)
            }
            getTotalVertices() {
                return this.isReady() ? this._totalVertices : 0
            }
            getVerticesData(e, t, i) {
                const s = this.getVertexBuffer(e);
                return s ? s.getFloatData(this._totalVertices, i || t && 1 !== this._meshes.length) : null
            }
            isVertexBufferUpdatable(e) {
                const t = this._vertexBuffers[e];
                return !!t && t.isUpdatable()
            }
            getVertexBuffer(e) {
                return this.isReady() ? this._vertexBuffers[e] : null
            }
            getVertexBuffers() {
                return this.isReady() ? this._vertexBuffers : null
            }
            isVerticesDataPresent(e) {
                return this._vertexBuffers ? void 0 !== this._vertexBuffers[e] : !!this._delayInfo && -1 !== this._delayInfo.indexOf(e)
            }
            getVerticesDataKinds() {
                const e = [];
                let t;
                if (!this._vertexBuffers && this._delayInfo)
                    for (t in this._delayInfo)
                        e.push(t);
                else
                    for (t in this._vertexBuffers)
                        e.push(t);
                return e
            }
            updateIndices(e, t, i=!1) {
                if (this._indexBuffer)
                    if (this._indexBufferIsUpdatable) {
                        const s = e.length !== this._indices.length;
                        if (i || (this._indices = e.slice()),
                        this._engine.updateDynamicIndexBuffer(this._indexBuffer, e, t),
                        s)
                            for (const e of this._meshes)
                                e._createGlobalSubMesh(!0)
                    } else
                        this.setIndices(e, null, !0)
            }
            setIndexBuffer(e, t, i) {
                this._indices = [],
                this._indexBufferIsUpdatable = !1,
                this._indexBuffer = e,
                this._totalVertices = t,
                this._totalIndices = i,
                e.is32Bits || (e.is32Bits = this._totalIndices > 65535);
                for (const e of this._meshes)
                    e._createGlobalSubMesh(!0),
                    e.synchronizeInstances();
                this._notifyUpdate()
            }
            setIndices(e, t=null, i=!1) {
                this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer),
                this._indices = e,
                this._indexBufferIsUpdatable = i,
                0 !== this._meshes.length && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, i, "Geometry_" + this.id + "_IndexBuffer")),
                null != t && (this._totalVertices = t);
                for (const e of this._meshes)
                    e._createGlobalSubMesh(!0),
                    e.synchronizeInstances();
                this._notifyUpdate()
            }
            getTotalIndices() {
                return this.isReady() ? void 0 !== this._totalIndices ? this._totalIndices : this._indices.length : 0
            }
            getIndices(e, t) {
                if (!this.isReady())
                    return null;
                const i = this._indices;
                return t || e && 1 !== this._meshes.length ? i.slice() : i
            }
            getIndexBuffer() {
                return this.isReady() ? this._indexBuffer : null
            }
            _releaseVertexArrayObject(e=null) {
                e && this._vertexArrayObjects && this._vertexArrayObjects[e.key] && (this._engine.releaseVertexArrayObject(this._vertexArrayObjects[e.key]),
                delete this._vertexArrayObjects[e.key])
            }
            releaseForMesh(e, t) {
                const i = this._meshes
                  , s = i.indexOf(e);
                -1 !== s && (i.splice(s, 1),
                this._vertexArrayObjects && e._invalidateInstanceVertexArrayObject(),
                e._geometry = null,
                0 === i.length && t && this.dispose())
            }
            applyToMesh(e) {
                if (e._geometry === this)
                    return;
                const t = e._geometry;
                t && t.releaseForMesh(e),
                this._vertexArrayObjects && e._invalidateInstanceVertexArrayObject();
                const i = this._meshes;
                e._geometry = this,
                e._internalAbstractMeshDataInfo._positions = null,
                this._scene.pushGeometry(this),
                i.push(e),
                this.isReady() ? this._applyToMesh(e) : this._boundingInfo && e.setBoundingInfo(this._boundingInfo)
            }
            _updateExtend(e=null) {
                if (this.useBoundingInfoFromGeometry && this._boundingInfo)
                    this._extend = {
                        minimum: this._boundingInfo.minimum.clone(),
                        maximum: this._boundingInfo.maximum.clone()
                    };
                else {
                    if (!e && !(e = this.getVerticesData(os.PositionKind)))
                        return;
                    this._extend = qs(e, 0, this._totalVertices, this.boundingBias, 3)
                }
            }
            _applyToMesh(e) {
                const t = this._meshes.length;
                for (const i in this._vertexBuffers)
                    1 === t && this._vertexBuffers[i].create(),
                    i === os.PositionKind && (this._extend || this._updateExtend(),
                    e.buildBoundingInfo(this._extend.minimum, this._extend.maximum),
                    e._createGlobalSubMesh(e.isUnIndexed),
                    e._updateBoundingInfo());
                1 === t && this._indices && this._indices.length > 0 && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable, "Geometry_" + this.id + "_IndexBuffer")),
                e._syncGeometryWithMorphTargetManager(),
                e.synchronizeInstances()
            }
            _notifyUpdate(e) {
                this.onGeometryUpdated && this.onGeometryUpdated(this, e),
                this._vertexArrayObjects && this._disposeVertexArrayObjects();
                for (const e of this._meshes)
                    e._markSubMeshesAsAttributesDirty()
            }
            load(e, t) {
                2 !== this.delayLoadState && (this.isReady() ? t && t() : (this.delayLoadState = 2,
                this._queueLoad(e, t)))
            }
            _queueLoad(e, t) {
                this.delayLoadingFile && (e.addPendingData(this),
                e._loadFile(this.delayLoadingFile, (i => {
                    if (!this._delayLoadingFunction)
                        return;
                    this._delayLoadingFunction(JSON.parse(i), this),
                    this.delayLoadState = 1,
                    this._delayInfo = [],
                    e.removePendingData(this);
                    const s = this._meshes
                      , r = s.length;
                    for (let e = 0; e < r; e++)
                        this._applyToMesh(s[e]);
                    t && t()
                }
                ), void 0, !0))
            }
            toLeftHanded() {
                const e = this.getIndices(!1);
                if (null != e && e.length > 0) {
                    for (let t = 0; t < e.length; t += 3) {
                        const i = e[t + 0];
                        e[t + 0] = e[t + 2],
                        e[t + 2] = i
                    }
                    this.setIndices(e)
                }
                const t = this.getVerticesData(os.PositionKind, !1);
                if (null != t && t.length > 0) {
                    for (let e = 0; e < t.length; e += 3)
                        t[e + 2] = -t[e + 2];
                    this.setVerticesData(os.PositionKind, t, !1)
                }
                const i = this.getVerticesData(os.NormalKind, !1);
                if (null != i && i.length > 0) {
                    for (let e = 0; e < i.length; e += 3)
                        i[e + 2] = -i[e + 2];
                    this.setVerticesData(os.NormalKind, i, !1)
                }
            }
            _resetPointsArrayCache() {
                this._positions = null
            }
            _generatePointsArray() {
                if (this._positions)
                    return !0;
                const e = this.getVerticesData(os.PositionKind);
                if (!e || 0 === e.length)
                    return !1;
                for (let t = 3 * this._positionsCache.length, i = this._positionsCache.length; t < e.length; t += 3,
                ++i)
                    this._positionsCache[i] = Di.FromArray(e, t);
                for (let t = 0, i = 0; t < e.length; t += 3,
                ++i)
                    this._positionsCache[i].set(e[0 + t], e[1 + t], e[2 + t]);
                return this._positionsCache.length = e.length / 3,
                this._positions = this._positionsCache,
                !0
            }
            isDisposed() {
                return this._isDisposed
            }
            _disposeVertexArrayObjects() {
                if (this._vertexArrayObjects) {
                    for (const e in this._vertexArrayObjects)
                        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[e]);
                    this._vertexArrayObjects = {};
                    const e = this._meshes
                      , t = e.length;
                    for (let i = 0; i < t; i++)
                        e[i]._invalidateInstanceVertexArrayObject()
                }
            }
            dispose() {
                const e = this._meshes
                  , t = e.length;
                let i;
                for (i = 0; i < t; i++)
                    this.releaseForMesh(e[i]);
                this._meshes.length = 0,
                this._disposeVertexArrayObjects();
                for (const e in this._vertexBuffers)
                    this._vertexBuffers[e].dispose();
                if (this._vertexBuffers = {},
                this._totalVertices = 0,
                this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer),
                this._indexBuffer = null,
                this._indices = [],
                this.delayLoadState = 0,
                this.delayLoadingFile = null,
                this._delayLoadingFunction = null,
                this._delayInfo = [],
                this._boundingInfo = null,
                this._scene.removeGeometry(this),
                this._parentContainer) {
                    const e = this._parentContainer.geometries.indexOf(this);
                    e > -1 && this._parentContainer.geometries.splice(e, 1),
                    this._parentContainer = null
                }
                this._isDisposed = !0
            }
            copy(e) {
                const t = new $s;
                t.indices = [];
                const i = this.getIndices();
                if (i)
                    for (let e = 0; e < i.length; e++)
                        t.indices.push(i[e]);
                let s, r = !1, n = !1;
                for (s in this._vertexBuffers) {
                    const e = this.getVerticesData(s);
                    if (e && (e instanceof Float32Array ? t.set(new Float32Array(e), s) : t.set(e.slice(0), s),
                    !n)) {
                        const e = this.getVertexBuffer(s);
                        e && (r = e.isUpdatable(),
                        n = !r)
                    }
                }
                const a = new tr(e,this._scene,t,r);
                for (s in a.delayLoadState = this.delayLoadState,
                a.delayLoadingFile = this.delayLoadingFile,
                a._delayLoadingFunction = this._delayLoadingFunction,
                this._delayInfo)
                    a._delayInfo = a._delayInfo || [],
                    a._delayInfo.push(s);
                return a._boundingInfo = new Ys(this._extend.minimum,this._extend.maximum),
                a
            }
            serialize() {
                const e = {};
                return e.id = this.id,
                e.uniqueId = this.uniqueId,
                e.updatable = this._updatable,
                ui && ui.HasTags(this) && (e.tags = ui.GetTags(this)),
                e
            }
            _toNumberArray(e) {
                return Array.isArray(e) ? e : Array.prototype.slice.call(e)
            }
            clearCachedData() {
                this._indices = [],
                this._resetPointsArrayCache();
                for (const e in this._vertexBuffers)
                    Object.prototype.hasOwnProperty.call(this._vertexBuffers, e) && (this._vertexBuffers[e]._buffer._data = null)
            }
            serializeVerticeData() {
                const e = this.serialize();
                return this.isVerticesDataPresent(os.PositionKind) && (e.positions = this._toNumberArray(this.getVerticesData(os.PositionKind)),
                this.isVertexBufferUpdatable(os.PositionKind) && (e.positions._updatable = !0)),
                this.isVerticesDataPresent(os.NormalKind) && (e.normals = this._toNumberArray(this.getVerticesData(os.NormalKind)),
                this.isVertexBufferUpdatable(os.NormalKind) && (e.normals._updatable = !0)),
                this.isVerticesDataPresent(os.TangentKind) && (e.tangents = this._toNumberArray(this.getVerticesData(os.TangentKind)),
                this.isVertexBufferUpdatable(os.TangentKind) && (e.tangents._updatable = !0)),
                this.isVerticesDataPresent(os.UVKind) && (e.uvs = this._toNumberArray(this.getVerticesData(os.UVKind)),
                this.isVertexBufferUpdatable(os.UVKind) && (e.uvs._updatable = !0)),
                this.isVerticesDataPresent(os.UV2Kind) && (e.uvs2 = this._toNumberArray(this.getVerticesData(os.UV2Kind)),
                this.isVertexBufferUpdatable(os.UV2Kind) && (e.uvs2._updatable = !0)),
                this.isVerticesDataPresent(os.UV3Kind) && (e.uvs3 = this._toNumberArray(this.getVerticesData(os.UV3Kind)),
                this.isVertexBufferUpdatable(os.UV3Kind) && (e.uvs3._updatable = !0)),
                this.isVerticesDataPresent(os.UV4Kind) && (e.uvs4 = this._toNumberArray(this.getVerticesData(os.UV4Kind)),
                this.isVertexBufferUpdatable(os.UV4Kind) && (e.uvs4._updatable = !0)),
                this.isVerticesDataPresent(os.UV5Kind) && (e.uvs5 = this._toNumberArray(this.getVerticesData(os.UV5Kind)),
                this.isVertexBufferUpdatable(os.UV5Kind) && (e.uvs5._updatable = !0)),
                this.isVerticesDataPresent(os.UV6Kind) && (e.uvs6 = this._toNumberArray(this.getVerticesData(os.UV6Kind)),
                this.isVertexBufferUpdatable(os.UV6Kind) && (e.uvs6._updatable = !0)),
                this.isVerticesDataPresent(os.ColorKind) && (e.colors = this._toNumberArray(this.getVerticesData(os.ColorKind)),
                this.isVertexBufferUpdatable(os.ColorKind) && (e.colors._updatable = !0)),
                this.isVerticesDataPresent(os.MatricesIndicesKind) && (e.matricesIndices = this._toNumberArray(this.getVerticesData(os.MatricesIndicesKind)),
                e.matricesIndices._isExpanded = !0,
                this.isVertexBufferUpdatable(os.MatricesIndicesKind) && (e.matricesIndices._updatable = !0)),
                this.isVerticesDataPresent(os.MatricesWeightsKind) && (e.matricesWeights = this._toNumberArray(this.getVerticesData(os.MatricesWeightsKind)),
                this.isVertexBufferUpdatable(os.MatricesWeightsKind) && (e.matricesWeights._updatable = !0)),
                e.indices = this._toNumberArray(this.getIndices()),
                e
            }
            static ExtractFromMesh(e, t) {
                const i = e._geometry;
                return i ? i.copy(t) : null
            }
            static RandomId() {
                return hi.RandomId()
            }
            static _GetGeometryByLoadedUniqueId(e, t) {
                for (let i = 0; i < t.geometries.length; i++)
                    if (t.geometries[i]._loadedUniqueId === e)
                        return t.geometries[i];
                return null
            }
            static _ImportGeometry(e, t) {
                const i = t.getScene()
                  , s = e.geometryUniqueId
                  , r = e.geometryId;
                if (s || r) {
                    const e = s ? this._GetGeometryByLoadedUniqueId(s, i) : i.getGeometryById(r);
                    e && e.applyToMesh(t)
                } else if (e instanceof ArrayBuffer) {
                    const i = t._binaryInfo;
                    if (i.positionsAttrDesc && i.positionsAttrDesc.count > 0) {
                        const s = new Float32Array(e,i.positionsAttrDesc.offset,i.positionsAttrDesc.count);
                        t.setVerticesData(os.PositionKind, s, !1)
                    }
                    if (i.normalsAttrDesc && i.normalsAttrDesc.count > 0) {
                        const s = new Float32Array(e,i.normalsAttrDesc.offset,i.normalsAttrDesc.count);
                        t.setVerticesData(os.NormalKind, s, !1)
                    }
                    if (i.tangetsAttrDesc && i.tangetsAttrDesc.count > 0) {
                        const s = new Float32Array(e,i.tangetsAttrDesc.offset,i.tangetsAttrDesc.count);
                        t.setVerticesData(os.TangentKind, s, !1)
                    }
                    if (i.uvsAttrDesc && i.uvsAttrDesc.count > 0) {
                        const s = new Float32Array(e,i.uvsAttrDesc.offset,i.uvsAttrDesc.count);
                        if (er.UseOpenGLOrientationForUV)
                            for (let e = 1; e < s.length; e += 2)
                                s[e] = 1 - s[e];
                        t.setVerticesData(os.UVKind, s, !1)
                    }
                    if (i.uvs2AttrDesc && i.uvs2AttrDesc.count > 0) {
                        const s = new Float32Array(e,i.uvs2AttrDesc.offset,i.uvs2AttrDesc.count);
                        if (er.UseOpenGLOrientationForUV)
                            for (let e = 1; e < s.length; e += 2)
                                s[e] = 1 - s[e];
                        t.setVerticesData(os.UV2Kind, s, !1)
                    }
                    if (i.uvs3AttrDesc && i.uvs3AttrDesc.count > 0) {
                        const s = new Float32Array(e,i.uvs3AttrDesc.offset,i.uvs3AttrDesc.count);
                        if (er.UseOpenGLOrientationForUV)
                            for (let e = 1; e < s.length; e += 2)
                                s[e] = 1 - s[e];
                        t.setVerticesData(os.UV3Kind, s, !1)
                    }
                    if (i.uvs4AttrDesc && i.uvs4AttrDesc.count > 0) {
                        const s = new Float32Array(e,i.uvs4AttrDesc.offset,i.uvs4AttrDesc.count);
                        if (er.UseOpenGLOrientationForUV)
                            for (let e = 1; e < s.length; e += 2)
                                s[e] = 1 - s[e];
                        t.setVerticesData(os.UV4Kind, s, !1)
                    }
                    if (i.uvs5AttrDesc && i.uvs5AttrDesc.count > 0) {
                        const s = new Float32Array(e,i.uvs5AttrDesc.offset,i.uvs5AttrDesc.count);
                        if (er.UseOpenGLOrientationForUV)
                            for (let e = 1; e < s.length; e += 2)
                                s[e] = 1 - s[e];
                        t.setVerticesData(os.UV5Kind, s, !1)
                    }
                    if (i.uvs6AttrDesc && i.uvs6AttrDesc.count > 0) {
                        const s = new Float32Array(e,i.uvs6AttrDesc.offset,i.uvs6AttrDesc.count);
                        if (er.UseOpenGLOrientationForUV)
                            for (let e = 1; e < s.length; e += 2)
                                s[e] = 1 - s[e];
                        t.setVerticesData(os.UV6Kind, s, !1)
                    }
                    if (i.colorsAttrDesc && i.colorsAttrDesc.count > 0) {
                        const s = new Float32Array(e,i.colorsAttrDesc.offset,i.colorsAttrDesc.count);
                        t.setVerticesData(os.ColorKind, s, !1, i.colorsAttrDesc.stride)
                    }
                    if (i.matricesIndicesAttrDesc && i.matricesIndicesAttrDesc.count > 0) {
                        const s = new Int32Array(e,i.matricesIndicesAttrDesc.offset,i.matricesIndicesAttrDesc.count)
                          , r = [];
                        for (let e = 0; e < s.length; e++) {
                            const t = s[e];
                            r.push(255 & t),
                            r.push((65280 & t) >> 8),
                            r.push((16711680 & t) >> 16),
                            r.push(t >> 24 & 255)
                        }
                        t.setVerticesData(os.MatricesIndicesKind, r, !1)
                    }
                    if (i.matricesIndicesExtraAttrDesc && i.matricesIndicesExtraAttrDesc.count > 0) {
                        const s = new Int32Array(e,i.matricesIndicesExtraAttrDesc.offset,i.matricesIndicesExtraAttrDesc.count)
                          , r = [];
                        for (let e = 0; e < s.length; e++) {
                            const t = s[e];
                            r.push(255 & t),
                            r.push((65280 & t) >> 8),
                            r.push((16711680 & t) >> 16),
                            r.push(t >> 24 & 255)
                        }
                        t.setVerticesData(os.MatricesIndicesExtraKind, r, !1)
                    }
                    if (i.matricesWeightsAttrDesc && i.matricesWeightsAttrDesc.count > 0) {
                        const s = new Float32Array(e,i.matricesWeightsAttrDesc.offset,i.matricesWeightsAttrDesc.count);
                        t.setVerticesData(os.MatricesWeightsKind, s, !1)
                    }
                    if (i.indicesAttrDesc && i.indicesAttrDesc.count > 0) {
                        const s = new Int32Array(e,i.indicesAttrDesc.offset,i.indicesAttrDesc.count);
                        t.setIndices(s, null)
                    }
                    if (i.subMeshesAttrDesc && i.subMeshesAttrDesc.count > 0) {
                        const s = new Int32Array(e,i.subMeshesAttrDesc.offset,5 * i.subMeshesAttrDesc.count);
                        t.subMeshes = [];
                        for (let e = 0; e < i.subMeshesAttrDesc.count; e++) {
                            const i = s[5 * e + 0]
                              , r = s[5 * e + 1]
                              , n = s[5 * e + 2]
                              , a = s[5 * e + 3]
                              , o = s[5 * e + 4];
                            Zs.AddToMesh(i, r, n, a, o, t)
                        }
                    }
                } else if (e.positions && e.normals && e.indices) {
                    if (t.setVerticesData(os.PositionKind, e.positions, e.positions._updatable),
                    t.setVerticesData(os.NormalKind, e.normals, e.normals._updatable),
                    e.tangents && t.setVerticesData(os.TangentKind, e.tangents, e.tangents._updatable),
                    e.uvs && t.setVerticesData(os.UVKind, e.uvs, e.uvs._updatable),
                    e.uvs2 && t.setVerticesData(os.UV2Kind, e.uvs2, e.uvs2._updatable),
                    e.uvs3 && t.setVerticesData(os.UV3Kind, e.uvs3, e.uvs3._updatable),
                    e.uvs4 && t.setVerticesData(os.UV4Kind, e.uvs4, e.uvs4._updatable),
                    e.uvs5 && t.setVerticesData(os.UV5Kind, e.uvs5, e.uvs5._updatable),
                    e.uvs6 && t.setVerticesData(os.UV6Kind, e.uvs6, e.uvs6._updatable),
                    e.colors && t.setVerticesData(os.ColorKind, Oe.CheckColors4(e.colors, e.positions.length / 3), e.colors._updatable),
                    e.matricesIndices)
                        if (e.matricesIndices._isExpanded)
                            delete e.matricesIndices._isExpanded,
                            t.setVerticesData(os.MatricesIndicesKind, e.matricesIndices, e.matricesIndices._updatable);
                        else {
                            const i = [];
                            for (let t = 0; t < e.matricesIndices.length; t++) {
                                const s = e.matricesIndices[t];
                                i.push(255 & s),
                                i.push((65280 & s) >> 8),
                                i.push((16711680 & s) >> 16),
                                i.push(s >> 24 & 255)
                            }
                            t.setVerticesData(os.MatricesIndicesKind, i, e.matricesIndices._updatable)
                        }
                    if (e.matricesIndicesExtra)
                        if (e.matricesIndicesExtra._isExpanded)
                            delete e.matricesIndices._isExpanded,
                            t.setVerticesData(os.MatricesIndicesExtraKind, e.matricesIndicesExtra, e.matricesIndicesExtra._updatable);
                        else {
                            const i = [];
                            for (let t = 0; t < e.matricesIndicesExtra.length; t++) {
                                const s = e.matricesIndicesExtra[t];
                                i.push(255 & s),
                                i.push((65280 & s) >> 8),
                                i.push((16711680 & s) >> 16),
                                i.push(s >> 24 & 255)
                            }
                            t.setVerticesData(os.MatricesIndicesExtraKind, i, e.matricesIndicesExtra._updatable)
                        }
                    e.matricesWeights && (tr._CleanMatricesWeights(e, t),
                    t.setVerticesData(os.MatricesWeightsKind, e.matricesWeights, e.matricesWeights._updatable)),
                    e.matricesWeightsExtra && t.setVerticesData(os.MatricesWeightsExtraKind, e.matricesWeightsExtra, e.matricesWeights._updatable),
                    t.setIndices(e.indices, null)
                }
                if (e.subMeshes) {
                    t.subMeshes = [];
                    for (let i = 0; i < e.subMeshes.length; i++) {
                        const s = e.subMeshes[i];
                        Zs.AddToMesh(s.materialIndex, s.verticesStart, s.verticesCount, s.indexStart, s.indexCount, t)
                    }
                }
                t._shouldGenerateFlatShading && (t.convertToFlatShadedMesh(),
                t._shouldGenerateFlatShading = !1),
                t.computeWorldMatrix(!0),
                i.onMeshImportedObservable.notifyObservers(t)
            }
            static _CleanMatricesWeights(e, t) {
                const i = .001;
                if (!Js.CleanBoneMatrixWeights)
                    return;
                let s = 0;
                if (!(e.skeletonId > -1))
                    return;
                {
                    const i = t.getScene().getLastSkeletonById(e.skeletonId);
                    if (!i)
                        return;
                    s = i.bones.length
                }
                const r = t.getVerticesData(os.MatricesIndicesKind)
                  , n = t.getVerticesData(os.MatricesIndicesExtraKind)
                  , a = e.matricesWeights
                  , o = e.matricesWeightsExtra
                  , h = e.numBoneInfluencer
                  , l = a.length;
                for (let e = 0; e < l; e += 4) {
                    let t = 0
                      , l = -1;
                    for (let s = 0; s < 4; s++) {
                        const r = a[e + s];
                        t += r,
                        r < i && l < 0 && (l = s)
                    }
                    if (o)
                        for (let s = 0; s < 4; s++) {
                            const r = o[e + s];
                            t += r,
                            r < i && l < 0 && (l = s + 4)
                        }
                    if ((l < 0 || l > h - 1) && (l = h - 1),
                    t > i) {
                        const i = 1 / t;
                        for (let t = 0; t < 4; t++)
                            a[e + t] *= i;
                        if (o)
                            for (let t = 0; t < 4; t++)
                                o[e + t] *= i
                    } else
                        l >= 4 ? (o[e + l - 4] = 1 - t,
                        n[e + l - 4] = s) : (a[e + l] = 1 - t,
                        r[e + l] = s)
                }
                t.setVerticesData(os.MatricesIndicesKind, r),
                e.matricesWeightsExtra && t.setVerticesData(os.MatricesIndicesExtraKind, n)
            }
            static Parse(e, t, i) {
                const s = new tr(e.id,t,void 0,e.updatable);
                return s._loadedUniqueId = e.uniqueId,
                ui && ui.AddTagsTo(s, e.tags),
                e.delayLoadingFile ? (s.delayLoadState = 4,
                s.delayLoadingFile = i + e.delayLoadingFile,
                s._boundingInfo = new Ys(Di.FromArray(e.boundingBoxMinimum),Di.FromArray(e.boundingBoxMaximum)),
                s._delayInfo = [],
                e.hasUVs && s._delayInfo.push(os.UVKind),
                e.hasUVs2 && s._delayInfo.push(os.UV2Kind),
                e.hasUVs3 && s._delayInfo.push(os.UV3Kind),
                e.hasUVs4 && s._delayInfo.push(os.UV4Kind),
                e.hasUVs5 && s._delayInfo.push(os.UV5Kind),
                e.hasUVs6 && s._delayInfo.push(os.UV6Kind),
                e.hasColors && s._delayInfo.push(os.ColorKind),
                e.hasMatricesIndices && s._delayInfo.push(os.MatricesIndicesKind),
                e.hasMatricesWeights && s._delayInfo.push(os.MatricesWeightsKind),
                s._delayLoadingFunction = $s.ImportVertexData) : $s.ImportVertexData(e, s),
                t.pushGeometry(s, !0),
                s
            }
        }
        class ir {
            constructor(e=30) {
                this._enabled = !0,
                this._rollingFrameTime = new sr(e)
            }
            sampleFrame(e=Ke.Now) {
                if (this._enabled) {
                    if (null != this._lastFrameTimeMs) {
                        const t = e - this._lastFrameTimeMs;
                        this._rollingFrameTime.add(t)
                    }
                    this._lastFrameTimeMs = e
                }
            }
            get averageFrameTime() {
                return this._rollingFrameTime.average
            }
            get averageFrameTimeVariance() {
                return this._rollingFrameTime.variance
            }
            get instantaneousFrameTime() {
                return this._rollingFrameTime.history(0)
            }
            get averageFPS() {
                return 1e3 / this._rollingFrameTime.average
            }
            get instantaneousFPS() {
                const e = this._rollingFrameTime.history(0);
                return 0 === e ? 0 : 1e3 / e
            }
            get isSaturated() {
                return this._rollingFrameTime.isSaturated()
            }
            enable() {
                this._enabled = !0
            }
            disable() {
                this._enabled = !1,
                this._lastFrameTimeMs = null
            }
            get isEnabled() {
                return this._enabled
            }
            reset() {
                this._lastFrameTimeMs = null,
                this._rollingFrameTime.reset()
            }
        }
        class sr {
            constructor(e) {
                this._samples = new Array(e),
                this.reset()
            }
            add(e) {
                let t;
                if (this.isSaturated()) {
                    const e = this._samples[this._pos];
                    t = e - this.average,
                    this.average -= t / (this._sampleCount - 1),
                    this._m2 -= t * (e - this.average)
                } else
                    this._sampleCount++;
                t = e - this.average,
                this.average += t / this._sampleCount,
                this._m2 += t * (e - this.average),
                this.variance = this._m2 / (this._sampleCount - 1),
                this._samples[this._pos] = e,
                this._pos++,
                this._pos %= this._samples.length
            }
            history(e) {
                if (e >= this._sampleCount || e >= this._samples.length)
                    return 0;
                const t = this._wrapPosition(this._pos - 1);
                return this._samples[this._wrapPosition(t - e)]
            }
            isSaturated() {
                return this._sampleCount >= this._samples.length
            }
            reset() {
                this.average = 0,
                this.variance = 0,
                this._sampleCount = 0,
                this._pos = 0,
                this._m2 = 0
            }
            _wrapPosition(e) {
                const t = this._samples.length;
                return (e % t + t) % t
            }
        }
        kt.prototype.setAlphaConstants = function(e, t, i, s) {
            this._alphaState.setAlphaBlendConstants(e, t, i, s)
        }
        ,
        kt.prototype.setAlphaMode = function(e, t=!1) {
            if (this._alphaMode !== e) {
                switch (e) {
                case 0:
                    this._alphaState.alphaBlend = !1;
                    break;
                case 7:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 8:
                case 14:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 2:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 6:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 1:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 3:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 4:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 5:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 9:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 10:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 11:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 12:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 13:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 15:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 16:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE),
                    this._alphaState.alphaBlend = !0;
                    break;
                case 17:
                    this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA),
                    this._alphaState.alphaBlend = !0
                }
                t || (this.depthCullingState.depthMask = 0 === e),
                this._alphaMode = e
            } else if (!t) {
                const t = 0 === e;
                this.depthCullingState.depthMask !== t && (this.depthCullingState.depthMask = t)
            }
        }
        ,
        kt.prototype.getAlphaMode = function() {
            return this._alphaMode
        }
        ,
        kt.prototype.setAlphaEquation = function(e) {
            if (this._alphaEquation !== e) {
                switch (e) {
                case 0:
                    this._alphaState.setAlphaEquationParameters(32774, 32774);
                    break;
                case 1:
                    this._alphaState.setAlphaEquationParameters(32778, 32778);
                    break;
                case 2:
                    this._alphaState.setAlphaEquationParameters(32779, 32779);
                    break;
                case 3:
                    this._alphaState.setAlphaEquationParameters(32776, 32776);
                    break;
                case 4:
                    this._alphaState.setAlphaEquationParameters(32775, 32775);
                    break;
                case 5:
                    this._alphaState.setAlphaEquationParameters(32775, 32774)
                }
                this._alphaEquation = e
            }
        }
        ,
        kt.prototype.getAlphaEquation = function() {
            return this._alphaEquation
        }
        ,
        kt.prototype._readTexturePixelsSync = function(e, t, i, s=-1, r=0, n=null, a=!0, o=!1, h=0, l=0) {
            const c = this._gl;
            if (!c)
                throw new Error("Engine does not have gl rendering context.");
            if (!this._dummyFramebuffer) {
                const e = c.createFramebuffer();
                if (!e)
                    throw new Error("Unable to create dummy framebuffer");
                this._dummyFramebuffer = e
            }
            c.bindFramebuffer(c.FRAMEBUFFER, this._dummyFramebuffer),
            s > -1 ? c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_CUBE_MAP_POSITIVE_X + s, e._hardwareTexture?.underlyingResource, r) : c.framebufferTexture2D(c.FRAMEBUFFER, c.COLOR_ATTACHMENT0, c.TEXTURE_2D, e._hardwareTexture?.underlyingResource, r);
            let u = void 0 !== e.type ? this._getWebGLTextureType(e.type) : c.UNSIGNED_BYTE;
            return o ? n || (n = function(e, t, i=!1, s) {
                switch (e) {
                case 3:
                    {
                        const e = (ArrayBuffer,
                        new Int8Array(t));
                        return s && e.set(new Int8Array(s)),
                        e
                    }
                case 0:
                    {
                        const e = (ArrayBuffer,
                        new Uint8Array(t));
                        return s && e.set(new Uint8Array(s)),
                        e
                    }
                case 4:
                    {
                        const e = t instanceof ArrayBuffer ? new Int16Array(t) : new Int16Array(i ? t / 2 : t);
                        return s && e.set(new Int16Array(s)),
                        e
                    }
                case 5:
                case 8:
                case 9:
                case 10:
                case 2:
                    {
                        const e = t instanceof ArrayBuffer ? new Uint16Array(t) : new Uint16Array(i ? t / 2 : t);
                        return s && e.set(new Uint16Array(s)),
                        e
                    }
                case 6:
                    {
                        const e = t instanceof ArrayBuffer ? new Int32Array(t) : new Int32Array(i ? t / 4 : t);
                        return s && e.set(new Int32Array(s)),
                        e
                    }
                case 7:
                case 11:
                case 12:
                case 13:
                case 14:
                case 15:
                    {
                        const e = t instanceof ArrayBuffer ? new Uint32Array(t) : new Uint32Array(i ? t / 4 : t);
                        return s && e.set(new Uint32Array(s)),
                        e
                    }
                case 1:
                    {
                        const e = t instanceof ArrayBuffer ? new Float32Array(t) : new Float32Array(i ? t / 4 : t);
                        return s && e.set(new Float32Array(s)),
                        e
                    }
                }
                const r = (ArrayBuffer,
                new Uint8Array(t));
                return s && r.set(new Uint8Array(s)),
                r
            }(e.type, 4 * t * i)) : u === c.UNSIGNED_BYTE ? (n || (n = new Uint8Array(4 * t * i)),
            u = c.UNSIGNED_BYTE) : (n || (n = new Float32Array(4 * t * i)),
            u = c.FLOAT),
            a && this.flushFramebuffer(),
            c.readPixels(h, l, t, i, c.RGBA, u, n),
            c.bindFramebuffer(c.FRAMEBUFFER, this._currentFramebuffer),
            n
        }
        ,
        kt.prototype._readTexturePixels = function(e, t, i, s=-1, r=0, n=null, a=!0, o=!1, h=0, l=0) {
            return Promise.resolve(this._readTexturePixelsSync(e, t, i, s, r, n, a, o, h, l))
        }
        ,
        kt.prototype.updateDynamicIndexBuffer = function(e, t, i=0) {
            let s;
            this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null,
            this.bindIndexBuffer(e),
            s = e.is32Bits ? t instanceof Uint32Array ? t : new Uint32Array(t) : t instanceof Uint16Array ? t : new Uint16Array(t),
            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, s, this._gl.DYNAMIC_DRAW),
            this._resetIndexBufferBinding()
        }
        ,
        kt.prototype.updateDynamicVertexBuffer = function(e, t, i, s) {
            this.bindArrayBuffer(e),
            void 0 === i && (i = 0);
            const r = t.byteLength || t.length;
            void 0 === s || s >= r && 0 === i ? t instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, i, new Float32Array(t)) : this._gl.bufferSubData(this._gl.ARRAY_BUFFER, i, t) : t instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(t).subarray(i, i + s)) : (t = t instanceof ArrayBuffer ? new Uint8Array(t,i,s) : new Uint8Array(t.buffer,t.byteOffset + i,s),
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, t)),
            this._resetVertexBufferBinding()
        }
        ;
        class rr extends kt {
            static get NpmPackage() {
                return kt.NpmPackage
            }
            static get Version() {
                return kt.Version
            }
            static get Instances() {
                return Ze.Instances
            }
            static get LastCreatedEngine() {
                return Ze.LastCreatedEngine
            }
            static get LastCreatedScene() {
                return Ze.LastCreatedScene
            }
            _createImageBitmapFromSource(e, t) {
                return new Promise(( (i, s) => {
                    const r = new Image;
                    r.onload = () => {
                        r.decode().then(( () => {
                            this.createImageBitmap(r, t).then((e => {
                                i(e)
                            }
                            ))
                        }
                        ))
                    }
                    ,
                    r.onerror = () => {
                        s(`Error loading image ${r.src}`)
                    }
                    ,
                    r.src = e
                }
                ))
            }
            createImageBitmap(e, t) {
                return createImageBitmap(e, t)
            }
            resizeImageBitmap(e, t, i) {
                const s = this.createCanvas(t, i).getContext("2d");
                if (!s)
                    throw new Error("Unable to get 2d context for resizeImageBitmap");
                return s.drawImage(e, 0, 0),
                s.getImageData(0, 0, t, i).data
            }
            static MarkAllMaterialsAsDirty(e, t) {
                for (let i = 0; i < rr.Instances.length; i++) {
                    const s = rr.Instances[i];
                    for (let i = 0; i < s.scenes.length; i++)
                        s.scenes[i].markAllMaterialsAsDirty(e, t)
                }
            }
            static DefaultLoadingScreenFactory(e) {
                throw je("LoadingScreen")
            }
            get _supportsHardwareTextureRescaling() {
                return !!rr._RescalePostProcessFactory
            }
            get performanceMonitor() {
                return this._performanceMonitor
            }
            get compatibilityMode() {
                return this._compatibilityMode
            }
            set compatibilityMode(e) {
                this._compatibilityMode = !0
            }
            getInputElement() {
                return this._renderingCanvas
            }
            constructor(e, t, i, s=!1) {
                if (super(e, t, i, s),
                this.enableOfflineSupport = !1,
                this.disableManifestCheck = !1,
                this.disableContextMenu = !0,
                this.scenes = [],
                this._virtualScenes = new Array,
                this.onNewSceneAddedObservable = new Ue,
                this.postProcesses = [],
                this.isPointerLock = !1,
                this.onResizeObservable = new Ue,
                this.onCanvasBlurObservable = new Ue,
                this.onCanvasFocusObservable = new Ue,
                this.onCanvasPointerOutObservable = new Ue,
                this.onBeginFrameObservable = new Ue,
                this.customAnimationFrameRequester = null,
                this.onEndFrameObservable = new Ue,
                this.onBeforeShaderCompilationObservable = new Ue,
                this.onAfterShaderCompilationObservable = new Ue,
                this._deterministicLockstep = !1,
                this._lockstepMaxSteps = 4,
                this._timeStep = 1 / 60,
                this._fps = 60,
                this._deltaTime = 0,
                this._drawCalls = new Os,
                this.canvasTabIndex = 1,
                this.disablePerformanceMonitorInBackground = !1,
                this._performanceMonitor = new ir,
                this._compatibilityMode = !0,
                this.currentRenderPassId = 0,
                this._renderPassNames = ["main"],
                rr.Instances.push(this),
                e && (this._features.supportRenderPasses = !0,
                i = this._creationOptions,
                e.getContext)) {
                    const t = e;
                    this._sharedInit(t)
                }
            }
            _initGLContext() {
                super._initGLContext(),
                this._rescalePostProcess = null
            }
            _sharedInit(e) {
                super._sharedInit(e),
                this._onCanvasFocus = () => {
                    this.onCanvasFocusObservable.notifyObservers(this)
                }
                ,
                this._onCanvasBlur = () => {
                    this.onCanvasBlurObservable.notifyObservers(this)
                }
                ,
                this._onCanvasContextMenu = e => {
                    this.disableContextMenu && e.preventDefault()
                }
                ,
                e.addEventListener("focus", this._onCanvasFocus),
                e.addEventListener("blur", this._onCanvasBlur),
                e.addEventListener("contextmenu", this._onCanvasContextMenu),
                this._onBlur = () => {
                    this.disablePerformanceMonitorInBackground && this._performanceMonitor.disable(),
                    this._windowIsBackground = !0
                }
                ,
                this._onFocus = () => {
                    this.disablePerformanceMonitorInBackground && this._performanceMonitor.enable(),
                    this._windowIsBackground = !1
                }
                ,
                this._onCanvasPointerOut = t => {
                    document.elementFromPoint(t.clientX, t.clientY) !== e && this.onCanvasPointerOutObservable.notifyObservers(t)
                }
                ;
                const t = this.getHostWindow();
                t && "function" == typeof t.addEventListener && (t.addEventListener("blur", this._onBlur),
                t.addEventListener("focus", this._onFocus)),
                e.addEventListener("pointerout", this._onCanvasPointerOut),
                this._creationOptions.doNotHandleTouchAction || this._disableTouchAction(),
                !rr.audioEngine && this._creationOptions.audioEngine && rr.AudioEngineFactory && (rr.audioEngine = rr.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination())),
                Ge() && (this._onFullscreenChange = () => {
                    this.isFullscreen = !!document.fullscreenElement,
                    this.isFullscreen && this._pointerLockRequested && e && rr._RequestPointerlock(e)
                }
                ,
                document.addEventListener("fullscreenchange", this._onFullscreenChange, !1),
                document.addEventListener("webkitfullscreenchange", this._onFullscreenChange, !1),
                this._onPointerLockChange = () => {
                    this.isPointerLock = document.pointerLockElement === e
                }
                ,
                document.addEventListener("pointerlockchange", this._onPointerLockChange, !1),
                document.addEventListener("webkitpointerlockchange", this._onPointerLockChange, !1)),
                this.enableOfflineSupport = void 0 !== rr.OfflineProviderFactory,
                this._deterministicLockstep = !!this._creationOptions.deterministicLockstep,
                this._lockstepMaxSteps = this._creationOptions.lockstepMaxSteps || 0,
                this._timeStep = this._creationOptions.timeStep || 1 / 60
            }
            _verifyPointerLock() {
                this._onPointerLockChange?.()
            }
            getAspectRatio(e, t=!1) {
                const i = e.viewport;
                return this.getRenderWidth(t) * i.width / (this.getRenderHeight(t) * i.height)
            }
            getScreenAspectRatio() {
                return this.getRenderWidth(!0) / this.getRenderHeight(!0)
            }
            getRenderingCanvasClientRect() {
                return this._renderingCanvas ? this._renderingCanvas.getBoundingClientRect() : null
            }
            getInputElementClientRect() {
                return this._renderingCanvas ? this.getInputElement().getBoundingClientRect() : null
            }
            isDeterministicLockStep() {
                return this._deterministicLockstep
            }
            getLockstepMaxSteps() {
                return this._lockstepMaxSteps
            }
            getTimeStep() {
                return 1e3 * this._timeStep
            }
            generateMipMapsForCubemap(e, t=!0) {
                if (e.generateMipMaps) {
                    const i = this._gl;
                    this._bindTextureDirectly(i.TEXTURE_CUBE_MAP, e, !0),
                    i.generateMipmap(i.TEXTURE_CUBE_MAP),
                    t && this._bindTextureDirectly(i.TEXTURE_CUBE_MAP, null)
                }
            }
            getDepthWrite() {
                return this._depthCullingState.depthMask
            }
            setDepthWrite(e) {
                this._depthCullingState.depthMask = e
            }
            getStencilBuffer() {
                return this._stencilState.stencilTest
            }
            setStencilBuffer(e) {
                this._stencilState.stencilTest = e
            }
            getStencilMask() {
                return this._stencilState.stencilMask
            }
            setStencilMask(e) {
                this._stencilState.stencilMask = e
            }
            getStencilFunction() {
                return this._stencilState.stencilFunc
            }
            getStencilFunctionReference() {
                return this._stencilState.stencilFuncRef
            }
            getStencilFunctionMask() {
                return this._stencilState.stencilFuncMask
            }
            setStencilFunction(e) {
                this._stencilState.stencilFunc = e
            }
            setStencilFunctionReference(e) {
                this._stencilState.stencilFuncRef = e
            }
            setStencilFunctionMask(e) {
                this._stencilState.stencilFuncMask = e
            }
            getStencilOperationFail() {
                return this._stencilState.stencilOpStencilFail
            }
            getStencilOperationDepthFail() {
                return this._stencilState.stencilOpDepthFail
            }
            getStencilOperationPass() {
                return this._stencilState.stencilOpStencilDepthPass
            }
            setStencilOperationFail(e) {
                this._stencilState.stencilOpStencilFail = e
            }
            setStencilOperationDepthFail(e) {
                this._stencilState.stencilOpDepthFail = e
            }
            setStencilOperationPass(e) {
                this._stencilState.stencilOpStencilDepthPass = e
            }
            setDitheringState(e) {
                e ? this._gl.enable(this._gl.DITHER) : this._gl.disable(this._gl.DITHER)
            }
            setRasterizerState(e) {
                e ? this._gl.disable(this._gl.RASTERIZER_DISCARD) : this._gl.enable(this._gl.RASTERIZER_DISCARD)
            }
            getDepthFunction() {
                return this._depthCullingState.depthFunc
            }
            setDepthFunction(e) {
                this._depthCullingState.depthFunc = e
            }
            setDepthFunctionToGreater() {
                this.setDepthFunction(516)
            }
            setDepthFunctionToGreaterOrEqual() {
                this.setDepthFunction(518)
            }
            setDepthFunctionToLess() {
                this.setDepthFunction(513)
            }
            setDepthFunctionToLessOrEqual() {
                this.setDepthFunction(515)
            }
            cacheStencilState() {
                this._cachedStencilBuffer = this.getStencilBuffer(),
                this._cachedStencilFunction = this.getStencilFunction(),
                this._cachedStencilMask = this.getStencilMask(),
                this._cachedStencilOperationPass = this.getStencilOperationPass(),
                this._cachedStencilOperationFail = this.getStencilOperationFail(),
                this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail(),
                this._cachedStencilReference = this.getStencilFunctionReference()
            }
            restoreStencilState() {
                this.setStencilFunction(this._cachedStencilFunction),
                this.setStencilMask(this._cachedStencilMask),
                this.setStencilBuffer(this._cachedStencilBuffer),
                this.setStencilOperationPass(this._cachedStencilOperationPass),
                this.setStencilOperationFail(this._cachedStencilOperationFail),
                this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail),
                this.setStencilFunctionReference(this._cachedStencilReference)
            }
            setDirectViewport(e, t, i, s) {
                const r = this._cachedViewport;
                return this._cachedViewport = null,
                this._viewport(e, t, i, s),
                r
            }
            scissorClear(e, t, i, s, r) {
                this.enableScissor(e, t, i, s),
                this.clear(r, !0, !0, !0),
                this.disableScissor()
            }
            enableScissor(e, t, i, s) {
                const r = this._gl;
                r.enable(r.SCISSOR_TEST),
                r.scissor(e, t, i, s)
            }
            disableScissor() {
                const e = this._gl;
                e.disable(e.SCISSOR_TEST)
            }
            _reportDrawCall(e=1) {
                this._drawCalls.addCount(e, !1)
            }
            _loadFileAsync(e, t, i) {
                return new Promise(( (s, r) => {
                    this._loadFile(e, (e => {
                        s(e)
                    }
                    ), void 0, t, i, ( (e, t) => {
                        r(t)
                    }
                    ))
                }
                ))
            }
            getVertexShaderSource(e) {
                const t = this._gl.getAttachedShaders(e);
                return t ? this._gl.getShaderSource(t[0]) : null
            }
            getFragmentShaderSource(e) {
                const t = this._gl.getAttachedShaders(e);
                return t ? this._gl.getShaderSource(t[1]) : null
            }
            setDepthStencilTexture(e, t, i, s) {
                void 0 !== e && (t && (this._boundUniforms[e] = t),
                i && i.depthStencilTexture ? this._setTexture(e, i, !1, !0, s) : this._setTexture(e, null, void 0, void 0, s))
            }
            setTextureFromPostProcess(e, t, i) {
                let s = null;
                t && (t._forcedOutputTexture ? s = t._forcedOutputTexture : t._textures.data[t._currentRenderTextureInd] && (s = t._textures.data[t._currentRenderTextureInd])),
                this._bindTexture(e, s?.texture ?? null, i)
            }
            setTextureFromPostProcessOutput(e, t, i) {
                this._bindTexture(e, t?._outputTexture?.texture ?? null, i)
            }
            set framebufferDimensionsObject(e) {
                this._framebufferDimensionsObject = e,
                this._framebufferDimensionsObject && this.onResizeObservable.notifyObservers(this)
            }
            _rebuildBuffers() {
                for (const e of this.scenes)
                    e.resetCachedMaterial(),
                    e._rebuildGeometries();
                for (const e of this._virtualScenes)
                    e.resetCachedMaterial(),
                    e._rebuildGeometries();
                super._rebuildBuffers()
            }
            _rebuildTextures() {
                for (const e of this.scenes)
                    e._rebuildTextures();
                for (const e of this._virtualScenes)
                    e._rebuildTextures();
                super._rebuildTextures()
            }
            _renderFrame() {
                for (let e = 0; e < this._activeRenderLoops.length; e++)
                    (0,
                    this._activeRenderLoops[e])()
            }
            _cancelFrame() {
                if (this.customAnimationFrameRequester) {
                    if (0 !== this._frameHandler) {
                        this._frameHandler = 0;
                        const {cancelAnimationFrame: e} = this.customAnimationFrameRequester;
                        e && e(this.customAnimationFrameRequester.requestID)
                    }
                } else
                    super._cancelFrame()
            }
            _renderLoop() {
                if (this._frameHandler = 0,
                !this._contextWasLost) {
                    let e = !0;
                    (this.isDisposed || !this.renderEvenInBackground && this._windowIsBackground) && (e = !1),
                    e && (this.beginFrame(),
                    this._renderViews() || this._renderFrame(),
                    this.endFrame())
                }
                0 === this._frameHandler && (this.customAnimationFrameRequester ? (this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester),
                this._frameHandler = this.customAnimationFrameRequester.requestID) : this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()))
            }
            _renderViews() {
                return !1
            }
            switchFullscreen(e) {
                this.isFullscreen ? this.exitFullscreen() : this.enterFullscreen(e)
            }
            enterFullscreen(e) {
                this.isFullscreen || (this._pointerLockRequested = e,
                this._renderingCanvas && rr._RequestFullscreen(this._renderingCanvas))
            }
            exitFullscreen() {
                this.isFullscreen && rr._ExitFullscreen()
            }
            enterPointerlock() {
                this._renderingCanvas && rr._RequestPointerlock(this._renderingCanvas)
            }
            exitPointerlock() {
                rr._ExitPointerlock()
            }
            beginFrame() {
                this._measureFps(),
                this.onBeginFrameObservable.notifyObservers(this),
                super.beginFrame()
            }
            endFrame() {
                super.endFrame(),
                this.onEndFrameObservable.notifyObservers(this)
            }
            setSize(e, t, i=!1) {
                if (!this._renderingCanvas)
                    return !1;
                if (!super.setSize(e, t, i))
                    return !1;
                if (this.scenes) {
                    for (let e = 0; e < this.scenes.length; e++) {
                        const t = this.scenes[e];
                        for (let e = 0; e < t.cameras.length; e++)
                            t.cameras[e]._currentRenderId = 0
                    }
                    this.onResizeObservable.hasObservers() && this.onResizeObservable.notifyObservers(this)
                }
                return !0
            }
            _deletePipelineContext(e) {
                const t = e;
                t && t.program && t.transformFeedback && (this.deleteTransformFeedback(t.transformFeedback),
                t.transformFeedback = null),
                super._deletePipelineContext(e)
            }
            createShaderProgram(e, t, i, s, r, n=null) {
                r = r || this._gl,
                this.onBeforeShaderCompilationObservable.notifyObservers(this);
                const a = super.createShaderProgram(e, t, i, s, r, n);
                return this.onAfterShaderCompilationObservable.notifyObservers(this),
                a
            }
            _createShaderProgram(e, t, i, s, r=null) {
                const n = s.createProgram();
                if (e.program = n,
                !n)
                    throw new Error("Unable to create program");
                if (s.attachShader(n, t),
                s.attachShader(n, i),
                this.webGLVersion > 1 && r) {
                    const t = this.createTransformFeedback();
                    this.bindTransformFeedback(t),
                    this.setTranformFeedbackVaryings(n, r),
                    e.transformFeedback = t
                }
                return s.linkProgram(n),
                this.webGLVersion > 1 && r && this.bindTransformFeedback(null),
                e.context = s,
                e.vertexShader = t,
                e.fragmentShader = i,
                e.isParallelCompiled || this._finalizePipelineContext(e),
                n
            }
            _releaseTexture(e) {
                super._releaseTexture(e)
            }
            _releaseRenderTargetWrapper(e) {
                super._releaseRenderTargetWrapper(e),
                this.scenes.forEach((t => {
                    t.postProcesses.forEach((t => {
                        t._outputTexture === e && (t._outputTexture = null)
                    }
                    )),
                    t.cameras.forEach((t => {
                        t._postProcesses.forEach((t => {
                            t && t._outputTexture === e && (t._outputTexture = null)
                        }
                        ))
                    }
                    ))
                }
                ))
            }
            getRenderPassNames() {
                return this._renderPassNames
            }
            getCurrentRenderPassName() {
                return this._renderPassNames[this.currentRenderPassId]
            }
            createRenderPassId(e) {
                const t = ++rr._RenderPassIdCounter;
                return this._renderPassNames[t] = e ?? "NONAME",
                t
            }
            releaseRenderPassId(e) {
                this._renderPassNames[e] = void 0;
                for (let t = 0; t < this.scenes.length; ++t) {
                    const i = this.scenes[t];
                    for (let t = 0; t < i.meshes.length; ++t) {
                        const s = i.meshes[t];
                        if (s.subMeshes)
                            for (let t = 0; t < s.subMeshes.length; ++t)
                                s.subMeshes[t]._removeDrawWrapper(e)
                    }
                }
            }
            _rescaleTexture(e, t, i, s, r) {
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR),
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR),
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE),
                this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
                const n = this.createRenderTargetTexture({
                    width: t.width,
                    height: t.height
                }, {
                    generateMipMaps: !1,
                    type: 0,
                    samplingMode: 2,
                    generateDepthBuffer: !1,
                    generateStencilBuffer: !1
                });
                !this._rescalePostProcess && rr._RescalePostProcessFactory && (this._rescalePostProcess = rr._RescalePostProcessFactory(this)),
                this._rescalePostProcess && (this._rescalePostProcess.externalTextureSamplerBinding = !0,
                this._rescalePostProcess.getEffect().executeWhenCompiled(( () => {
                    this._rescalePostProcess.onApply = function(t) {
                        t._bindTexture("textureSampler", e)
                    }
                    ;
                    let a = i;
                    a || (a = this.scenes[this.scenes.length - 1]),
                    a.postProcessManager.directRender([this._rescalePostProcess], n, !0),
                    this._bindTextureDirectly(this._gl.TEXTURE_2D, t, !0),
                    this._gl.copyTexImage2D(this._gl.TEXTURE_2D, 0, s, 0, 0, t.width, t.height, 0),
                    this.unBindFramebuffer(n),
                    n.dispose(),
                    r && r()
                }
                )))
            }
            getFps() {
                return this._fps
            }
            getDeltaTime() {
                return this._deltaTime
            }
            _measureFps() {
                this._performanceMonitor.sampleFrame(),
                this._fps = this._performanceMonitor.averageFPS,
                this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0
            }
            wrapWebGLTexture(e, t=!1, i=3, s=0, r=0) {
                const n = new Lt(e,this._gl)
                  , a = new It(this,At.Unknown,!0);
                return a._hardwareTexture = n,
                a.baseWidth = s,
                a.baseHeight = r,
                a.width = s,
                a.height = r,
                a.isReady = !0,
                a.useMipMaps = t,
                this.updateTextureSamplingMode(i, a),
                a
            }
            _uploadImageToTexture(e, t, i=0, s=0) {
                const r = this._gl
                  , n = this._getWebGLTextureType(e.type)
                  , a = this._getInternalFormat(e.format)
                  , o = this._getRGBABufferInternalSizedFormat(e.type, a)
                  , h = e.isCube ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D;
                this._bindTextureDirectly(h, e, !0),
                this._unpackFlipY(e.invertY);
                let l = r.TEXTURE_2D;
                e.isCube && (l = r.TEXTURE_CUBE_MAP_POSITIVE_X + i),
                r.texImage2D(l, s, o, a, n, t),
                this._bindTextureDirectly(h, null, !0)
            }
            updateTextureComparisonFunction(e, t) {
                if (1 === this.webGLVersion)
                    return void We.Error("WebGL 1 does not support texture comparison.");
                const i = this._gl;
                e.isCube ? (this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, e, !0),
                0 === t ? (i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_FUNC, 515),
                i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_MODE, i.NONE)) : (i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_FUNC, t),
                i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)),
                this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)) : (this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0),
                0 === t ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_FUNC, 515),
                i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_MODE, i.NONE)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_FUNC, t),
                i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)),
                this._bindTextureDirectly(this._gl.TEXTURE_2D, null)),
                e._comparisonFunction = t
            }
            createInstancesBuffer(e) {
                const t = this._gl.createBuffer();
                if (!t)
                    throw new Error("Unable to create instance buffer");
                const i = new wt(t);
                return i.capacity = e,
                this.bindArrayBuffer(i),
                this._gl.bufferData(this._gl.ARRAY_BUFFER, e, this._gl.DYNAMIC_DRAW),
                i.references = 1,
                i
            }
            deleteInstancesBuffer(e) {
                this._gl.deleteBuffer(e)
            }
            _clientWaitAsync(e, t=0, i=10) {
                const s = this._gl;
                return new Promise(( (r, n) => {
                    const a = () => {
                        const o = s.clientWaitSync(e, t, 0);
                        o != s.WAIT_FAILED ? o != s.TIMEOUT_EXPIRED ? r() : setTimeout(a, i) : n()
                    }
                    ;
                    a()
                }
                ))
            }
            _readPixelsAsync(e, t, i, s, r, n, a) {
                if (this._webGLVersion < 2)
                    throw new Error("_readPixelsAsync only work on WebGL2+");
                const o = this._gl
                  , h = o.createBuffer();
                o.bindBuffer(o.PIXEL_PACK_BUFFER, h),
                o.bufferData(o.PIXEL_PACK_BUFFER, a.byteLength, o.STREAM_READ),
                o.readPixels(e, t, i, s, r, n, 0),
                o.bindBuffer(o.PIXEL_PACK_BUFFER, null);
                const l = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
                return l ? (o.flush(),
                this._clientWaitAsync(l, 0, 10).then(( () => (o.deleteSync(l),
                o.bindBuffer(o.PIXEL_PACK_BUFFER, h),
                o.getBufferSubData(o.PIXEL_PACK_BUFFER, 0, a),
                o.bindBuffer(o.PIXEL_PACK_BUFFER, null),
                o.deleteBuffer(h),
                a)))) : null
            }
            dispose() {
                for (this.hideLoadingUI(),
                this.onNewSceneAddedObservable.clear(); this.postProcesses.length; )
                    this.postProcesses[0].dispose();
                for (this._rescalePostProcess && this._rescalePostProcess.dispose(); this.scenes.length; )
                    this.scenes[0].dispose();
                for (; this._virtualScenes.length; )
                    this._virtualScenes[0].dispose();
                1 === Ze.Instances.length && rr.audioEngine && (rr.audioEngine.dispose(),
                rr.audioEngine = null);
                const e = this.getHostWindow();
                e && "function" == typeof e.removeEventListener && (e.removeEventListener("blur", this._onBlur),
                e.removeEventListener("focus", this._onFocus)),
                this._renderingCanvas && (this._renderingCanvas.removeEventListener("focus", this._onCanvasFocus),
                this._renderingCanvas.removeEventListener("blur", this._onCanvasBlur),
                this._renderingCanvas.removeEventListener("pointerout", this._onCanvasPointerOut),
                this._renderingCanvas.removeEventListener("contextmenu", this._onCanvasContextMenu)),
                Ge() && (document.removeEventListener("fullscreenchange", this._onFullscreenChange),
                document.removeEventListener("mozfullscreenchange", this._onFullscreenChange),
                document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange),
                document.removeEventListener("msfullscreenchange", this._onFullscreenChange),
                document.removeEventListener("pointerlockchange", this._onPointerLockChange),
                document.removeEventListener("mspointerlockchange", this._onPointerLockChange),
                document.removeEventListener("mozpointerlockchange", this._onPointerLockChange),
                document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange)),
                super.dispose();
                const t = Ze.Instances.indexOf(this);
                t >= 0 && Ze.Instances.splice(t, 1),
                rr.Instances.length || Ze.OnEnginesDisposedObservable.notifyObservers(this),
                this.onResizeObservable.clear(),
                this.onCanvasBlurObservable.clear(),
                this.onCanvasFocusObservable.clear(),
                this.onCanvasPointerOutObservable.clear(),
                this.onBeginFrameObservable.clear(),
                this.onEndFrameObservable.clear()
            }
            _disableTouchAction() {
                this._renderingCanvas && this._renderingCanvas.setAttribute && (this._renderingCanvas.setAttribute("touch-action", "none"),
                this._renderingCanvas.style.touchAction = "none",
                this._renderingCanvas.style.webkitTapHighlightColor = "transparent")
            }
            displayLoadingUI() {
                if (!ke())
                    return;
                const e = this.loadingScreen;
                e && e.displayLoadingUI()
            }
            hideLoadingUI() {
                if (!ke())
                    return;
                const e = this._loadingScreen;
                e && e.hideLoadingUI()
            }
            get loadingScreen() {
                return !this._loadingScreen && this._renderingCanvas && (this._loadingScreen = rr.DefaultLoadingScreenFactory(this._renderingCanvas)),
                this._loadingScreen
            }
            set loadingScreen(e) {
                this._loadingScreen = e
            }
            set loadingUIText(e) {
                this.loadingScreen.loadingUIText = e
            }
            set loadingUIBackgroundColor(e) {
                this.loadingScreen.loadingUIBackgroundColor = e
            }
            createVideoElement(e) {
                return document.createElement("video")
            }
            static _RequestPointerlock(e) {
                if (e.requestPointerLock) {
                    const t = e.requestPointerLock();
                    t instanceof Promise ? t.then(( () => {
                        e.focus()
                    }
                    )).catch(( () => {}
                    )) : e.focus()
                }
            }
            static _ExitPointerlock() {
                document.exitPointerLock && document.exitPointerLock()
            }
            static _RequestFullscreen(e) {
                const t = e.requestFullscreen || e.webkitRequestFullscreen;
                t && t.call(e)
            }
            static _ExitFullscreen() {
                const e = document;
                document.exitFullscreen ? document.exitFullscreen() : e.webkitCancelFullScreen && e.webkitCancelFullScreen()
            }
            getFontOffset(e) {
                const t = document.createElement("span");
                t.innerHTML = "Hg",
                t.setAttribute("style", `font: ${e} !important`);
                const i = document.createElement("div");
                i.style.display = "inline-block",
                i.style.width = "1px",
                i.style.height = "0px",
                i.style.verticalAlign = "bottom";
                const s = document.createElement("div");
                s.style.whiteSpace = "nowrap",
                s.appendChild(t),
                s.appendChild(i),
                document.body.appendChild(s);
                let r = 0
                  , n = 0;
                try {
                    n = i.getBoundingClientRect().top - t.getBoundingClientRect().top,
                    i.style.verticalAlign = "baseline",
                    r = i.getBoundingClientRect().top - t.getBoundingClientRect().top
                } finally {
                    document.body.removeChild(s)
                }
                return {
                    ascent: r,
                    height: n,
                    descent: n - r
                }
            }
        }
        var nr, ar;
        rr.ALPHA_DISABLE = 0,
        rr.ALPHA_ADD = 1,
        rr.ALPHA_COMBINE = 2,
        rr.ALPHA_SUBTRACT = 3,
        rr.ALPHA_MULTIPLY = 4,
        rr.ALPHA_MAXIMIZED = 5,
        rr.ALPHA_ONEONE = 6,
        rr.ALPHA_PREMULTIPLIED = 7,
        rr.ALPHA_PREMULTIPLIED_PORTERDUFF = 8,
        rr.ALPHA_INTERPOLATE = 9,
        rr.ALPHA_SCREENMODE = 10,
        rr.DELAYLOADSTATE_NONE = 0,
        rr.DELAYLOADSTATE_LOADED = 1,
        rr.DELAYLOADSTATE_LOADING = 2,
        rr.DELAYLOADSTATE_NOTLOADED = 4,
        rr.NEVER = 512,
        rr.ALWAYS = 519,
        rr.LESS = 513,
        rr.EQUAL = 514,
        rr.LEQUAL = 515,
        rr.GREATER = 516,
        rr.GEQUAL = 518,
        rr.NOTEQUAL = 517,
        rr.KEEP = 7680,
        rr.REPLACE = 7681,
        rr.INCR = 7682,
        rr.DECR = 7683,
        rr.INVERT = 5386,
        rr.INCR_WRAP = 34055,
        rr.DECR_WRAP = 34056,
        rr.TEXTURE_CLAMP_ADDRESSMODE = 0,
        rr.TEXTURE_WRAP_ADDRESSMODE = 1,
        rr.TEXTURE_MIRROR_ADDRESSMODE = 2,
        rr.TEXTUREFORMAT_ALPHA = 0,
        rr.TEXTUREFORMAT_LUMINANCE = 1,
        rr.TEXTUREFORMAT_LUMINANCE_ALPHA = 2,
        rr.TEXTUREFORMAT_RGB = 4,
        rr.TEXTUREFORMAT_RGBA = 5,
        rr.TEXTUREFORMAT_RED = 6,
        rr.TEXTUREFORMAT_R = 6,
        rr.TEXTUREFORMAT_RG = 7,
        rr.TEXTUREFORMAT_RED_INTEGER = 8,
        rr.TEXTUREFORMAT_R_INTEGER = 8,
        rr.TEXTUREFORMAT_RG_INTEGER = 9,
        rr.TEXTUREFORMAT_RGB_INTEGER = 10,
        rr.TEXTUREFORMAT_RGBA_INTEGER = 11,
        rr.TEXTURETYPE_UNSIGNED_BYTE = 0,
        rr.TEXTURETYPE_UNSIGNED_INT = 0,
        rr.TEXTURETYPE_FLOAT = 1,
        rr.TEXTURETYPE_HALF_FLOAT = 2,
        rr.TEXTURETYPE_BYTE = 3,
        rr.TEXTURETYPE_SHORT = 4,
        rr.TEXTURETYPE_UNSIGNED_SHORT = 5,
        rr.TEXTURETYPE_INT = 6,
        rr.TEXTURETYPE_UNSIGNED_INTEGER = 7,
        rr.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8,
        rr.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9,
        rr.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10,
        rr.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11,
        rr.TEXTURETYPE_UNSIGNED_INT_24_8 = 12,
        rr.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13,
        rr.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14,
        rr.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15,
        rr.TEXTURE_NEAREST_SAMPLINGMODE = 1,
        rr.TEXTURE_BILINEAR_SAMPLINGMODE = 2,
        rr.TEXTURE_TRILINEAR_SAMPLINGMODE = 3,
        rr.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8,
        rr.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11,
        rr.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3,
        rr.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4,
        rr.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5,
        rr.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6,
        rr.TEXTURE_NEAREST_LINEAR = 7,
        rr.TEXTURE_NEAREST_NEAREST = 1,
        rr.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9,
        rr.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10,
        rr.TEXTURE_LINEAR_LINEAR = 2,
        rr.TEXTURE_LINEAR_NEAREST = 12,
        rr.TEXTURE_EXPLICIT_MODE = 0,
        rr.TEXTURE_SPHERICAL_MODE = 1,
        rr.TEXTURE_PLANAR_MODE = 2,
        rr.TEXTURE_CUBIC_MODE = 3,
        rr.TEXTURE_PROJECTION_MODE = 4,
        rr.TEXTURE_SKYBOX_MODE = 5,
        rr.TEXTURE_INVCUBIC_MODE = 6,
        rr.TEXTURE_EQUIRECTANGULAR_MODE = 7,
        rr.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8,
        rr.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9,
        rr.SCALEMODE_FLOOR = 1,
        rr.SCALEMODE_NEAREST = 2,
        rr.SCALEMODE_CEILING = 3,
        rr._RescalePostProcessFactory = null,
        rr._RenderPassIdCounter = 0,
        function(e) {
            e[e.LOCAL = 0] = "LOCAL",
            e[e.WORLD = 1] = "WORLD",
            e[e.BONE = 2] = "BONE"
        }(nr || (nr = {}));
        class or {
        }
        or.X = new Di(1,0,0),
        or.Y = new Di(0,1,0),
        or.Z = new Di(0,0,1),
        function(e) {
            e[e.X = 0] = "X",
            e[e.Y = 1] = "Y",
            e[e.Z = 2] = "Z"
        }(ar || (ar = {}));
        const hr = Oi.Compose(Di.One(), Fi.FromEulerAngles(0, Math.PI, 0), Di.Zero());
        class lr extends Gi {
            get billboardMode() {
                return this._billboardMode
            }
            set billboardMode(e) {
                this._billboardMode !== e && (this._billboardMode = e,
                this._cache.useBillboardPosition = !!(this._billboardMode & lr.BILLBOARDMODE_USE_POSITION),
                this._computeUseBillboardPath())
            }
            get preserveParentRotationForBillboard() {
                return this._preserveParentRotationForBillboard
            }
            set preserveParentRotationForBillboard(e) {
                e !== this._preserveParentRotationForBillboard && (this._preserveParentRotationForBillboard = e,
                this._computeUseBillboardPath())
            }
            _computeUseBillboardPath() {
                this._cache.useBillboardPath = this._billboardMode !== lr.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard
            }
            get infiniteDistance() {
                return this._infiniteDistance
            }
            set infiniteDistance(e) {
                this._infiniteDistance !== e && (this._infiniteDistance = e)
            }
            constructor(e, t=null, i=!0) {
                super(e, t),
                this._forward = new Di(0,0,1),
                this._up = new Di(0,1,0),
                this._right = new Di(1,0,0),
                this._position = Di.Zero(),
                this._rotation = Di.Zero(),
                this._rotationQuaternion = null,
                this._scaling = Di.One(),
                this._transformToBoneReferal = null,
                this._isAbsoluteSynced = !1,
                this._billboardMode = lr.BILLBOARDMODE_NONE,
                this._preserveParentRotationForBillboard = !1,
                this.scalingDeterminant = 1,
                this._infiniteDistance = !1,
                this.ignoreNonUniformScaling = !1,
                this.reIntegrateRotationIntoRotationQuaternion = !1,
                this._poseMatrix = null,
                this._localMatrix = Oi.Zero(),
                this._usePivotMatrix = !1,
                this._absolutePosition = Di.Zero(),
                this._absoluteScaling = Di.Zero(),
                this._absoluteRotationQuaternion = Fi.Identity(),
                this._pivotMatrix = Oi.Identity(),
                this._postMultiplyPivotMatrix = !1,
                this._isWorldMatrixFrozen = !1,
                this._indexInSceneTransformNodesArray = -1,
                this.onAfterWorldMatrixUpdateObservable = new Ue,
                this._nonUniformScaling = !1,
                i && this.getScene().addTransformNode(this)
            }
            getClassName() {
                return "TransformNode"
            }
            get position() {
                return this._position
            }
            set position(e) {
                this._position = e,
                this._isDirty = !0
            }
            isUsingPivotMatrix() {
                return this._usePivotMatrix
            }
            isUsingPostMultiplyPivotMatrix() {
                return this._postMultiplyPivotMatrix
            }
            get rotation() {
                return this._rotation
            }
            set rotation(e) {
                this._rotation = e,
                this._rotationQuaternion = null,
                this._isDirty = !0
            }
            get scaling() {
                return this._scaling
            }
            set scaling(e) {
                this._scaling = e,
                this._isDirty = !0
            }
            get rotationQuaternion() {
                return this._rotationQuaternion
            }
            set rotationQuaternion(e) {
                this._rotationQuaternion = e,
                e && this._rotation.setAll(0),
                this._isDirty = !0
            }
            get forward() {
                return Di.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward),
                this._forward.normalize()
            }
            get up() {
                return Di.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up),
                this._up.normalize()
            }
            get right() {
                return Di.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right),
                this._right.normalize()
            }
            updatePoseMatrix(e) {
                return this._poseMatrix ? (this._poseMatrix.copyFrom(e),
                this) : (this._poseMatrix = e.clone(),
                this)
            }
            getPoseMatrix() {
                return this._poseMatrix || (this._poseMatrix = Oi.Identity()),
                this._poseMatrix
            }
            _isSynchronized() {
                const e = this._cache;
                return !(this._billboardMode !== e.billboardMode || this._billboardMode !== lr.BILLBOARDMODE_NONE || e.pivotMatrixUpdated || this._infiniteDistance || this._position._isDirty || this._scaling._isDirty || this._rotationQuaternion && this._rotationQuaternion._isDirty || this._rotation._isDirty)
            }
            _initCache() {
                super._initCache();
                const e = this._cache;
                e.localMatrixUpdated = !1,
                e.billboardMode = -1,
                e.infiniteDistance = !1,
                e.useBillboardPosition = !1,
                e.useBillboardPath = !1
            }
            get absolutePosition() {
                return this.getAbsolutePosition()
            }
            get absoluteScaling() {
                return this._syncAbsoluteScalingAndRotation(),
                this._absoluteScaling
            }
            get absoluteRotationQuaternion() {
                return this._syncAbsoluteScalingAndRotation(),
                this._absoluteRotationQuaternion
            }
            setPreTransformMatrix(e) {
                return this.setPivotMatrix(e, !1)
            }
            setPivotMatrix(e, t=!0) {
                return this._pivotMatrix.copyFrom(e),
                this._usePivotMatrix = !this._pivotMatrix.isIdentity(),
                this._cache.pivotMatrixUpdated = !0,
                this._postMultiplyPivotMatrix = t,
                this._postMultiplyPivotMatrix && (this._pivotMatrixInverse ? this._pivotMatrix.invertToRef(this._pivotMatrixInverse) : this._pivotMatrixInverse = Oi.Invert(this._pivotMatrix)),
                this
            }
            getPivotMatrix() {
                return this._pivotMatrix
            }
            instantiateHierarchy(e=null, t, i) {
                const s = this.clone("Clone of " + (this.name || this.id), e || this.parent, !0);
                s && i && i(this, s);
                for (const e of this.getChildTransformNodes(!0))
                    e.instantiateHierarchy(s, t, i);
                return s
            }
            freezeWorldMatrix(e=null, t=!1) {
                return e ? t ? (this._rotation.setAll(0),
                this._rotationQuaternion = this._rotationQuaternion || Fi.Identity(),
                e.decompose(this._scaling, this._rotationQuaternion, this._position),
                this.computeWorldMatrix(!0)) : (this._worldMatrix = e,
                this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]),
                this._afterComputeWorldMatrix()) : (this._isWorldMatrixFrozen = !1,
                this.computeWorldMatrix(!0)),
                this._isDirty = !1,
                this._isWorldMatrixFrozen = !0,
                this
            }
            unfreezeWorldMatrix() {
                return this._isWorldMatrixFrozen = !1,
                this.computeWorldMatrix(!0),
                this
            }
            get isWorldMatrixFrozen() {
                return this._isWorldMatrixFrozen
            }
            getAbsolutePosition() {
                return this.computeWorldMatrix(),
                this._absolutePosition
            }
            setAbsolutePosition(e) {
                if (!e)
                    return this;
                let t, i, s;
                if (void 0 === e.x) {
                    if (arguments.length < 3)
                        return this;
                    t = arguments[0],
                    i = arguments[1],
                    s = arguments[2]
                } else
                    t = e.x,
                    i = e.y,
                    s = e.z;
                if (this.parent) {
                    const e = Bi.Matrix[0];
                    this.parent.getWorldMatrix().invertToRef(e),
                    Di.TransformCoordinatesFromFloatsToRef(t, i, s, e, this.position)
                } else
                    this.position.x = t,
                    this.position.y = i,
                    this.position.z = s;
                return this._absolutePosition.copyFrom(e),
                this
            }
            setPositionWithLocalVector(e) {
                return this.computeWorldMatrix(),
                this.position = Di.TransformNormal(e, this._localMatrix),
                this
            }
            getPositionExpressedInLocalSpace() {
                this.computeWorldMatrix();
                const e = Bi.Matrix[0];
                return this._localMatrix.invertToRef(e),
                Di.TransformNormal(this.position, e)
            }
            locallyTranslate(e) {
                return this.computeWorldMatrix(!0),
                this.position = Di.TransformCoordinates(e, this._localMatrix),
                this
            }
            lookAt(e, t=0, i=0, s=0, r=nr.LOCAL) {
                const n = lr._LookAtVectorCache
                  , a = r === nr.LOCAL ? this.position : this.getAbsolutePosition();
                if (e.subtractToRef(a, n),
                this.setDirection(n, t, i, s),
                r === nr.WORLD && this.parent)
                    if (this.rotationQuaternion) {
                        const e = Bi.Matrix[0];
                        this.rotationQuaternion.toRotationMatrix(e);
                        const t = Bi.Matrix[1];
                        this.parent.getWorldMatrix().getRotationMatrixToRef(t),
                        t.invert(),
                        e.multiplyToRef(t, e),
                        this.rotationQuaternion.fromRotationMatrix(e)
                    } else {
                        const e = Bi.Quaternion[0];
                        Fi.FromEulerVectorToRef(this.rotation, e);
                        const t = Bi.Matrix[0];
                        e.toRotationMatrix(t);
                        const i = Bi.Matrix[1];
                        this.parent.getWorldMatrix().getRotationMatrixToRef(i),
                        i.invert(),
                        t.multiplyToRef(i, t),
                        e.fromRotationMatrix(t),
                        e.toEulerAnglesToRef(this.rotation)
                    }
                return this
            }
            getDirection(e) {
                const t = Di.Zero();
                return this.getDirectionToRef(e, t),
                t
            }
            getDirectionToRef(e, t) {
                return Di.TransformNormalToRef(e, this.getWorldMatrix(), t),
                this
            }
            setDirection(e, t=0, i=0, s=0) {
                const r = -Math.atan2(e.z, e.x) + Math.PI / 2
                  , n = Math.sqrt(e.x * e.x + e.z * e.z)
                  , a = -Math.atan2(e.y, n);
                return this.rotationQuaternion ? Fi.RotationYawPitchRollToRef(r + t, a + i, s, this.rotationQuaternion) : (this.rotation.x = a + i,
                this.rotation.y = r + t,
                this.rotation.z = s),
                this
            }
            setPivotPoint(e, t=nr.LOCAL) {
                0 == this.getScene().getRenderId() && this.computeWorldMatrix(!0);
                const i = this.getWorldMatrix();
                if (t == nr.WORLD) {
                    const t = Bi.Matrix[0];
                    i.invertToRef(t),
                    e = Di.TransformCoordinates(e, t)
                }
                return this.setPivotMatrix(Oi.Translation(-e.x, -e.y, -e.z), !0)
            }
            getPivotPoint() {
                const e = Di.Zero();
                return this.getPivotPointToRef(e),
                e
            }
            getPivotPointToRef(e) {
                return e.x = -this._pivotMatrix.m[12],
                e.y = -this._pivotMatrix.m[13],
                e.z = -this._pivotMatrix.m[14],
                this
            }
            getAbsolutePivotPoint() {
                const e = Di.Zero();
                return this.getAbsolutePivotPointToRef(e),
                e
            }
            getAbsolutePivotPointToRef(e) {
                return this.getPivotPointToRef(e),
                Di.TransformCoordinatesToRef(e, this.getWorldMatrix(), e),
                this
            }
            markAsDirty(e) {
                if (this._isDirty)
                    return this;
                if (this._children)
                    for (const t of this._children)
                        t.markAsDirty(e);
                return super.markAsDirty(e)
            }
            setParent(e, t=!1, i=!1) {
                if (!e && !this.parent)
                    return this;
                const s = Bi.Quaternion[0]
                  , r = Bi.Vector3[0]
                  , n = Bi.Vector3[1]
                  , a = Bi.Matrix[1];
                Oi.IdentityToRef(a);
                const o = Bi.Matrix[0];
                this.computeWorldMatrix(!0);
                let h = this.rotationQuaternion;
                return h || (h = lr._TmpRotation,
                Fi.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, h)),
                Oi.ComposeToRef(this.scaling, h, this.position, o),
                this.parent && o.multiplyToRef(this.parent.computeWorldMatrix(!0), o),
                e && (e.computeWorldMatrix(!0).invertToRef(a),
                o.multiplyToRef(a, o)),
                o.decompose(n, s, r, t ? this : void 0),
                this.rotationQuaternion ? this.rotationQuaternion.copyFrom(s) : s.toEulerAnglesToRef(this.rotation),
                this.scaling.copyFrom(n),
                this.position.copyFrom(r),
                this.parent = e,
                i && this.setPivotMatrix(Oi.Identity()),
                this
            }
            get nonUniformScaling() {
                return this._nonUniformScaling
            }
            _updateNonUniformScalingState(e) {
                return this._nonUniformScaling !== e && (this._nonUniformScaling = e,
                !0)
            }
            attachToBone(e, t) {
                return this._currentParentWhenAttachingToBone = this.parent,
                this._transformToBoneReferal = t,
                this.parent = e,
                e.getSkeleton().prepare(!0),
                e.getFinalMatrix().determinant() < 0 && (this.scalingDeterminant *= -1),
                this
            }
            detachFromBone(e=!1) {
                return this.parent ? (this.parent.getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1),
                this._transformToBoneReferal = null,
                this.parent = e ? this._currentParentWhenAttachingToBone : null,
                this) : (e && (this.parent = this._currentParentWhenAttachingToBone),
                this)
            }
            rotate(e, t, i) {
                let s;
                if (e.normalize(),
                this.rotationQuaternion || (this.rotationQuaternion = this.rotation.toQuaternion(),
                this.rotation.setAll(0)),
                i && i !== nr.LOCAL) {
                    if (this.parent) {
                        const i = this.parent.getWorldMatrix()
                          , s = Bi.Matrix[0];
                        i.invertToRef(s),
                        e = Di.TransformNormal(e, s),
                        i.determinant() < 0 && (t *= -1)
                    }
                    s = Fi.RotationAxisToRef(e, t, lr._RotationAxisCache),
                    s.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion)
                } else
                    s = Fi.RotationAxisToRef(e, t, lr._RotationAxisCache),
                    this.rotationQuaternion.multiplyToRef(s, this.rotationQuaternion);
                return this
            }
            rotateAround(e, t, i) {
                t.normalize(),
                this.rotationQuaternion || (this.rotationQuaternion = Fi.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z),
                this.rotation.setAll(0));
                const s = Bi.Vector3[0]
                  , r = Bi.Vector3[1]
                  , n = Bi.Vector3[2]
                  , a = Bi.Quaternion[0]
                  , o = Bi.Matrix[0]
                  , h = Bi.Matrix[1]
                  , l = Bi.Matrix[2]
                  , c = Bi.Matrix[3];
                return e.subtractToRef(this.position, s),
                Oi.TranslationToRef(s.x, s.y, s.z, o),
                Oi.TranslationToRef(-s.x, -s.y, -s.z, h),
                Oi.RotationAxisToRef(t, i, l),
                h.multiplyToRef(l, c),
                c.multiplyToRef(o, c),
                c.decompose(r, a, n),
                this.position.addInPlace(n),
                a.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion),
                this
            }
            translate(e, t, i) {
                const s = e.scale(t);
                if (i && i !== nr.LOCAL)
                    this.setAbsolutePosition(this.getAbsolutePosition().add(s));
                else {
                    const e = this.getPositionExpressedInLocalSpace().add(s);
                    this.setPositionWithLocalVector(e)
                }
                return this
            }
            addRotation(e, t, i) {
                let s;
                this.rotationQuaternion ? s = this.rotationQuaternion : (s = Bi.Quaternion[1],
                Fi.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, s));
                const r = Bi.Quaternion[0];
                return Fi.RotationYawPitchRollToRef(t, e, i, r),
                s.multiplyInPlace(r),
                this.rotationQuaternion || s.toEulerAnglesToRef(this.rotation),
                this
            }
            _getEffectiveParent() {
                return this.parent
            }
            isWorldMatrixCameraDependent() {
                return this._infiniteDistance && !this.parent || this._billboardMode !== lr.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard
            }
            computeWorldMatrix(e=!1, t=null) {
                if (this._isWorldMatrixFrozen && !this._isDirty)
                    return this._worldMatrix;
                const i = this.getScene().getRenderId();
                if (!this._isDirty && !e && (this._currentRenderId === i || this.isSynchronized()))
                    return this._currentRenderId = i,
                    this._worldMatrix;
                t = t || this.getScene().activeCamera,
                this._updateCache();
                const s = this._cache;
                s.pivotMatrixUpdated = !1,
                s.billboardMode = this.billboardMode,
                s.infiniteDistance = this.infiniteDistance,
                s.parent = this._parentNode,
                this._currentRenderId = i,
                this._childUpdateId += 1,
                this._isDirty = !1,
                this._position._isDirty = !1,
                this._rotation._isDirty = !1,
                this._scaling._isDirty = !1;
                const r = this._getEffectiveParent()
                  , n = lr._TmpScaling;
                let a, o = this._position;
                if (this._infiniteDistance && !this.parent && t) {
                    const e = t.getWorldMatrix()
                      , i = new Di(e.m[12],e.m[13],e.m[14]);
                    o = lr._TmpTranslation,
                    o.copyFromFloats(this._position.x + i.x, this._position.y + i.y, this._position.z + i.z)
                }
                if (n.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant),
                this._rotationQuaternion ? (this._rotationQuaternion._isDirty = !1,
                a = this._rotationQuaternion,
                this.reIntegrateRotationIntoRotationQuaternion && this.rotation.lengthSquared() && (this._rotationQuaternion.multiplyInPlace(Fi.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z)),
                this._rotation.copyFromFloats(0, 0, 0))) : (a = lr._TmpRotation,
                Fi.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, a)),
                this._usePivotMatrix) {
                    const e = Bi.Matrix[1];
                    Oi.ScalingToRef(n.x, n.y, n.z, e);
                    const t = Bi.Matrix[0];
                    a.toRotationMatrix(t),
                    this._pivotMatrix.multiplyToRef(e, Bi.Matrix[4]),
                    Bi.Matrix[4].multiplyToRef(t, this._localMatrix),
                    this._postMultiplyPivotMatrix && this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix),
                    this._localMatrix.addTranslationFromFloats(o.x, o.y, o.z)
                } else
                    Oi.ComposeToRef(n, a, o, this._localMatrix);
                if (r && r.getWorldMatrix) {
                    if (e && r.computeWorldMatrix(e),
                    s.useBillboardPath) {
                        if (this._transformToBoneReferal) {
                            const e = this.parent;
                            e.getSkeleton().prepare(),
                            e.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), Bi.Matrix[7])
                        } else
                            Bi.Matrix[7].copyFrom(r.getWorldMatrix());
                        const e = Bi.Vector3[5]
                          , t = Bi.Vector3[6]
                          , i = Bi.Quaternion[0];
                        Bi.Matrix[7].decompose(t, i, e),
                        Oi.ScalingToRef(t.x, t.y, t.z, Bi.Matrix[7]),
                        Bi.Matrix[7].setTranslation(e),
                        lr.BillboardUseParentOrientation && (this._position.applyRotationQuaternionToRef(i, e),
                        this._localMatrix.setTranslation(e)),
                        this._localMatrix.multiplyToRef(Bi.Matrix[7], this._worldMatrix)
                    } else if (this._transformToBoneReferal) {
                        const e = this.parent;
                        e.getSkeleton().prepare(),
                        this._localMatrix.multiplyToRef(e.getFinalMatrix(), Bi.Matrix[6]),
                        Bi.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix)
                    } else
                        this._localMatrix.multiplyToRef(r.getWorldMatrix(), this._worldMatrix);
                    this._markSyncedWithParent()
                } else
                    this._worldMatrix.copyFrom(this._localMatrix);
                if (s.useBillboardPath && t && this.billboardMode && !s.useBillboardPosition) {
                    const e = Bi.Vector3[0];
                    if (this._worldMatrix.getTranslationToRef(e),
                    Bi.Matrix[1].copyFrom(t.getViewMatrix()),
                    this._scene.useRightHandedSystem && Bi.Matrix[1].multiplyToRef(hr, Bi.Matrix[1]),
                    Bi.Matrix[1].setTranslationFromFloats(0, 0, 0),
                    Bi.Matrix[1].invertToRef(Bi.Matrix[0]),
                    (this.billboardMode & lr.BILLBOARDMODE_ALL) !== lr.BILLBOARDMODE_ALL) {
                        Bi.Matrix[0].decompose(void 0, Bi.Quaternion[0], void 0);
                        const e = Bi.Vector3[1];
                        Bi.Quaternion[0].toEulerAnglesToRef(e),
                        (this.billboardMode & lr.BILLBOARDMODE_X) !== lr.BILLBOARDMODE_X && (e.x = 0),
                        (this.billboardMode & lr.BILLBOARDMODE_Y) !== lr.BILLBOARDMODE_Y && (e.y = 0),
                        (this.billboardMode & lr.BILLBOARDMODE_Z) !== lr.BILLBOARDMODE_Z && (e.z = 0),
                        Oi.RotationYawPitchRollToRef(e.y, e.x, e.z, Bi.Matrix[0])
                    }
                    this._worldMatrix.setTranslationFromFloats(0, 0, 0),
                    this._worldMatrix.multiplyToRef(Bi.Matrix[0], this._worldMatrix),
                    this._worldMatrix.setTranslation(Bi.Vector3[0])
                } else if (s.useBillboardPath && t && s.useBillboardPosition) {
                    const e = Bi.Vector3[0];
                    this._worldMatrix.getTranslationToRef(e);
                    const i = t.globalPosition;
                    this._worldMatrix.invertToRef(Bi.Matrix[1]);
                    const s = Bi.Vector3[1];
                    Di.TransformCoordinatesToRef(i, Bi.Matrix[1], s),
                    s.normalize();
                    const r = -Math.atan2(s.z, s.x) + Math.PI / 2
                      , n = Math.sqrt(s.x * s.x + s.z * s.z)
                      , a = -Math.atan2(s.y, n);
                    if (Fi.RotationYawPitchRollToRef(r, a, 0, Bi.Quaternion[0]),
                    (this.billboardMode & lr.BILLBOARDMODE_ALL) !== lr.BILLBOARDMODE_ALL) {
                        const e = Bi.Vector3[1];
                        Bi.Quaternion[0].toEulerAnglesToRef(e),
                        (this.billboardMode & lr.BILLBOARDMODE_X) !== lr.BILLBOARDMODE_X && (e.x = 0),
                        (this.billboardMode & lr.BILLBOARDMODE_Y) !== lr.BILLBOARDMODE_Y && (e.y = 0),
                        (this.billboardMode & lr.BILLBOARDMODE_Z) !== lr.BILLBOARDMODE_Z && (e.z = 0),
                        Oi.RotationYawPitchRollToRef(e.y, e.x, e.z, Bi.Matrix[0])
                    } else
                        Oi.FromQuaternionToRef(Bi.Quaternion[0], Bi.Matrix[0]);
                    this._worldMatrix.setTranslationFromFloats(0, 0, 0),
                    this._worldMatrix.multiplyToRef(Bi.Matrix[0], this._worldMatrix),
                    this._worldMatrix.setTranslation(Bi.Vector3[0])
                }
                return this.ignoreNonUniformScaling ? this._updateNonUniformScalingState(!1) : this._scaling.isNonUniformWithinEpsilon(1e-6) ? this._updateNonUniformScalingState(!0) : r && r._nonUniformScaling ? this._updateNonUniformScalingState(r._nonUniformScaling) : this._updateNonUniformScalingState(!1),
                this._afterComputeWorldMatrix(),
                this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]),
                this._isAbsoluteSynced = !1,
                this.onAfterWorldMatrixUpdateObservable.notifyObservers(this),
                this._poseMatrix || (this._poseMatrix = Oi.Invert(this._worldMatrix)),
                this._worldMatrixDeterminantIsDirty = !0,
                this._worldMatrix
            }
            resetLocalMatrix(e=!0) {
                if (this.computeWorldMatrix(),
                e) {
                    const e = this.getChildren();
                    for (let t = 0; t < e.length; ++t) {
                        const i = e[t];
                        if (i) {
                            i.computeWorldMatrix();
                            const e = Bi.Matrix[0];
                            i._localMatrix.multiplyToRef(this._localMatrix, e);
                            const t = Bi.Quaternion[0];
                            e.decompose(i.scaling, t, i.position),
                            i.rotationQuaternion ? i.rotationQuaternion.copyFrom(t) : t.toEulerAnglesToRef(i.rotation)
                        }
                    }
                }
                this.scaling.copyFromFloats(1, 1, 1),
                this.position.copyFromFloats(0, 0, 0),
                this.rotation.copyFromFloats(0, 0, 0),
                this.rotationQuaternion && (this.rotationQuaternion = Fi.Identity()),
                this._worldMatrix = Oi.Identity()
            }
            _afterComputeWorldMatrix() {}
            registerAfterWorldMatrixUpdate(e) {
                return this.onAfterWorldMatrixUpdateObservable.add(e),
                this
            }
            unregisterAfterWorldMatrixUpdate(e) {
                return this.onAfterWorldMatrixUpdateObservable.removeCallback(e),
                this
            }
            getPositionInCameraSpace(e=null) {
                return e || (e = this.getScene().activeCamera),
                Di.TransformCoordinates(this.getAbsolutePosition(), e.getViewMatrix())
            }
            getDistanceToCamera(e=null) {
                return e || (e = this.getScene().activeCamera),
                this.getAbsolutePosition().subtract(e.globalPosition).length()
            }
            clone(e, t, i) {
                const s = ki.Clone(( () => new lr(e,this.getScene())), this);
                if (s.name = e,
                s.id = e,
                t && (s.parent = t),
                !i) {
                    const t = this.getDescendants(!0);
                    for (let i = 0; i < t.length; i++) {
                        const r = t[i];
                        r.clone && r.clone(e + "." + r.name, s)
                    }
                }
                return s
            }
            serialize(e) {
                const t = ki.Serialize(this, e);
                return t.type = this.getClassName(),
                t.uniqueId = this.uniqueId,
                this.parent && this.parent._serializeAsParent(t),
                t.localMatrix = this.getPivotMatrix().asArray(),
                t.isEnabled = this.isEnabled(),
                ki.AppendSerializedAnimations(this, t),
                t.ranges = this.serializeAnimationRanges(),
                t
            }
            static Parse(e, t, i) {
                const s = ki.Parse(( () => new lr(e.name,t)), e, t, i);
                if (e.localMatrix ? s.setPreTransformMatrix(Oi.FromArray(e.localMatrix)) : e.pivotMatrix && s.setPivotMatrix(Oi.FromArray(e.pivotMatrix)),
                s.setEnabled(e.isEnabled),
                s._waitingParsedUniqueId = e.uniqueId,
                void 0 !== e.parentId && (s._waitingParentId = e.parentId),
                void 0 !== e.parentInstanceIndex && (s._waitingParentInstanceIndex = e.parentInstanceIndex),
                e.animations) {
                    for (let t = 0; t < e.animations.length; t++) {
                        const i = e.animations[t]
                          , r = Re("BABYLON.Animation");
                        r && s.animations.push(r.Parse(i))
                    }
                    Gi.ParseAnimationRanges(s, e, t)
                }
                return e.autoAnimate && t.beginAnimation(s, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1),
                s
            }
            getChildTransformNodes(e, t) {
                const i = [];
                return this._getDescendants(i, e, (e => (!t || t(e)) && e instanceof lr)),
                i
            }
            dispose(e, t=!1) {
                if (this.getScene().stopAnimation(this),
                this.getScene().removeTransformNode(this),
                this._parentContainer) {
                    const e = this._parentContainer.transformNodes.indexOf(this);
                    e > -1 && this._parentContainer.transformNodes.splice(e, 1),
                    this._parentContainer = null
                }
                if (this.onAfterWorldMatrixUpdateObservable.clear(),
                e) {
                    const e = this.getChildTransformNodes(!0);
                    for (const t of e)
                        t.parent = null,
                        t.computeWorldMatrix(!0)
                }
                super.dispose(e, t)
            }
            normalizeToUnitCube(e=!0, t=!1, i) {
                let s = null
                  , r = null;
                t && (this.rotationQuaternion ? (r = this.rotationQuaternion.clone(),
                this.rotationQuaternion.copyFromFloats(0, 0, 0, 1)) : this.rotation && (s = this.rotation.clone(),
                this.rotation.copyFromFloats(0, 0, 0)));
                const n = this.getHierarchyBoundingVectors(e, i)
                  , a = n.max.subtract(n.min)
                  , o = Math.max(a.x, a.y, a.z);
                if (0 === o)
                    return this;
                const h = 1 / o;
                return this.scaling.scaleInPlace(h),
                t && (this.rotationQuaternion && r ? this.rotationQuaternion.copyFrom(r) : this.rotation && s && this.rotation.copyFrom(s)),
                this
            }
            _syncAbsoluteScalingAndRotation() {
                this._isAbsoluteSynced || (this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion),
                this._isAbsoluteSynced = !0)
            }
        }
        lr.BILLBOARDMODE_NONE = 0,
        lr.BILLBOARDMODE_X = 1,
        lr.BILLBOARDMODE_Y = 2,
        lr.BILLBOARDMODE_Z = 4,
        lr.BILLBOARDMODE_ALL = 7,
        lr.BILLBOARDMODE_USE_POSITION = 128,
        lr.BillboardUseParentOrientation = !1,
        lr._TmpRotation = Fi.Zero(),
        lr._TmpScaling = Di.Zero(),
        lr._TmpTranslation = Di.Zero(),
        lr._LookAtVectorCache = new Di(0,0,0),
        lr._RotationAxisCache = new Fi,
        pi([Si("position")], lr.prototype, "_position", void 0),
        pi([Si("rotation")], lr.prototype, "_rotation", void 0),
        pi([yi(10, "rotationQuaternion")], lr.prototype, "_rotationQuaternion", void 0),
        pi([Si("scaling")], lr.prototype, "_scaling", void 0),
        pi([xi("billboardMode")], lr.prototype, "_billboardMode", void 0),
        pi([xi()], lr.prototype, "scalingDeterminant", void 0),
        pi([xi("infiniteDistance")], lr.prototype, "_infiniteDistance", void 0),
        pi([xi()], lr.prototype, "ignoreNonUniformScaling", void 0),
        pi([xi()], lr.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0);
        class cr {
            constructor() {
                this._checkCollisions = !1,
                this._collisionMask = -1,
                this._collisionGroup = -1,
                this._surroundingMeshes = null,
                this._collider = null,
                this._oldPositionForCollisions = new Di(0,0,0),
                this._diffPositionForCollisions = new Di(0,0,0),
                this._collisionResponse = !0
            }
        }
        class ur {
            constructor() {
                this.facetNb = 0,
                this.partitioningSubdivisions = 10,
                this.partitioningBBoxRatio = 1.01,
                this.facetDataEnabled = !1,
                this.facetParameters = {},
                this.bbSize = Di.Zero(),
                this.subDiv = {
                    max: 1,
                    X: 1,
                    Y: 1,
                    Z: 1
                },
                this.facetDepthSort = !1,
                this.facetDepthSortEnabled = !1
            }
        }
        class dr {
            constructor() {
                this._hasVertexAlpha = !1,
                this._useVertexColors = !0,
                this._numBoneInfluencers = 4,
                this._applyFog = !0,
                this._receiveShadows = !1,
                this._facetData = new ur,
                this._visibility = 1,
                this._skeleton = null,
                this._layerMask = 268435455,
                this._computeBonesUsingShaders = !0,
                this._isActive = !1,
                this._onlyForInstances = !1,
                this._isActiveIntermediate = !1,
                this._onlyForInstancesIntermediate = !1,
                this._actAsRegularMesh = !1,
                this._currentLOD = null,
                this._currentLODIsUpToDate = !1,
                this._collisionRetryCount = 3,
                this._morphTargetManager = null,
                this._renderingGroupId = 0,
                this._bakedVertexAnimationManager = null,
                this._material = null,
                this._positions = null,
                this._pointerOverDisableMeshTesting = !1,
                this._meshCollisionData = new cr,
                this._enableDistantPicking = !1,
                this._rawBoundingInfo = null
            }
        }
        class fr extends lr {
            static get BILLBOARDMODE_NONE() {
                return lr.BILLBOARDMODE_NONE
            }
            static get BILLBOARDMODE_X() {
                return lr.BILLBOARDMODE_X
            }
            static get BILLBOARDMODE_Y() {
                return lr.BILLBOARDMODE_Y
            }
            static get BILLBOARDMODE_Z() {
                return lr.BILLBOARDMODE_Z
            }
            static get BILLBOARDMODE_ALL() {
                return lr.BILLBOARDMODE_ALL
            }
            static get BILLBOARDMODE_USE_POSITION() {
                return lr.BILLBOARDMODE_USE_POSITION
            }
            get facetNb() {
                return this._internalAbstractMeshDataInfo._facetData.facetNb
            }
            get partitioningSubdivisions() {
                return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions
            }
            set partitioningSubdivisions(e) {
                this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = e
            }
            get partitioningBBoxRatio() {
                return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio
            }
            set partitioningBBoxRatio(e) {
                this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = e
            }
            get mustDepthSortFacets() {
                return this._internalAbstractMeshDataInfo._facetData.facetDepthSort
            }
            set mustDepthSortFacets(e) {
                this._internalAbstractMeshDataInfo._facetData.facetDepthSort = e
            }
            get facetDepthSortFrom() {
                return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom
            }
            set facetDepthSortFrom(e) {
                this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = e
            }
            get collisionRetryCount() {
                return this._internalAbstractMeshDataInfo._collisionRetryCount
            }
            set collisionRetryCount(e) {
                this._internalAbstractMeshDataInfo._collisionRetryCount = e
            }
            get isFacetDataEnabled() {
                return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled
            }
            get morphTargetManager() {
                return this._internalAbstractMeshDataInfo._morphTargetManager
            }
            set morphTargetManager(e) {
                this._internalAbstractMeshDataInfo._morphTargetManager !== e && (this._internalAbstractMeshDataInfo._morphTargetManager = e,
                this._syncGeometryWithMorphTargetManager())
            }
            get bakedVertexAnimationManager() {
                return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager
            }
            set bakedVertexAnimationManager(e) {
                this._internalAbstractMeshDataInfo._bakedVertexAnimationManager !== e && (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = e,
                this._markSubMeshesAsAttributesDirty())
            }
            _syncGeometryWithMorphTargetManager() {}
            _updateNonUniformScalingState(e) {
                return !!super._updateNonUniformScalingState(e) && (this._markSubMeshesAsMiscDirty(),
                !0)
            }
            get rawBoundingInfo() {
                return this._internalAbstractMeshDataInfo._rawBoundingInfo
            }
            set rawBoundingInfo(e) {
                this._internalAbstractMeshDataInfo._rawBoundingInfo = e
            }
            set onCollide(e) {
                this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver && this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver),
                this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(e)
            }
            set onCollisionPositionChange(e) {
                this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver && this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver),
                this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(e)
            }
            get visibility() {
                return this._internalAbstractMeshDataInfo._visibility
            }
            set visibility(e) {
                if (this._internalAbstractMeshDataInfo._visibility === e)
                    return;
                const t = this._internalAbstractMeshDataInfo._visibility;
                this._internalAbstractMeshDataInfo._visibility = e,
                (1 === t && 1 !== e || 1 !== t && 1 === e) && this._markSubMeshesAsDirty((e => {
                    e.markAsMiscDirty(),
                    e.markAsPrePassDirty()
                }
                ))
            }
            get pointerOverDisableMeshTesting() {
                return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting
            }
            set pointerOverDisableMeshTesting(e) {
                this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting = e
            }
            get renderingGroupId() {
                return this._internalAbstractMeshDataInfo._renderingGroupId
            }
            set renderingGroupId(e) {
                this._internalAbstractMeshDataInfo._renderingGroupId = e
            }
            get material() {
                return this._internalAbstractMeshDataInfo._material
            }
            set material(e) {
                this._internalAbstractMeshDataInfo._material !== e && (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap && (this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0),
                this._internalAbstractMeshDataInfo._material = e,
                e && e.meshMap && (e.meshMap[this.uniqueId] = this),
                this.onMaterialChangedObservable.hasObservers() && this.onMaterialChangedObservable.notifyObservers(this),
                this.subMeshes && (this.resetDrawCache(),
                this._unBindEffect()))
            }
            getMaterialForRenderPass(e) {
                return this._internalAbstractMeshDataInfo._materialForRenderPass?.[e]
            }
            setMaterialForRenderPass(e, t) {
                this.resetDrawCache(e),
                this._internalAbstractMeshDataInfo._materialForRenderPass || (this._internalAbstractMeshDataInfo._materialForRenderPass = []),
                this._internalAbstractMeshDataInfo._materialForRenderPass[e] = t
            }
            get receiveShadows() {
                return this._internalAbstractMeshDataInfo._receiveShadows
            }
            set receiveShadows(e) {
                this._internalAbstractMeshDataInfo._receiveShadows !== e && (this._internalAbstractMeshDataInfo._receiveShadows = e,
                this._markSubMeshesAsLightDirty())
            }
            get hasVertexAlpha() {
                return this._internalAbstractMeshDataInfo._hasVertexAlpha
            }
            set hasVertexAlpha(e) {
                this._internalAbstractMeshDataInfo._hasVertexAlpha !== e && (this._internalAbstractMeshDataInfo._hasVertexAlpha = e,
                this._markSubMeshesAsAttributesDirty(),
                this._markSubMeshesAsMiscDirty())
            }
            get useVertexColors() {
                return this._internalAbstractMeshDataInfo._useVertexColors
            }
            set useVertexColors(e) {
                this._internalAbstractMeshDataInfo._useVertexColors !== e && (this._internalAbstractMeshDataInfo._useVertexColors = e,
                this._markSubMeshesAsAttributesDirty())
            }
            get computeBonesUsingShaders() {
                return this._internalAbstractMeshDataInfo._computeBonesUsingShaders
            }
            set computeBonesUsingShaders(e) {
                this._internalAbstractMeshDataInfo._computeBonesUsingShaders !== e && (this._internalAbstractMeshDataInfo._computeBonesUsingShaders = e,
                this._markSubMeshesAsAttributesDirty())
            }
            get numBoneInfluencers() {
                return this._internalAbstractMeshDataInfo._numBoneInfluencers
            }
            set numBoneInfluencers(e) {
                this._internalAbstractMeshDataInfo._numBoneInfluencers !== e && (this._internalAbstractMeshDataInfo._numBoneInfluencers = e,
                this._markSubMeshesAsAttributesDirty())
            }
            get applyFog() {
                return this._internalAbstractMeshDataInfo._applyFog
            }
            set applyFog(e) {
                this._internalAbstractMeshDataInfo._applyFog !== e && (this._internalAbstractMeshDataInfo._applyFog = e,
                this._markSubMeshesAsMiscDirty())
            }
            get enableDistantPicking() {
                return this._internalAbstractMeshDataInfo._enableDistantPicking
            }
            set enableDistantPicking(e) {
                this._internalAbstractMeshDataInfo._enableDistantPicking = e
            }
            get layerMask() {
                return this._internalAbstractMeshDataInfo._layerMask
            }
            set layerMask(e) {
                e !== this._internalAbstractMeshDataInfo._layerMask && (this._internalAbstractMeshDataInfo._layerMask = e,
                this._resyncLightSources())
            }
            get collisionMask() {
                return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask
            }
            set collisionMask(e) {
                this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = isNaN(e) ? -1 : e
            }
            get collisionResponse() {
                return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse
            }
            set collisionResponse(e) {
                this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = e
            }
            get collisionGroup() {
                return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup
            }
            set collisionGroup(e) {
                this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = isNaN(e) ? -1 : e
            }
            get surroundingMeshes() {
                return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes
            }
            set surroundingMeshes(e) {
                this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = e
            }
            get lightSources() {
                return this._lightSources
            }
            get _positions() {
                return null
            }
            set skeleton(e) {
                const t = this._internalAbstractMeshDataInfo._skeleton;
                t && t.needInitialSkinMatrix && t._unregisterMeshWithPoseMatrix(this),
                e && e.needInitialSkinMatrix && e._registerMeshWithPoseMatrix(this),
                this._internalAbstractMeshDataInfo._skeleton = e,
                this._internalAbstractMeshDataInfo._skeleton || (this._bonesTransformMatrices = null),
                this._markSubMeshesAsAttributesDirty()
            }
            get skeleton() {
                return this._internalAbstractMeshDataInfo._skeleton
            }
            constructor(e, t=null) {
                switch (super(e, t, !1),
                this._internalAbstractMeshDataInfo = new dr,
                this._waitingMaterialId = null,
                this.cullingStrategy = fr.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY,
                this.onCollideObservable = new Ue,
                this.onCollisionPositionChangeObservable = new Ue,
                this.onMaterialChangedObservable = new Ue,
                this.definedFacingForward = !0,
                this._occlusionQuery = null,
                this._renderingGroup = null,
                this.alphaIndex = Number.MAX_VALUE,
                this.isVisible = !0,
                this.isPickable = !0,
                this.isNearPickable = !1,
                this.isNearGrabbable = !1,
                this.showSubMeshesBoundingBox = !1,
                this.isBlocker = !1,
                this.enablePointerMoveEvents = !1,
                this.outlineColor = Fe.Red(),
                this.outlineWidth = .02,
                this.overlayColor = Fe.Red(),
                this.overlayAlpha = .5,
                this.useOctreeForRenderingSelection = !0,
                this.useOctreeForPicking = !0,
                this.useOctreeForCollisions = !0,
                this.alwaysSelectAsActiveMesh = !1,
                this.doNotSyncBoundingInfo = !1,
                this.actionManager = null,
                this.ellipsoid = new Di(.5,1,.5),
                this.ellipsoidOffset = new Di(0,0,0),
                this.edgesWidth = 1,
                this.edgesColor = new Oe(1,0,0,1),
                this._edgesRenderer = null,
                this._masterMesh = null,
                this._boundingInfo = null,
                this._boundingInfoIsDirty = !0,
                this._renderId = 0,
                this._intersectionsInProgress = new Array,
                this._unIndexed = !1,
                this._lightSources = new Array,
                this._waitingData = {
                    lods: null,
                    actions: null,
                    freezeWorldMatrix: null
                },
                this._bonesTransformMatrices = null,
                this._transformMatrixTexture = null,
                this.onRebuildObservable = new Ue,
                this._onCollisionPositionChange = (e, t, i=null) => {
                    t.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions),
                    this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > rr.CollisionsEpsilon && this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions),
                    i && this.onCollideObservable.notifyObservers(i),
                    this.onCollisionPositionChangeObservable.notifyObservers(this.position)
                }
                ,
                (t = this.getScene()).addMesh(this),
                this._resyncLightSources(),
                this._uniformBuffer = new ns(this.getScene().getEngine(),void 0,void 0,e,!this.getScene().getEngine().isWebGPU),
                this._buildUniformLayout(),
                t.performancePriority) {
                case Us.Aggressive:
                    this.doNotSyncBoundingInfo = !0;
                case Us.Intermediate:
                    this.alwaysSelectAsActiveMesh = !0,
                    this.isPickable = !1
                }
            }
            _buildUniformLayout() {
                this._uniformBuffer.addUniform("world", 16),
                this._uniformBuffer.addUniform("visibility", 1),
                this._uniformBuffer.create()
            }
            transferToEffect(e) {
                const t = this._uniformBuffer;
                t.updateMatrix("world", e),
                t.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility),
                t.update()
            }
            getMeshUniformBuffer() {
                return this._uniformBuffer
            }
            getClassName() {
                return "AbstractMesh"
            }
            toString(e) {
                let t = "Name: " + this.name + ", isInstance: " + ("InstancedMesh" !== this.getClassName() ? "YES" : "NO");
                t += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
                const i = this._internalAbstractMeshDataInfo._skeleton;
                return i && (t += ", skeleton: " + i.name),
                e && (t += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode],
                t += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO")),
                t
            }
            _getEffectiveParent() {
                return this._masterMesh && this.billboardMode !== lr.BILLBOARDMODE_NONE ? this._masterMesh : super._getEffectiveParent()
            }
            _getActionManagerForTrigger(e, t=!0) {
                if (this.actionManager && (t || this.actionManager.isRecursive)) {
                    if (!e)
                        return this.actionManager;
                    if (this.actionManager.hasSpecificTrigger(e))
                        return this.actionManager
                }
                return this.parent ? this.parent._getActionManagerForTrigger(e, !1) : null
            }
            _rebuild(e=!1) {
                if (this.onRebuildObservable.notifyObservers(this),
                null !== this._occlusionQuery && (this._occlusionQuery = null),
                this.subMeshes) {
                    for (const e of this.subMeshes)
                        e._rebuild();
                    this.resetDrawCache()
                }
            }
            _resyncLightSources() {
                this._lightSources.length = 0;
                for (const e of this.getScene().lights)
                    e.isEnabled() && e.canAffectMesh(this) && this._lightSources.push(e);
                this._markSubMeshesAsLightDirty()
            }
            _resyncLightSource(e) {
                const t = e.isEnabled() && e.canAffectMesh(this)
                  , i = this._lightSources.indexOf(e);
                let s = !1;
                if (-1 === i) {
                    if (!t)
                        return;
                    this._lightSources.push(e)
                } else {
                    if (t)
                        return;
                    s = !0,
                    this._lightSources.splice(i, 1)
                }
                this._markSubMeshesAsLightDirty(s)
            }
            _unBindEffect() {
                for (const e of this.subMeshes)
                    e.setEffect(null)
            }
            _removeLightSource(e, t) {
                const i = this._lightSources.indexOf(e);
                -1 !== i && (this._lightSources.splice(i, 1),
                this._markSubMeshesAsLightDirty(t))
            }
            _markSubMeshesAsDirty(e) {
                if (this.subMeshes)
                    for (const t of this.subMeshes)
                        for (let i = 0; i < t._drawWrappers.length; ++i) {
                            const s = t._drawWrappers[i];
                            s && s.defines && s.defines.markAllAsDirty && e(s.defines)
                        }
            }
            _markSubMeshesAsLightDirty(e=!1) {
                this._markSubMeshesAsDirty((t => t.markAsLightDirty(e)))
            }
            _markSubMeshesAsAttributesDirty() {
                this._markSubMeshesAsDirty((e => e.markAsAttributesDirty()))
            }
            _markSubMeshesAsMiscDirty() {
                this._markSubMeshesAsDirty((e => e.markAsMiscDirty()))
            }
            markAsDirty(e) {
                return this._currentRenderId = Number.MAX_VALUE,
                this._isDirty = !0,
                this
            }
            resetDrawCache(e) {
                if (this.subMeshes)
                    for (const t of this.subMeshes)
                        t.resetDrawCache(e)
            }
            get isBlocked() {
                return !1
            }
            getLOD(e) {
                return this
            }
            getTotalVertices() {
                return 0
            }
            getTotalIndices() {
                return 0
            }
            getIndices() {
                return null
            }
            getVerticesData(e) {
                return null
            }
            setVerticesData(e, t, i, s) {
                return this
            }
            updateVerticesData(e, t, i, s) {
                return this
            }
            setIndices(e, t) {
                return this
            }
            isVerticesDataPresent(e) {
                return !1
            }
            getBoundingInfo() {
                return this._masterMesh ? this._masterMesh.getBoundingInfo() : (this._boundingInfoIsDirty && (this._boundingInfoIsDirty = !1,
                this._updateBoundingInfo()),
                this._boundingInfo)
            }
            getRawBoundingInfo() {
                return this.rawBoundingInfo ?? this.getBoundingInfo()
            }
            setBoundingInfo(e) {
                return this._boundingInfo = e,
                this
            }
            get hasBoundingInfo() {
                return null !== this._boundingInfo
            }
            buildBoundingInfo(e, t, i) {
                return this._boundingInfo = new Ys(e,t,i),
                this._boundingInfo
            }
            normalizeToUnitCube(e=!0, t=!1, i) {
                return super.normalizeToUnitCube(e, t, i)
            }
            get useBones() {
                return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(os.MatricesIndicesKind) && this.isVerticesDataPresent(os.MatricesWeightsKind)
            }
            _preActivate() {}
            _preActivateForIntermediateRendering(e) {}
            _activate(e, t) {
                return this._renderId = e,
                !0
            }
            _postActivate() {}
            _freeze() {}
            _unFreeze() {}
            getWorldMatrix() {
                return this._masterMesh && this.billboardMode === lr.BILLBOARDMODE_NONE ? this._masterMesh.getWorldMatrix() : super.getWorldMatrix()
            }
            _getWorldMatrixDeterminant() {
                return this._masterMesh ? this._masterMesh._getWorldMatrixDeterminant() : super._getWorldMatrixDeterminant()
            }
            get isAnInstance() {
                return !1
            }
            get hasInstances() {
                return !1
            }
            get hasThinInstances() {
                return !1
            }
            movePOV(e, t, i) {
                return this.position.addInPlace(this.calcMovePOV(e, t, i)),
                this
            }
            calcMovePOV(e, t, i) {
                const s = new Oi;
                (this.rotationQuaternion ? this.rotationQuaternion : Fi.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z)).toRotationMatrix(s);
                const r = Di.Zero()
                  , n = this.definedFacingForward ? -1 : 1;
                return Di.TransformCoordinatesFromFloatsToRef(e * n, t, i * n, s, r),
                r
            }
            rotatePOV(e, t, i) {
                return this.rotation.addInPlace(this.calcRotatePOV(e, t, i)),
                this
            }
            calcRotatePOV(e, t, i) {
                const s = this.definedFacingForward ? 1 : -1;
                return new Di(e * s,t,i * s)
            }
            refreshBoundingInfo(e=!1, t=!1) {
                return this._boundingInfo && this._boundingInfo.isLocked || this._refreshBoundingInfo(this._getPositionData(e, t), null),
                this
            }
            _refreshBoundingInfo(e, t) {
                if (e) {
                    const i = qs(e, 0, this.getTotalVertices(), t);
                    this._boundingInfo ? this._boundingInfo.reConstruct(i.minimum, i.maximum) : this._boundingInfo = new Ys(i.minimum,i.maximum)
                }
                if (this.subMeshes)
                    for (let t = 0; t < this.subMeshes.length; t++)
                        this.subMeshes[t].refreshBoundingInfo(e);
                this._updateBoundingInfo()
            }
            _getData(e=!1, t=!1, i, s=os.PositionKind) {
                if ((i = i ?? this.getVerticesData(s).slice()) && t && this.morphTargetManager) {
                    let e = 0
                      , t = 0;
                    for (let r = 0; r < i.length; r++) {
                        let n = i[r];
                        for (let e = 0; e < this.morphTargetManager.numTargets; e++) {
                            const t = this.morphTargetManager.getTarget(e)
                              , a = t.influence;
                            if (0 !== a) {
                                let e = null;
                                switch (s) {
                                case os.PositionKind:
                                    e = t.getPositions();
                                    break;
                                case os.NormalKind:
                                    e = t.getNormals();
                                    break;
                                case os.TangentKind:
                                    e = t.getTangents();
                                    break;
                                case os.UVKind:
                                    e = t.getUVs()
                                }
                                e && (n += (e[r] - i[r]) * a)
                            }
                        }
                        if (i[r] = n,
                        e++,
                        s === os.PositionKind && this._positions && 3 === e) {
                            e = 0;
                            const s = 3 * t;
                            this._positions[t++].copyFromFloats(i[s], i[s + 1], i[s + 2])
                        }
                    }
                }
                if (i && e && this.skeleton) {
                    const e = this.getVerticesData(os.MatricesIndicesKind)
                      , t = this.getVerticesData(os.MatricesWeightsKind);
                    if (t && e) {
                        const r = this.numBoneInfluencers > 4
                          , n = r ? this.getVerticesData(os.MatricesIndicesExtraKind) : null
                          , a = r ? this.getVerticesData(os.MatricesWeightsExtraKind) : null
                          , o = this.skeleton.getTransformMatrices(this)
                          , h = Bi.Vector3[0]
                          , l = Bi.Matrix[0]
                          , c = Bi.Matrix[1];
                        let u = 0;
                        for (let d = 0; d < i.length; d += 3,
                        u += 4) {
                            let f, _;
                            for (l.reset(),
                            f = 0; f < 4; f++)
                                _ = t[u + f],
                                _ > 0 && (Oi.FromFloat32ArrayToRefScaled(o, Math.floor(16 * e[u + f]), _, c),
                                l.addToSelf(c));
                            if (r)
                                for (f = 0; f < 4; f++)
                                    _ = a[u + f],
                                    _ > 0 && (Oi.FromFloat32ArrayToRefScaled(o, Math.floor(16 * n[u + f]), _, c),
                                    l.addToSelf(c));
                            s === os.NormalKind ? Di.TransformNormalFromFloatsToRef(i[d], i[d + 1], i[d + 2], l, h) : Di.TransformCoordinatesFromFloatsToRef(i[d], i[d + 1], i[d + 2], l, h),
                            h.toArray(i, d),
                            s === os.PositionKind && this._positions && this._positions[d / 3].copyFrom(h)
                        }
                    }
                }
                return i
            }
            getNormalsData(e=!1, t=!1) {
                return this._getData(e, t, null, os.NormalKind)
            }
            getPositionData(e=!1, t=!1, i) {
                return this._getData(e, t, i, os.PositionKind)
            }
            _getPositionData(e, t) {
                let i = this.getVerticesData(os.PositionKind);
                if (this._internalAbstractMeshDataInfo._positions && (this._internalAbstractMeshDataInfo._positions = null),
                i && (e && this.skeleton || t && this.morphTargetManager)) {
                    if (i = i.slice(),
                    this._generatePointsArray(),
                    this._positions) {
                        const e = this._positions;
                        this._internalAbstractMeshDataInfo._positions = new Array(e.length);
                        for (let t = 0; t < e.length; t++)
                            this._internalAbstractMeshDataInfo._positions[t] = e[t]?.clone() || new Di
                    }
                    return this.getPositionData(e, t, i)
                }
                return i
            }
            _updateBoundingInfo() {
                return this._boundingInfo ? this._boundingInfo.update(this.worldMatrixFromCache) : this._boundingInfo = new Ys(Di.Zero(),Di.Zero(),this.worldMatrixFromCache),
                this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),
                this
            }
            _updateSubMeshesBoundingInfo(e) {
                if (!this.subMeshes)
                    return this;
                const t = this.subMeshes.length;
                for (let i = 0; i < t; i++) {
                    const s = this.subMeshes[i];
                    (t > 1 || !s.IsGlobal) && s.updateBoundingInfo(e)
                }
                return this
            }
            _afterComputeWorldMatrix() {
                this.doNotSyncBoundingInfo || (this._boundingInfoIsDirty = !0)
            }
            isInFrustum(e) {
                return this.getBoundingInfo().isInFrustum(e, this.cullingStrategy)
            }
            isCompletelyInFrustum(e) {
                return this.getBoundingInfo().isCompletelyInFrustum(e)
            }
            intersectsMesh(e, t=!1, i) {
                const s = this.getBoundingInfo()
                  , r = e.getBoundingInfo();
                if (s.intersects(r, t))
                    return !0;
                if (i)
                    for (const i of this.getChildMeshes())
                        if (i.intersectsMesh(e, t, !0))
                            return !0;
                return !1
            }
            intersectsPoint(e) {
                return this.getBoundingInfo().intersectsPoint(e)
            }
            get checkCollisions() {
                return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions
            }
            set checkCollisions(e) {
                this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = e
            }
            get collider() {
                return this._internalAbstractMeshDataInfo._meshCollisionData._collider
            }
            moveWithCollisions(e) {
                this.getAbsolutePosition().addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);
                const t = this.getScene().collisionCoordinator;
                return this._internalAbstractMeshDataInfo._meshCollisionData._collider || (this._internalAbstractMeshDataInfo._meshCollisionData._collider = t.createCollider()),
                this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid,
                t.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, e, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId),
                this
            }
            _collideForSubMesh(e, t, i) {
                if (this._generatePointsArray(),
                !this._positions)
                    return this;
                if (!e._lastColliderWorldVertices || !e._lastColliderTransformMatrix.equals(t)) {
                    e._lastColliderTransformMatrix = t.clone(),
                    e._lastColliderWorldVertices = [],
                    e._trianglePlanes = [];
                    const i = e.verticesStart
                      , s = e.verticesStart + e.verticesCount;
                    for (let r = i; r < s; r++)
                        e._lastColliderWorldVertices.push(Di.TransformCoordinates(this._positions[r], t))
                }
                return i._collide(e._trianglePlanes, e._lastColliderWorldVertices, this.getIndices(), e.indexStart, e.indexStart + e.indexCount, e.verticesStart, !!e.getMaterial(), this, this._shouldConvertRHS(), 7 === e.getMaterial()?.fillMode),
                this
            }
            _processCollisionsForSubMeshes(e, t) {
                const i = this._scene.getCollidingSubMeshCandidates(this, e)
                  , s = i.length;
                for (let r = 0; r < s; r++) {
                    const n = i.data[r];
                    s > 1 && !n._checkCollision(e) || this._collideForSubMesh(n, t, e)
                }
                return this
            }
            _shouldConvertRHS() {
                return !1
            }
            _checkCollision(e) {
                if (!this.getBoundingInfo()._checkCollision(e))
                    return this;
                const t = Bi.Matrix[0]
                  , i = Bi.Matrix[1];
                return Oi.ScalingToRef(1 / e._radius.x, 1 / e._radius.y, 1 / e._radius.z, t),
                this.worldMatrixFromCache.multiplyToRef(t, i),
                this._processCollisionsForSubMeshes(e, i),
                this
            }
            _generatePointsArray() {
                return !1
            }
            intersects(e, t, i, s=!1, r, n=!1) {
                const a = new hs
                  , o = this.getClassName()
                  , h = "InstancedLinesMesh" === o || "LinesMesh" === o || "GreasedLineMesh" === o ? this.intersectionThreshold : 0
                  , l = this.getBoundingInfo();
                if (!this.subMeshes)
                    return a;
                if (!(n || e.intersectsSphere(l.boundingSphere, h) && e.intersectsBox(l.boundingBox, h)))
                    return a;
                if (s)
                    return a.hit = !n,
                    a.pickedMesh = n ? null : this,
                    a.distance = n ? 0 : Di.Distance(e.origin, l.boundingSphere.center),
                    a.subMeshId = 0,
                    a;
                if (!this._generatePointsArray())
                    return a;
                let c = null;
                const u = this._scene.getIntersectingSubMeshCandidates(this, e)
                  , d = u.length;
                let f = !1;
                for (let e = 0; e < d; e++) {
                    const t = u.data[e].getMaterial();
                    if (t && (7 == t.fillMode || 0 == t.fillMode || 1 == t.fillMode || 2 == t.fillMode || 4 == t.fillMode)) {
                        f = !0;
                        break
                    }
                }
                if (!f)
                    return a.hit = !0,
                    a.pickedMesh = this,
                    a.distance = Di.Distance(e.origin, l.boundingSphere.center),
                    a.subMeshId = -1,
                    a;
                for (let s = 0; s < d; s++) {
                    const r = u.data[s];
                    if (d > 1 && !n && !r.canIntersects(e))
                        continue;
                    const a = r.intersects(e, this._positions, this.getIndices(), t, i);
                    if (a && (t || !c || a.distance < c.distance) && (c = a,
                    c.subMeshId = s,
                    t))
                        break
                }
                if (c) {
                    const t = r ?? this.getWorldMatrix()
                      , i = Bi.Vector3[0]
                      , s = Bi.Vector3[1];
                    Di.TransformCoordinatesToRef(e.origin, t, i),
                    e.direction.scaleToRef(c.distance, s);
                    const n = Di.TransformNormal(s, t).addInPlace(i);
                    return a.hit = !0,
                    a.distance = Di.Distance(i, n),
                    a.pickedPoint = n,
                    a.pickedMesh = this,
                    a.bu = c.bu || 0,
                    a.bv = c.bv || 0,
                    a.subMeshFaceId = c.faceId,
                    a.faceId = c.faceId + u.data[c.subMeshId].indexStart / (-1 !== this.getClassName().indexOf("LinesMesh") ? 2 : 3),
                    a.subMeshId = c.subMeshId,
                    a
                }
                return a
            }
            clone(e, t, i) {
                return null
            }
            releaseSubMeshes() {
                if (this.subMeshes)
                    for (; this.subMeshes.length; )
                        this.subMeshes[0].dispose();
                else
                    this.subMeshes = [];
                return this
            }
            dispose(e, t=!1) {
                let i;
                const s = this.getScene();
                for (this._scene.useMaterialMeshMap && this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap && (this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0),
                s.freeActiveMeshes(),
                s.freeRenderingGroups(),
                s.renderingManager.maintainStateBetweenFrames && s.renderingManager.restoreDispachedFlags(),
                void 0 !== this.actionManager && null !== this.actionManager && (this._scene.meshes.some((e => e !== this && e.actionManager === this.actionManager)) || this.actionManager.dispose(),
                this.actionManager = null),
                this._internalAbstractMeshDataInfo._skeleton = null,
                this._transformMatrixTexture && (this._transformMatrixTexture.dispose(),
                this._transformMatrixTexture = null),
                i = 0; i < this._intersectionsInProgress.length; i++) {
                    const e = this._intersectionsInProgress[i]
                      , t = e._intersectionsInProgress.indexOf(this);
                    e._intersectionsInProgress.splice(t, 1)
                }
                this._intersectionsInProgress.length = 0,
                s.lights.forEach((e => {
                    let t = e.includedOnlyMeshes.indexOf(this);
                    -1 !== t && e.includedOnlyMeshes.splice(t, 1),
                    t = e.excludedMeshes.indexOf(this),
                    -1 !== t && e.excludedMeshes.splice(t, 1);
                    const i = e.getShadowGenerators();
                    if (i) {
                        const e = i.values();
                        for (let i = e.next(); !0 !== i.done; i = e.next()) {
                            const e = i.value.getShadowMap();
                            e && e.renderList && (t = e.renderList.indexOf(this),
                            -1 !== t && e.renderList.splice(t, 1))
                        }
                    }
                }
                )),
                "InstancedMesh" === this.getClassName() && "InstancedLinesMesh" === this.getClassName() || this.releaseSubMeshes();
                const r = s.getEngine();
                if (null !== this._occlusionQuery && (this.isOcclusionQueryInProgress = !1,
                r.deleteQuery(this._occlusionQuery),
                this._occlusionQuery = null),
                r.wipeCaches(),
                s.removeMesh(this),
                this._parentContainer) {
                    const e = this._parentContainer.meshes.indexOf(this);
                    e > -1 && this._parentContainer.meshes.splice(e, 1),
                    this._parentContainer = null
                }
                if (t && this.material && ("MultiMaterial" === this.material.getClassName() ? this.material.dispose(!1, !0, !0) : this.material.dispose(!1, !0)),
                !e)
                    for (i = 0; i < s.particleSystems.length; i++)
                        s.particleSystems[i].emitter === this && (s.particleSystems[i].dispose(),
                        i--);
                this._internalAbstractMeshDataInfo._facetData.facetDataEnabled && this.disableFacetData(),
                this._uniformBuffer.dispose(),
                this.onAfterWorldMatrixUpdateObservable.clear(),
                this.onCollideObservable.clear(),
                this.onCollisionPositionChangeObservable.clear(),
                this.onRebuildObservable.clear(),
                super.dispose(e, t)
            }
            addChild(e, t=!1) {
                return e.setParent(this, t),
                this
            }
            removeChild(e, t=!1) {
                return e.setParent(null, t),
                this
            }
            _initFacetData() {
                const e = this._internalAbstractMeshDataInfo._facetData;
                e.facetNormals || (e.facetNormals = []),
                e.facetPositions || (e.facetPositions = []),
                e.facetPartitioning || (e.facetPartitioning = new Array),
                e.facetNb = this.getIndices().length / 3 | 0,
                e.partitioningSubdivisions = e.partitioningSubdivisions ? e.partitioningSubdivisions : 10,
                e.partitioningBBoxRatio = e.partitioningBBoxRatio ? e.partitioningBBoxRatio : 1.01;
                for (let t = 0; t < e.facetNb; t++)
                    e.facetNormals[t] = Di.Zero(),
                    e.facetPositions[t] = Di.Zero();
                return e.facetDataEnabled = !0,
                this
            }
            updateFacetData() {
                const e = this._internalAbstractMeshDataInfo._facetData;
                e.facetDataEnabled || this._initFacetData();
                const t = this.getVerticesData(os.PositionKind)
                  , i = this.getIndices()
                  , s = this.getVerticesData(os.NormalKind)
                  , r = this.getBoundingInfo();
                if (e.facetDepthSort && !e.facetDepthSortEnabled) {
                    if (e.facetDepthSortEnabled = !0,
                    i instanceof Uint16Array)
                        e.depthSortedIndices = new Uint16Array(i);
                    else if (i instanceof Uint32Array)
                        e.depthSortedIndices = new Uint32Array(i);
                    else {
                        let t = !1;
                        for (let e = 0; e < i.length; e++)
                            if (i[e] > 65535) {
                                t = !0;
                                break
                            }
                        e.depthSortedIndices = t ? new Uint32Array(i) : new Uint16Array(i)
                    }
                    if (e.facetDepthSortFunction = function(e, t) {
                        return t.sqDistance - e.sqDistance
                    }
                    ,
                    !e.facetDepthSortFrom) {
                        const t = this.getScene().activeCamera;
                        e.facetDepthSortFrom = t ? t.position : Di.Zero()
                    }
                    e.depthSortedFacets = [];
                    for (let t = 0; t < e.facetNb; t++) {
                        const i = {
                            ind: 3 * t,
                            sqDistance: 0
                        };
                        e.depthSortedFacets.push(i)
                    }
                    e.invertedMatrix = Oi.Identity(),
                    e.facetDepthSortOrigin = Di.Zero()
                }
                e.bbSize.x = r.maximum.x - r.minimum.x > Ee ? r.maximum.x - r.minimum.x : Ee,
                e.bbSize.y = r.maximum.y - r.minimum.y > Ee ? r.maximum.y - r.minimum.y : Ee,
                e.bbSize.z = r.maximum.z - r.minimum.z > Ee ? r.maximum.z - r.minimum.z : Ee;
                let n = e.bbSize.x > e.bbSize.y ? e.bbSize.x : e.bbSize.y;
                if (n = n > e.bbSize.z ? n : e.bbSize.z,
                e.subDiv.max = e.partitioningSubdivisions,
                e.subDiv.X = Math.floor(e.subDiv.max * e.bbSize.x / n),
                e.subDiv.Y = Math.floor(e.subDiv.max * e.bbSize.y / n),
                e.subDiv.Z = Math.floor(e.subDiv.max * e.bbSize.z / n),
                e.subDiv.X = e.subDiv.X < 1 ? 1 : e.subDiv.X,
                e.subDiv.Y = e.subDiv.Y < 1 ? 1 : e.subDiv.Y,
                e.subDiv.Z = e.subDiv.Z < 1 ? 1 : e.subDiv.Z,
                e.facetParameters.facetNormals = this.getFacetLocalNormals(),
                e.facetParameters.facetPositions = this.getFacetLocalPositions(),
                e.facetParameters.facetPartitioning = this.getFacetLocalPartitioning(),
                e.facetParameters.bInfo = r,
                e.facetParameters.bbSize = e.bbSize,
                e.facetParameters.subDiv = e.subDiv,
                e.facetParameters.ratio = this.partitioningBBoxRatio,
                e.facetParameters.depthSort = e.facetDepthSort,
                e.facetDepthSort && e.facetDepthSortEnabled && (this.computeWorldMatrix(!0),
                this._worldMatrix.invertToRef(e.invertedMatrix),
                Di.TransformCoordinatesToRef(e.facetDepthSortFrom, e.invertedMatrix, e.facetDepthSortOrigin),
                e.facetParameters.distanceTo = e.facetDepthSortOrigin),
                e.facetParameters.depthSortedFacets = e.depthSortedFacets,
                s && $s.ComputeNormals(t, i, s, e.facetParameters),
                e.facetDepthSort && e.facetDepthSortEnabled) {
                    e.depthSortedFacets.sort(e.facetDepthSortFunction);
                    const t = e.depthSortedIndices.length / 3 | 0;
                    for (let s = 0; s < t; s++) {
                        const t = e.depthSortedFacets[s].ind;
                        e.depthSortedIndices[3 * s] = i[t],
                        e.depthSortedIndices[3 * s + 1] = i[t + 1],
                        e.depthSortedIndices[3 * s + 2] = i[t + 2]
                    }
                    this.updateIndices(e.depthSortedIndices, void 0, !0)
                }
                return this
            }
            getFacetLocalNormals() {
                const e = this._internalAbstractMeshDataInfo._facetData;
                return e.facetNormals || this.updateFacetData(),
                e.facetNormals
            }
            getFacetLocalPositions() {
                const e = this._internalAbstractMeshDataInfo._facetData;
                return e.facetPositions || this.updateFacetData(),
                e.facetPositions
            }
            getFacetLocalPartitioning() {
                const e = this._internalAbstractMeshDataInfo._facetData;
                return e.facetPartitioning || this.updateFacetData(),
                e.facetPartitioning
            }
            getFacetPosition(e) {
                const t = Di.Zero();
                return this.getFacetPositionToRef(e, t),
                t
            }
            getFacetPositionToRef(e, t) {
                const i = this.getFacetLocalPositions()[e]
                  , s = this.getWorldMatrix();
                return Di.TransformCoordinatesToRef(i, s, t),
                this
            }
            getFacetNormal(e) {
                const t = Di.Zero();
                return this.getFacetNormalToRef(e, t),
                t
            }
            getFacetNormalToRef(e, t) {
                const i = this.getFacetLocalNormals()[e];
                return Di.TransformNormalToRef(i, this.getWorldMatrix(), t),
                this
            }
            getFacetsAtLocalCoordinates(e, t, i) {
                const s = this.getBoundingInfo()
                  , r = this._internalAbstractMeshDataInfo._facetData
                  , n = Math.floor((e - s.minimum.x * r.partitioningBBoxRatio) * r.subDiv.X * r.partitioningBBoxRatio / r.bbSize.x)
                  , a = Math.floor((t - s.minimum.y * r.partitioningBBoxRatio) * r.subDiv.Y * r.partitioningBBoxRatio / r.bbSize.y)
                  , o = Math.floor((i - s.minimum.z * r.partitioningBBoxRatio) * r.subDiv.Z * r.partitioningBBoxRatio / r.bbSize.z);
                return n < 0 || n > r.subDiv.max || a < 0 || a > r.subDiv.max || o < 0 || o > r.subDiv.max ? null : r.facetPartitioning[n + r.subDiv.max * a + r.subDiv.max * r.subDiv.max * o]
            }
            getClosestFacetAtCoordinates(e, t, i, s, r=!1, n=!0) {
                const a = this.getWorldMatrix()
                  , o = Bi.Matrix[5];
                a.invertToRef(o);
                const h = Bi.Vector3[8];
                Di.TransformCoordinatesFromFloatsToRef(e, t, i, o, h);
                const l = this.getClosestFacetAtLocalCoordinates(h.x, h.y, h.z, s, r, n);
                return s && Di.TransformCoordinatesFromFloatsToRef(s.x, s.y, s.z, a, s),
                l
            }
            getClosestFacetAtLocalCoordinates(e, t, i, s, r=!1, n=!0) {
                let a = null
                  , o = 0
                  , h = 0
                  , l = 0
                  , c = 0
                  , u = 0
                  , d = 0
                  , f = 0
                  , _ = 0;
                const p = this.getFacetLocalPositions()
                  , m = this.getFacetLocalNormals()
                  , g = this.getFacetsAtLocalCoordinates(e, t, i);
                if (!g)
                    return null;
                let v, y, b, x = Number.MAX_VALUE, T = x;
                for (let E = 0; E < g.length; E++)
                    v = g[E],
                    y = m[v],
                    b = p[v],
                    c = (e - b.x) * y.x + (t - b.y) * y.y + (i - b.z) * y.z,
                    (!r || r && n && c >= 0 || r && !n && c <= 0) && (c = y.x * b.x + y.y * b.y + y.z * b.z,
                    u = -(y.x * e + y.y * t + y.z * i - c) / (y.x * y.x + y.y * y.y + y.z * y.z),
                    d = e + y.x * u,
                    f = t + y.y * u,
                    _ = i + y.z * u,
                    o = d - e,
                    h = f - t,
                    l = _ - i,
                    T = o * o + h * h + l * l,
                    T < x && (x = T,
                    a = v,
                    s && (s.x = d,
                    s.y = f,
                    s.z = _)));
                return a
            }
            getFacetDataParameters() {
                return this._internalAbstractMeshDataInfo._facetData.facetParameters
            }
            disableFacetData() {
                const e = this._internalAbstractMeshDataInfo._facetData;
                return e.facetDataEnabled && (e.facetDataEnabled = !1,
                e.facetPositions = [],
                e.facetNormals = [],
                e.facetPartitioning = new Array,
                e.facetParameters = null,
                e.depthSortedIndices = new Uint32Array(0)),
                this
            }
            updateIndices(e, t, i=!1) {
                return this
            }
            createNormals(e) {
                const t = this.getVerticesData(os.PositionKind)
                  , i = this.getIndices();
                let s;
                return s = this.isVerticesDataPresent(os.NormalKind) ? this.getVerticesData(os.NormalKind) : [],
                $s.ComputeNormals(t, i, s, {
                    useRightHandedSystem: this.getScene().useRightHandedSystem
                }),
                this.setVerticesData(os.NormalKind, s, e),
                this
            }
            alignWithNormal(e, t) {
                t || (t = or.Y);
                const i = Bi.Vector3[0]
                  , s = Bi.Vector3[1];
                return Di.CrossToRef(t, e, s),
                Di.CrossToRef(e, s, i),
                this.rotationQuaternion ? Fi.RotationQuaternionFromAxisToRef(i, e, s, this.rotationQuaternion) : Di.RotationFromAxisToRef(i, e, s, this.rotation),
                this
            }
            _checkOcclusionQuery() {
                return !1
            }
            disableEdgesRendering() {
                throw je("EdgesRenderer")
            }
            enableEdgesRendering(e, t, i) {
                throw je("EdgesRenderer")
            }
            getConnectedParticleSystems() {
                return this._scene.particleSystems.filter((e => e.emitter === this))
            }
        }
        fr.OCCLUSION_TYPE_NONE = 0,
        fr.OCCLUSION_TYPE_OPTIMISTIC = 1,
        fr.OCCLUSION_TYPE_STRICT = 2,
        fr.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0,
        fr.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1,
        fr.CULLINGSTRATEGY_STANDARD = 0,
        fr.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1,
        fr.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2,
        fr.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3,
        Ie("BABYLON.AbstractMesh", fr);
        class _r {
            constructor() {
                this.reset()
            }
            reset() {
                this.enabled = !1,
                this.mask = 255,
                this.func = 519,
                this.funcRef = 1,
                this.funcMask = 255,
                this.opStencilFail = 7680,
                this.opDepthFail = 7680,
                this.opStencilDepthPass = 7681
            }
            get func() {
                return this._func
            }
            set func(e) {
                this._func = e
            }
            get funcRef() {
                return this._funcRef
            }
            set funcRef(e) {
                this._funcRef = e
            }
            get funcMask() {
                return this._funcMask
            }
            set funcMask(e) {
                this._funcMask = e
            }
            get opStencilFail() {
                return this._opStencilFail
            }
            set opStencilFail(e) {
                this._opStencilFail = e
            }
            get opDepthFail() {
                return this._opDepthFail
            }
            set opDepthFail(e) {
                this._opDepthFail = e
            }
            get opStencilDepthPass() {
                return this._opStencilDepthPass
            }
            set opStencilDepthPass(e) {
                this._opStencilDepthPass = e
            }
            get mask() {
                return this._mask
            }
            set mask(e) {
                this._mask = e
            }
            get enabled() {
                return this._enabled
            }
            set enabled(e) {
                this._enabled = e
            }
            getClassName() {
                return "MaterialStencilState"
            }
            copyTo(e) {
                ki.Clone(( () => e), this)
            }
            serialize() {
                return ki.Serialize(this)
            }
            parse(e, t, i) {
                ki.Parse(( () => this), e, t, i)
            }
        }
        var pr, mr;
        function gr(e) {
            -1 === e.indexOf("vClipPlane") && e.push("vClipPlane"),
            -1 === e.indexOf("vClipPlane2") && e.push("vClipPlane2"),
            -1 === e.indexOf("vClipPlane3") && e.push("vClipPlane3"),
            -1 === e.indexOf("vClipPlane4") && e.push("vClipPlane4"),
            -1 === e.indexOf("vClipPlane5") && e.push("vClipPlane5"),
            -1 === e.indexOf("vClipPlane6") && e.push("vClipPlane6")
        }
        function vr(e, t, i) {
            let s = t.clipPlane ?? i.clipPlane;
            yr(e, "vClipPlane", s),
            s = t.clipPlane2 ?? i.clipPlane2,
            yr(e, "vClipPlane2", s),
            s = t.clipPlane3 ?? i.clipPlane3,
            yr(e, "vClipPlane3", s),
            s = t.clipPlane4 ?? i.clipPlane4,
            yr(e, "vClipPlane4", s),
            s = t.clipPlane5 ?? i.clipPlane5,
            yr(e, "vClipPlane5", s),
            s = t.clipPlane6 ?? i.clipPlane6,
            yr(e, "vClipPlane6", s)
        }
        function yr(e, t, i) {
            i && e.setFloat4(t, i.normal.x, i.normal.y, i.normal.z, i.d)
        }
        pi([xi()], _r.prototype, "func", null),
        pi([xi()], _r.prototype, "funcRef", null),
        pi([xi()], _r.prototype, "funcMask", null),
        pi([xi()], _r.prototype, "opStencilFail", null),
        pi([xi()], _r.prototype, "opDepthFail", null),
        pi([xi()], _r.prototype, "opStencilDepthPass", null),
        pi([xi()], _r.prototype, "mask", null),
        pi([xi()], _r.prototype, "enabled", null),
        (mr = pr || (pr = {}))[mr.Created = 1] = "Created",
        mr[mr.Disposed = 2] = "Disposed",
        mr[mr.GetDefineNames = 4] = "GetDefineNames",
        mr[mr.PrepareUniformBuffer = 8] = "PrepareUniformBuffer",
        mr[mr.IsReadyForSubMesh = 16] = "IsReadyForSubMesh",
        mr[mr.PrepareDefines = 32] = "PrepareDefines",
        mr[mr.BindForSubMesh = 64] = "BindForSubMesh",
        mr[mr.PrepareEffect = 128] = "PrepareEffect",
        mr[mr.GetAnimatables = 256] = "GetAnimatables",
        mr[mr.GetActiveTextures = 512] = "GetActiveTextures",
        mr[mr.HasTexture = 1024] = "HasTexture",
        mr[mr.FillRenderTargetTextures = 2048] = "FillRenderTargetTextures",
        mr[mr.HasRenderTargetTextures = 4096] = "HasRenderTargetTextures",
        mr[mr.HardBindForSubMesh = 8192] = "HardBindForSubMesh";
        const br = Fe.Black();
        function xr(e, t, i) {
            if (!e || e.LOGARITHMICDEPTH || e.indexOf && e.indexOf("LOGARITHMICDEPTH") >= 0) {
                const e = i.activeCamera;
                1 === e.mode && We.Error("Logarithmic depth is not compatible with orthographic cameras!", 20),
                t.setFloat("logarithmicDepthConstant", 2 / (Math.log(e.maxZ + 1) / Math.LN2))
            }
        }
        function Tr(e, t, i, s=!1) {
            i && e.fogEnabled && (!t || t.applyFog) && 0 !== e.fogMode && (i.setFloat4("vFogInfos", e.fogMode, e.fogStart, e.fogEnd, e.fogDensity),
            s ? (e.fogColor.toLinearSpaceToRef(br, e.getEngine().useExactSrgbConversions),
            i.setColor3("vFogColor", br)) : i.setColor3("vFogColor", e.fogColor))
        }
        function Er(e, t=!1) {
            e.push("world0"),
            e.push("world1"),
            e.push("world2"),
            e.push("world3"),
            t && (e.push("previousWorld0"),
            e.push("previousWorld1"),
            e.push("previousWorld2"),
            e.push("previousWorld3"))
        }
        function Mr(e, t) {
            const i = e.morphTargetManager;
            e && i && t.setFloatArray("morphTargetInfluences", i.influences)
        }
        function Sr(e, t) {
            t.bindToEffect(e, "Scene")
        }
        function Ar(e, t, i) {
            t._needUVs = !0,
            t[i] = !0,
            e.optimizeUVAllocation && e.getTextureMatrix().isIdentityAs3x2() ? (t[i + "DIRECTUV"] = e.coordinatesIndex + 1,
            t["MAINUV" + (e.coordinatesIndex + 1)] = !0) : t[i + "DIRECTUV"] = 0
        }
        function Ir(e, t, i) {
            const s = e.getTextureMatrix();
            t.updateMatrix(i + "Matrix", s)
        }
        function Rr(e, t, i) {
            i.BAKED_VERTEX_ANIMATION_TEXTURE && i.INSTANCES && e.push("bakedVertexAnimationSettingsInstanced")
        }
        function Cr(e, t, i) {
            var s;
            if (t && e && (e.computeBonesUsingShaders && t._bonesComputationForcedToCPU && (e.computeBonesUsingShaders = !1),
            e.useBones && e.computeBonesUsingShaders && e.skeleton)) {
                const r = e.skeleton;
                if (r.isUsingTextureForMatrices && t.getUniformIndex("boneTextureWidth") > -1) {
                    const i = r.getTransformMatrixTexture(e);
                    t.setTexture("boneSampler", i),
                    t.setFloat("boneTextureWidth", 4 * (r.bones.length + 1))
                } else {
                    const n = r.getTransformMatrices(e);
                    n && (t.setMatrices("mBones", n),
                    i && e.getScene().prePassRenderer && e.getScene().prePassRenderer.getIndex(2) && (i.previousBones[e.uniqueId] || (i.previousBones[e.uniqueId] = n.slice()),
                    t.setMatrices("mPreviousBones", i.previousBones[e.uniqueId]),
                    s = n,
                    i.previousBones[e.uniqueId].set(s)))
                }
            }
        }
        function Pr(e, t, i, s, r, n=!0) {
            e._bindLight(t, i, s, r, n)
        }
        function Dr(e, t, i, s, r, n, a) {
            switch (a.needNormals = !0,
            void 0 === r["LIGHT" + s] && (a.needRebuild = !0),
            r["LIGHT" + s] = !0,
            r["SPOTLIGHT" + s] = !1,
            r["HEMILIGHT" + s] = !1,
            r["POINTLIGHT" + s] = !1,
            r["DIRLIGHT" + s] = !1,
            i.prepareLightSpecificDefines(r, s),
            r["LIGHT_FALLOFF_PHYSICAL" + s] = !1,
            r["LIGHT_FALLOFF_GLTF" + s] = !1,
            r["LIGHT_FALLOFF_STANDARD" + s] = !1,
            i.falloffType) {
            case Bs.FALLOFF_GLTF:
                r["LIGHT_FALLOFF_GLTF" + s] = !0;
                break;
            case Bs.FALLOFF_PHYSICAL:
                r["LIGHT_FALLOFF_PHYSICAL" + s] = !0;
                break;
            case Bs.FALLOFF_STANDARD:
                r["LIGHT_FALLOFF_STANDARD" + s] = !0
            }
            if (n && !i.specular.equalsFloats(0, 0, 0) && (a.specularEnabled = !0),
            r["SHADOW" + s] = !1,
            r["SHADOWCSM" + s] = !1,
            r["SHADOWCSMDEBUG" + s] = !1,
            r["SHADOWCSMNUM_CASCADES" + s] = !1,
            r["SHADOWCSMUSESHADOWMAXZ" + s] = !1,
            r["SHADOWCSMNOBLEND" + s] = !1,
            r["SHADOWCSM_RIGHTHANDED" + s] = !1,
            r["SHADOWPCF" + s] = !1,
            r["SHADOWPCSS" + s] = !1,
            r["SHADOWPOISSON" + s] = !1,
            r["SHADOWESM" + s] = !1,
            r["SHADOWCLOSEESM" + s] = !1,
            r["SHADOWCUBE" + s] = !1,
            r["SHADOWLOWQUALITY" + s] = !1,
            r["SHADOWMEDIUMQUALITY" + s] = !1,
            t && t.receiveShadows && e.shadowsEnabled && i.shadowEnabled) {
                const t = i.getShadowGenerator(e.activeCamera) ?? i.getShadowGenerator();
                if (t) {
                    const e = t.getShadowMap();
                    e && e.renderList && e.renderList.length > 0 && (a.shadowEnabled = !0,
                    t.prepareDefines(r, s))
                }
            }
            i.lightmapMode != Bs.LIGHTMAP_DEFAULT ? (a.lightmapMode = !0,
            r["LIGHTMAPEXCLUDED" + s] = !0,
            r["LIGHTMAPNOSPECULAR" + s] = i.lightmapMode == Bs.LIGHTMAP_SHADOWSONLY) : (r["LIGHTMAPEXCLUDED" + s] = !1,
            r["LIGHTMAPNOSPECULAR" + s] = !1)
        }
        function wr(e, t, i, s, r=null, n=!1) {
            r && r.push("Light" + e),
            n || (t.push("vLightData" + e, "vLightDiffuse" + e, "vLightSpecular" + e, "vLightDirection" + e, "vLightFalloff" + e, "vLightGround" + e, "lightMatrix" + e, "shadowsInfo" + e, "depthValues" + e),
            i.push("shadowSampler" + e),
            i.push("depthSampler" + e),
            t.push("viewFrustumZ" + e, "cascadeBlendFactor" + e, "lightSizeUVCorrection" + e, "depthCorrection" + e, "penumbraDarkness" + e, "frustumLengths" + e),
            s && (i.push("projectionLightSampler" + e),
            t.push("textureProjectionMatrix" + e)))
        }
        class Fr {
            get canRenderToMRT() {
                return !1
            }
            set alpha(e) {
                if (this._alpha === e)
                    return;
                const t = this._alpha;
                this._alpha = e,
                1 !== t && 1 !== e || this.markAsDirty(Fr.MiscDirtyFlag + Fr.PrePassDirtyFlag)
            }
            get alpha() {
                return this._alpha
            }
            set backFaceCulling(e) {
                this._backFaceCulling !== e && (this._backFaceCulling = e,
                this.markAsDirty(Fr.TextureDirtyFlag))
            }
            get backFaceCulling() {
                return this._backFaceCulling
            }
            set cullBackFaces(e) {
                this._cullBackFaces !== e && (this._cullBackFaces = e,
                this.markAsDirty(Fr.TextureDirtyFlag))
            }
            get cullBackFaces() {
                return this._cullBackFaces
            }
            get blockDirtyMechanism() {
                return this._blockDirtyMechanism
            }
            set blockDirtyMechanism(e) {
                this._blockDirtyMechanism !== e && (this._blockDirtyMechanism = e,
                e || this.markDirty())
            }
            atomicMaterialsUpdate(e) {
                this.blockDirtyMechanism = !0;
                try {
                    e(this)
                } finally {
                    this.blockDirtyMechanism = !1
                }
            }
            get hasRenderTargetTextures() {
                return this._eventInfo.hasRenderTargetTextures = !1,
                this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),
                this._eventInfo.hasRenderTargetTextures
            }
            set onDispose(e) {
                this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver),
                this._onDisposeObserver = this.onDisposeObservable.add(e)
            }
            get onBindObservable() {
                return this._onBindObservable || (this._onBindObservable = new Ue),
                this._onBindObservable
            }
            set onBind(e) {
                this._onBindObserver && this.onBindObservable.remove(this._onBindObserver),
                this._onBindObserver = this.onBindObservable.add(e)
            }
            get onUnBindObservable() {
                return this._onUnBindObservable || (this._onUnBindObservable = new Ue),
                this._onUnBindObservable
            }
            get onEffectCreatedObservable() {
                return this._onEffectCreatedObservable || (this._onEffectCreatedObservable = new Ue),
                this._onEffectCreatedObservable
            }
            set alphaMode(e) {
                this._alphaMode !== e && (this._alphaMode = e,
                this.markAsDirty(Fr.TextureDirtyFlag))
            }
            get alphaMode() {
                return this._alphaMode
            }
            set needDepthPrePass(e) {
                this._needDepthPrePass !== e && (this._needDepthPrePass = e,
                this._needDepthPrePass && (this.checkReadyOnEveryCall = !0))
            }
            get needDepthPrePass() {
                return this._needDepthPrePass
            }
            get isPrePassCapable() {
                return !1
            }
            set fogEnabled(e) {
                this._fogEnabled !== e && (this._fogEnabled = e,
                this.markAsDirty(Fr.MiscDirtyFlag))
            }
            get fogEnabled() {
                return this._fogEnabled
            }
            get wireframe() {
                switch (this._fillMode) {
                case Fr.WireFrameFillMode:
                case Fr.LineListDrawMode:
                case Fr.LineLoopDrawMode:
                case Fr.LineStripDrawMode:
                    return !0
                }
                return this._scene.forceWireframe
            }
            set wireframe(e) {
                this.fillMode = e ? Fr.WireFrameFillMode : Fr.TriangleFillMode
            }
            get pointsCloud() {
                switch (this._fillMode) {
                case Fr.PointFillMode:
                case Fr.PointListDrawMode:
                    return !0
                }
                return this._scene.forcePointsCloud
            }
            set pointsCloud(e) {
                this.fillMode = e ? Fr.PointFillMode : Fr.TriangleFillMode
            }
            get fillMode() {
                return this._fillMode
            }
            set fillMode(e) {
                this._fillMode !== e && (this._fillMode = e,
                this.markAsDirty(Fr.MiscDirtyFlag))
            }
            get useLogarithmicDepth() {
                return this._useLogarithmicDepth
            }
            set useLogarithmicDepth(e) {
                const t = this.getScene().getEngine().getCaps().fragmentDepthSupported;
                e && !t && We.Warn("Logarithmic depth has been requested for a material on a device that doesn't support it."),
                this._useLogarithmicDepth = e && t,
                this._markAllSubMeshesAsMiscDirty()
            }
            _getDrawWrapper() {
                return this._drawWrapper
            }
            _setDrawWrapper(e) {
                this._drawWrapper = e
            }
            constructor(e, t, i) {
                this.shadowDepthWrapper = null,
                this.allowShaderHotSwapping = !0,
                this.metadata = null,
                this.reservedDataStore = null,
                this.checkReadyOnEveryCall = !1,
                this.checkReadyOnlyOnce = !1,
                this.state = "",
                this._alpha = 1,
                this._backFaceCulling = !0,
                this._cullBackFaces = !0,
                this._blockDirtyMechanism = !1,
                this.onCompiled = null,
                this.onError = null,
                this.getRenderTargetTextures = null,
                this.doNotSerialize = !1,
                this._storeEffectOnSubMeshes = !1,
                this.animations = null,
                this.onDisposeObservable = new Ue,
                this._onDisposeObserver = null,
                this._onUnBindObservable = null,
                this._onBindObserver = null,
                this._alphaMode = 2,
                this._needDepthPrePass = !1,
                this.disableDepthWrite = !1,
                this.disableColorWrite = !1,
                this.forceDepthWrite = !1,
                this.depthFunction = 0,
                this.separateCullingPass = !1,
                this._fogEnabled = !0,
                this.pointSize = 1,
                this.zOffset = 0,
                this.zOffsetUnits = 0,
                this.stencil = new _r,
                this._useUBO = !1,
                this._fillMode = Fr.TriangleFillMode,
                this._cachedDepthWriteState = !1,
                this._cachedColorWriteState = !1,
                this._cachedDepthFunctionState = 0,
                this._indexInSceneMaterialArray = -1,
                this.meshMap = null,
                this._parentContainer = null,
                this._uniformBufferLayoutBuilt = !1,
                this._eventInfo = {},
                this._callbackPluginEventGeneric = () => {}
                ,
                this._callbackPluginEventIsReadyForSubMesh = () => {}
                ,
                this._callbackPluginEventPrepareDefines = () => {}
                ,
                this._callbackPluginEventPrepareDefinesBeforeAttributes = () => {}
                ,
                this._callbackPluginEventHardBindForSubMesh = () => {}
                ,
                this._callbackPluginEventBindForSubMesh = () => {}
                ,
                this._callbackPluginEventHasRenderTargetTextures = () => {}
                ,
                this._callbackPluginEventFillRenderTargetTextures = () => {}
                ,
                this._forceAlphaTest = !1,
                this._transparencyMode = null,
                this.name = e;
                const s = t || Ze.LastCreatedScene;
                s && (this._scene = s,
                this._dirtyCallbacks = {},
                this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this),
                this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this),
                this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this),
                this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this),
                this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this),
                this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this),
                this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this),
                this.id = e || hi.RandomId(),
                this.uniqueId = this._scene.getUniqueId(),
                this._materialContext = this._scene.getEngine().createMaterialContext(),
                this._drawWrapper = new Bt(this._scene.getEngine(),!1),
                this._drawWrapper.materialContext = this._materialContext,
                this._scene.useRightHandedSystem ? this.sideOrientation = Fr.ClockWiseSideOrientation : this.sideOrientation = Fr.CounterClockWiseSideOrientation,
                this._uniformBuffer = new ns(this._scene.getEngine(),void 0,void 0,e),
                this._useUBO = this.getScene().getEngine().supportsUniformBuffers,
                i || this._scene.addMaterial(this),
                this._scene.useMaterialMeshMap && (this.meshMap = {}),
                Fr.OnEventObservable.notifyObservers(this, pr.Created))
            }
            toString(e) {
                return "Name: " + this.name
            }
            getClassName() {
                return "Material"
            }
            get _isMaterial() {
                return !0
            }
            get isFrozen() {
                return this.checkReadyOnlyOnce
            }
            freeze() {
                this.markDirty(),
                this.checkReadyOnlyOnce = !0
            }
            unfreeze() {
                this.markDirty(),
                this.checkReadyOnlyOnce = !1
            }
            isReady(e, t) {
                return !0
            }
            isReadyForSubMesh(e, t, i) {
                const s = t.materialDefines;
                return !!s && (this._eventInfo.isReadyForSubMesh = !0,
                this._eventInfo.defines = s,
                this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),
                this._eventInfo.isReadyForSubMesh)
            }
            getEffect() {
                return this._drawWrapper.effect
            }
            getScene() {
                return this._scene
            }
            get transparencyMode() {
                return this._transparencyMode
            }
            set transparencyMode(e) {
                this._transparencyMode !== e && (this._transparencyMode = e,
                this._forceAlphaTest = e === Fr.MATERIAL_ALPHATESTANDBLEND,
                this._markAllSubMeshesAsTexturesAndMiscDirty())
            }
            get _disableAlphaBlending() {
                return this._transparencyMode === Fr.MATERIAL_OPAQUE || this._transparencyMode === Fr.MATERIAL_ALPHATEST
            }
            needAlphaBlending() {
                return !this._disableAlphaBlending && this.alpha < 1
            }
            needAlphaBlendingForMesh(e) {
                return e.visibility < 1 || !this._disableAlphaBlending && (e.hasVertexAlpha || this.needAlphaBlending())
            }
            needAlphaTesting() {
                return !!this._forceAlphaTest
            }
            _shouldTurnAlphaTestOn(e) {
                return !this.needAlphaBlendingForMesh(e) && this.needAlphaTesting()
            }
            getAlphaTestTexture() {
                return null
            }
            markDirty(e=!1) {
                const t = this.getScene().meshes;
                for (const i of t)
                    if (i.subMeshes)
                        for (const t of i.subMeshes)
                            if (t.getMaterial() === this)
                                for (const i of t._drawWrappers)
                                    i && this._materialContext === i.materialContext && (i._wasPreviouslyReady = !1,
                                    i._wasPreviouslyUsingInstances = null,
                                    i._forceRebindOnNextCall = e);
                e && this.markAsDirty(Fr.AllDirtyFlag)
            }
            _preBind(e, t=null) {
                const i = this._scene.getEngine()
                  , s = (null == t ? this.sideOrientation : t) === Fr.ClockWiseSideOrientation;
                return i.enableEffect(e || this._getDrawWrapper()),
                i.setState(this.backFaceCulling, this.zOffset, !1, s, this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces, this.stencil, this.zOffsetUnits),
                s
            }
            bind(e, t) {}
            buildUniformLayout() {
                const e = this._uniformBuffer;
                this._eventInfo.ubo = e,
                this._callbackPluginEventGeneric(pr.PrepareUniformBuffer, this._eventInfo),
                e.create(),
                this._uniformBufferLayoutBuilt = !0
            }
            bindForSubMesh(e, t, i) {
                const s = i._drawWrapper;
                this._eventInfo.subMesh = i,
                this._callbackPluginEventBindForSubMesh(this._eventInfo),
                s._forceRebindOnNextCall = !1
            }
            bindOnlyWorldMatrix(e) {}
            bindView(e) {
                this._useUBO ? this._needToBindSceneUbo = !0 : e.setMatrix("view", this.getScene().getViewMatrix())
            }
            bindViewProjection(e) {
                this._useUBO ? this._needToBindSceneUbo = !0 : (e.setMatrix("viewProjection", this.getScene().getTransformMatrix()),
                e.setMatrix("projection", this.getScene().getProjectionMatrix()))
            }
            bindEyePosition(e, t) {
                this._useUBO ? this._needToBindSceneUbo = !0 : this._scene.bindEyePosition(e, t)
            }
            _afterBind(e, t=null, i) {
                if (this._scene._cachedMaterial = this,
                this._needToBindSceneUbo && t && (this._needToBindSceneUbo = !1,
                Sr(t, this.getScene().getSceneUniformBuffer()),
                this._scene.finalizeSceneUbo()),
                this._scene._cachedVisibility = e ? e.visibility : 1,
                this._onBindObservable && e && this._onBindObservable.notifyObservers(e),
                this.disableDepthWrite) {
                    const e = this._scene.getEngine();
                    this._cachedDepthWriteState = e.getDepthWrite(),
                    e.setDepthWrite(!1)
                }
                if (this.disableColorWrite) {
                    const e = this._scene.getEngine();
                    this._cachedColorWriteState = e.getColorWrite(),
                    e.setColorWrite(!1)
                }
                if (0 !== this.depthFunction) {
                    const e = this._scene.getEngine();
                    this._cachedDepthFunctionState = e.getDepthFunction() || 0,
                    e.setDepthFunction(this.depthFunction)
                }
            }
            unbind() {
                this._onUnBindObservable && this._onUnBindObservable.notifyObservers(this),
                0 !== this.depthFunction && this._scene.getEngine().setDepthFunction(this._cachedDepthFunctionState),
                this.disableDepthWrite && this._scene.getEngine().setDepthWrite(this._cachedDepthWriteState),
                this.disableColorWrite && this._scene.getEngine().setColorWrite(this._cachedColorWriteState)
            }
            getAnimatables() {
                return this._eventInfo.animatables = [],
                this._callbackPluginEventGeneric(pr.GetAnimatables, this._eventInfo),
                this._eventInfo.animatables
            }
            getActiveTextures() {
                return this._eventInfo.activeTextures = [],
                this._callbackPluginEventGeneric(pr.GetActiveTextures, this._eventInfo),
                this._eventInfo.activeTextures
            }
            hasTexture(e) {
                return this._eventInfo.hasTexture = !1,
                this._eventInfo.texture = e,
                this._callbackPluginEventGeneric(pr.HasTexture, this._eventInfo),
                this._eventInfo.hasTexture
            }
            clone(e) {
                return null
            }
            _clonePlugins(e, t) {
                const i = {};
                if (this._serializePlugins(i),
                Fr._ParsePlugins(i, e, this._scene, t),
                this.pluginManager)
                    for (const t of this.pluginManager._plugins) {
                        const i = e.pluginManager.getPlugin(t.name);
                        i && t.copyTo(i)
                    }
            }
            getBindedMeshes() {
                if (this.meshMap) {
                    const e = [];
                    for (const t in this.meshMap) {
                        const i = this.meshMap[t];
                        i && e.push(i)
                    }
                    return e
                }
                return this._scene.meshes.filter((e => e.material === this))
            }
            forceCompilation(e, t, i, s) {
                const r = {
                    clipPlane: !1,
                    useInstances: !1,
                    ...i
                }
                  , n = this.getScene()
                  , a = this.allowShaderHotSwapping;
                this.allowShaderHotSwapping = !1;
                const o = () => {
                    if (!this._scene || !this._scene.getEngine())
                        return;
                    const i = n.clipPlane;
                    if (r.clipPlane && (n.clipPlane = new Wi(0,0,0,1)),
                    this._storeEffectOnSubMeshes) {
                        let i = !0
                          , n = null;
                        if (e.subMeshes) {
                            const t = new Zs(0,0,0,0,0,e,void 0,!1,!1);
                            t.materialDefines && (t.materialDefines._renderId = -1),
                            this.isReadyForSubMesh(e, t, r.useInstances) || (t.effect && t.effect.getCompilationError() && t.effect.allFallbacksProcessed() ? n = t.effect.getCompilationError() : (i = !1,
                            setTimeout(o, 16)))
                        }
                        i && (this.allowShaderHotSwapping = a,
                        n && s && s(n),
                        t && t(this))
                    } else
                        this.isReady() ? (this.allowShaderHotSwapping = a,
                        t && t(this)) : setTimeout(o, 16);
                    r.clipPlane && (n.clipPlane = i)
                }
                ;
                o()
            }
            forceCompilationAsync(e, t) {
                return new Promise(( (i, s) => {
                    this.forceCompilation(e, ( () => {
                        i()
                    }
                    ), t, (e => {
                        s(e)
                    }
                    ))
                }
                ))
            }
            markAsDirty(e) {
                this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism || (Fr._DirtyCallbackArray.length = 0,
                e & Fr.TextureDirtyFlag && Fr._DirtyCallbackArray.push(Fr._TextureDirtyCallBack),
                e & Fr.LightDirtyFlag && Fr._DirtyCallbackArray.push(Fr._LightsDirtyCallBack),
                e & Fr.FresnelDirtyFlag && Fr._DirtyCallbackArray.push(Fr._FresnelDirtyCallBack),
                e & Fr.AttributesDirtyFlag && Fr._DirtyCallbackArray.push(Fr._AttributeDirtyCallBack),
                e & Fr.MiscDirtyFlag && Fr._DirtyCallbackArray.push(Fr._MiscDirtyCallBack),
                e & Fr.PrePassDirtyFlag && Fr._DirtyCallbackArray.push(Fr._PrePassDirtyCallBack),
                Fr._DirtyCallbackArray.length && this._markAllSubMeshesAsDirty(Fr._RunDirtyCallBacks),
                this.getScene().resetCachedMaterial())
            }
            resetDrawCache() {
                const e = this.getScene().meshes;
                for (const t of e)
                    if (t.subMeshes)
                        for (const e of t.subMeshes)
                            e.getMaterial() === this && e.resetDrawCache()
            }
            _markAllSubMeshesAsDirty(e) {
                if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism)
                    return;
                const t = this.getScene().meshes;
                for (const i of t)
                    if (i.subMeshes)
                        for (const t of i.subMeshes)
                            if (t.getMaterial(!1) === this)
                                for (const i of t._drawWrappers)
                                    i && i.defines && i.defines.markAllAsDirty && this._materialContext === i.materialContext && e(i.defines)
            }
            _markScenePrePassDirty() {
                if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism)
                    return;
                const e = this.getScene().enablePrePassRenderer();
                e && e.markAsDirty()
            }
            _markAllSubMeshesAsAllDirty() {
                this._markAllSubMeshesAsDirty(Fr._AllDirtyCallBack)
            }
            _markAllSubMeshesAsImageProcessingDirty() {
                this._markAllSubMeshesAsDirty(Fr._ImageProcessingDirtyCallBack)
            }
            _markAllSubMeshesAsTexturesDirty() {
                this._markAllSubMeshesAsDirty(Fr._TextureDirtyCallBack)
            }
            _markAllSubMeshesAsFresnelDirty() {
                this._markAllSubMeshesAsDirty(Fr._FresnelDirtyCallBack)
            }
            _markAllSubMeshesAsFresnelAndMiscDirty() {
                this._markAllSubMeshesAsDirty(Fr._FresnelAndMiscDirtyCallBack)
            }
            _markAllSubMeshesAsLightsDirty() {
                this._markAllSubMeshesAsDirty(Fr._LightsDirtyCallBack)
            }
            _markAllSubMeshesAsAttributesDirty() {
                this._markAllSubMeshesAsDirty(Fr._AttributeDirtyCallBack)
            }
            _markAllSubMeshesAsMiscDirty() {
                this._markAllSubMeshesAsDirty(Fr._MiscDirtyCallBack)
            }
            _markAllSubMeshesAsPrePassDirty() {
                this._markAllSubMeshesAsDirty(Fr._MiscDirtyCallBack)
            }
            _markAllSubMeshesAsTexturesAndMiscDirty() {
                this._markAllSubMeshesAsDirty(Fr._TextureAndMiscDirtyCallBack)
            }
            _checkScenePerformancePriority() {
                if (this._scene.performancePriority !== Us.BackwardCompatible) {
                    this.checkReadyOnlyOnce = !0;
                    const e = this._scene.onScenePerformancePriorityChangedObservable.addOnce(( () => {
                        this.checkReadyOnlyOnce = !1
                    }
                    ));
                    this.onDisposeObservable.add(( () => {
                        this._scene.onScenePerformancePriorityChangedObservable.remove(e)
                    }
                    ))
                }
            }
            setPrePassRenderer(e) {
                return !1
            }
            dispose(e, t, i) {
                const s = this.getScene();
                if (s.stopAnimation(this),
                s.freeProcessedMaterials(),
                s.removeMaterial(this),
                this._eventInfo.forceDisposeTextures = t,
                this._callbackPluginEventGeneric(pr.Disposed, this._eventInfo),
                this._parentContainer) {
                    const e = this._parentContainer.materials.indexOf(this);
                    e > -1 && this._parentContainer.materials.splice(e, 1),
                    this._parentContainer = null
                }
                if (!0 !== i)
                    if (this.meshMap)
                        for (const t in this.meshMap) {
                            const i = this.meshMap[t];
                            i && (i.material = null,
                            this.releaseVertexArrayObject(i, e))
                        }
                    else {
                        const t = s.meshes;
                        for (const i of t)
                            i.material !== this || i.sourceMesh || (i.material = null,
                            this.releaseVertexArrayObject(i, e))
                    }
                this._uniformBuffer.dispose(),
                e && this._drawWrapper.effect && (this._storeEffectOnSubMeshes || this._drawWrapper.effect.dispose(),
                this._drawWrapper.effect = null),
                this.metadata = null,
                this.onDisposeObservable.notifyObservers(this),
                this.onDisposeObservable.clear(),
                this._onBindObservable && this._onBindObservable.clear(),
                this._onUnBindObservable && this._onUnBindObservable.clear(),
                this._onEffectCreatedObservable && this._onEffectCreatedObservable.clear(),
                this._eventInfo && (this._eventInfo = {})
            }
            releaseVertexArrayObject(e, t) {
                const i = e.geometry;
                if (i)
                    if (this._storeEffectOnSubMeshes) {
                        if (e.subMeshes)
                            for (const s of e.subMeshes)
                                i._releaseVertexArrayObject(s.effect),
                                t && s.effect && s.effect.dispose()
                    } else
                        i._releaseVertexArrayObject(this._drawWrapper.effect)
            }
            serialize() {
                const e = ki.Serialize(this);
                return e.stencil = this.stencil.serialize(),
                e.uniqueId = this.uniqueId,
                this._serializePlugins(e),
                e
            }
            _serializePlugins(e) {
                if (e.plugins = {},
                this.pluginManager)
                    for (const t of this.pluginManager._plugins)
                        e.plugins[t.getClassName()] = t.serialize()
            }
            static Parse(e, t, i) {
                if (e.customType) {
                    if ("BABYLON.PBRMaterial" === e.customType && e.overloadedAlbedo && (e.customType = "BABYLON.LegacyPBRMaterial",
                    !BABYLON.LegacyPBRMaterial))
                        return We.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library."),
                        null
                } else
                    e.customType = "BABYLON.StandardMaterial";
                const s = hi.Instantiate(e.customType).Parse(e, t, i);
                return s._loadedUniqueId = e.uniqueId,
                s
            }
            static _ParsePlugins(e, t, i, s) {
                if (e.plugins)
                    for (const r in e.plugins) {
                        const n = e.plugins[r];
                        let a = t.pluginManager?.getPlugin(n.name);
                        if (!a) {
                            const e = hi.Instantiate("BABYLON." + r);
                            e && (a = new e(t))
                        }
                        a?.parse(n, i, s)
                    }
            }
        }
        Fr.TriangleFillMode = 0,
        Fr.WireFrameFillMode = 1,
        Fr.PointFillMode = 2,
        Fr.PointListDrawMode = 3,
        Fr.LineListDrawMode = 4,
        Fr.LineLoopDrawMode = 5,
        Fr.LineStripDrawMode = 6,
        Fr.TriangleStripDrawMode = 7,
        Fr.TriangleFanDrawMode = 8,
        Fr.ClockWiseSideOrientation = 0,
        Fr.CounterClockWiseSideOrientation = 1,
        Fr.TextureDirtyFlag = 1,
        Fr.LightDirtyFlag = 2,
        Fr.FresnelDirtyFlag = 4,
        Fr.AttributesDirtyFlag = 8,
        Fr.MiscDirtyFlag = 16,
        Fr.PrePassDirtyFlag = 32,
        Fr.AllDirtyFlag = 63,
        Fr.MATERIAL_OPAQUE = 0,
        Fr.MATERIAL_ALPHATEST = 1,
        Fr.MATERIAL_ALPHABLEND = 2,
        Fr.MATERIAL_ALPHATESTANDBLEND = 3,
        Fr.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0,
        Fr.MATERIAL_NORMALBLENDMETHOD_RNM = 1,
        Fr.OnEventObservable = new Ue,
        Fr._AllDirtyCallBack = e => e.markAllAsDirty(),
        Fr._ImageProcessingDirtyCallBack = e => e.markAsImageProcessingDirty(),
        Fr._TextureDirtyCallBack = e => e.markAsTexturesDirty(),
        Fr._FresnelDirtyCallBack = e => e.markAsFresnelDirty(),
        Fr._MiscDirtyCallBack = e => e.markAsMiscDirty(),
        Fr._PrePassDirtyCallBack = e => e.markAsPrePassDirty(),
        Fr._LightsDirtyCallBack = e => e.markAsLightDirty(),
        Fr._AttributeDirtyCallBack = e => e.markAsAttributesDirty(),
        Fr._FresnelAndMiscDirtyCallBack = e => {
            Fr._FresnelDirtyCallBack(e),
            Fr._MiscDirtyCallBack(e)
        }
        ,
        Fr._TextureAndMiscDirtyCallBack = e => {
            Fr._TextureDirtyCallBack(e),
            Fr._MiscDirtyCallBack(e)
        }
        ,
        Fr._DirtyCallbackArray = [],
        Fr._RunDirtyCallBacks = e => {
            for (const t of Fr._DirtyCallbackArray)
                t(e)
        }
        ,
        pi([xi()], Fr.prototype, "id", void 0),
        pi([xi()], Fr.prototype, "uniqueId", void 0),
        pi([xi()], Fr.prototype, "name", void 0),
        pi([xi()], Fr.prototype, "metadata", void 0),
        pi([xi()], Fr.prototype, "checkReadyOnEveryCall", void 0),
        pi([xi()], Fr.prototype, "checkReadyOnlyOnce", void 0),
        pi([xi()], Fr.prototype, "state", void 0),
        pi([xi("alpha")], Fr.prototype, "_alpha", void 0),
        pi([xi("backFaceCulling")], Fr.prototype, "_backFaceCulling", void 0),
        pi([xi("cullBackFaces")], Fr.prototype, "_cullBackFaces", void 0),
        pi([xi()], Fr.prototype, "sideOrientation", void 0),
        pi([xi("alphaMode")], Fr.prototype, "_alphaMode", void 0),
        pi([xi()], Fr.prototype, "_needDepthPrePass", void 0),
        pi([xi()], Fr.prototype, "disableDepthWrite", void 0),
        pi([xi()], Fr.prototype, "disableColorWrite", void 0),
        pi([xi()], Fr.prototype, "forceDepthWrite", void 0),
        pi([xi()], Fr.prototype, "depthFunction", void 0),
        pi([xi()], Fr.prototype, "separateCullingPass", void 0),
        pi([xi("fogEnabled")], Fr.prototype, "_fogEnabled", void 0),
        pi([xi()], Fr.prototype, "pointSize", void 0),
        pi([xi()], Fr.prototype, "zOffset", void 0),
        pi([xi()], Fr.prototype, "zOffsetUnits", void 0),
        pi([xi()], Fr.prototype, "pointsCloud", null),
        pi([xi()], Fr.prototype, "fillMode", null),
        pi([xi()], Fr.prototype, "useLogarithmicDepth", null),
        pi([xi()], Fr.prototype, "transparencyMode", null);
        class Or extends Fr {
            get subMaterials() {
                return this._subMaterials
            }
            set subMaterials(e) {
                this._subMaterials = e,
                this._hookArray(e)
            }
            getChildren() {
                return this.subMaterials
            }
            constructor(e, t) {
                super(e, t, !0),
                this._waitingSubMaterialsUniqueIds = [],
                this.getScene().addMultiMaterial(this),
                this.subMaterials = [],
                this._storeEffectOnSubMeshes = !0
            }
            _hookArray(e) {
                const t = e.push;
                e.push = (...i) => {
                    const s = t.apply(e, i);
                    return this._markAllSubMeshesAsTexturesDirty(),
                    s
                }
                ;
                const i = e.splice;
                e.splice = (t, s) => {
                    const r = i.apply(e, [t, s]);
                    return this._markAllSubMeshesAsTexturesDirty(),
                    r
                }
            }
            getSubMaterial(e) {
                return e < 0 || e >= this.subMaterials.length ? this.getScene().defaultMaterial : this.subMaterials[e]
            }
            getActiveTextures() {
                return super.getActiveTextures().concat(...this.subMaterials.map((e => e ? e.getActiveTextures() : [])))
            }
            hasTexture(e) {
                if (super.hasTexture(e))
                    return !0;
                for (let t = 0; t < this.subMaterials.length; t++)
                    if (this.subMaterials[t]?.hasTexture(e))
                        return !0;
                return !1
            }
            getClassName() {
                return "MultiMaterial"
            }
            isReadyForSubMesh(e, t, i) {
                for (let s = 0; s < this.subMaterials.length; s++) {
                    const r = this.subMaterials[s];
                    if (r) {
                        if (r._storeEffectOnSubMeshes) {
                            if (!r.isReadyForSubMesh(e, t, i))
                                return !1;
                            continue
                        }
                        if (!r.isReady(e))
                            return !1
                    }
                }
                return !0
            }
            clone(e, t) {
                const i = new Or(e,this.getScene());
                for (let s = 0; s < this.subMaterials.length; s++) {
                    let r = null;
                    const n = this.subMaterials[s];
                    r = t && n ? n.clone(e + "-" + n.name) : this.subMaterials[s],
                    i.subMaterials.push(r)
                }
                return i
            }
            serialize() {
                const e = {};
                e.name = this.name,
                e.id = this.id,
                e.uniqueId = this.uniqueId,
                ui && (e.tags = ui.GetTags(this)),
                e.materialsUniqueIds = [],
                e.materials = [];
                for (let t = 0; t < this.subMaterials.length; t++) {
                    const i = this.subMaterials[t];
                    i ? (e.materialsUniqueIds.push(i.uniqueId),
                    e.materials.push(i.id)) : (e.materialsUniqueIds.push(null),
                    e.materials.push(null))
                }
                return e
            }
            dispose(e, t, i) {
                const s = this.getScene();
                if (!s)
                    return;
                if (i)
                    for (let i = 0; i < this.subMaterials.length; i++) {
                        const s = this.subMaterials[i];
                        s && s.dispose(e, t)
                    }
                const r = s.multiMaterials.indexOf(this);
                r >= 0 && s.multiMaterials.splice(r, 1),
                super.dispose(e, t)
            }
            static ParseMultiMaterial(e, t) {
                const i = new Or(e.name,t);
                return i.id = e.id,
                i._loadedUniqueId = e.uniqueId,
                ui && ui.AddTagsTo(i, e.tags),
                e.materialsUniqueIds ? i._waitingSubMaterialsUniqueIds = e.materialsUniqueIds : e.materials.forEach((e => i.subMaterials.push(t.getLastMaterialById(e)))),
                i
            }
        }
        Ie("BABYLON.MultiMaterial", Or);
        class Lr {
            constructor(e, t) {
                this.distanceOrScreenCoverage = e,
                this.mesh = t
            }
        }
        class Br {
        }
        class Nr {
            constructor() {
                this.visibleInstances = {},
                this.batchCache = new Ur,
                this.batchCacheReplacementModeInFrozenMode = new Ur,
                this.instancesBufferSize = 2048
            }
        }
        class Ur {
            constructor() {
                this.mustReturn = !1,
                this.visibleInstances = new Array,
                this.renderSelf = [],
                this.hardwareInstancedRendering = []
            }
        }
        class kr {
            constructor() {
                this.instancesCount = 0,
                this.matrixBuffer = null,
                this.previousMatrixBuffer = null,
                this.matrixBufferSize = 512,
                this.matrixData = null,
                this.boundingVectors = [],
                this.worldMatrices = null
            }
        }
        class Vr {
            constructor() {
                this._areNormalsFrozen = !1,
                this._source = null,
                this.meshMap = null,
                this._preActivateId = -1,
                this._LODLevels = new Array,
                this._useLODScreenCoverage = !1,
                this._effectiveMaterial = null,
                this._forcedInstanceCount = 0,
                this._overrideRenderingFillMode = null
            }
        }
        class Gr extends fr {
            static _GetDefaultSideOrientation(e) {
                return e || Gr.FRONTSIDE
            }
            get useLODScreenCoverage() {
                return this._internalMeshDataInfo._useLODScreenCoverage
            }
            set useLODScreenCoverage(e) {
                this._internalMeshDataInfo._useLODScreenCoverage = e,
                this._sortLODLevels()
            }
            get computeBonesUsingShaders() {
                return this._internalAbstractMeshDataInfo._computeBonesUsingShaders
            }
            set computeBonesUsingShaders(e) {
                this._internalAbstractMeshDataInfo._computeBonesUsingShaders !== e && (e && this._internalMeshDataInfo._sourcePositions && (this.setVerticesData(os.PositionKind, this._internalMeshDataInfo._sourcePositions, !0),
                this._internalMeshDataInfo._sourceNormals && this.setVerticesData(os.NormalKind, this._internalMeshDataInfo._sourceNormals, !0),
                this._internalMeshDataInfo._sourcePositions = null,
                this._internalMeshDataInfo._sourceNormals = null),
                this._internalAbstractMeshDataInfo._computeBonesUsingShaders = e,
                this._markSubMeshesAsAttributesDirty())
            }
            get onBeforeRenderObservable() {
                return this._internalMeshDataInfo._onBeforeRenderObservable || (this._internalMeshDataInfo._onBeforeRenderObservable = new Ue),
                this._internalMeshDataInfo._onBeforeRenderObservable
            }
            get onBeforeBindObservable() {
                return this._internalMeshDataInfo._onBeforeBindObservable || (this._internalMeshDataInfo._onBeforeBindObservable = new Ue),
                this._internalMeshDataInfo._onBeforeBindObservable
            }
            get onAfterRenderObservable() {
                return this._internalMeshDataInfo._onAfterRenderObservable || (this._internalMeshDataInfo._onAfterRenderObservable = new Ue),
                this._internalMeshDataInfo._onAfterRenderObservable
            }
            get onBetweenPassObservable() {
                return this._internalMeshDataInfo._onBetweenPassObservable || (this._internalMeshDataInfo._onBetweenPassObservable = new Ue),
                this._internalMeshDataInfo._onBetweenPassObservable
            }
            get onBeforeDrawObservable() {
                return this._internalMeshDataInfo._onBeforeDrawObservable || (this._internalMeshDataInfo._onBeforeDrawObservable = new Ue),
                this._internalMeshDataInfo._onBeforeDrawObservable
            }
            set onBeforeDraw(e) {
                this._onBeforeDrawObserver && this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver),
                this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(e)
            }
            get hasInstances() {
                return this.instances.length > 0
            }
            get hasThinInstances() {
                return (this.forcedInstanceCount || this._thinInstanceDataStorage.instancesCount || 0) > 0
            }
            get forcedInstanceCount() {
                return this._internalMeshDataInfo._forcedInstanceCount
            }
            set forcedInstanceCount(e) {
                this._internalMeshDataInfo._forcedInstanceCount = e
            }
            get overrideRenderingFillMode() {
                return this._internalMeshDataInfo._overrideRenderingFillMode
            }
            set overrideRenderingFillMode(e) {
                this._internalMeshDataInfo._overrideRenderingFillMode = e
            }
            get source() {
                return this._internalMeshDataInfo._source
            }
            get cloneMeshMap() {
                return this._internalMeshDataInfo.meshMap
            }
            get isUnIndexed() {
                return this._unIndexed
            }
            set isUnIndexed(e) {
                this._unIndexed !== e && (this._unIndexed = e,
                this._markSubMeshesAsAttributesDirty())
            }
            get worldMatrixInstancedBuffer() {
                return this._instanceDataStorage.instancesData
            }
            get previousWorldMatrixInstancedBuffer() {
                return this._instanceDataStorage.instancesPreviousData
            }
            get manualUpdateOfWorldMatrixInstancedBuffer() {
                return this._instanceDataStorage.manualUpdate
            }
            set manualUpdateOfWorldMatrixInstancedBuffer(e) {
                this._instanceDataStorage.manualUpdate = e
            }
            get manualUpdateOfPreviousWorldMatrixInstancedBuffer() {
                return this._instanceDataStorage.previousManualUpdate
            }
            set manualUpdateOfPreviousWorldMatrixInstancedBuffer(e) {
                this._instanceDataStorage.previousManualUpdate = e
            }
            get forceWorldMatrixInstancedBufferUpdate() {
                return this._instanceDataStorage.forceMatrixUpdates
            }
            set forceWorldMatrixInstancedBufferUpdate(e) {
                this._instanceDataStorage.forceMatrixUpdates = e
            }
            constructor(e, t=null, i=null, s=null, r, n=!0) {
                if (super(e, t),
                this._internalMeshDataInfo = new Vr,
                this.delayLoadState = 0,
                this.instances = [],
                this._creationDataStorage = null,
                this._geometry = null,
                this._instanceDataStorage = new Nr,
                this._thinInstanceDataStorage = new kr,
                this._shouldGenerateFlatShading = !1,
                this._originalBuilderSideOrientation = Gr.DEFAULTSIDE,
                this.overrideMaterialSideOrientation = null,
                this.ignoreCameraMaxZ = !1,
                t = this.getScene(),
                this._onBeforeDraw = (e, t, i) => {
                    e && i && (this._uniformBuffer ? this.transferToEffect(t) : i.bindOnlyWorldMatrix(t))
                }
                ,
                s) {
                    if (s._geometry && s._geometry.applyToMesh(this),
                    He.DeepCopy(s, this, ["name", "material", "skeleton", "instances", "parent", "uniqueId", "source", "metadata", "morphTargetManager", "hasInstances", "worldMatrixInstancedBuffer", "previousWorldMatrixInstancedBuffer", "hasLODLevels", "geometry", "isBlocked", "areNormalsFrozen", "facetNb", "isFacetDataEnabled", "lightSources", "useBones", "isAnInstance", "collider", "edgesRenderer", "forward", "up", "right", "absolutePosition", "absoluteScaling", "absoluteRotationQuaternion", "isWorldMatrixFrozen", "nonUniformScaling", "behaviors", "worldMatrixFromCache", "hasThinInstances", "cloneMeshMap", "hasBoundingInfo", "physicsBody", "physicsImpostor"], ["_poseMatrix"]),
                    this._internalMeshDataInfo._source = s,
                    t.useClonedMeshMap && (s._internalMeshDataInfo.meshMap || (s._internalMeshDataInfo.meshMap = {}),
                    s._internalMeshDataInfo.meshMap[this.uniqueId] = this),
                    this._originalBuilderSideOrientation = s._originalBuilderSideOrientation,
                    this._creationDataStorage = s._creationDataStorage,
                    s._ranges) {
                        const e = s._ranges;
                        for (const t in e)
                            Object.prototype.hasOwnProperty.call(e, t) && e[t] && this.createAnimationRange(t, e[t].from, e[t].to)
                    }
                    if (s.metadata && s.metadata.clone ? this.metadata = s.metadata.clone() : this.metadata = s.metadata,
                    this._internalMetadata = s._internalMetadata,
                    ui && ui.HasTags(s) && ui.AddTagsTo(this, ui.GetTags(s, !0)),
                    this.setEnabled(s.isEnabled(!1)),
                    this.parent = s.parent,
                    this.setPivotMatrix(s.getPivotMatrix(), this._postMultiplyPivotMatrix),
                    this.id = e + "." + s.id,
                    this.material = s.material,
                    !r) {
                        const t = s.getDescendants(!0);
                        for (let i = 0; i < t.length; i++) {
                            const s = t[i];
                            s.clone && s.clone(e + "." + s.name, this)
                        }
                    }
                    if (s.morphTargetManager && (this.morphTargetManager = s.morphTargetManager),
                    t.getPhysicsEngine) {
                        const e = t.getPhysicsEngine();
                        if (n && e)
                            if (1 === e.getPluginVersion()) {
                                const t = e.getImpostorForPhysicsObject(s);
                                t && (this.physicsImpostor = t.clone(this))
                            } else
                                2 === e.getPluginVersion() && s.physicsBody && s.physicsBody.clone(this)
                    }
                    for (let e = 0; e < t.particleSystems.length; e++) {
                        const i = t.particleSystems[e];
                        i.emitter === s && i.clone(i.name, this)
                    }
                    this.skeleton = s.skeleton,
                    this.refreshBoundingInfo(!0, !0),
                    this.computeWorldMatrix(!0)
                }
                null !== i && (this.parent = i),
                this._instanceDataStorage.hardwareInstancedRendering = this.getEngine().getCaps().instancedArrays,
                this._internalMeshDataInfo._onMeshReadyObserverAdded = e => {
                    e.unregisterOnNextCall = !0,
                    this.isReady(!0) ? this.onMeshReadyObservable.notifyObservers(this) : this._internalMeshDataInfo._checkReadinessObserver || (this._internalMeshDataInfo._checkReadinessObserver = this._scene.onBeforeRenderObservable.add(( () => {
                        this.isReady(!0) && (this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),
                        this._internalMeshDataInfo._checkReadinessObserver = null,
                        this.onMeshReadyObservable.notifyObservers(this))
                    }
                    )))
                }
                ,
                this.onMeshReadyObservable = new Ue(this._internalMeshDataInfo._onMeshReadyObserverAdded),
                s && s.onClonedObservable.notifyObservers(this)
            }
            instantiateHierarchy(e=null, t, i) {
                const s = 0 === this.getTotalVertices() || t && t.doNotInstantiate && (!0 === t.doNotInstantiate || t.doNotInstantiate(this)) ? this.clone("Clone of " + (this.name || this.id), e || this.parent, !0) : this.createInstance("instance of " + (this.name || this.id));
                s.parent = e || this.parent,
                s.position = this.position.clone(),
                s.scaling = this.scaling.clone(),
                this.rotationQuaternion ? s.rotationQuaternion = this.rotationQuaternion.clone() : s.rotation = this.rotation.clone(),
                i && i(this, s);
                for (const e of this.getChildTransformNodes(!0))
                    "InstancedMesh" === e.getClassName() && "Mesh" === s.getClassName() && e.sourceMesh === this ? e.instantiateHierarchy(s, {
                        doNotInstantiate: t && t.doNotInstantiate || !1,
                        newSourcedMesh: s
                    }, i) : e.instantiateHierarchy(s, t, i);
                return s
            }
            getClassName() {
                return "Mesh"
            }
            get _isMesh() {
                return !0
            }
            toString(e) {
                let t = super.toString(e);
                if (t += ", n vertices: " + this.getTotalVertices(),
                t += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE"),
                this.animations)
                    for (let i = 0; i < this.animations.length; i++)
                        t += ", animation[0]: " + this.animations[i].toString(e);
                if (e)
                    if (this._geometry) {
                        const e = this.getIndices()
                          , i = this.getVerticesData(os.PositionKind);
                        i && e && (t += ", flat shading: " + (i.length / 3 === e.length ? "YES" : "NO"))
                    } else
                        t += ", flat shading: UNKNOWN";
                return t
            }
            _unBindEffect() {
                super._unBindEffect();
                for (const e of this.instances)
                    e._unBindEffect()
            }
            get hasLODLevels() {
                return this._internalMeshDataInfo._LODLevels.length > 0
            }
            getLODLevels() {
                return this._internalMeshDataInfo._LODLevels
            }
            _sortLODLevels() {
                const e = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;
                this._internalMeshDataInfo._LODLevels.sort(( (t, i) => t.distanceOrScreenCoverage < i.distanceOrScreenCoverage ? e : t.distanceOrScreenCoverage > i.distanceOrScreenCoverage ? -e : 0))
            }
            addLODLevel(e, t) {
                if (t && t._masterMesh)
                    return We.Warn("You cannot use a mesh as LOD level twice"),
                    this;
                const i = new Lr(e,t);
                return this._internalMeshDataInfo._LODLevels.push(i),
                t && (t._masterMesh = this),
                this._sortLODLevels(),
                this
            }
            getLODLevelAtDistance(e) {
                const t = this._internalMeshDataInfo;
                for (let i = 0; i < t._LODLevels.length; i++) {
                    const s = t._LODLevels[i];
                    if (s.distanceOrScreenCoverage === e)
                        return s.mesh
                }
                return null
            }
            removeLODLevel(e) {
                const t = this._internalMeshDataInfo;
                for (let i = 0; i < t._LODLevels.length; i++)
                    t._LODLevels[i].mesh === e && (t._LODLevels.splice(i, 1),
                    e && (e._masterMesh = null));
                return this._sortLODLevels(),
                this
            }
            getLOD(e, t) {
                const i = this._internalMeshDataInfo;
                if (!i._LODLevels || 0 === i._LODLevels.length)
                    return this;
                const s = t || this.getBoundingInfo().boundingSphere
                  , r = e.mode === Hi.ORTHOGRAPHIC_CAMERA ? e.minZ : s.centerWorld.subtract(e.globalPosition).length();
                let n = r
                  , a = 1;
                if (i._useLODScreenCoverage) {
                    const t = e.screenArea;
                    let i = s.radiusWorld * e.minZ / r;
                    i = i * i * Math.PI,
                    n = i / t,
                    a = -1
                }
                if (a * i._LODLevels[i._LODLevels.length - 1].distanceOrScreenCoverage > a * n)
                    return this.onLODLevelSelection && this.onLODLevelSelection(n, this, this),
                    this;
                for (let e = 0; e < i._LODLevels.length; e++) {
                    const t = i._LODLevels[e];
                    if (a * t.distanceOrScreenCoverage < a * n) {
                        if (t.mesh) {
                            if (4 === t.mesh.delayLoadState)
                                return t.mesh._checkDelayState(),
                                this;
                            if (2 === t.mesh.delayLoadState)
                                return this;
                            t.mesh._preActivate(),
                            t.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache)
                        }
                        return this.onLODLevelSelection && this.onLODLevelSelection(n, this, t.mesh),
                        t.mesh
                    }
                }
                return this.onLODLevelSelection && this.onLODLevelSelection(n, this, this),
                this
            }
            get geometry() {
                return this._geometry
            }
            getTotalVertices() {
                return null === this._geometry || void 0 === this._geometry ? 0 : this._geometry.getTotalVertices()
            }
            getVerticesData(e, t, i, s) {
                if (!this._geometry)
                    return null;
                let r = s ? void 0 : this._userInstancedBuffersStorage?.vertexBuffers[e]?.getFloatData(this.instances.length + 1, i || t && 1 !== this._geometry.meshes.length);
                return r || (r = this._geometry.getVerticesData(e, t, i)),
                r
            }
            getVertexBuffer(e, t) {
                return this._geometry ? (t ? void 0 : this._userInstancedBuffersStorage?.vertexBuffers[e]) ?? this._geometry.getVertexBuffer(e) : null
            }
            isVerticesDataPresent(e, t) {
                return this._geometry ? !t && void 0 !== this._userInstancedBuffersStorage?.vertexBuffers[e] || this._geometry.isVerticesDataPresent(e) : !!this._delayInfo && -1 !== this._delayInfo.indexOf(e)
            }
            isVertexBufferUpdatable(e, t) {
                if (!this._geometry)
                    return !!this._delayInfo && -1 !== this._delayInfo.indexOf(e);
                if (!t) {
                    const t = this._userInstancedBuffersStorage?.vertexBuffers[e];
                    if (t)
                        return t.isUpdatable()
                }
                return this._geometry.isVertexBufferUpdatable(e)
            }
            getVerticesDataKinds(e) {
                if (!this._geometry) {
                    const e = [];
                    return this._delayInfo && this._delayInfo.forEach((function(t) {
                        e.push(t)
                    }
                    )),
                    e
                }
                const t = this._geometry.getVerticesDataKinds();
                if (!e && this._userInstancedBuffersStorage)
                    for (const e in this._userInstancedBuffersStorage.vertexBuffers)
                        -1 === t.indexOf(e) && t.push(e);
                return t
            }
            getTotalIndices() {
                return this._geometry ? this._geometry.getTotalIndices() : 0
            }
            getIndices(e, t) {
                return this._geometry ? this._geometry.getIndices(e, t) : []
            }
            get isBlocked() {
                return null !== this._masterMesh && void 0 !== this._masterMesh
            }
            isReady(e=!1, t=!1) {
                if (2 === this.delayLoadState)
                    return !1;
                if (!super.isReady(e))
                    return !1;
                if (!this.subMeshes || 0 === this.subMeshes.length)
                    return !0;
                if (!e)
                    return !0;
                const i = this.getEngine()
                  , s = this.getScene()
                  , r = t || i.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);
                this.computeWorldMatrix();
                const n = this.material || s.defaultMaterial;
                if (n)
                    if (n._storeEffectOnSubMeshes)
                        for (const e of this.subMeshes) {
                            const t = e.getMaterial();
                            if (t)
                                if (t._storeEffectOnSubMeshes) {
                                    if (!t.isReadyForSubMesh(this, e, r))
                                        return !1
                                } else if (!t.isReady(this, r))
                                    return !1
                        }
                    else if (!n.isReady(this, r))
                        return !1;
                const a = i.currentRenderPassId;
                for (const e of this.lightSources) {
                    const t = e.getShadowGenerators();
                    if (!t)
                        continue;
                    const s = t.values();
                    for (let e = s.next(); !0 !== e.done; e = s.next()) {
                        const t = e.value;
                        if (t && (!t.getShadowMap()?.renderList || t.getShadowMap()?.renderList && -1 !== t.getShadowMap()?.renderList?.indexOf(this))) {
                            const e = t.getShadowMap().renderPassIds ?? [i.currentRenderPassId];
                            for (let s = 0; s < e.length; ++s) {
                                i.currentRenderPassId = e[s];
                                for (const e of this.subMeshes)
                                    if (!t.isReady(e, r, e.getMaterial()?.needAlphaBlendingForMesh(this) ?? !1))
                                        return i.currentRenderPassId = a,
                                        !1
                            }
                            i.currentRenderPassId = a
                        }
                    }
                }
                for (const e of this._internalMeshDataInfo._LODLevels)
                    if (e.mesh && !e.mesh.isReady(r))
                        return !1;
                return !0
            }
            get areNormalsFrozen() {
                return this._internalMeshDataInfo._areNormalsFrozen
            }
            freezeNormals() {
                return this._internalMeshDataInfo._areNormalsFrozen = !0,
                this
            }
            unfreezeNormals() {
                return this._internalMeshDataInfo._areNormalsFrozen = !1,
                this
            }
            set overridenInstanceCount(e) {
                this._instanceDataStorage.overridenInstanceCount = e
            }
            _preActivate() {
                const e = this._internalMeshDataInfo
                  , t = this.getScene().getRenderId();
                return e._preActivateId === t || (e._preActivateId = t,
                this._instanceDataStorage.visibleInstances = null),
                this
            }
            _preActivateForIntermediateRendering(e) {
                return this._instanceDataStorage.visibleInstances && (this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = e),
                this
            }
            _registerInstanceForRenderId(e, t) {
                return this._instanceDataStorage.visibleInstances || (this._instanceDataStorage.visibleInstances = {
                    defaultRenderId: t,
                    selfDefaultRenderId: this._renderId
                }),
                this._instanceDataStorage.visibleInstances[t] || (void 0 !== this._instanceDataStorage.previousRenderId && this._instanceDataStorage.isFrozen && (this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null),
                this._instanceDataStorage.previousRenderId = t,
                this._instanceDataStorage.visibleInstances[t] = new Array),
                this._instanceDataStorage.visibleInstances[t].push(e),
                this
            }
            _afterComputeWorldMatrix() {
                super._afterComputeWorldMatrix(),
                this.hasThinInstances && (this.doNotSyncBoundingInfo || this.thinInstanceRefreshBoundingInfo(!1))
            }
            _postActivate() {
                this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup && (this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer),
                this.edgesRenderer.customInstances.push(this.getWorldMatrix()))
            }
            refreshBoundingInfo(e=!1, t=!1) {
                if (this.hasBoundingInfo && this.getBoundingInfo().isLocked)
                    return this;
                const i = this.geometry ? this.geometry.boundingBias : null;
                return this._refreshBoundingInfo(this._getPositionData(e, t), i),
                this
            }
            _createGlobalSubMesh(e) {
                const t = this.getTotalVertices();
                if (!t || !this.getIndices())
                    return null;
                if (this.subMeshes && this.subMeshes.length > 0) {
                    const i = this.getIndices();
                    if (!i)
                        return null;
                    const s = i.length;
                    let r = !1;
                    if (e)
                        r = !0;
                    else
                        for (const e of this.subMeshes) {
                            if (e.indexStart + e.indexCount > s) {
                                r = !0;
                                break
                            }
                            if (e.verticesStart + e.verticesCount > t) {
                                r = !0;
                                break
                            }
                        }
                    if (!r)
                        return this.subMeshes[0]
                }
                return this.releaseSubMeshes(),
                new Zs(0,0,t,0,this.getTotalIndices(),this)
            }
            subdivide(e) {
                if (e < 1)
                    return;
                const t = this.getTotalIndices();
                let i = t / e | 0
                  , s = 0;
                for (; i % 3 != 0; )
                    i++;
                this.releaseSubMeshes();
                for (let r = 0; r < e && !(s >= t); r++)
                    Zs.CreateFromIndices(0, s, r === e - 1 ? t - s : i, this, void 0, !1),
                    s += i;
                this.refreshBoundingInfo(),
                this.synchronizeInstances()
            }
            setVerticesData(e, t, i=!1, s) {
                if (this._geometry)
                    this._geometry.setVerticesData(e, t, i, s);
                else {
                    const s = new $s;
                    s.set(t, e);
                    const r = this.getScene();
                    new tr(tr.RandomId(),r,s,i,this)
                }
                return this
            }
            removeVerticesData(e) {
                this._geometry && this._geometry.removeVerticesData(e)
            }
            markVerticesDataAsUpdatable(e, t=!0) {
                const i = this.getVertexBuffer(e);
                i && i.isUpdatable() !== t && this.setVerticesData(e, this.getVerticesData(e), t)
            }
            setVerticesBuffer(e, t=!0) {
                return this._geometry || (this._geometry = tr.CreateGeometryForMesh(this)),
                this._geometry.setVerticesBuffer(e, null, t),
                this
            }
            updateVerticesData(e, t, i, s) {
                return this._geometry ? (s ? (this.makeGeometryUnique(),
                this.updateVerticesData(e, t, i, !1)) : this._geometry.updateVerticesData(e, t, i),
                this) : this
            }
            updateMeshPositions(e, t=!0) {
                const i = this.getVerticesData(os.PositionKind);
                if (!i)
                    return this;
                if (e(i),
                this.updateVerticesData(os.PositionKind, i, !1, !1),
                t) {
                    const e = this.getIndices()
                      , t = this.getVerticesData(os.NormalKind);
                    if (!t)
                        return this;
                    $s.ComputeNormals(i, e, t),
                    this.updateVerticesData(os.NormalKind, t, !1, !1)
                }
                return this
            }
            makeGeometryUnique() {
                if (!this._geometry)
                    return this;
                if (1 === this._geometry.meshes.length)
                    return this;
                const e = this._geometry
                  , t = this._geometry.copy(tr.RandomId());
                return e.releaseForMesh(this, !0),
                t.applyToMesh(this),
                this
            }
            setIndexBuffer(e, t, i) {
                let s = this._geometry;
                s || (s = new tr(tr.RandomId(),this.getScene(),void 0,void 0,this)),
                s.setIndexBuffer(e, t, i)
            }
            setIndices(e, t=null, i=!1) {
                if (this._geometry)
                    this._geometry.setIndices(e, t, i);
                else {
                    const t = new $s;
                    t.indices = e;
                    const s = this.getScene();
                    new tr(tr.RandomId(),s,t,i,this)
                }
                return this
            }
            updateIndices(e, t, i=!1) {
                return this._geometry ? (this._geometry.updateIndices(e, t, i),
                this) : this
            }
            toLeftHanded() {
                return this._geometry ? (this._geometry.toLeftHanded(),
                this) : this
            }
            _bind(e, t, i, s=!0) {
                if (!this._geometry)
                    return this;
                const r = this.getScene().getEngine();
                let n;
                if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets && this.morphTargetManager._bind(t),
                this._unIndexed)
                    n = null;
                else
                    switch (this._getRenderingFillMode(i)) {
                    case Fr.PointFillMode:
                        n = null;
                        break;
                    case Fr.WireFrameFillMode:
                        n = e._getLinesIndexBuffer(this.getIndices(), r);
                        break;
                    default:
                    case Fr.TriangleFillMode:
                        n = this._geometry.getIndexBuffer()
                    }
                return s && this._userInstancedBuffersStorage && !this.hasThinInstances ? this._geometry._bind(t, n, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects) : this._geometry._bind(t, n),
                this
            }
            _draw(e, t, i) {
                if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer())
                    return this;
                this._internalMeshDataInfo._onBeforeDrawObservable && this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);
                const s = this.getScene().getEngine();
                return this._unIndexed || t == Fr.PointFillMode ? s.drawArraysType(t, e.verticesStart, e.verticesCount, this.forcedInstanceCount || i) : t == Fr.WireFrameFillMode ? s.drawElementsType(t, 0, e._linesIndexCount, this.forcedInstanceCount || i) : s.drawElementsType(t, e.indexStart, e.indexCount, this.forcedInstanceCount || i),
                this
            }
            registerBeforeRender(e) {
                return this.onBeforeRenderObservable.add(e),
                this
            }
            unregisterBeforeRender(e) {
                return this.onBeforeRenderObservable.removeCallback(e),
                this
            }
            registerAfterRender(e) {
                return this.onAfterRenderObservable.add(e),
                this
            }
            unregisterAfterRender(e) {
                return this.onAfterRenderObservable.removeCallback(e),
                this
            }
            _getInstancesRenderList(e, t=!1) {
                if (this._instanceDataStorage.isFrozen) {
                    if (t)
                        return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[e] = !1,
                        this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[e] = !0,
                        this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;
                    if (this._instanceDataStorage.previousBatch)
                        return this._instanceDataStorage.previousBatch
                }
                const i = this.getScene()
                  , s = i._isInIntermediateRendering()
                  , r = s ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances
                  , n = this._instanceDataStorage.batchCache;
                if (n.mustReturn = !1,
                n.renderSelf[e] = t || !r && this.isEnabled() && this.isVisible,
                n.visibleInstances[e] = null,
                this._instanceDataStorage.visibleInstances && !t) {
                    const t = this._instanceDataStorage.visibleInstances
                      , r = i.getRenderId()
                      , a = s ? t.intermediateDefaultRenderId : t.defaultRenderId;
                    n.visibleInstances[e] = t[r],
                    !n.visibleInstances[e] && a && (n.visibleInstances[e] = t[a])
                }
                return n.hardwareInstancedRendering[e] = !t && this._instanceDataStorage.hardwareInstancedRendering && null !== n.visibleInstances[e] && void 0 !== n.visibleInstances[e],
                this._instanceDataStorage.previousBatch = n,
                n
            }
            _renderWithInstances(e, t, i, s, r) {
                const n = i.visibleInstances[e._id]
                  , a = n ? n.length : 0
                  , o = this._instanceDataStorage
                  , h = o.instancesBufferSize;
                let l = o.instancesBuffer
                  , c = o.instancesPreviousBuffer;
                const u = 16 * (a + 1) * 4;
                for (; o.instancesBufferSize < u; )
                    o.instancesBufferSize *= 2;
                o.instancesData && h == o.instancesBufferSize || (o.instancesData = new Float32Array(o.instancesBufferSize / 4)),
                (this._scene.needsPreviousWorldMatrices && !o.instancesPreviousData || h != o.instancesBufferSize) && (o.instancesPreviousData = new Float32Array(o.instancesBufferSize / 4));
                let d = 0
                  , f = 0;
                const _ = i.renderSelf[e._id]
                  , p = !l || h !== o.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !o.instancesPreviousBuffer;
                if (this._instanceDataStorage.manualUpdate || o.isFrozen && !p)
                    f = (_ ? 1 : 0) + a;
                else {
                    const t = this.getWorldMatrix();
                    if (_ && (this._scene.needsPreviousWorldMatrices && (o.masterMeshPreviousWorldMatrix ? (o.masterMeshPreviousWorldMatrix.copyToArray(o.instancesPreviousData, d),
                    o.masterMeshPreviousWorldMatrix.copyFrom(t)) : (o.masterMeshPreviousWorldMatrix = t.clone(),
                    o.masterMeshPreviousWorldMatrix.copyToArray(o.instancesPreviousData, d))),
                    t.copyToArray(o.instancesData, d),
                    d += 16,
                    f++),
                    n) {
                        if (Gr.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && e.getMaterial()?.needAlphaBlendingForMesh(e.getRenderingMesh())) {
                            const e = this._scene.activeCamera.globalPosition;
                            for (let t = 0; t < n.length; t++) {
                                const i = n[t];
                                i._distanceToCamera = Di.Distance(i.getBoundingInfo().boundingSphere.centerWorld, e)
                            }
                            n.sort(( (e, t) => e._distanceToCamera > t._distanceToCamera ? -1 : e._distanceToCamera < t._distanceToCamera ? 1 : 0))
                        }
                        for (let e = 0; e < n.length; e++) {
                            const t = n[e]
                              , i = t.getWorldMatrix();
                            i.copyToArray(o.instancesData, d),
                            this._scene.needsPreviousWorldMatrices && (t._previousWorldMatrix ? (t._previousWorldMatrix.copyToArray(o.instancesPreviousData, d),
                            t._previousWorldMatrix.copyFrom(i)) : (t._previousWorldMatrix = i.clone(),
                            t._previousWorldMatrix.copyToArray(o.instancesPreviousData, d))),
                            d += 16,
                            f++
                        }
                    }
                }
                return p ? (l && l.dispose(),
                c && c.dispose(),
                l = new as(r,o.instancesData,!0,16,!1,!0),
                o.instancesBuffer = l,
                this._userInstancedBuffersStorage || (this._userInstancedBuffersStorage = {
                    data: {},
                    vertexBuffers: {},
                    strides: {},
                    sizes: {},
                    vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
                }),
                this._userInstancedBuffersStorage.vertexBuffers.world0 = l.createVertexBuffer("world0", 0, 4),
                this._userInstancedBuffersStorage.vertexBuffers.world1 = l.createVertexBuffer("world1", 4, 4),
                this._userInstancedBuffersStorage.vertexBuffers.world2 = l.createVertexBuffer("world2", 8, 4),
                this._userInstancedBuffersStorage.vertexBuffers.world3 = l.createVertexBuffer("world3", 12, 4),
                this._scene.needsPreviousWorldMatrices && (c = new as(r,o.instancesPreviousData,!0,16,!1,!0),
                o.instancesPreviousBuffer = c,
                this._userInstancedBuffersStorage.vertexBuffers.previousWorld0 = c.createVertexBuffer("previousWorld0", 0, 4),
                this._userInstancedBuffersStorage.vertexBuffers.previousWorld1 = c.createVertexBuffer("previousWorld1", 4, 4),
                this._userInstancedBuffersStorage.vertexBuffers.previousWorld2 = c.createVertexBuffer("previousWorld2", 8, 4),
                this._userInstancedBuffersStorage.vertexBuffers.previousWorld3 = c.createVertexBuffer("previousWorld3", 12, 4)),
                this._invalidateInstanceVertexArrayObject()) : this._instanceDataStorage.isFrozen && !this._instanceDataStorage.forceMatrixUpdates || (l.updateDirectly(o.instancesData, 0, f),
                !this._scene.needsPreviousWorldMatrices || this._instanceDataStorage.manualUpdate && !this._instanceDataStorage.previousManualUpdate || c.updateDirectly(o.instancesPreviousData, 0, f)),
                this._processInstancedBuffers(n, _),
                this.getScene()._activeIndices.addCount(e.indexCount * f, !1),
                r._currentDrawContext && (r._currentDrawContext.useInstancing = !0),
                this._bind(e, s, t),
                this._draw(e, t, f),
                !this._scene.needsPreviousWorldMatrices || p || !this._instanceDataStorage.manualUpdate || this._instanceDataStorage.isFrozen && !this._instanceDataStorage.forceMatrixUpdates || this._instanceDataStorage.previousManualUpdate || c.updateDirectly(o.instancesData, 0, f),
                r.unbindInstanceAttributes(),
                this
            }
            _renderWithThinInstances(e, t, i, s) {
                const r = this._thinInstanceDataStorage?.instancesCount ?? 0;
                this.getScene()._activeIndices.addCount(e.indexCount * r, !1),
                s._currentDrawContext && (s._currentDrawContext.useInstancing = !0),
                this._bind(e, i, t),
                this._draw(e, t, r),
                this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData && (this._thinInstanceDataStorage.previousMatrixBuffer ? this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, r) : this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.matrixData, !1)),
                s.unbindInstanceAttributes()
            }
            _processInstancedBuffers(e, t) {}
            _processRendering(e, t, i, s, r, n, a, o) {
                const h = this.getScene()
                  , l = h.getEngine();
                if (s = this._getRenderingFillMode(s),
                n && t.getRenderingMesh().hasThinInstances)
                    return this._renderWithThinInstances(t, s, i, l),
                    this;
                if (n)
                    this._renderWithInstances(t, s, r, i, l);
                else {
                    l._currentDrawContext && (l._currentDrawContext.useInstancing = !1);
                    let i = 0;
                    r.renderSelf[t._id] && (a && a(!1, e.getWorldMatrix(), o),
                    i++,
                    this._draw(t, s, this._instanceDataStorage.overridenInstanceCount));
                    const n = r.visibleInstances[t._id];
                    if (n) {
                        const e = n.length;
                        i += e;
                        for (let i = 0; i < e; i++) {
                            const e = n[i].getWorldMatrix();
                            a && a(!0, e, o),
                            this._draw(t, s)
                        }
                    }
                    h._activeIndices.addCount(t.indexCount * i, !1)
                }
                return this
            }
            _rebuild(e=!1) {
                if (this._instanceDataStorage.instancesBuffer && (e && this._instanceDataStorage.instancesBuffer.dispose(),
                this._instanceDataStorage.instancesBuffer = null),
                this._userInstancedBuffersStorage) {
                    for (const t in this._userInstancedBuffersStorage.vertexBuffers) {
                        const i = this._userInstancedBuffersStorage.vertexBuffers[t];
                        i && (e && i.dispose(),
                        this._userInstancedBuffersStorage.vertexBuffers[t] = null)
                    }
                    this._userInstancedBuffersStorage.vertexArrayObjects && (this._userInstancedBuffersStorage.vertexArrayObjects = {})
                }
                this._internalMeshDataInfo._effectiveMaterial = null,
                super._rebuild(e)
            }
            _freeze() {
                if (this.subMeshes) {
                    for (let e = 0; e < this.subMeshes.length; e++)
                        this._getInstancesRenderList(e);
                    this._internalMeshDataInfo._effectiveMaterial = null,
                    this._instanceDataStorage.isFrozen = !0
                }
            }
            _unFreeze() {
                this._instanceDataStorage.isFrozen = !1,
                this._instanceDataStorage.previousBatch = null
            }
            renderWithRenderPassId(e, t, i, s, r=!0) {
                const n = this._scene.getEngine()
                  , a = n.currentRenderPassId;
                if (void 0 !== e && (n.currentRenderPassId = e),
                s)
                    (!r || r && s.isInFrustum(this._scene._frustumPlanes)) && this.render(s, !!t, i);
                else
                    for (let e = 0; e < this.subMeshes.length; e++) {
                        const s = this.subMeshes[e];
                        (!r || r && s.isInFrustum(this._scene._frustumPlanes)) && this.render(s, !!t, i)
                    }
                return void 0 !== e && (n.currentRenderPassId = a),
                this
            }
            render(e, t, i) {
                const s = this.getScene();
                this._internalAbstractMeshDataInfo._isActiveIntermediate ? this._internalAbstractMeshDataInfo._isActiveIntermediate = !1 : this._internalAbstractMeshDataInfo._isActive = !1;
                const r = s.activeCameras?.length ?? 0;
                if ((r > 1 && s.activeCamera === s.activeCameras[0] || r <= 1) && this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded)
                    return this;
                const n = this._getInstancesRenderList(e._id, !!i);
                if (n.mustReturn)
                    return this;
                if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer())
                    return this;
                const a = s.getEngine();
                let o = 0
                  , h = null;
                this.ignoreCameraMaxZ && s.activeCamera && !s._isInIntermediateRendering() && (o = s.activeCamera.maxZ,
                h = s.activeCamera,
                s.activeCamera.maxZ = 0,
                s.updateTransformMatrix(!0)),
                this._internalMeshDataInfo._onBeforeRenderObservable && this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);
                const l = e.getRenderingMesh()
                  , c = n.hardwareInstancedRendering[e._id] || l.hasThinInstances || !!this._userInstancedBuffersStorage && !e.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh
                  , u = this._instanceDataStorage
                  , d = e.getMaterial();
                if (!d)
                    return h && (h.maxZ = o,
                    s.updateTransformMatrix(!0)),
                    this;
                if (u.isFrozen && this._internalMeshDataInfo._effectiveMaterial && this._internalMeshDataInfo._effectiveMaterial === d) {
                    if (d._storeEffectOnSubMeshes && !e._drawWrapper?._wasPreviouslyReady || !d._storeEffectOnSubMeshes && !d._getDrawWrapper()._wasPreviouslyReady)
                        return h && (h.maxZ = o,
                        s.updateTransformMatrix(!0)),
                        this
                } else {
                    if (d._storeEffectOnSubMeshes) {
                        if (!d.isReadyForSubMesh(this, e, c))
                            return h && (h.maxZ = o,
                            s.updateTransformMatrix(!0)),
                            this
                    } else if (!d.isReady(this, c))
                        return h && (h.maxZ = o,
                        s.updateTransformMatrix(!0)),
                        this;
                    this._internalMeshDataInfo._effectiveMaterial = d
                }
                let f;
                t && a.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode),
                f = this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes ? e._drawWrapper : this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();
                const _ = f?.effect ?? null;
                for (const t of s._beforeRenderingMeshStage)
                    t.action(this, e, n, _);
                if (!f || !_)
                    return h && (h.maxZ = o,
                    s.updateTransformMatrix(!0)),
                    this;
                const p = i || this;
                let m;
                if (u.isFrozen || !this._internalMeshDataInfo._effectiveMaterial.backFaceCulling && null === this.overrideMaterialSideOrientation && !this._internalMeshDataInfo._effectiveMaterial.twoSidedLighting)
                    m = u.sideOrientation;
                else {
                    const e = p._getWorldMatrixDeterminant();
                    m = this.overrideMaterialSideOrientation,
                    null == m && (m = this._internalMeshDataInfo._effectiveMaterial.sideOrientation),
                    e < 0 && (m = m === Fr.ClockWiseSideOrientation ? Fr.CounterClockWiseSideOrientation : Fr.ClockWiseSideOrientation),
                    u.sideOrientation = m
                }
                const g = this._internalMeshDataInfo._effectiveMaterial._preBind(f, m);
                this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite && a.setDepthWrite(!0);
                const v = this._internalMeshDataInfo._effectiveMaterial
                  , y = v.fillMode;
                this._internalMeshDataInfo._onBeforeBindObservable && this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this),
                c || this._bind(e, _, y, !1);
                const b = p.getWorldMatrix();
                v._storeEffectOnSubMeshes ? v.bindForSubMesh(b, this, e) : v.bind(b, this),
                !v.backFaceCulling && v.separateCullingPass && (a.setState(!0, v.zOffset, !1, !g, v.cullBackFaces, v.stencil, v.zOffsetUnits),
                this._processRendering(this, e, _, y, n, c, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial),
                a.setState(!0, v.zOffset, !1, g, v.cullBackFaces, v.stencil, v.zOffsetUnits),
                this._internalMeshDataInfo._onBetweenPassObservable && this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(e)),
                this._processRendering(this, e, _, y, n, c, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial),
                this._internalMeshDataInfo._effectiveMaterial.unbind();
                for (const t of s._afterRenderingMeshStage)
                    t.action(this, e, n, _);
                return this._internalMeshDataInfo._onAfterRenderObservable && this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this),
                h && (h.maxZ = o,
                s.updateTransformMatrix(!0)),
                s.performancePriority !== Us.Aggressive || u.isFrozen || this._freeze(),
                this
            }
            cleanMatrixWeights() {
                this.isVerticesDataPresent(os.MatricesWeightsKind) && (this.isVerticesDataPresent(os.MatricesWeightsExtraKind) ? this._normalizeSkinWeightsAndExtra() : this._normalizeSkinFourWeights())
            }
            _normalizeSkinFourWeights() {
                const e = this.getVerticesData(os.MatricesWeightsKind)
                  , t = e.length;
                for (let i = 0; i < t; i += 4) {
                    const t = e[i] + e[i + 1] + e[i + 2] + e[i + 3];
                    if (0 === t)
                        e[i] = 1;
                    else {
                        const s = 1 / t;
                        e[i] *= s,
                        e[i + 1] *= s,
                        e[i + 2] *= s,
                        e[i + 3] *= s
                    }
                }
                this.setVerticesData(os.MatricesWeightsKind, e)
            }
            _normalizeSkinWeightsAndExtra() {
                const e = this.getVerticesData(os.MatricesWeightsExtraKind)
                  , t = this.getVerticesData(os.MatricesWeightsKind)
                  , i = t.length;
                for (let s = 0; s < i; s += 4) {
                    let i = t[s] + t[s + 1] + t[s + 2] + t[s + 3];
                    if (i += e[s] + e[s + 1] + e[s + 2] + e[s + 3],
                    0 === i)
                        t[s] = 1;
                    else {
                        const r = 1 / i;
                        t[s] *= r,
                        t[s + 1] *= r,
                        t[s + 2] *= r,
                        t[s + 3] *= r,
                        e[s] *= r,
                        e[s + 1] *= r,
                        e[s + 2] *= r,
                        e[s + 3] *= r
                    }
                }
                this.setVerticesData(os.MatricesWeightsKind, t),
                this.setVerticesData(os.MatricesWeightsKind, e)
            }
            validateSkinning() {
                const e = this.getVerticesData(os.MatricesWeightsExtraKind)
                  , t = this.getVerticesData(os.MatricesWeightsKind);
                if (null === t || null == this.skeleton)
                    return {
                        skinned: !1,
                        valid: !0,
                        report: "not skinned"
                    };
                const i = t.length;
                let s = 0
                  , r = 0
                  , n = 0
                  , a = 0;
                const o = null === e ? 4 : 8
                  , h = [];
                for (let e = 0; e <= o; e++)
                    h[e] = 0;
                for (let l = 0; l < i; l += 4) {
                    let i = t[l]
                      , c = i
                      , u = 0 === c ? 0 : 1;
                    for (let r = 1; r < o; r++) {
                        const n = r < 4 ? t[l + r] : e[l + r - 4];
                        n > i && s++,
                        0 !== n && u++,
                        c += n,
                        i = n
                    }
                    if (h[u]++,
                    u > n && (n = u),
                    0 === c)
                        r++;
                    else {
                        const i = 1 / c;
                        let s = 0;
                        for (let r = 0; r < o; r++)
                            s += r < 4 ? Math.abs(t[l + r] - t[l + r] * i) : Math.abs(e[l + r - 4] - e[l + r - 4] * i);
                        s > .001 && a++
                    }
                }
                const l = this.skeleton.bones.length
                  , c = this.getVerticesData(os.MatricesIndicesKind)
                  , u = this.getVerticesData(os.MatricesIndicesExtraKind);
                let d = 0;
                for (let e = 0; e < i; e += 4)
                    for (let t = 0; t < o; t++) {
                        const i = t < 4 ? c[e + t] : u[e + t - 4];
                        (i >= l || i < 0) && d++
                    }
                return {
                    skinned: !0,
                    valid: 0 === r && 0 === a && 0 === d,
                    report: "Number of Weights = " + i / 4 + "\nMaximum influences = " + n + "\nMissing Weights = " + r + "\nNot Sorted = " + s + "\nNot Normalized = " + a + "\nWeightCounts = [" + h + "]\nNumber of bones = " + l + "\nBad Bone Indices = " + d
                }
            }
            _checkDelayState() {
                const e = this.getScene();
                return this._geometry ? this._geometry.load(e) : 4 === this.delayLoadState && (this.delayLoadState = 2,
                this._queueLoad(e)),
                this
            }
            _queueLoad(e) {
                e.addPendingData(this);
                const t = -1 !== this.delayLoadingFile.indexOf(".babylonbinarymeshdata");
                return hi.LoadFile(this.delayLoadingFile, (t => {
                    t instanceof ArrayBuffer ? this._delayLoadingFunction(t, this) : this._delayLoadingFunction(JSON.parse(t), this),
                    this.instances.forEach((e => {
                        e.refreshBoundingInfo(),
                        e._syncSubMeshes()
                    }
                    )),
                    this.delayLoadState = 1,
                    e.removePendingData(this)
                }
                ), ( () => {}
                ), e.offlineProvider, t),
                this
            }
            isInFrustum(e) {
                return 2 !== this.delayLoadState && !!super.isInFrustum(e) && (this._checkDelayState(),
                !0)
            }
            setMaterialById(e) {
                const t = this.getScene().materials;
                let i;
                for (i = t.length - 1; i > -1; i--)
                    if (t[i].id === e)
                        return this.material = t[i],
                        this;
                const s = this.getScene().multiMaterials;
                for (i = s.length - 1; i > -1; i--)
                    if (s[i].id === e)
                        return this.material = s[i],
                        this;
                return this
            }
            getAnimatables() {
                const e = [];
                return this.material && e.push(this.material),
                this.skeleton && e.push(this.skeleton),
                e
            }
            bakeTransformIntoVertices(e) {
                if (!this.isVerticesDataPresent(os.PositionKind))
                    return this;
                const t = this.subMeshes.splice(0);
                this._resetPointsArrayCache();
                let i = this.getVerticesData(os.PositionKind);
                const s = Di.Zero();
                let r;
                for (r = 0; r < i.length; r += 3)
                    Di.TransformCoordinatesFromFloatsToRef(i[r], i[r + 1], i[r + 2], e, s).toArray(i, r);
                if (this.setVerticesData(os.PositionKind, i, this.getVertexBuffer(os.PositionKind).isUpdatable()),
                this.isVerticesDataPresent(os.NormalKind)) {
                    for (i = this.getVerticesData(os.NormalKind),
                    r = 0; r < i.length; r += 3)
                        Di.TransformNormalFromFloatsToRef(i[r], i[r + 1], i[r + 2], e, s).normalize().toArray(i, r);
                    this.setVerticesData(os.NormalKind, i, this.getVertexBuffer(os.NormalKind).isUpdatable())
                }
                if (this.isVerticesDataPresent(os.TangentKind)) {
                    for (i = this.getVerticesData(os.TangentKind),
                    r = 0; r < i.length; r += 4)
                        Di.TransformNormalFromFloatsToRef(i[r], i[r + 1], i[r + 2], e, s).normalize().toArray(i, r);
                    this.setVerticesData(os.TangentKind, i, this.getVertexBuffer(os.TangentKind).isUpdatable())
                }
                return e.determinant() < 0 && this.flipFaces(),
                this.releaseSubMeshes(),
                this.subMeshes = t,
                this
            }
            bakeCurrentTransformIntoVertices(e=!0) {
                return this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)),
                this.resetLocalMatrix(e),
                this
            }
            get _positions() {
                return this._internalAbstractMeshDataInfo._positions ? this._internalAbstractMeshDataInfo._positions : this._geometry ? this._geometry._positions : null
            }
            _resetPointsArrayCache() {
                return this._geometry && this._geometry._resetPointsArrayCache(),
                this
            }
            _generatePointsArray() {
                return !!this._geometry && this._geometry._generatePointsArray()
            }
            clone(e="", t=null, i, s=!0) {
                return new Gr(e,this.getScene(),t,this,i,s)
            }
            dispose(e, t=!1) {
                this.morphTargetManager = null,
                this._geometry && this._geometry.releaseForMesh(this, !0);
                const i = this._internalMeshDataInfo;
                if (i._onBeforeDrawObservable && i._onBeforeDrawObservable.clear(),
                i._onBeforeBindObservable && i._onBeforeBindObservable.clear(),
                i._onBeforeRenderObservable && i._onBeforeRenderObservable.clear(),
                i._onAfterRenderObservable && i._onAfterRenderObservable.clear(),
                i._onBetweenPassObservable && i._onBetweenPassObservable.clear(),
                this._scene.useClonedMeshMap) {
                    if (i.meshMap)
                        for (const e in i.meshMap) {
                            const t = i.meshMap[e];
                            t && (t._internalMeshDataInfo._source = null,
                            i.meshMap[e] = void 0)
                        }
                    i._source && i._source._internalMeshDataInfo.meshMap && (i._source._internalMeshDataInfo.meshMap[this.uniqueId] = void 0)
                } else {
                    const e = this.getScene().meshes;
                    for (const t of e) {
                        const e = t;
                        e._internalMeshDataInfo && e._internalMeshDataInfo._source && e._internalMeshDataInfo._source === this && (e._internalMeshDataInfo._source = null)
                    }
                }
                i._source = null,
                this._instanceDataStorage.visibleInstances = {},
                this._disposeInstanceSpecificData(),
                this._disposeThinInstanceSpecificData(),
                this._internalMeshDataInfo._checkReadinessObserver && this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver),
                super.dispose(e, t)
            }
            _disposeInstanceSpecificData() {}
            _disposeThinInstanceSpecificData() {}
            _invalidateInstanceVertexArrayObject() {}
            applyDisplacementMap(e, t, i, s, r, n, a=!1, o) {
                const h = this.getScene();
                return hi.LoadImage(e, (e => {
                    const o = e.width
                      , h = e.height
                      , l = this.getEngine().createCanvas(o, h).getContext("2d");
                    l.drawImage(e, 0, 0);
                    const c = l.getImageData(0, 0, o, h).data;
                    this.applyDisplacementMapFromBuffer(c, o, h, t, i, r, n, a),
                    s && s(this)
                }
                ), o || ( () => {}
                ), h.offlineProvider),
                this
            }
            applyDisplacementMapFromBuffer(e, t, i, s, r, n, a, o=!1) {
                if (!this.isVerticesDataPresent(os.PositionKind) || !this.isVerticesDataPresent(os.NormalKind) || !this.isVerticesDataPresent(os.UVKind))
                    return We.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"),
                    this;
                const h = this.getVerticesData(os.PositionKind, !0, !0)
                  , l = this.getVerticesData(os.NormalKind)
                  , c = this.getVerticesData(os.UVKind);
                let u = Di.Zero();
                const d = Di.Zero()
                  , f = Pi.Zero();
                n = n || Pi.Zero(),
                a = a || new Pi(1,1);
                for (let o = 0; o < h.length; o += 3) {
                    Di.FromArrayToRef(h, o, u),
                    Di.FromArrayToRef(l, o, d),
                    Pi.FromArrayToRef(c, o / 3 * 2, f);
                    const _ = 4 * ((Math.abs(f.x * a.x + n.x % 1) * (t - 1) % t | 0) + (Math.abs(f.y * a.y + n.y % 1) * (i - 1) % i | 0) * t)
                      , p = e[_] / 255 * .3 + e[_ + 1] / 255 * .59 + e[_ + 2] / 255 * .11;
                    d.normalize(),
                    d.scaleInPlace(s + (r - s) * p),
                    u = u.add(d),
                    u.toArray(h, o)
                }
                return $s.ComputeNormals(h, this.getIndices(), l),
                o ? (this.setVerticesData(os.PositionKind, h),
                this.setVerticesData(os.NormalKind, l),
                this.setVerticesData(os.UVKind, c)) : (this.updateVerticesData(os.PositionKind, h),
                this.updateVerticesData(os.NormalKind, l)),
                this
            }
            _getFlattenedNormals(e, t) {
                const i = new Float32Array(3 * e.length);
                let s = 0;
                const r = this.overrideMaterialSideOrientation === (this._scene.useRightHandedSystem ? 1 : 0);
                for (let n = 0; n < e.length; n += 3) {
                    const a = Di.FromArray(t, 3 * e[n])
                      , o = Di.FromArray(t, 3 * e[n + 1])
                      , h = Di.FromArray(t, 3 * e[n + 2])
                      , l = a.subtract(o)
                      , c = h.subtract(o)
                      , u = Di.Normalize(Di.Cross(l, c));
                    r && u.scaleInPlace(-1);
                    for (let e = 0; e < 3; e++)
                        i[s++] = u.x,
                        i[s++] = u.y,
                        i[s++] = u.z
                }
                return i
            }
            _convertToUnIndexedMesh(e=!1) {
                const t = this.getVerticesDataKinds()
                  , i = this.getIndices()
                  , s = {}
                  , r = (e, t) => {
                    const s = new Float32Array(i.length * t);
                    let r = 0;
                    for (let n = 0; n < i.length; n++)
                        for (let a = 0; a < t; a++)
                            s[r++] = e[i[n] * t + a];
                    return s
                }
                  , n = this.geometry ? this.subMeshes.slice(0) : [];
                for (const e of t)
                    s[e] = this.getVerticesData(e);
                for (const n of t) {
                    const t = this.getVertexBuffer(n)
                      , a = t.getStrideSize();
                    if (e && n === os.NormalKind) {
                        const e = this._getFlattenedNormals(i, s[os.PositionKind]);
                        this.setVerticesData(os.NormalKind, e, t.isUpdatable(), a)
                    } else
                        this.setVerticesData(n, r(s[n], a), t.isUpdatable(), a)
                }
                if (this.morphTargetManager) {
                    for (let t = 0; t < this.morphTargetManager.numTargets; t++) {
                        const s = this.morphTargetManager.getTarget(t)
                          , n = s.getPositions();
                        s.setPositions(r(n, 3));
                        const a = s.getNormals();
                        a && s.setNormals(e ? this._getFlattenedNormals(i, n) : r(a, 3));
                        const o = s.getTangents();
                        o && s.setTangents(r(o, 3));
                        const h = s.getUVs();
                        h && s.setUVs(r(h, 2))
                    }
                    this.morphTargetManager.synchronize()
                }
                for (let e = 0; e < i.length; e++)
                    i[e] = e;
                this.setIndices(i),
                this._unIndexed = !0,
                this.releaseSubMeshes();
                for (const e of n)
                    Zs.AddToMesh(e.materialIndex, e.indexStart, e.indexCount, e.indexStart, e.indexCount, this);
                return this.synchronizeInstances(),
                this
            }
            convertToFlatShadedMesh() {
                return this._convertToUnIndexedMesh(!0)
            }
            convertToUnIndexedMesh() {
                return this._convertToUnIndexedMesh()
            }
            flipFaces(e=!1) {
                const t = $s.ExtractFromMesh(this);
                let i;
                if (e && this.isVerticesDataPresent(os.NormalKind) && t.normals)
                    for (i = 0; i < t.normals.length; i++)
                        t.normals[i] *= -1;
                if (t.indices) {
                    let e;
                    for (i = 0; i < t.indices.length; i += 3)
                        e = t.indices[i + 1],
                        t.indices[i + 1] = t.indices[i + 2],
                        t.indices[i + 2] = e
                }
                return t.applyToMesh(this, this.isVertexBufferUpdatable(os.PositionKind)),
                this
            }
            increaseVertices(e=1) {
                const t = $s.ExtractFromMesh(this)
                  , i = t.indices && !Array.isArray(t.indices) && Array.from ? Array.from(t.indices) : t.indices
                  , s = t.positions && !Array.isArray(t.positions) && Array.from ? Array.from(t.positions) : t.positions
                  , r = t.uvs && !Array.isArray(t.uvs) && Array.from ? Array.from(t.uvs) : t.uvs
                  , n = t.normals && !Array.isArray(t.normals) && Array.from ? Array.from(t.normals) : t.normals;
                if (i && s) {
                    t.indices = i,
                    t.positions = s,
                    r && (t.uvs = r),
                    n && (t.normals = n);
                    const a = e + 1
                      , o = new Array;
                    for (let e = 0; e < a + 1; e++)
                        o[e] = new Array;
                    let h, l;
                    const c = new Di(0,0,0)
                      , u = new Di(0,0,0)
                      , d = new Pi(0,0)
                      , f = new Array
                      , _ = new Array
                      , p = new Array;
                    let m, g, v, y = s.length;
                    r && (g = r.length),
                    n && (v = n.length);
                    for (let e = 0; e < i.length; e += 3) {
                        _[0] = i[e],
                        _[1] = i[e + 1],
                        _[2] = i[e + 2];
                        for (let e = 0; e < 3; e++)
                            if (h = _[e],
                            l = _[(e + 1) % 3],
                            void 0 === p[h] && void 0 === p[l] ? (p[h] = new Array,
                            p[l] = new Array) : (void 0 === p[h] && (p[h] = new Array),
                            void 0 === p[l] && (p[l] = new Array)),
                            void 0 === p[h][l] && void 0 === p[l][h]) {
                                p[h][l] = [],
                                c.x = (s[3 * l] - s[3 * h]) / a,
                                c.y = (s[3 * l + 1] - s[3 * h + 1]) / a,
                                c.z = (s[3 * l + 2] - s[3 * h + 2]) / a,
                                n && (u.x = (n[3 * l] - n[3 * h]) / a,
                                u.y = (n[3 * l + 1] - n[3 * h + 1]) / a,
                                u.z = (n[3 * l + 2] - n[3 * h + 2]) / a),
                                r && (d.x = (r[2 * l] - r[2 * h]) / a,
                                d.y = (r[2 * l + 1] - r[2 * h + 1]) / a),
                                p[h][l].push(h);
                                for (let e = 1; e < a; e++)
                                    p[h][l].push(s.length / 3),
                                    s[y++] = s[3 * h] + e * c.x,
                                    s[y++] = s[3 * h + 1] + e * c.y,
                                    s[y++] = s[3 * h + 2] + e * c.z,
                                    n && (n[v++] = n[3 * h] + e * u.x,
                                    n[v++] = n[3 * h + 1] + e * u.y,
                                    n[v++] = n[3 * h + 2] + e * u.z),
                                    r && (r[g++] = r[2 * h] + e * d.x,
                                    r[g++] = r[2 * h + 1] + e * d.y);
                                p[h][l].push(l),
                                p[l][h] = new Array,
                                m = p[h][l].length;
                                for (let e = 0; e < m; e++)
                                    p[l][h][e] = p[h][l][m - 1 - e]
                            }
                        o[0][0] = i[e],
                        o[1][0] = p[i[e]][i[e + 1]][1],
                        o[1][1] = p[i[e]][i[e + 2]][1];
                        for (let t = 2; t < a; t++) {
                            o[t][0] = p[i[e]][i[e + 1]][t],
                            o[t][t] = p[i[e]][i[e + 2]][t],
                            c.x = (s[3 * o[t][t]] - s[3 * o[t][0]]) / t,
                            c.y = (s[3 * o[t][t] + 1] - s[3 * o[t][0] + 1]) / t,
                            c.z = (s[3 * o[t][t] + 2] - s[3 * o[t][0] + 2]) / t,
                            n && (u.x = (n[3 * o[t][t]] - n[3 * o[t][0]]) / t,
                            u.y = (n[3 * o[t][t] + 1] - n[3 * o[t][0] + 1]) / t,
                            u.z = (n[3 * o[t][t] + 2] - n[3 * o[t][0] + 2]) / t),
                            r && (d.x = (r[2 * o[t][t]] - r[2 * o[t][0]]) / t,
                            d.y = (r[2 * o[t][t] + 1] - r[2 * o[t][0] + 1]) / t);
                            for (let e = 1; e < t; e++)
                                o[t][e] = s.length / 3,
                                s[y++] = s[3 * o[t][0]] + e * c.x,
                                s[y++] = s[3 * o[t][0] + 1] + e * c.y,
                                s[y++] = s[3 * o[t][0] + 2] + e * c.z,
                                n && (n[v++] = n[3 * o[t][0]] + e * u.x,
                                n[v++] = n[3 * o[t][0] + 1] + e * u.y,
                                n[v++] = n[3 * o[t][0] + 2] + e * u.z),
                                r && (r[g++] = r[2 * o[t][0]] + e * d.x,
                                r[g++] = r[2 * o[t][0] + 1] + e * d.y)
                        }
                        o[a] = p[i[e + 1]][i[e + 2]],
                        f.push(o[0][0], o[1][0], o[1][1]);
                        for (let e = 1; e < a; e++) {
                            let t;
                            for (t = 0; t < e; t++)
                                f.push(o[e][t], o[e + 1][t], o[e + 1][t + 1]),
                                f.push(o[e][t], o[e + 1][t + 1], o[e][t + 1]);
                            f.push(o[e][t], o[e + 1][t], o[e + 1][t + 1])
                        }
                    }
                    t.indices = f,
                    t.applyToMesh(this, this.isVertexBufferUpdatable(os.PositionKind))
                } else
                    We.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions")
            }
            forceSharedVertices() {
                const e = $s.ExtractFromMesh(this)
                  , t = e.uvs
                  , i = e.indices
                  , s = e.positions
                  , r = e.colors
                  , n = e.matricesIndices
                  , a = e.matricesWeights
                  , o = e.matricesIndicesExtra
                  , h = e.matricesWeightsExtra;
                if (void 0 === i || void 0 === s || null === i || null === s)
                    We.Warn("VertexData contains empty entries");
                else {
                    const l = new Array
                      , c = new Array
                      , u = new Array
                      , d = new Array
                      , f = new Array
                      , _ = new Array
                      , p = new Array
                      , m = new Array;
                    let g = new Array
                      , v = 0;
                    const y = {};
                    let b, x;
                    for (let e = 0; e < i.length; e += 3) {
                        x = [i[e], i[e + 1], i[e + 2]],
                        g = [];
                        for (let e = 0; e < 3; e++) {
                            g[e] = "";
                            for (let t = 0; t < 3; t++)
                                Math.abs(s[3 * x[e] + t]) < 1e-8 && (s[3 * x[e] + t] = 0),
                                g[e] += s[3 * x[e] + t] + "|"
                        }
                        if (g[0] != g[1] && g[0] != g[2] && g[1] != g[2])
                            for (let e = 0; e < 3; e++) {
                                if (b = y[g[e]],
                                void 0 === b) {
                                    y[g[e]] = v,
                                    b = v++;
                                    for (let t = 0; t < 3; t++)
                                        l.push(s[3 * x[e] + t]);
                                    if (null != r)
                                        for (let t = 0; t < 4; t++)
                                            d.push(r[4 * x[e] + t]);
                                    if (null != t)
                                        for (let i = 0; i < 2; i++)
                                            u.push(t[2 * x[e] + i]);
                                    if (null != n)
                                        for (let t = 0; t < 4; t++)
                                            f.push(n[4 * x[e] + t]);
                                    if (null != a)
                                        for (let t = 0; t < 4; t++)
                                            _.push(a[4 * x[e] + t]);
                                    if (null != o)
                                        for (let t = 0; t < 4; t++)
                                            p.push(o[4 * x[e] + t]);
                                    if (null != h)
                                        for (let t = 0; t < 4; t++)
                                            m.push(h[4 * x[e] + t])
                                }
                                c.push(b)
                            }
                    }
                    const T = new Array;
                    $s.ComputeNormals(l, c, T),
                    e.positions = l,
                    e.indices = c,
                    e.normals = T,
                    null != t && (e.uvs = u),
                    null != r && (e.colors = d),
                    null != n && (e.matricesIndices = f),
                    null != a && (e.matricesWeights = _),
                    null != o && (e.matricesIndicesExtra = p),
                    null != a && (e.matricesWeightsExtra = m),
                    e.applyToMesh(this, this.isVertexBufferUpdatable(os.PositionKind))
                }
            }
            static _instancedMeshFactory(e, t) {
                throw je("InstancedMesh")
            }
            static _PhysicsImpostorParser(e, t, i) {
                throw je("PhysicsImpostor")
            }
            createInstance(e) {
                return Gr._instancedMeshFactory(e, this)
            }
            synchronizeInstances() {
                for (let e = 0; e < this.instances.length; e++)
                    this.instances[e]._syncSubMeshes();
                return this
            }
            optimizeIndices(e) {
                const t = this.getIndices()
                  , i = this.getVerticesData(os.PositionKind);
                if (!i || !t)
                    return this;
                const s = [];
                for (let e = 0; e < i.length; e += 3)
                    s.push(Di.FromArray(i, e));
                const r = [];
                return li.SyncAsyncForLoop(s.length, 40, (e => {
                    const t = s.length - 1 - e
                      , i = s[t];
                    for (let e = 0; e < t; ++e) {
                        const n = s[e];
                        if (i.equals(n)) {
                            r[t] = e;
                            break
                        }
                    }
                }
                ), ( () => {
                    for (let e = 0; e < t.length; ++e)
                        t[e] = r[t[e]] || t[e];
                    const i = this.subMeshes.slice(0);
                    this.setIndices(t),
                    this.subMeshes = i,
                    e && e(this)
                }
                )),
                this
            }
            serialize(e={}) {
                e.name = this.name,
                e.id = this.id,
                e.uniqueId = this.uniqueId,
                e.type = this.getClassName(),
                ui && ui.HasTags(this) && (e.tags = ui.GetTags(this)),
                e.position = this.position.asArray(),
                this.rotationQuaternion ? e.rotationQuaternion = this.rotationQuaternion.asArray() : this.rotation && (e.rotation = this.rotation.asArray()),
                e.scaling = this.scaling.asArray(),
                this._postMultiplyPivotMatrix ? e.pivotMatrix = this.getPivotMatrix().asArray() : e.localMatrix = this.getPivotMatrix().asArray(),
                e.isEnabled = this.isEnabled(!1),
                e.isVisible = this.isVisible,
                e.infiniteDistance = this.infiniteDistance,
                e.pickable = this.isPickable,
                e.receiveShadows = this.receiveShadows,
                e.billboardMode = this.billboardMode,
                e.visibility = this.visibility,
                e.alwaysSelectAsActiveMesh = this.alwaysSelectAsActiveMesh,
                e.checkCollisions = this.checkCollisions,
                e.ellipsoid = this.ellipsoid.asArray(),
                e.ellipsoidOffset = this.ellipsoidOffset.asArray(),
                e.doNotSyncBoundingInfo = this.doNotSyncBoundingInfo,
                e.isBlocker = this.isBlocker,
                e.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation,
                this.parent && this.parent._serializeAsParent(e),
                e.isUnIndexed = this.isUnIndexed;
                const t = this._geometry;
                if (t && this.subMeshes) {
                    e.geometryUniqueId = t.uniqueId,
                    e.geometryId = t.id,
                    e.subMeshes = [];
                    for (let t = 0; t < this.subMeshes.length; t++) {
                        const i = this.subMeshes[t];
                        e.subMeshes.push({
                            materialIndex: i.materialIndex,
                            verticesStart: i.verticesStart,
                            verticesCount: i.verticesCount,
                            indexStart: i.indexStart,
                            indexCount: i.indexCount
                        })
                    }
                }
                if (this.material ? this.material.doNotSerialize || (e.materialUniqueId = this.material.uniqueId,
                e.materialId = this.material.id) : (this.material = null,
                e.materialUniqueId = this._scene.defaultMaterial.uniqueId,
                e.materialId = this._scene.defaultMaterial.id),
                this.morphTargetManager && (e.morphTargetManagerId = this.morphTargetManager.uniqueId),
                this.skeleton && (e.skeletonId = this.skeleton.id,
                e.numBoneInfluencers = this.numBoneInfluencers),
                this.getScene()._getComponent(_s.NAME_PHYSICSENGINE)) {
                    const t = this.getPhysicsImpostor();
                    t && (e.physicsMass = t.getParam("mass"),
                    e.physicsFriction = t.getParam("friction"),
                    e.physicsRestitution = t.getParam("mass"),
                    e.physicsImpostor = t.type)
                }
                this.metadata && (e.metadata = this.metadata),
                e.instances = [];
                for (let t = 0; t < this.instances.length; t++) {
                    const i = this.instances[t];
                    if (i.doNotSerialize)
                        continue;
                    const s = {
                        name: i.name,
                        id: i.id,
                        isEnabled: i.isEnabled(!1),
                        isVisible: i.isVisible,
                        isPickable: i.isPickable,
                        checkCollisions: i.checkCollisions,
                        position: i.position.asArray(),
                        scaling: i.scaling.asArray()
                    };
                    if (i.parent && i.parent._serializeAsParent(s),
                    i.rotationQuaternion ? s.rotationQuaternion = i.rotationQuaternion.asArray() : i.rotation && (s.rotation = i.rotation.asArray()),
                    this.getScene()._getComponent(_s.NAME_PHYSICSENGINE)) {
                        const e = i.getPhysicsImpostor();
                        e && (s.physicsMass = e.getParam("mass"),
                        s.physicsFriction = e.getParam("friction"),
                        s.physicsRestitution = e.getParam("mass"),
                        s.physicsImpostor = e.type)
                    }
                    i.metadata && (s.metadata = i.metadata),
                    i.actionManager && (s.actions = i.actionManager.serialize(i.name)),
                    e.instances.push(s),
                    ki.AppendSerializedAnimations(i, s),
                    s.ranges = i.serializeAnimationRanges()
                }
                if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData && (e.thinInstances = {
                    instancesCount: this._thinInstanceDataStorage.instancesCount,
                    matrixData: Array.from(this._thinInstanceDataStorage.matrixData),
                    matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,
                    enablePicking: this.thinInstanceEnablePicking
                },
                this._userThinInstanceBuffersStorage)) {
                    const t = {
                        data: {},
                        sizes: {},
                        strides: {}
                    };
                    for (const e in this._userThinInstanceBuffersStorage.data)
                        t.data[e] = Array.from(this._userThinInstanceBuffersStorage.data[e]),
                        t.sizes[e] = this._userThinInstanceBuffersStorage.sizes[e],
                        t.strides[e] = this._userThinInstanceBuffersStorage.strides[e];
                    e.thinInstances.userThinInstance = t
                }
                return ki.AppendSerializedAnimations(this, e),
                e.ranges = this.serializeAnimationRanges(),
                e.layerMask = this.layerMask,
                e.alphaIndex = this.alphaIndex,
                e.hasVertexAlpha = this.hasVertexAlpha,
                e.overlayAlpha = this.overlayAlpha,
                e.overlayColor = this.overlayColor.asArray(),
                e.renderOverlay = this.renderOverlay,
                e.applyFog = this.applyFog,
                this.actionManager && (e.actions = this.actionManager.serialize(this.name)),
                e
            }
            _syncGeometryWithMorphTargetManager() {
                if (!this.geometry)
                    return;
                this._markSubMeshesAsAttributesDirty();
                const e = this._internalAbstractMeshDataInfo._morphTargetManager;
                if (e && e.vertexCount) {
                    if (e.vertexCount !== this.getTotalVertices())
                        return We.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."),
                        void (this.morphTargetManager = null);
                    if (e.isUsingTextureForTargets)
                        return;
                    for (let t = 0; t < e.numInfluencers; t++) {
                        const i = e.getActiveTarget(t)
                          , s = i.getPositions();
                        if (!s)
                            return void We.Error("Invalid morph target. Target must have positions.");
                        this.geometry.setVerticesData(os.PositionKind + t, s, !1, 3);
                        const r = i.getNormals();
                        r && this.geometry.setVerticesData(os.NormalKind + t, r, !1, 3);
                        const n = i.getTangents();
                        n && this.geometry.setVerticesData(os.TangentKind + t, n, !1, 3);
                        const a = i.getUVs();
                        a && this.geometry.setVerticesData(os.UVKind + "_" + t, a, !1, 2)
                    }
                } else {
                    let e = 0;
                    for (; this.geometry.isVerticesDataPresent(os.PositionKind + e); )
                        this.geometry.removeVerticesData(os.PositionKind + e),
                        this.geometry.isVerticesDataPresent(os.NormalKind + e) && this.geometry.removeVerticesData(os.NormalKind + e),
                        this.geometry.isVerticesDataPresent(os.TangentKind + e) && this.geometry.removeVerticesData(os.TangentKind + e),
                        this.geometry.isVerticesDataPresent(os.UVKind + e) && this.geometry.removeVerticesData(os.UVKind + "_" + e),
                        e++
                }
            }
            static Parse(e, t, i) {
                let s;
                if (s = e.type && "LinesMesh" === e.type ? Gr._LinesMeshParser(e, t) : e.type && "GroundMesh" === e.type ? Gr._GroundMeshParser(e, t) : e.type && "GoldbergMesh" === e.type ? Gr._GoldbergMeshParser(e, t) : e.type && "GreasedLineMesh" === e.type ? Gr._GreasedLineMeshParser(e, t) : e.type && "TrailMesh" === e.type ? Gr._TrailMeshParser(e, t) : new Gr(e.name,t),
                s.id = e.id,
                s._waitingParsedUniqueId = e.uniqueId,
                ui && ui.AddTagsTo(s, e.tags),
                s.position = Di.FromArray(e.position),
                void 0 !== e.metadata && (s.metadata = e.metadata),
                e.rotationQuaternion ? s.rotationQuaternion = Fi.FromArray(e.rotationQuaternion) : e.rotation && (s.rotation = Di.FromArray(e.rotation)),
                s.scaling = Di.FromArray(e.scaling),
                e.localMatrix ? s.setPreTransformMatrix(Oi.FromArray(e.localMatrix)) : e.pivotMatrix && s.setPivotMatrix(Oi.FromArray(e.pivotMatrix)),
                s.setEnabled(e.isEnabled),
                s.isVisible = e.isVisible,
                s.infiniteDistance = e.infiniteDistance,
                s.alwaysSelectAsActiveMesh = !!e.alwaysSelectAsActiveMesh,
                s.showBoundingBox = e.showBoundingBox,
                s.showSubMeshesBoundingBox = e.showSubMeshesBoundingBox,
                void 0 !== e.applyFog && (s.applyFog = e.applyFog),
                void 0 !== e.pickable && (s.isPickable = e.pickable),
                void 0 !== e.alphaIndex && (s.alphaIndex = e.alphaIndex),
                s.receiveShadows = e.receiveShadows,
                void 0 !== e.billboardMode && (s.billboardMode = e.billboardMode),
                void 0 !== e.visibility && (s.visibility = e.visibility),
                s.checkCollisions = e.checkCollisions,
                s.doNotSyncBoundingInfo = !!e.doNotSyncBoundingInfo,
                e.ellipsoid && (s.ellipsoid = Di.FromArray(e.ellipsoid)),
                e.ellipsoidOffset && (s.ellipsoidOffset = Di.FromArray(e.ellipsoidOffset)),
                void 0 !== e.overrideMaterialSideOrientation && (s.overrideMaterialSideOrientation = e.overrideMaterialSideOrientation),
                void 0 !== e.isBlocker && (s.isBlocker = e.isBlocker),
                s._shouldGenerateFlatShading = e.useFlatShading,
                e.freezeWorldMatrix && (s._waitingData.freezeWorldMatrix = e.freezeWorldMatrix),
                void 0 !== e.parentId && (s._waitingParentId = e.parentId),
                void 0 !== e.parentInstanceIndex && (s._waitingParentInstanceIndex = e.parentInstanceIndex),
                void 0 !== e.actions && (s._waitingData.actions = e.actions),
                void 0 !== e.overlayAlpha && (s.overlayAlpha = e.overlayAlpha),
                void 0 !== e.overlayColor && (s.overlayColor = Fe.FromArray(e.overlayColor)),
                void 0 !== e.renderOverlay && (s.renderOverlay = e.renderOverlay),
                s.isUnIndexed = !!e.isUnIndexed,
                s.hasVertexAlpha = e.hasVertexAlpha,
                e.delayLoadingFile ? (s.delayLoadState = 4,
                s.delayLoadingFile = i + e.delayLoadingFile,
                s.buildBoundingInfo(Di.FromArray(e.boundingBoxMinimum), Di.FromArray(e.boundingBoxMaximum)),
                e._binaryInfo && (s._binaryInfo = e._binaryInfo),
                s._delayInfo = [],
                e.hasUVs && s._delayInfo.push(os.UVKind),
                e.hasUVs2 && s._delayInfo.push(os.UV2Kind),
                e.hasUVs3 && s._delayInfo.push(os.UV3Kind),
                e.hasUVs4 && s._delayInfo.push(os.UV4Kind),
                e.hasUVs5 && s._delayInfo.push(os.UV5Kind),
                e.hasUVs6 && s._delayInfo.push(os.UV6Kind),
                e.hasColors && s._delayInfo.push(os.ColorKind),
                e.hasMatricesIndices && s._delayInfo.push(os.MatricesIndicesKind),
                e.hasMatricesWeights && s._delayInfo.push(os.MatricesWeightsKind),
                s._delayLoadingFunction = tr._ImportGeometry,
                Js.ForceFullSceneLoadingForIncremental && s._checkDelayState()) : tr._ImportGeometry(e, s),
                e.materialUniqueId ? s._waitingMaterialId = e.materialUniqueId : e.materialId && (s._waitingMaterialId = e.materialId),
                e.morphTargetManagerId > -1 && (s.morphTargetManager = t.getMorphTargetManagerById(e.morphTargetManagerId)),
                void 0 !== e.skeletonId && null !== e.skeletonId && (s.skeleton = t.getLastSkeletonById(e.skeletonId),
                e.numBoneInfluencers && (s.numBoneInfluencers = e.numBoneInfluencers)),
                e.animations) {
                    for (let t = 0; t < e.animations.length; t++) {
                        const i = e.animations[t]
                          , r = Re("BABYLON.Animation");
                        r && s.animations.push(r.Parse(i))
                    }
                    Gi.ParseAnimationRanges(s, e, t)
                }
                if (e.autoAnimate && t.beginAnimation(s, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1),
                e.layerMask && !isNaN(e.layerMask) ? s.layerMask = Math.abs(parseInt(e.layerMask)) : s.layerMask = 268435455,
                e.physicsImpostor && Gr._PhysicsImpostorParser(t, s, e),
                e.lodMeshIds && (s._waitingData.lods = {
                    ids: e.lodMeshIds,
                    distances: e.lodDistances ? e.lodDistances : null,
                    coverages: e.lodCoverages ? e.lodCoverages : null
                }),
                e.instances)
                    for (let i = 0; i < e.instances.length; i++) {
                        const r = e.instances[i]
                          , n = s.createInstance(r.name);
                        if (r.id && (n.id = r.id),
                        ui && (r.tags ? ui.AddTagsTo(n, r.tags) : ui.AddTagsTo(n, e.tags)),
                        n.position = Di.FromArray(r.position),
                        void 0 !== r.metadata && (n.metadata = r.metadata),
                        void 0 !== r.parentId && (n._waitingParentId = r.parentId),
                        void 0 !== r.parentInstanceIndex && (n._waitingParentInstanceIndex = r.parentInstanceIndex),
                        void 0 !== r.isEnabled && null !== r.isEnabled && n.setEnabled(r.isEnabled),
                        void 0 !== r.isVisible && null !== r.isVisible && (n.isVisible = r.isVisible),
                        void 0 !== r.isPickable && null !== r.isPickable && (n.isPickable = r.isPickable),
                        r.rotationQuaternion ? n.rotationQuaternion = Fi.FromArray(r.rotationQuaternion) : r.rotation && (n.rotation = Di.FromArray(r.rotation)),
                        n.scaling = Di.FromArray(r.scaling),
                        null != r.checkCollisions && null != r.checkCollisions && (n.checkCollisions = r.checkCollisions),
                        null != r.pickable && null != r.pickable && (n.isPickable = r.pickable),
                        null != r.showBoundingBox && null != r.showBoundingBox && (n.showBoundingBox = r.showBoundingBox),
                        null != r.showSubMeshesBoundingBox && null != r.showSubMeshesBoundingBox && (n.showSubMeshesBoundingBox = r.showSubMeshesBoundingBox),
                        null != r.alphaIndex && null != r.showSubMeshesBoundingBox && (n.alphaIndex = r.alphaIndex),
                        r.physicsImpostor && Gr._PhysicsImpostorParser(t, n, r),
                        void 0 !== r.actions && (n._waitingData.actions = r.actions),
                        r.animations) {
                            for (let e = 0; e < r.animations.length; e++) {
                                const t = r.animations[e]
                                  , i = Re("BABYLON.Animation");
                                i && n.animations.push(i.Parse(t))
                            }
                            Gi.ParseAnimationRanges(n, r, t),
                            r.autoAnimate && t.beginAnimation(n, r.autoAnimateFrom, r.autoAnimateTo, r.autoAnimateLoop, r.autoAnimateSpeed || 1)
                        }
                    }
                if (e.thinInstances) {
                    const t = e.thinInstances;
                    if (s.thinInstanceEnablePicking = !!t.enablePicking,
                    t.matrixData ? (s.thinInstanceSetBuffer("matrix", new Float32Array(t.matrixData), 16, !1),
                    s._thinInstanceDataStorage.matrixBufferSize = t.matrixBufferSize,
                    s._thinInstanceDataStorage.instancesCount = t.instancesCount) : s._thinInstanceDataStorage.matrixBufferSize = t.matrixBufferSize,
                    e.thinInstances.userThinInstance) {
                        const t = e.thinInstances.userThinInstance;
                        for (const e in t.data)
                            s.thinInstanceSetBuffer(e, new Float32Array(t.data[e]), t.strides[e], !1),
                            s._userThinInstanceBuffersStorage.sizes[e] = t.sizes[e]
                    }
                }
                return s
            }
            setPositionsForCPUSkinning() {
                const e = this._internalMeshDataInfo;
                if (!e._sourcePositions) {
                    const t = this.getVerticesData(os.PositionKind);
                    if (!t)
                        return e._sourcePositions;
                    e._sourcePositions = new Float32Array(t),
                    this.isVertexBufferUpdatable(os.PositionKind) || this.setVerticesData(os.PositionKind, t, !0)
                }
                return e._sourcePositions
            }
            setNormalsForCPUSkinning() {
                const e = this._internalMeshDataInfo;
                if (!e._sourceNormals) {
                    const t = this.getVerticesData(os.NormalKind);
                    if (!t)
                        return e._sourceNormals;
                    e._sourceNormals = new Float32Array(t),
                    this.isVertexBufferUpdatable(os.NormalKind) || this.setVerticesData(os.NormalKind, t, !0)
                }
                return e._sourceNormals
            }
            applySkeleton(e) {
                if (!this.geometry)
                    return this;
                if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId())
                    return this;
                if (this.geometry._softwareSkinningFrameId = this.getScene().getFrameId(),
                !this.isVerticesDataPresent(os.PositionKind))
                    return this;
                if (!this.isVerticesDataPresent(os.MatricesIndicesKind))
                    return this;
                if (!this.isVerticesDataPresent(os.MatricesWeightsKind))
                    return this;
                const t = this.isVerticesDataPresent(os.NormalKind)
                  , i = this._internalMeshDataInfo;
                if (!i._sourcePositions) {
                    const e = this.subMeshes.slice();
                    this.setPositionsForCPUSkinning(),
                    this.subMeshes = e
                }
                t && !i._sourceNormals && this.setNormalsForCPUSkinning();
                let s = this.getVerticesData(os.PositionKind);
                if (!s)
                    return this;
                s instanceof Float32Array || (s = new Float32Array(s));
                let r = this.getVerticesData(os.NormalKind);
                if (t) {
                    if (!r)
                        return this;
                    r instanceof Float32Array || (r = new Float32Array(r))
                }
                const n = this.getVerticesData(os.MatricesIndicesKind)
                  , a = this.getVerticesData(os.MatricesWeightsKind);
                if (!a || !n)
                    return this;
                const o = this.numBoneInfluencers > 4
                  , h = o ? this.getVerticesData(os.MatricesIndicesExtraKind) : null
                  , l = o ? this.getVerticesData(os.MatricesWeightsExtraKind) : null
                  , c = e.getTransformMatrices(this)
                  , u = Di.Zero()
                  , d = new Oi
                  , f = new Oi;
                let _, p = 0;
                for (let e = 0; e < s.length; e += 3,
                p += 4) {
                    let m;
                    for (_ = 0; _ < 4; _++)
                        m = a[p + _],
                        m > 0 && (Oi.FromFloat32ArrayToRefScaled(c, Math.floor(16 * n[p + _]), m, f),
                        d.addToSelf(f));
                    if (o)
                        for (_ = 0; _ < 4; _++)
                            m = l[p + _],
                            m > 0 && (Oi.FromFloat32ArrayToRefScaled(c, Math.floor(16 * h[p + _]), m, f),
                            d.addToSelf(f));
                    Di.TransformCoordinatesFromFloatsToRef(i._sourcePositions[e], i._sourcePositions[e + 1], i._sourcePositions[e + 2], d, u),
                    u.toArray(s, e),
                    t && (Di.TransformNormalFromFloatsToRef(i._sourceNormals[e], i._sourceNormals[e + 1], i._sourceNormals[e + 2], d, u),
                    u.toArray(r, e)),
                    d.reset()
                }
                return this.updateVerticesData(os.PositionKind, s),
                t && this.updateVerticesData(os.NormalKind, r),
                this
            }
            static MinMax(e) {
                let t = null
                  , i = null;
                return e.forEach((function(e) {
                    const s = e.getBoundingInfo().boundingBox;
                    t && i ? (t.minimizeInPlace(s.minimumWorld),
                    i.maximizeInPlace(s.maximumWorld)) : (t = s.minimumWorld,
                    i = s.maximumWorld)
                }
                )),
                t && i ? {
                    min: t,
                    max: i
                } : {
                    min: Di.Zero(),
                    max: Di.Zero()
                }
            }
            static Center(e) {
                const t = e instanceof Array ? Gr.MinMax(e) : e;
                return Di.Center(t.min, t.max)
            }
            static MergeMeshes(e, t=!0, i, s, r, n) {
                return _i(Gr._MergeMeshesCoroutine(e, t, i, s, r, n, !1))
            }
            static MergeMeshesAsync(e, t=!0, i, s, r, n) {
                return a = Gr._MergeMeshesCoroutine(e, t, i, s, r, n, !0),
                o = function(e=25) {
                    let t;
                    return (i, s, r) => {
                        const n = performance.now();
                        void 0 === t || n - t > e ? (t = n,
                        setTimeout(( () => {
                            di(i, s, r)
                        }
                        ), 0)) : di(i, s, r)
                    }
                }(),
                new Promise(( (e, t) => {
                    fi(a, o, e, t, h)
                }
                ));
                var a, o, h
            }
            static*_MergeMeshesCoroutine(e, t=!0, i, s, r, n, a) {
                if (0 === (e = e.filter(Boolean)).length)
                    return null;
                let o;
                if (!i) {
                    let t = 0;
                    for (o = 0; o < e.length; o++)
                        if (t += e[o].getTotalVertices(),
                        t >= 65536)
                            return We.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"),
                            null
                }
                n && (r = !1);
                const h = new Array
                  , l = new Array
                  , c = new Array
                  , u = e[0].overrideMaterialSideOrientation;
                for (o = 0; o < e.length; o++) {
                    const t = e[o];
                    if (t.isAnInstance)
                        return We.Warn("Cannot merge instance meshes."),
                        null;
                    if (u !== t.overrideMaterialSideOrientation)
                        return We.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values."),
                        null;
                    if (r && c.push(t.getTotalIndices()),
                    n)
                        if (t.material) {
                            const e = t.material;
                            if (e instanceof Or) {
                                for (let t = 0; t < e.subMaterials.length; t++)
                                    h.indexOf(e.subMaterials[t]) < 0 && h.push(e.subMaterials[t]);
                                for (let i = 0; i < t.subMeshes.length; i++)
                                    l.push(h.indexOf(e.subMaterials[t.subMeshes[i].materialIndex])),
                                    c.push(t.subMeshes[i].indexCount)
                            } else {
                                h.indexOf(e) < 0 && h.push(e);
                                for (let i = 0; i < t.subMeshes.length; i++)
                                    l.push(h.indexOf(e)),
                                    c.push(t.subMeshes[i].indexCount)
                            }
                        } else
                            for (let e = 0; e < t.subMeshes.length; e++)
                                l.push(0),
                                c.push(t.subMeshes[e].indexCount)
                }
                const d = e[0]
                  , f = e => {
                    const t = e.computeWorldMatrix(!0);
                    return {
                        vertexData: $s.ExtractFromMesh(e, !1, !1),
                        transform: t
                    }
                }
                  , {vertexData: _, transform: p} = f(d);
                a && (yield);
                const m = new Array(e.length - 1);
                for (let t = 1; t < e.length; t++)
                    m[t - 1] = f(e[t]),
                    a && (yield);
                const g = _._mergeCoroutine(p, m, i, a, !t);
                let v = g.next();
                for (; !v.done; )
                    a && (yield),
                    v = g.next();
                const y = v.value;
                s || (s = new Gr(d.name + "_merged",d.getScene()));
                const b = y._applyToCoroutine(s, void 0, a);
                let x = b.next();
                for (; !x.done; )
                    a && (yield),
                    x = b.next();
                if (s.checkCollisions = d.checkCollisions,
                s.overrideMaterialSideOrientation = d.overrideMaterialSideOrientation,
                t)
                    for (o = 0; o < e.length; o++)
                        e[o].dispose();
                if (r || n) {
                    s.releaseSubMeshes(),
                    o = 0;
                    let e = 0;
                    for (; o < c.length; )
                        Zs.CreateFromIndices(0, e, c[o], s, void 0, !1),
                        e += c[o],
                        o++;
                    for (const e of s.subMeshes)
                        e.refreshBoundingInfo();
                    s.computeWorldMatrix(!0)
                }
                if (n) {
                    const e = new Or(d.name + "_merged",d.getScene());
                    e.subMaterials = h;
                    for (let e = 0; e < s.subMeshes.length; e++)
                        s.subMeshes[e].materialIndex = l[e];
                    s.material = e
                } else
                    s.material = d.material;
                return s
            }
            addInstance(e) {
                e._indexInSourceMeshInstanceArray = this.instances.length,
                this.instances.push(e)
            }
            removeInstance(e) {
                const t = e._indexInSourceMeshInstanceArray;
                if (-1 != t) {
                    if (t !== this.instances.length - 1) {
                        const e = this.instances[this.instances.length - 1];
                        this.instances[t] = e,
                        e._indexInSourceMeshInstanceArray = t
                    }
                    e._indexInSourceMeshInstanceArray = -1,
                    this.instances.pop()
                }
            }
            _shouldConvertRHS() {
                return this.overrideMaterialSideOrientation === Fr.CounterClockWiseSideOrientation
            }
            _getRenderingFillMode(e) {
                const t = this.getScene();
                return t.forcePointsCloud ? Fr.PointFillMode : t.forceWireframe ? Fr.WireFrameFillMode : this.overrideRenderingFillMode ?? e
            }
            setMaterialByID(e) {
                return this.setMaterialById(e)
            }
            static CreateRibbon(e, t, i, s, r, n, a, o, h) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateDisc(e, t, i, s, r, n) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateBox(e, t, i, s, r) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateSphere(e, t, i, s, r, n) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateHemisphere(e, t, i, s) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateCylinder(e, t, i, s, r, n, a, o, h) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateTorus(e, t, i, s, r, n, a) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateTorusKnot(e, t, i, s, r, n, a, o, h, l) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateLines(e, t, i, s, r) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateDashedLines(e, t, i, s, r, n, a, o) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreatePolygon(e, t, i, s, r, n, a) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static ExtrudePolygon(e, t, i, s, r, n, a, o) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static ExtrudeShape(e, t, i, s, r, n, a, o, h, l) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static ExtrudeShapeCustom(e, t, i, s, r, n, a, o, h, l, c, u) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateLathe(e, t, i, s, r, n, a) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreatePlane(e, t, i, s, r) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateGround(e, t, i, s, r, n) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateTiledGround(e, t, i, s, r, n, a, o, h) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateGroundFromHeightMap(e, t, i, s, r, n, a, o, h, l, c) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateTube(e, t, i, s, r, n, a, o, h, l) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreatePolyhedron(e, t, i) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateIcoSphere(e, t, i) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateDecal(e, t, i, s, r, n) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static CreateCapsule(e, t, i) {
                throw new Error("Import MeshBuilder to populate this function")
            }
            static ExtendToGoldberg(e) {
                throw new Error("Import MeshBuilder to populate this function")
            }
        }
        function zr(e) {
            const t = []
              , i = []
              , s = []
              , r = []
              , n = e.radius || .5
              , a = e.tessellation || 64
              , o = e.arc && (e.arc <= 0 || e.arc > 1) ? 1 : e.arc || 1
              , h = 0 === e.sideOrientation ? 0 : e.sideOrientation || $s.DEFAULTSIDE;
            t.push(0, 0, 0),
            r.push(.5, .5);
            const l = 2 * Math.PI * o
              , c = 1 === o ? l / a : l / (a - 1);
            let u = 0;
            for (let e = 0; e < a; e++) {
                const e = Math.cos(u)
                  , i = Math.sin(u)
                  , s = (e + 1) / 2
                  , a = (1 - i) / 2;
                t.push(n * e, n * i, 0),
                r.push(s, er.UseOpenGLOrientationForUV ? 1 - a : a),
                u += c
            }
            1 === o && (t.push(t[3], t[4], t[5]),
            r.push(r[2], er.UseOpenGLOrientationForUV ? 1 - r[3] : r[3]));
            const d = t.length / 3;
            for (let e = 1; e < d - 1; e++)
                i.push(e + 1, 0, e);
            $s.ComputeNormals(t, i, s),
            $s._ComputeSides(h, t, i, s, r, e.frontUVs, e.backUVs);
            const f = new $s;
            return f.indices = i,
            f.positions = t,
            f.normals = s,
            f.uvs = r,
            f
        }
        function Wr(e, t={}, i=null) {
            const s = new Gr(e,i);
            return t.sideOrientation = Gr._GetDefaultSideOrientation(t.sideOrientation),
            s._originalBuilderSideOrientation = t.sideOrientation,
            zr(t).applyToMesh(s, t.updatable),
            s
        }
        Gr.FRONTSIDE = $s.FRONTSIDE,
        Gr.BACKSIDE = $s.BACKSIDE,
        Gr.DOUBLESIDE = $s.DOUBLESIDE,
        Gr.DEFAULTSIDE = $s.DEFAULTSIDE,
        Gr.NO_CAP = 0,
        Gr.CAP_START = 1,
        Gr.CAP_END = 2,
        Gr.CAP_ALL = 3,
        Gr.NO_FLIP = 0,
        Gr.FLIP_TILE = 1,
        Gr.ROTATE_TILE = 2,
        Gr.FLIP_ROW = 3,
        Gr.ROTATE_ROW = 4,
        Gr.FLIP_N_ROTATE_TILE = 5,
        Gr.FLIP_N_ROTATE_ROW = 6,
        Gr.CENTER = 0,
        Gr.LEFT = 1,
        Gr.RIGHT = 2,
        Gr.TOP = 3,
        Gr.BOTTOM = 4,
        Gr.INSTANCEDMESH_SORT_TRANSPARENT = !1,
        Gr._GroundMeshParser = (e, t) => {
            throw je("GroundMesh")
        }
        ,
        Gr._GoldbergMeshParser = (e, t) => {
            throw je("GoldbergMesh")
        }
        ,
        Gr._LinesMeshParser = (e, t) => {
            throw je("LinesMesh")
        }
        ,
        Gr._GreasedLineMeshParser = (e, t) => {
            throw je("GreasedLineMesh")
        }
        ,
        Gr._GreasedLineRibbonMeshParser = (e, t) => {
            throw je("GreasedLineRibbonMesh")
        }
        ,
        Gr._TrailMeshParser = (e, t) => {
            throw je("TrailMesh")
        }
        ,
        Ie("BABYLON.Mesh", Gr),
        $s.CreateDisc = zr,
        Gr.CreateDisc = (e, t, i, s=null, r, n) => Wr(e, {
            radius: t,
            tessellation: i,
            sideOrientation: n,
            updatable: r
        }, s),
        Gr._instancedMeshFactory = (e, t) => {
            const i = new Xr(e,t);
            if (t.instancedBuffers) {
                i.instancedBuffers = {};
                for (const e in t.instancedBuffers)
                    i.instancedBuffers[e] = t.instancedBuffers[e]
            }
            return i
        }
        ;
        class Xr extends fr {
            constructor(e, t) {
                super(e, t.getScene()),
                this._indexInSourceMeshInstanceArray = -1,
                this._distanceToCamera = 0,
                t.addInstance(this),
                this._sourceMesh = t,
                this._unIndexed = t._unIndexed,
                this.position.copyFrom(t.position),
                this.rotation.copyFrom(t.rotation),
                this.scaling.copyFrom(t.scaling),
                t.rotationQuaternion && (this.rotationQuaternion = t.rotationQuaternion.clone()),
                this.animations = t.animations.slice();
                for (const e of t.getAnimationRanges())
                    null != e && this.createAnimationRange(e.name, e.from, e.to);
                this.infiniteDistance = t.infiniteDistance,
                this.setPivotMatrix(t.getPivotMatrix()),
                this.refreshBoundingInfo(!0, !0),
                this._syncSubMeshes()
            }
            getClassName() {
                return "InstancedMesh"
            }
            get lightSources() {
                return this._sourceMesh._lightSources
            }
            _resyncLightSources() {}
            _resyncLightSource() {}
            _removeLightSource() {}
            get receiveShadows() {
                return this._sourceMesh.receiveShadows
            }
            set receiveShadows(e) {
                this._sourceMesh?.receiveShadows !== e && hi.Warn("Setting receiveShadows on an instanced mesh has no effect")
            }
            get material() {
                return this._sourceMesh.material
            }
            set material(e) {
                this._sourceMesh?.material !== e && hi.Warn("Setting material on an instanced mesh has no effect")
            }
            get visibility() {
                return this._sourceMesh.visibility
            }
            set visibility(e) {
                this._sourceMesh?.visibility !== e && hi.Warn("Setting visibility on an instanced mesh has no effect")
            }
            get skeleton() {
                return this._sourceMesh.skeleton
            }
            set skeleton(e) {
                this._sourceMesh?.skeleton !== e && hi.Warn("Setting skeleton on an instanced mesh has no effect")
            }
            get renderingGroupId() {
                return this._sourceMesh.renderingGroupId
            }
            set renderingGroupId(e) {
                this._sourceMesh && e !== this._sourceMesh.renderingGroupId && We.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene")
            }
            getTotalVertices() {
                return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0
            }
            getTotalIndices() {
                return this._sourceMesh.getTotalIndices()
            }
            get sourceMesh() {
                return this._sourceMesh
            }
            createInstance(e) {
                return this._sourceMesh.createInstance(e)
            }
            isReady(e=!1) {
                return this._sourceMesh.isReady(e, !0)
            }
            getVerticesData(e, t, i) {
                return this._sourceMesh.getVerticesData(e, t, i)
            }
            setVerticesData(e, t, i, s) {
                return this.sourceMesh && this.sourceMesh.setVerticesData(e, t, i, s),
                this.sourceMesh
            }
            updateVerticesData(e, t, i, s) {
                return this.sourceMesh && this.sourceMesh.updateVerticesData(e, t, i, s),
                this.sourceMesh
            }
            setIndices(e, t=null) {
                return this.sourceMesh && this.sourceMesh.setIndices(e, t),
                this.sourceMesh
            }
            isVerticesDataPresent(e) {
                return this._sourceMesh.isVerticesDataPresent(e)
            }
            getIndices() {
                return this._sourceMesh.getIndices()
            }
            get _positions() {
                return this._sourceMesh._positions
            }
            refreshBoundingInfo(e=!1, t=!1) {
                if (this.hasBoundingInfo && this.getBoundingInfo().isLocked)
                    return this;
                const i = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
                return this._refreshBoundingInfo(this._sourceMesh._getPositionData(e, t), i),
                this
            }
            _preActivate() {
                return this._currentLOD && this._currentLOD._preActivate(),
                this
            }
            _activate(e, t) {
                if (super._activate(e, t),
                this._sourceMesh.subMeshes || We.Warn("Instances should only be created for meshes with geometry."),
                this._currentLOD) {
                    if (this._currentLOD._getWorldMatrixDeterminant() >= 0 != this._getWorldMatrixDeterminant() >= 0)
                        return this._internalAbstractMeshDataInfo._actAsRegularMesh = !0,
                        !0;
                    if (this._internalAbstractMeshDataInfo._actAsRegularMesh = !1,
                    this._currentLOD._registerInstanceForRenderId(this, e),
                    t) {
                        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)
                            return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = !0,
                            !0
                    } else if (!this._currentLOD._internalAbstractMeshDataInfo._isActive)
                        return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = !0,
                        !0
                }
                return !1
            }
            _postActivate() {
                this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup ? (this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer),
                this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())) : this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup && this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer)
            }
            getWorldMatrix() {
                if (this._currentLOD && this._currentLOD.billboardMode !== lr.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
                    this._billboardWorldMatrix || (this._billboardWorldMatrix = new Oi);
                    const e = this._currentLOD._masterMesh;
                    return this._currentLOD._masterMesh = this,
                    Bi.Vector3[7].copyFrom(this._currentLOD.position),
                    this._currentLOD.position.set(0, 0, 0),
                    this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)),
                    this._currentLOD.position.copyFrom(Bi.Vector3[7]),
                    this._currentLOD._masterMesh = e,
                    this._billboardWorldMatrix
                }
                return super.getWorldMatrix()
            }
            get isAnInstance() {
                return !0
            }
            getLOD(e) {
                if (!e)
                    return this;
                const t = this.sourceMesh.getLODLevels();
                if (t && 0 !== t.length) {
                    const t = this.getBoundingInfo();
                    this._currentLOD = this.sourceMesh.getLOD(e, t.boundingSphere)
                } else
                    this._currentLOD = this.sourceMesh;
                return this._currentLOD
            }
            _preActivateForIntermediateRendering(e) {
                return this.sourceMesh._preActivateForIntermediateRendering(e)
            }
            _syncSubMeshes() {
                if (this.releaseSubMeshes(),
                this._sourceMesh.subMeshes)
                    for (let e = 0; e < this._sourceMesh.subMeshes.length; e++)
                        this._sourceMesh.subMeshes[e].clone(this, this._sourceMesh);
                return this
            }
            _generatePointsArray() {
                return this._sourceMesh._generatePointsArray()
            }
            _updateBoundingInfo() {
                return this.hasBoundingInfo ? this.getBoundingInfo().update(this.worldMatrixFromCache) : this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache),
                this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache),
                this
            }
            clone(e, t=null, i, s) {
                const r = (s || this._sourceMesh).createInstance(e);
                if (He.DeepCopy(this, r, ["name", "subMeshes", "uniqueId", "parent", "lightSources", "receiveShadows", "material", "visibility", "skeleton", "sourceMesh", "isAnInstance", "facetNb", "isFacetDataEnabled", "isBlocked", "useBones", "hasInstances", "collider", "edgesRenderer", "forward", "up", "right", "absolutePosition", "absoluteScaling", "absoluteRotationQuaternion", "isWorldMatrixFrozen", "nonUniformScaling", "behaviors", "worldMatrixFromCache", "hasThinInstances", "hasBoundingInfo"], []),
                this.refreshBoundingInfo(),
                t && (r.parent = t),
                !i)
                    for (let e = 0; e < this.getScene().meshes.length; e++) {
                        const t = this.getScene().meshes[e];
                        t.parent === this && t.clone(t.name, r)
                    }
                return r.computeWorldMatrix(!0),
                this.onClonedObservable.notifyObservers(r),
                r
            }
            dispose(e, t=!1) {
                this._sourceMesh.removeInstance(this),
                super.dispose(e, t)
            }
            _serializeAsParent(e) {
                super._serializeAsParent(e),
                e.parentId = this._sourceMesh.uniqueId,
                e.parentInstanceIndex = this._indexInSourceMeshInstanceArray
            }
            instantiateHierarchy(e=null, t, i) {
                const s = this.clone("Clone of " + (this.name || this.id), e || this.parent, !0, t && t.newSourcedMesh);
                s && i && i(this, s);
                for (const e of this.getChildTransformNodes(!0))
                    e.instantiateHierarchy(s, t, i);
                return s
            }
        }
        function Hr(e, t=10) {
            var i = t
              , s = Wr("shadow", {
                radius: .75,
                tessellation: 30
            }, e.rendering.getScene());
            s.rotation.x = Math.PI / 2;
            var r = e.rendering.makeStandardMaterial("shadow_component_mat");
            return r.diffuseColor.set(0, 0, 0),
            r.ambientColor.set(0, 0, 0),
            r.alpha = .5,
            s.material = r,
            r.freeze(),
            e.rendering.setMeshVisibility(s, !1),
            {
                name: "shadow",
                order: 80,
                state: {
                    size: .5,
                    _mesh: null
                },
                onAdd: function(t, i) {
                    var r = s.createInstance("shadow_instance");
                    e.rendering.addMeshToScene(r),
                    r.setEnabled(!1),
                    i._mesh = r
                },
                onRemove: function(e, t) {
                    t._mesh.dispose(),
                    t._mesh = null
                },
                system: function(t, s) {
                    for (var r = e.camera._localGetPosition(), n = i, a = 0; a < s.length; a++) {
                        var o = s[a]
                          , h = e.ents.getPositionData(o.__id)
                          , l = e.ents.getPhysics(o.__id);
                        jr(e, h, l, o._mesh, o.size, n, r)
                    }
                },
                renderSystem: function(t, i) {
                    for (var s = 0; s < i.length; s++) {
                        var r = i[s]
                          , n = e.ents.getPositionData(r.__id)._renderPosition
                          , a = r._mesh.position;
                        a.x = n[0],
                        a.z = n[2]
                    }
                }
            }
        }
        Gr.prototype.registerInstancedBuffer = function(e, t) {
            if (this._userInstancedBuffersStorage?.vertexBuffers[e]?.dispose(),
            !this.instancedBuffers) {
                this.instancedBuffers = {};
                for (const e of this.instances)
                    e.instancedBuffers = {}
            }
            this._userInstancedBuffersStorage || (this._userInstancedBuffersStorage = {
                data: {},
                vertexBuffers: {},
                strides: {},
                sizes: {},
                vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
            }),
            this.instancedBuffers[e] = null,
            this._userInstancedBuffersStorage.strides[e] = t,
            this._userInstancedBuffersStorage.sizes[e] = 32 * t,
            this._userInstancedBuffersStorage.data[e] = new Float32Array(this._userInstancedBuffersStorage.sizes[e]),
            this._userInstancedBuffersStorage.vertexBuffers[e] = new os(this.getEngine(),this._userInstancedBuffersStorage.data[e],e,!0,!1,t,!0);
            for (const t of this.instances)
                t.instancedBuffers[e] = null;
            this._invalidateInstanceVertexArrayObject(),
            this._markSubMeshesAsAttributesDirty()
        }
        ,
        Gr.prototype._processInstancedBuffers = function(e, t) {
            const i = e ? e.length : 0;
            for (const s in this.instancedBuffers) {
                let r = this._userInstancedBuffersStorage.sizes[s];
                const n = this._userInstancedBuffersStorage.strides[s]
                  , a = (i + 1) * n;
                for (; r < a; )
                    r *= 2;
                this._userInstancedBuffersStorage.data[s].length != r && (this._userInstancedBuffersStorage.data[s] = new Float32Array(r),
                this._userInstancedBuffersStorage.sizes[s] = r,
                this._userInstancedBuffersStorage.vertexBuffers[s] && (this._userInstancedBuffersStorage.vertexBuffers[s].dispose(),
                this._userInstancedBuffersStorage.vertexBuffers[s] = null));
                const o = this._userInstancedBuffersStorage.data[s];
                let h = 0;
                if (t) {
                    const e = this.instancedBuffers[s];
                    e.toArray ? e.toArray(o, h) : e.copyToArray ? e.copyToArray(o, h) : o[h] = e,
                    h += n
                }
                for (let t = 0; t < i; t++) {
                    const i = e[t].instancedBuffers[s];
                    i.toArray ? i.toArray(o, h) : i.copyToArray ? i.copyToArray(o, h) : o[h] = i,
                    h += n
                }
                this._userInstancedBuffersStorage.vertexBuffers[s] ? this._userInstancedBuffersStorage.vertexBuffers[s].updateDirectly(o, 0) : (this._userInstancedBuffersStorage.vertexBuffers[s] = new os(this.getEngine(),this._userInstancedBuffersStorage.data[s],s,!0,!1,n,!0),
                this._invalidateInstanceVertexArrayObject())
            }
        }
        ,
        Gr.prototype._invalidateInstanceVertexArrayObject = function() {
            if (this._userInstancedBuffersStorage && void 0 !== this._userInstancedBuffersStorage.vertexArrayObjects) {
                for (const e in this._userInstancedBuffersStorage.vertexArrayObjects)
                    this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[e]);
                this._userInstancedBuffersStorage.vertexArrayObjects = {}
            }
        }
        ,
        Gr.prototype._disposeInstanceSpecificData = function() {
            for (this._instanceDataStorage.instancesBuffer && (this._instanceDataStorage.instancesBuffer.dispose(),
            this._instanceDataStorage.instancesBuffer = null); this.instances.length; )
                this.instances[0].dispose();
            for (const e in this.instancedBuffers)
                this._userInstancedBuffersStorage.vertexBuffers[e] && this._userInstancedBuffersStorage.vertexBuffers[e].dispose();
            this._invalidateInstanceVertexArrayObject(),
            this.instancedBuffers = {}
        }
        ;
        var Kr = r().fromValues(0, 0, 0)
          , Yr = r().fromValues(0, -1, 0);
        function jr(e, t, i, s, n, a, o) {
            var h;
            if (i && i.body.resting[1] < 0)
                h = t._localPosition[1];
            else {
                var l = e._localPick(t._localPosition, Yr, a);
                if (!l)
                    return void s.setEnabled(!1);
                h = l.position[1] - e.worldOriginOffset[1]
            }
            h = Math.round(h),
            r().copy(Kr, t._localPosition),
            Kr[1] = h;
            var c = .01 + r().squaredDistance(o, Kr) / 1600 * .1;
            c > .1 && (c = .1),
            s.position.y = h + c;
            var u = .7 * n * (1 - (t._localPosition[1] - h) / a);
            s.scaling.copyFromFloats(u, u, u),
            s.setEnabled(!0)
        }
        function qr(e) {
            var t = "smoothCamera";
            return {
                name: t,
                order: 99,
                state: {
                    time: 100.1
                },
                onAdd: null,
                onRemove: null,
                system: function(i, s) {
                    for (var r = 0; r < s.length; r++) {
                        var n = s[r];
                        n.time -= i,
                        n.time < 0 && e.ents.removeComponent(n.__id, t)
                    }
                }
            }
        }
        var Zr = {
            shadowDistance: 10
        };
        class Qr extends (W()) {
            constructor(e, t) {
                super();
                var i = {
                    shadow: (t = Object.assign({}, Zr, t)).shadowDistance
                };
                this.noa = e,
                this.names = {};
                var s = {
                    collideEntities: te,
                    collideTerrain: ie,
                    fadeOnZoom: se,
                    followsEntity: ne,
                    mesh: ae,
                    movement: he,
                    physics: j,
                    position: H,
                    receivesInputs: fe,
                    shadow: Hr,
                    smoothCamera: qr
                };
                Object.keys(s).forEach((t => {
                    var r = (0,
                    s[t])(e, i[t] || void 0);
                    this.names[t] = this.createComponent(r)
                }
                )),
                this.cameraSmoothed = this.getComponentAccessor(this.names.smoothCamera),
                this.hasPhysics = this.getComponentAccessor(this.names.physics),
                this.hasPosition = this.getComponentAccessor(this.names.position),
                this.getPositionData = this.getStateAccessor(this.names.position),
                this.getPosition = e => {
                    var t = this.getPositionData(e);
                    return t ? t.position : null
                }
                ,
                this.getPhysics = this.getStateAccessor(this.names.physics),
                this.getPhysicsBody = e => {
                    var t = this.getPhysics(e);
                    return t ? t.body : null
                }
                ,
                this.hasMesh = this.getComponentAccessor(this.names.mesh),
                this.getMeshData = this.getStateAccessor(this.names.mesh),
                this.getMovement = this.getStateAccessor(this.names.movement),
                this.getCollideTerrain = this.getStateAccessor(this.names.collideTerrain),
                this.getCollideEntities = this.getStateAccessor(this.names.collideEntities),
                this.onPairwiseEntityCollision = function(e, t) {}
            }
            setPosition(e, t, i=0, s=0) {
                "number" == typeof t && (t = [t, i, s]);
                var r = this.noa.globalToLocal(t, null, []);
                this._localSetPosition(e, r)
            }
            setEntitySize(e, t, i, s) {
                var r = this.getPositionData(e);
                r.width = (t + s) / 2,
                r.height = i,
                this._updateDerivedPositionData(e, r)
            }
            _rebaseOrigin(e) {
                for (var t of this.getStatesList(this.names.position)) {
                    var i = t._localPosition
                      , s = t.width / 2;
                    $r(i, 0, -s, s, t.__id),
                    $r(i, 1, 0, t.height, t.__id),
                    $r(i, 2, -s, s, t.__id),
                    r().subtract(i, i, e),
                    this._updateDerivedPositionData(t.__id, t)
                }
            }
            _localGetPosition(e) {
                return this.getPositionData(e)._localPosition
            }
            _localSetPosition(e, t) {
                var i = this.getPositionData(e);
                r().copy(i._localPosition, t),
                this._updateDerivedPositionData(e, i)
            }
            _updateDerivedPositionData(e, t) {
                r().copy(t._renderPosition, t._localPosition);
                var i = this.noa.worldOriginOffset;
                r().add(t.position, t._localPosition, i),
                K(t);
                var s = this.getPhysics(e);
                s && Z(s, t)
            }
            addComponentAgain(e, t, i) {
                this.hasComponent(e, t) && this.removeComponent(e, t),
                this.addComponent(e, t, i)
            }
            isTerrainBlocked(e, t, i) {
                for (var s = this.noa.worldOriginOffset, r = Math.floor(e - s[0]), n = Math.floor(t - s[1]), a = Math.floor(i - s[2]), o = [r + .001, n + .001, a + .001, r + .999, n + .999, a + .999], h = this.getStatesList(this.names.collideTerrain), l = 0; l < h.length; l++) {
                    var c = h[l].__id;
                    if (Jr(o, this.getPositionData(c)._extents))
                        return !0
                }
                return !1
            }
            getEntitiesInAABB(e, t) {
                var i, s = this.noa.worldOriginOffset, r = [e.base[0] - s[0], e.base[1] - s[1], e.base[2] - s[2], e.max[0] - s[0], e.max[1] - s[1], e.max[2] - s[2]];
                if (t)
                    for (var n of (i = [],
                    this.getStatesList(t))) {
                        var a = this.getPositionData(n.__id);
                        a && i.push(a)
                    }
                else
                    i = this.getStatesList(this.names.position);
                for (var o = [], h = 0; h < i.length; h++) {
                    var l = i[h];
                    Jr(r, l._extents) && o.push(l.__id)
                }
                return o
            }
            add(e=null, t=1, i=1, s=null, n=null, a=!1, o=!1) {
                var h = this
                  , l = this.createEntity();
                if (this.addComponent(l, this.names.position, {
                    position: e || r().create(),
                    width: t,
                    height: i
                }),
                a) {
                    this.addComponent(l, this.names.physics);
                    var c = this.getPhysics(l).body
                      , u = this.names.smoothCamera;
                    c.onStep = function() {
                        h.addComponentAgain(l, u)
                    }
                }
                return s && (n || (n = r().create()),
                this.addComponent(l, this.names.mesh, {
                    mesh: s,
                    offset: n
                })),
                o && this.addComponent(l, this.names.shadow, {
                    size: t
                }),
                l
            }
        }
        function $r(e, t, i, s, r) {
            var n = e[t] + i
              , a = e[t] + s;
            Math.abs(n - Math.round(n)) < .002 && (e[t] += .002),
            Math.abs(a - Math.round(a)) < .001 && (e[t] -= .001)
        }
        function Jr(e, t) {
            return !(e[0] > t[3] || e[1] > t[4] || e[2] > t[5] || e[3] < t[0] || e[4] < t[1] || e[5] < t[2])
        }
        function en(e, t) {
            var i = e.indexOf(t);
            i < 0 || (i === e.length - 1 ? e.pop() : e[i] = e.pop())
        }
        function tn(e, t, i) {
            return 1023 & e | (1023 & t) << 10 | (1023 & i) << 20
        }
        class sn {
            constructor() {
                this.hash = {}
            }
            getChunkByIndexes(e=0, t=0, i=0) {
                return this.hash[tn(e, t, i)] || null
            }
            storeChunkByIndexes(e=0, t=0, i=0, s) {
                this.hash[tn(e, t, i)] = s
            }
            removeChunkByIndexes(e=0, t=0, i=0) {
                delete this.hash[tn(e, t, i)]
            }
        }
        class rn {
            constructor() {
                this.arr = [],
                this.hash = {}
            }
            forEach(e, t) {
                this.arr.forEach(e, t)
            }
            includes(e, t, i) {
                var s = tn(e, t, i);
                return !!this.hash[s]
            }
            add(e, t, i, s=!1) {
                var r = tn(e, t, i);
                this.hash[r] || (s ? this.arr.unshift([e, t, i, r]) : this.arr.push([e, t, i, r]),
                this.hash[r] = !0)
            }
            removeByIndex(e) {
                var t = this.arr[e];
                delete this.hash[t[3]],
                this.arr.splice(e, 1)
            }
            remove(e, t, i) {
                var s = tn(e, t, i);
                if (this.hash[s]) {
                    delete this.hash[s];
                    for (var r = 0; r < this.arr.length; r++)
                        if (s === this.arr[r][3])
                            return void this.arr.splice(r, 1);
                    throw "internal bug with location queue - hash value overlapped"
                }
            }
            count() {
                return this.arr.length
            }
            isEmpty() {
                return 0 === this.arr.length
            }
            empty() {
                this.arr = [],
                this.hash = {}
            }
            pop() {
                var e = this.arr.pop();
                return delete this.hash[e[3]],
                e
            }
            copyFrom(e) {
                for (var t in this.arr = e.arr.slice(),
                this.hash = {},
                e.hash)
                    this.hash[t] = !0
            }
            sortByDistance(e, t=!1) {
                !function(e, t, i) {
                    var s = {};
                    for (var r of e)
                        s[r[3]] = t(r[0], r[1], r[2]);
                    i ? e.sort(( (e, t) => s[e[3]] - s[t[3]])) : e.sort(( (e, t) => s[t[3]] - s[e[3]])),
                    s = null
                }(this.arr, e, t)
            }
        }
        function nn(e) {
            this.rootNode = new lr("objectMeshRoot",e.rendering.scene);
            var t = [0, 0, 0]
              , i = !1
              , s = new lr("");
            this.allBaseMeshes = [];
            var r = {}
              , n = t => {
                if (r[t])
                    return r[t];
                var i = e.registry._blockMeshLookup[t];
                for (var s in r) {
                    var n = r[s].mesh;
                    if (n === i || n.geometry === i.geometry)
                        return r[t] = r[s]
                }
                return this.allBaseMeshes.push(i),
                i.metadata || (i.metadata = {}),
                i.metadata[a] = !0,
                r[t] = new an(e,i)
            }
              , a = "noa_object_base_mesh";
            this.initChunk = function(e) {
                e._objectBlocks = {}
            }
            ,
            this.setObjectBlock = function(i, r, a, o, h) {
                var l = i.x + a
                  , c = i.y + o
                  , u = i.z + h
                  , d = `${l}:${c}:${u}`
                  , f = i._objectBlocks[d] || 0;
                if (f !== r) {
                    if (f > 0 && n(f).removeInstance(i, d),
                    r > 0) {
                        var _ = e.registry._blockHandlerLookup[r]
                          , p = _ && _.onCustomMeshCreate;
                        p && (s.position.copyFromFloats(.5, 0, .5),
                        s.scaling.setAll(1),
                        s.rotation.setAll(0),
                        p(s, l, c, u));
                        var m = n(r)
                          , g = p ? s : null;
                        m.addInstance(i, d, a, o, h, g, t)
                    }
                    f > 0 && !r && delete i._objectBlocks[d],
                    r > 0 && (i._objectBlocks[d] = r)
                }
            }
            ,
            this.buildObjectMeshes = function() {
                for (var e in ln("start"),
                r) {
                    var t = r[e];
                    t.updateMatrix(),
                    0 === t.count && t.dispose(),
                    t.disposed && delete r[e]
                }
                ln("rebuilt"),
                ln("end")
            }
            ,
            this.disposeChunk = function(e) {
                for (var t in e._objectBlocks) {
                    var s = e._objectBlocks[t];
                    s > 0 && n(s).removeInstance(e, t)
                }
                e._objectBlocks = null,
                i = !0
            }
            ,
            this.tick = function() {
                i && (this.buildObjectMeshes(),
                i = !1)
            }
            ,
            this._rebaseOrigin = function(e) {
                for (var s in t[0] += e[0],
                t[1] += e[1],
                t[2] += e[2],
                r)
                    r[s].rebased = !1;
                for (var n in r) {
                    var a = r[n];
                    if (!a.rebased) {
                        for (var o = 0; o < a.count; o++) {
                            var h = o << 4;
                            a.buffer[h + 12] -= e[0],
                            a.buffer[h + 13] -= e[1],
                            a.buffer[h + 14] -= e[2]
                        }
                        a.rebased = !0,
                        a.dirty = !0
                    }
                }
                i = !0
            }
        }
        function an(e, t) {
            this.noa = e,
            this.mesh = t,
            this.buffer = null,
            this.capacity = 0,
            this.count = 0,
            this.dirty = !1,
            this.rebased = !0,
            this.disposed = !1,
            this.keyToIndex = {},
            this.locToKey = [],
            this.mesh.position.setAll(0),
            this.mesh.parent = e._objectMesher.rootNode,
            this.noa.rendering.addMeshToScene(this.mesh, !1),
            this.noa.emit("addingTerrainMesh", this.mesh),
            this.mesh.isPickable = !1,
            this.mesh.doNotSyncBoundingInfo = !0,
            this.mesh.alwaysSelectAsActiveMesh = !0
        }
        Gr.prototype.thinInstanceAdd = function(e, t=!0) {
            if (!this.getScene().getEngine().getCaps().instancedArrays)
                return We.Error("Thin Instances are not supported on this device as Instanced Array extension not supported"),
                -1;
            this._thinInstanceUpdateBufferSize("matrix", Array.isArray(e) ? e.length : 1);
            const i = this._thinInstanceDataStorage.instancesCount;
            if (Array.isArray(e))
                for (let i = 0; i < e.length; ++i)
                    this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, e[i], i === e.length - 1 && t);
            else
                this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, e, t);
            return i
        }
        ,
        Gr.prototype.thinInstanceAddSelf = function(e=!0) {
            return this.thinInstanceAdd(Oi.IdentityReadOnly, e)
        }
        ,
        Gr.prototype.thinInstanceRegisterAttribute = function(e, t) {
            e === os.ColorKind && (e = os.ColorInstanceKind),
            this.removeVerticesData(e),
            this._thinInstanceInitializeUserStorage(),
            this._userThinInstanceBuffersStorage.strides[e] = t,
            this._userThinInstanceBuffersStorage.sizes[e] = t * Math.max(32, this._thinInstanceDataStorage.instancesCount),
            this._userThinInstanceBuffersStorage.data[e] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[e]),
            this._userThinInstanceBuffersStorage.vertexBuffers[e] = new os(this.getEngine(),this._userThinInstanceBuffersStorage.data[e],e,!0,!1,t,!0),
            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e])
        }
        ,
        Gr.prototype.thinInstanceSetMatrixAt = function(e, t, i=!0) {
            if (!this._thinInstanceDataStorage.matrixData || e >= this._thinInstanceDataStorage.instancesCount)
                return !1;
            const s = this._thinInstanceDataStorage.matrixData;
            return t.copyToArray(s, 16 * e),
            this._thinInstanceDataStorage.worldMatrices && (this._thinInstanceDataStorage.worldMatrices[e] = t),
            i && (this.thinInstanceBufferUpdated("matrix"),
            this.doNotSyncBoundingInfo || this.thinInstanceRefreshBoundingInfo(!1)),
            !0
        }
        ,
        Gr.prototype.thinInstanceSetAttributeAt = function(e, t, i, s=!0) {
            return e === os.ColorKind && (e = os.ColorInstanceKind),
            !(!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[e] || t >= this._thinInstanceDataStorage.instancesCount || (this._thinInstanceUpdateBufferSize(e, 0),
            this._userThinInstanceBuffersStorage.data[e].set(i, t * this._userThinInstanceBuffersStorage.strides[e]),
            s && this.thinInstanceBufferUpdated(e),
            0))
        }
        ,
        Object.defineProperty(Gr.prototype, "thinInstanceCount", {
            get: function() {
                return this._thinInstanceDataStorage.instancesCount
            },
            set: function(e) {
                const t = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;
                e <= (t ? t.length / 16 : 0) && (this._thinInstanceDataStorage.instancesCount = e)
            },
            enumerable: !0,
            configurable: !0
        }),
        Gr.prototype._thinInstanceCreateMatrixBuffer = function(e, t, i=!0) {
            const s = new as(this.getEngine(),t,!i,16,!1,!0);
            for (let t = 0; t < 4; t++)
                this.setVerticesBuffer(s.createVertexBuffer(e + t, 4 * t, 4));
            return s
        }
        ,
        Gr.prototype.thinInstanceSetBuffer = function(e, t, i=0, s=!0) {
            i = i || 16,
            "matrix" === e ? (this._thinInstanceDataStorage.matrixBuffer?.dispose(),
            this._thinInstanceDataStorage.matrixBuffer = null,
            this._thinInstanceDataStorage.matrixBufferSize = t ? t.length : 32 * i,
            this._thinInstanceDataStorage.matrixData = t,
            this._thinInstanceDataStorage.worldMatrices = null,
            null !== t ? (this._thinInstanceDataStorage.instancesCount = t.length / i,
            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", t, s),
            this.doNotSyncBoundingInfo || this.thinInstanceRefreshBoundingInfo(!1)) : (this._thinInstanceDataStorage.instancesCount = 0,
            this.doNotSyncBoundingInfo || this.refreshBoundingInfo())) : "previousMatrix" === e ? (this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),
            this._thinInstanceDataStorage.previousMatrixBuffer = null,
            this._thinInstanceDataStorage.previousMatrixData = t,
            null !== t && (this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", t, s))) : (e === os.ColorKind && (e = os.ColorInstanceKind),
            null === t ? this._userThinInstanceBuffersStorage?.data[e] && (this.removeVerticesData(e),
            delete this._userThinInstanceBuffersStorage.data[e],
            delete this._userThinInstanceBuffersStorage.strides[e],
            delete this._userThinInstanceBuffersStorage.sizes[e],
            delete this._userThinInstanceBuffersStorage.vertexBuffers[e]) : (this._thinInstanceInitializeUserStorage(),
            this._userThinInstanceBuffersStorage.data[e] = t,
            this._userThinInstanceBuffersStorage.strides[e] = i,
            this._userThinInstanceBuffersStorage.sizes[e] = t.length,
            this._userThinInstanceBuffersStorage.vertexBuffers[e] = new os(this.getEngine(),t,e,!s,!1,i,!0),
            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e])))
        }
        ,
        Gr.prototype.thinInstanceBufferUpdated = function(e) {
            "matrix" === e ? (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.matrixBuffer && !this._thinInstanceDataStorage.matrixBuffer.isUpdatable() && this._thinInstanceRecreateBuffer(e),
            this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount)) : "previousMatrix" === e ? (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.previousMatrixBuffer && !this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable() && this._thinInstanceRecreateBuffer(e),
            this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount)) : (e === os.ColorKind && (e = os.ColorInstanceKind),
            this._userThinInstanceBuffersStorage?.vertexBuffers[e] && (this.thinInstanceAllowAutomaticStaticBufferRecreation && !this._userThinInstanceBuffersStorage.vertexBuffers[e].isUpdatable() && this._thinInstanceRecreateBuffer(e),
            this._userThinInstanceBuffersStorage.vertexBuffers[e].updateDirectly(this._userThinInstanceBuffersStorage.data[e], 0)))
        }
        ,
        Gr.prototype.thinInstancePartialBufferUpdate = function(e, t, i) {
            "matrix" === e ? this._thinInstanceDataStorage.matrixBuffer && this._thinInstanceDataStorage.matrixBuffer.updateDirectly(t, i) : (e === os.ColorKind && (e = os.ColorInstanceKind),
            this._userThinInstanceBuffersStorage?.vertexBuffers[e] && this._userThinInstanceBuffersStorage.vertexBuffers[e].updateDirectly(t, i))
        }
        ,
        Gr.prototype.thinInstanceGetWorldMatrices = function() {
            if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer)
                return [];
            const e = this._thinInstanceDataStorage.matrixData;
            if (!this._thinInstanceDataStorage.worldMatrices) {
                this._thinInstanceDataStorage.worldMatrices = [];
                for (let t = 0; t < this._thinInstanceDataStorage.instancesCount; ++t)
                    this._thinInstanceDataStorage.worldMatrices[t] = Oi.FromArray(e, 16 * t)
            }
            return this._thinInstanceDataStorage.worldMatrices
        }
        ,
        Gr.prototype.thinInstanceRefreshBoundingInfo = function(e=!1, t=!1, i=!1) {
            if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer)
                return;
            const s = this._thinInstanceDataStorage.boundingVectors;
            if (e || !this.rawBoundingInfo) {
                s.length = 0,
                this.refreshBoundingInfo(t, i);
                const e = this.getBoundingInfo();
                this.rawBoundingInfo = new Ys(e.minimum,e.maximum)
            }
            const r = this.getBoundingInfo()
              , n = this._thinInstanceDataStorage.matrixData;
            if (0 === s.length)
                for (let e = 0; e < r.boundingBox.vectors.length; ++e)
                    s.push(r.boundingBox.vectors[e].clone());
            Bi.Vector3[0].setAll(Number.POSITIVE_INFINITY),
            Bi.Vector3[1].setAll(Number.NEGATIVE_INFINITY);
            for (let e = 0; e < this._thinInstanceDataStorage.instancesCount; ++e) {
                Oi.FromArrayToRef(n, 16 * e, Bi.Matrix[0]);
                for (let e = 0; e < s.length; ++e)
                    Di.TransformCoordinatesToRef(s[e], Bi.Matrix[0], Bi.Vector3[2]),
                    Bi.Vector3[0].minimizeInPlace(Bi.Vector3[2]),
                    Bi.Vector3[1].maximizeInPlace(Bi.Vector3[2])
            }
            r.reConstruct(Bi.Vector3[0], Bi.Vector3[1]),
            this._updateBoundingInfo()
        }
        ,
        Gr.prototype._thinInstanceRecreateBuffer = function(e, t=!0) {
            "matrix" === e ? (this._thinInstanceDataStorage.matrixBuffer?.dispose(),
            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", this._thinInstanceDataStorage.matrixData, t)) : "previousMatrix" === e ? this._scene.needsPreviousWorldMatrices && (this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),
            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.previousMatrixData ?? this._thinInstanceDataStorage.matrixData, t)) : (e === os.ColorKind && (e = os.ColorInstanceKind),
            this._userThinInstanceBuffersStorage.vertexBuffers[e]?.dispose(),
            this._userThinInstanceBuffersStorage.vertexBuffers[e] = new os(this.getEngine(),this._userThinInstanceBuffersStorage.data[e],e,!t,!1,this._userThinInstanceBuffersStorage.strides[e],!0),
            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e]))
        }
        ,
        Gr.prototype._thinInstanceUpdateBufferSize = function(e, t=1) {
            e === os.ColorKind && (e = os.ColorInstanceKind);
            const i = "matrix" === e;
            if (!(i || this._userThinInstanceBuffersStorage && this._userThinInstanceBuffersStorage.strides[e]))
                return;
            const s = i ? 16 : this._userThinInstanceBuffersStorage.strides[e]
              , r = i ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[e];
            let n = i ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[e];
            const a = (this._thinInstanceDataStorage.instancesCount + t) * s;
            let o = r;
            for (; o < a; )
                o *= 2;
            if (!n || r != o) {
                if (n) {
                    const e = new Float32Array(o);
                    e.set(n, 0),
                    n = e
                } else
                    n = new Float32Array(o);
                i ? (this._thinInstanceDataStorage.matrixBuffer?.dispose(),
                this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", n, !1),
                this._thinInstanceDataStorage.matrixData = n,
                this._thinInstanceDataStorage.matrixBufferSize = o,
                this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && (this._thinInstanceDataStorage.previousMatrixBuffer?.dispose(),
                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", n, !1))) : (this._userThinInstanceBuffersStorage.vertexBuffers[e]?.dispose(),
                this._userThinInstanceBuffersStorage.data[e] = n,
                this._userThinInstanceBuffersStorage.sizes[e] = o,
                this._userThinInstanceBuffersStorage.vertexBuffers[e] = new os(this.getEngine(),n,e,!0,!1,s,!0),
                this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[e]))
            }
        }
        ,
        Gr.prototype._thinInstanceInitializeUserStorage = function() {
            this._userThinInstanceBuffersStorage || (this._userThinInstanceBuffersStorage = {
                data: {},
                sizes: {},
                vertexBuffers: {},
                strides: {}
            })
        }
        ,
        Gr.prototype._disposeThinInstanceSpecificData = function() {
            this._thinInstanceDataStorage?.matrixBuffer && (this._thinInstanceDataStorage.matrixBuffer.dispose(),
            this._thinInstanceDataStorage.matrixBuffer = null)
        }
        ,
        an.prototype.dispose = function() {
            this.disposed || (this.mesh.thinInstanceCount = 0,
            this.setCapacity(0),
            this.noa.emit("removingTerrainMesh", this.mesh),
            this.noa.rendering.setMeshVisibility(this.mesh, !1),
            this.mesh = null,
            this.keyToIndex = null,
            this.locToKey = null,
            this.disposed = !0)
        }
        ,
        an.prototype.addInstance = function(e, t, i, s, r, n, a) {
            !function(e) {
                if (!(e.count < e.capacity)) {
                    var t = Math.max(8, 2 * e.capacity);
                    e.setCapacity(t)
                }
            }(this);
            var o = this.count << 4;
            if (this.locToKey[this.count] = t,
            this.keyToIndex[t] = o,
            n)
                n.position.x += e.x - a[0] + i,
                n.position.y += e.y - a[1] + s,
                n.position.z += e.z - a[2] + r,
                n.computeWorldMatrix(!0),
                hn(n._localMatrix._m, 0, this.buffer, o);
            else {
                var h = on;
                h[12] = e.x - a[0] + i + .5,
                h[13] = e.y - a[1] + s,
                h[14] = e.z - a[2] + r + .5,
                hn(h, 0, this.buffer, o)
            }
            this.count++,
            this.dirty = !0
        }
        ,
        an.prototype.removeInstance = function(e, t) {
            var i = this.keyToIndex[t];
            if (!(i >= 0))
                throw "tried to remove object instance not in storage";
            delete this.keyToIndex[t];
            var s, r = i >> 4, n = this.count - 1;
            if (r !== n) {
                var a = n << 4;
                hn(this.buffer, a, this.buffer, i);
                var o = this.locToKey[n];
                this.keyToIndex[o] = i,
                this.locToKey[r] = o
            }
            this.count--,
            this.dirty = !0,
            (s = this).count > .4 * s.capacity || s.capacity < 100 || (s.setCapacity(Math.round(s.capacity / 2)),
            s.locToKey.length = Math.min(s.locToKey.length, s.capacity))
        }
        ,
        an.prototype.updateMatrix = function() {
            this.dirty && (this.mesh.thinInstanceCount = this.count,
            this.mesh.thinInstanceBufferUpdated("matrix"),
            this.mesh.isVisible = this.count > 0,
            this.dirty = !1)
        }
        ,
        an.prototype.setCapacity = function(e=4) {
            if (this.capacity = e,
            0 === e)
                this.buffer = null;
            else {
                var t = new Float32Array(16 * this.capacity);
                if (this.buffer)
                    for (var i = Math.min(this.buffer.length, t.length), s = 0; s < i; s++)
                        t[s] = this.buffer[s];
                this.buffer = t
            }
            this.mesh.thinInstanceSetBuffer("matrix", this.buffer),
            this.updateMatrix()
        }
        ;
        var on = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
        function hn(e, t, i, s) {
            for (var r = 0; r < 16; r++)
                i[s + r] = e[t + r]
        }
        var ln = () => {}
        ;
        class cn {
            constructor(e, t) {
                this.width = e,
                this.height = t
            }
            toString() {
                return `{W: ${this.width}, H: ${this.height}}`
            }
            getClassName() {
                return "Size"
            }
            getHashCode() {
                let e = 0 | this.width;
                return e = 397 * e ^ this.height,
                e
            }
            copyFrom(e) {
                this.width = e.width,
                this.height = e.height
            }
            copyFromFloats(e, t) {
                return this.width = e,
                this.height = t,
                this
            }
            set(e, t) {
                return this.copyFromFloats(e, t)
            }
            multiplyByFloats(e, t) {
                return new cn(this.width * e,this.height * t)
            }
            clone() {
                return new cn(this.width,this.height)
            }
            equals(e) {
                return !!e && this.width === e.width && this.height === e.height
            }
            get surface() {
                return this.width * this.height
            }
            static Zero() {
                return new cn(0,0)
            }
            add(e) {
                return new cn(this.width + e.width,this.height + e.height)
            }
            subtract(e) {
                return new cn(this.width - e.width,this.height - e.height)
            }
            scale(e) {
                return new cn(this.width * e,this.height * e)
            }
            static Lerp(e, t, i) {
                const s = e.width + (t.width - e.width) * i
                  , r = e.height + (t.height - e.height) * i;
                return new cn(s,r)
            }
        }
        class un {
            get wrapU() {
                return this._wrapU
            }
            set wrapU(e) {
                this._wrapU = e
            }
            get wrapV() {
                return this._wrapV
            }
            set wrapV(e) {
                this._wrapV = e
            }
            get coordinatesMode() {
                return 0
            }
            get isCube() {
                return !!this._texture && this._texture.isCube
            }
            set isCube(e) {
                this._texture && (this._texture.isCube = e)
            }
            get is3D() {
                return !!this._texture && this._texture.is3D
            }
            set is3D(e) {
                this._texture && (this._texture.is3D = e)
            }
            get is2DArray() {
                return !!this._texture && this._texture.is2DArray
            }
            set is2DArray(e) {
                this._texture && (this._texture.is2DArray = e)
            }
            getClassName() {
                return "ThinTexture"
            }
            static _IsRenderTargetWrapper(e) {
                return void 0 !== e?._shareDepth
            }
            constructor(e) {
                this._wrapU = 1,
                this._wrapV = 1,
                this.wrapR = 1,
                this.anisotropicFilteringLevel = 4,
                this.delayLoadState = 0,
                this._texture = null,
                this._engine = null,
                this._cachedSize = cn.Zero(),
                this._cachedBaseSize = cn.Zero(),
                this._initialSamplingMode = 2,
                this._texture = un._IsRenderTargetWrapper(e) ? e.texture : e,
                this._texture && (this._engine = this._texture.getEngine())
            }
            isReady() {
                return 4 === this.delayLoadState ? (this.delayLoad(),
                !1) : !!this._texture && this._texture.isReady
            }
            delayLoad() {}
            getInternalTexture() {
                return this._texture
            }
            getSize() {
                if (this._texture) {
                    if (this._texture.width)
                        return this._cachedSize.width = this._texture.width,
                        this._cachedSize.height = this._texture.height,
                        this._cachedSize;
                    if (this._texture._size)
                        return this._cachedSize.width = this._texture._size,
                        this._cachedSize.height = this._texture._size,
                        this._cachedSize
                }
                return this._cachedSize
            }
            getBaseSize() {
                return this.isReady() && this._texture ? this._texture._size ? (this._cachedBaseSize.width = this._texture._size,
                this._cachedBaseSize.height = this._texture._size,
                this._cachedBaseSize) : (this._cachedBaseSize.width = this._texture.baseWidth,
                this._cachedBaseSize.height = this._texture.baseHeight,
                this._cachedBaseSize) : (this._cachedBaseSize.width = 0,
                this._cachedBaseSize.height = 0,
                this._cachedBaseSize)
            }
            get samplingMode() {
                return this._texture ? this._texture.samplingMode : this._initialSamplingMode
            }
            updateSamplingMode(e) {
                this._texture && this._engine && this._engine.updateTextureSamplingMode(e, this._texture)
            }
            releaseInternalTexture() {
                this._texture && (this._texture.dispose(),
                this._texture = null)
            }
            dispose() {
                this._texture && (this.releaseInternalTexture(),
                this._engine = null)
            }
        }
        class dn extends un {
            set hasAlpha(e) {
                this._hasAlpha !== e && (this._hasAlpha = e,
                this._scene && this._scene.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))))
            }
            get hasAlpha() {
                return this._hasAlpha
            }
            set getAlphaFromRGB(e) {
                this._getAlphaFromRGB !== e && (this._getAlphaFromRGB = e,
                this._scene && this._scene.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))))
            }
            get getAlphaFromRGB() {
                return this._getAlphaFromRGB
            }
            set coordinatesIndex(e) {
                this._coordinatesIndex !== e && (this._coordinatesIndex = e,
                this._scene && this._scene.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))))
            }
            get coordinatesIndex() {
                return this._coordinatesIndex
            }
            set coordinatesMode(e) {
                this._coordinatesMode !== e && (this._coordinatesMode = e,
                this._scene && this._scene.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))))
            }
            get coordinatesMode() {
                return this._coordinatesMode
            }
            get wrapU() {
                return this._wrapU
            }
            set wrapU(e) {
                this._wrapU = e
            }
            get wrapV() {
                return this._wrapV
            }
            set wrapV(e) {
                this._wrapV = e
            }
            get isCube() {
                return this._texture ? this._texture.isCube : this._isCube
            }
            set isCube(e) {
                this._texture ? this._texture.isCube = e : this._isCube = e
            }
            get is3D() {
                return !!this._texture && this._texture.is3D
            }
            set is3D(e) {
                this._texture && (this._texture.is3D = e)
            }
            get is2DArray() {
                return !!this._texture && this._texture.is2DArray
            }
            set is2DArray(e) {
                this._texture && (this._texture.is2DArray = e)
            }
            get gammaSpace() {
                return this._texture ? (null === this._texture._gammaSpace && (this._texture._gammaSpace = this._gammaSpace),
                this._texture._gammaSpace && !this._texture._useSRGBBuffer) : this._gammaSpace
            }
            set gammaSpace(e) {
                if (this._texture) {
                    if (this._texture._gammaSpace === e)
                        return;
                    this._texture._gammaSpace = e
                } else {
                    if (this._gammaSpace === e)
                        return;
                    this._gammaSpace = e
                }
                this.getScene()?.markAllMaterialsAsDirty(1, (e => e.hasTexture(this)))
            }
            get isRGBD() {
                return null != this._texture && this._texture._isRGBD
            }
            set isRGBD(e) {
                e !== this.isRGBD && (this._texture && (this._texture._isRGBD = e),
                this.getScene()?.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))))
            }
            get noMipmap() {
                return !1
            }
            get lodGenerationOffset() {
                return this._texture ? this._texture._lodGenerationOffset : 0
            }
            set lodGenerationOffset(e) {
                this._texture && (this._texture._lodGenerationOffset = e)
            }
            get lodGenerationScale() {
                return this._texture ? this._texture._lodGenerationScale : 0
            }
            set lodGenerationScale(e) {
                this._texture && (this._texture._lodGenerationScale = e)
            }
            get linearSpecularLOD() {
                return !!this._texture && this._texture._linearSpecularLOD
            }
            set linearSpecularLOD(e) {
                this._texture && (this._texture._linearSpecularLOD = e)
            }
            get irradianceTexture() {
                return this._texture ? this._texture._irradianceTexture : null
            }
            set irradianceTexture(e) {
                this._texture && (this._texture._irradianceTexture = e)
            }
            get uid() {
                return this._uid || (this._uid = ni()),
                this._uid
            }
            toString() {
                return this.name
            }
            getClassName() {
                return "BaseTexture"
            }
            set onDispose(e) {
                this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver),
                this._onDisposeObserver = this.onDisposeObservable.add(e)
            }
            get isBlocking() {
                return !0
            }
            get loadingError() {
                return this._loadingError
            }
            get errorObject() {
                return this._errorObject
            }
            constructor(e, t=null) {
                super(null),
                this.metadata = null,
                this.reservedDataStore = null,
                this._hasAlpha = !1,
                this._getAlphaFromRGB = !1,
                this.level = 1,
                this._coordinatesIndex = 0,
                this.optimizeUVAllocation = !0,
                this._coordinatesMode = 0,
                this.wrapR = 1,
                this.anisotropicFilteringLevel = dn.DEFAULT_ANISOTROPIC_FILTERING_LEVEL,
                this._isCube = !1,
                this._gammaSpace = !0,
                this.invertZ = !1,
                this.lodLevelInAlpha = !1,
                this.isRenderTarget = !1,
                this._prefiltered = !1,
                this._forceSerialize = !1,
                this.animations = [],
                this.onDisposeObservable = new Ue,
                this._onDisposeObserver = null,
                this._scene = null,
                this._uid = null,
                this._parentContainer = null,
                this._loadingError = !1,
                e ? dn._IsScene(e) ? this._scene = e : this._engine = e : this._scene = Ze.LastCreatedScene,
                this._scene && (this.uniqueId = this._scene.getUniqueId(),
                this._scene.addTexture(this),
                this._engine = this._scene.getEngine()),
                this._texture = t,
                this._uid = null
            }
            getScene() {
                return this._scene
            }
            _getEngine() {
                return this._engine
            }
            checkTransformsAreIdentical(e) {
                return null !== e
            }
            getTextureMatrix() {
                return Oi.IdentityReadOnly
            }
            getReflectionTextureMatrix() {
                return Oi.IdentityReadOnly
            }
            getRefractionTextureMatrix() {
                return this.getReflectionTextureMatrix()
            }
            isReadyOrNotBlocking() {
                return !this.isBlocking || this.isReady() || this.loadingError
            }
            scale(e) {}
            get canRescale() {
                return !1
            }
            _getFromCache(e, t, i, s, r, n) {
                const a = this._getEngine();
                if (!a)
                    return null;
                const o = a._getUseSRGBBuffer(!!r, t)
                  , h = a.getLoadedTexturesCache();
                for (let a = 0; a < h.length; a++) {
                    const l = h[a];
                    if (!(void 0 !== r && o !== l._useSRGBBuffer || void 0 !== s && s !== l.invertY || l.url !== e || l.generateMipMaps !== !t || i && i !== l.samplingMode || void 0 !== n && n !== l.isCube))
                        return l.incrementReferences(),
                        l
                }
                return null
            }
            _rebuild(e=!1) {}
            clone() {
                return null
            }
            get textureType() {
                return this._texture && void 0 !== this._texture.type ? this._texture.type : 0
            }
            get textureFormat() {
                return this._texture && void 0 !== this._texture.format ? this._texture.format : 5
            }
            _markAllSubMeshesAsTexturesDirty() {
                const e = this.getScene();
                e && e.markAllMaterialsAsDirty(1)
            }
            readPixels(e=0, t=0, i=null, s=!0, r=!1, n=0, a=0, o=Number.MAX_VALUE, h=Number.MAX_VALUE) {
                if (!this._texture)
                    return null;
                const l = this._getEngine();
                if (!l)
                    return null;
                const c = this.getSize();
                let u = c.width
                  , d = c.height;
                0 !== t && (u /= Math.pow(2, t),
                d /= Math.pow(2, t),
                u = Math.round(u),
                d = Math.round(d)),
                o = Math.min(u, o),
                h = Math.min(d, h);
                try {
                    return this._texture.isCube ? l._readTexturePixels(this._texture, o, h, e, t, i, s, r, n, a) : l._readTexturePixels(this._texture, o, h, -1, t, i, s, r, n, a)
                } catch (e) {
                    return null
                }
            }
            _readPixelsSync(e=0, t=0, i=null, s=!0, r=!1) {
                if (!this._texture)
                    return null;
                const n = this.getSize();
                let a = n.width
                  , o = n.height;
                const h = this._getEngine();
                if (!h)
                    return null;
                0 != t && (a /= Math.pow(2, t),
                o /= Math.pow(2, t),
                a = Math.round(a),
                o = Math.round(o));
                try {
                    return this._texture.isCube ? h._readTexturePixelsSync(this._texture, a, o, e, t, i, s, r) : h._readTexturePixelsSync(this._texture, a, o, -1, t, i, s, r)
                } catch (e) {
                    return null
                }
            }
            get _lodTextureHigh() {
                return this._texture ? this._texture._lodTextureHigh : null
            }
            get _lodTextureMid() {
                return this._texture ? this._texture._lodTextureMid : null
            }
            get _lodTextureLow() {
                return this._texture ? this._texture._lodTextureLow : null
            }
            dispose() {
                if (this._scene) {
                    this._scene.stopAnimation && this._scene.stopAnimation(this),
                    this._scene.removePendingData(this);
                    const e = this._scene.textures.indexOf(this);
                    if (e >= 0 && this._scene.textures.splice(e, 1),
                    this._scene.onTextureRemovedObservable.notifyObservers(this),
                    this._scene = null,
                    this._parentContainer) {
                        const e = this._parentContainer.textures.indexOf(this);
                        e > -1 && this._parentContainer.textures.splice(e, 1),
                        this._parentContainer = null
                    }
                }
                this.onDisposeObservable.notifyObservers(this),
                this.onDisposeObservable.clear(),
                this.metadata = null,
                super.dispose()
            }
            serialize(e=!1) {
                if (!this.name && !e)
                    return null;
                const t = ki.Serialize(this);
                return ki.AppendSerializedAnimations(this, t),
                t
            }
            static WhenAllReady(e, t) {
                let i = e.length;
                if (0 !== i)
                    for (let s = 0; s < e.length; s++) {
                        const r = e[s];
                        if (r.isReady())
                            0 == --i && t();
                        else {
                            const e = r.onLoadObservable;
                            e ? e.addOnce(( () => {
                                0 == --i && t()
                            }
                            )) : 0 == --i && t()
                        }
                    }
                else
                    t()
            }
            static _IsScene(e) {
                return "Scene" === e.getClassName()
            }
        }
        function fn(e, t, i=!1) {
            const s = t.width
              , r = t.height;
            if (e instanceof Float32Array) {
                let t = e.byteLength / e.BYTES_PER_ELEMENT;
                const i = new Uint8Array(t);
                for (; --t >= 0; ) {
                    let s = e[t];
                    s < 0 ? s = 0 : s > 1 && (s = 1),
                    i[t] = 255 * s
                }
                e = i
            }
            const n = document.createElement("canvas");
            n.width = s,
            n.height = r;
            const a = n.getContext("2d");
            if (!a)
                return null;
            const o = a.createImageData(s, r);
            if (o.data.set(e),
            a.putImageData(o, 0, 0),
            i) {
                const e = document.createElement("canvas");
                e.width = s,
                e.height = r;
                const t = e.getContext("2d");
                return t ? (t.translate(0, r),
                t.scale(1, -1),
                t.drawImage(n, 0, 0),
                e.toDataURL("image/png")) : null
            }
            return n.toDataURL("image/png")
        }
        dn.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4,
        pi([xi()], dn.prototype, "uniqueId", void 0),
        pi([xi()], dn.prototype, "name", void 0),
        pi([xi()], dn.prototype, "metadata", void 0),
        pi([xi("hasAlpha")], dn.prototype, "_hasAlpha", void 0),
        pi([xi("getAlphaFromRGB")], dn.prototype, "_getAlphaFromRGB", void 0),
        pi([xi()], dn.prototype, "level", void 0),
        pi([xi("coordinatesIndex")], dn.prototype, "_coordinatesIndex", void 0),
        pi([xi()], dn.prototype, "optimizeUVAllocation", void 0),
        pi([xi("coordinatesMode")], dn.prototype, "_coordinatesMode", void 0),
        pi([xi()], dn.prototype, "wrapU", null),
        pi([xi()], dn.prototype, "wrapV", null),
        pi([xi()], dn.prototype, "wrapR", void 0),
        pi([xi()], dn.prototype, "anisotropicFilteringLevel", void 0),
        pi([xi()], dn.prototype, "isCube", null),
        pi([xi()], dn.prototype, "is3D", null),
        pi([xi()], dn.prototype, "is2DArray", null),
        pi([xi()], dn.prototype, "gammaSpace", null),
        pi([xi()], dn.prototype, "invertZ", void 0),
        pi([xi()], dn.prototype, "lodLevelInAlpha", void 0),
        pi([xi()], dn.prototype, "lodGenerationOffset", null),
        pi([xi()], dn.prototype, "lodGenerationScale", null),
        pi([xi()], dn.prototype, "linearSpecularLOD", null),
        pi([Ti()], dn.prototype, "irradianceTexture", null),
        pi([xi()], dn.prototype, "isRenderTarget", void 0);
        class _n extends dn {
            static _CreateVideoTexture(e, t, i, s=!1, r=!1, n=_n.TRILINEAR_SAMPLINGMODE, a={}, o, h=5) {
                throw je("VideoTexture")
            }
            get noMipmap() {
                return this._noMipmap
            }
            get mimeType() {
                return this._mimeType
            }
            set isBlocking(e) {
                this._isBlocking = e
            }
            get isBlocking() {
                return this._isBlocking
            }
            get invertY() {
                return this._invertY
            }
            constructor(e, t, i, s, r=_n.TRILINEAR_SAMPLINGMODE, n=null, a=null, o=null, h=!1, l, c, u, d, f) {
                let _;
                super(t),
                this.url = null,
                this.uOffset = 0,
                this.vOffset = 0,
                this.uScale = 1,
                this.vScale = 1,
                this.uAng = 0,
                this.vAng = 0,
                this.wAng = 0,
                this.uRotationCenter = .5,
                this.vRotationCenter = .5,
                this.wRotationCenter = .5,
                this.homogeneousRotationInUVTransform = !1,
                this.inspectableCustomProperties = null,
                this._noMipmap = !1,
                this._invertY = !1,
                this._rowGenerationMatrix = null,
                this._cachedTextureMatrix = null,
                this._projectionModeMatrix = null,
                this._t0 = null,
                this._t1 = null,
                this._t2 = null,
                this._cachedUOffset = -1,
                this._cachedVOffset = -1,
                this._cachedUScale = 0,
                this._cachedVScale = 0,
                this._cachedUAng = -1,
                this._cachedVAng = -1,
                this._cachedWAng = -1,
                this._cachedReflectionProjectionMatrixId = -1,
                this._cachedURotationCenter = -1,
                this._cachedVRotationCenter = -1,
                this._cachedWRotationCenter = -1,
                this._cachedHomogeneousRotationInUVTransform = !1,
                this._cachedReflectionTextureMatrix = null,
                this._cachedReflectionUOffset = -1,
                this._cachedReflectionVOffset = -1,
                this._cachedReflectionUScale = 0,
                this._cachedReflectionVScale = 0,
                this._cachedReflectionCoordinatesMode = -1,
                this._buffer = null,
                this._deleteBuffer = !1,
                this._format = null,
                this._delayedOnLoad = null,
                this._delayedOnError = null,
                this.onLoadObservable = new Ue,
                this._isBlocking = !0,
                this.name = e || "",
                this.url = e;
                let p = !1
                  , m = null
                  , g = !0;
                "object" == typeof i && null !== i ? (_ = i.noMipmap ?? !1,
                s = i.invertY ?? !er.UseOpenGLOrientationForUV,
                r = i.samplingMode ?? _n.TRILINEAR_SAMPLINGMODE,
                n = i.onLoad ?? null,
                a = i.onError ?? null,
                o = i.buffer ?? null,
                h = i.deleteBuffer ?? !1,
                l = i.format,
                c = i.mimeType,
                u = i.loaderOptions,
                d = i.creationFlags,
                p = i.useSRGBBuffer ?? !1,
                m = i.internalTexture ?? null,
                g = i.gammaSpace ?? g) : _ = !!i,
                this._gammaSpace = g,
                this._noMipmap = _,
                this._invertY = void 0 === s ? !er.UseOpenGLOrientationForUV : s,
                this._initialSamplingMode = r,
                this._buffer = o,
                this._deleteBuffer = h,
                this._mimeType = c,
                this._loaderOptions = u,
                this._creationFlags = d,
                this._useSRGBBuffer = p,
                this._forcedExtension = f,
                l && (this._format = l);
                const v = this.getScene()
                  , y = this._getEngine();
                if (!y)
                    return;
                y.onBeforeTextureInitObservable.notifyObservers(this);
                const b = () => {
                    this._texture && (this._texture._invertVScale && (this.vScale *= -1,
                    this.vOffset += 1),
                    null !== this._texture._cachedWrapU && (this.wrapU = this._texture._cachedWrapU,
                    this._texture._cachedWrapU = null),
                    null !== this._texture._cachedWrapV && (this.wrapV = this._texture._cachedWrapV,
                    this._texture._cachedWrapV = null),
                    null !== this._texture._cachedWrapR && (this.wrapR = this._texture._cachedWrapR,
                    this._texture._cachedWrapR = null)),
                    this.onLoadObservable.hasObservers() && this.onLoadObservable.notifyObservers(this),
                    n && n(),
                    !this.isBlocking && v && v.resetCachedMaterial()
                }
                  , x = (e, t) => {
                    this._loadingError = !0,
                    this._errorObject = {
                        message: e,
                        exception: t
                    },
                    a && a(e, t),
                    _n.OnTextureLoadErrorObservable.notifyObservers(this)
                }
                ;
                if (!this.url && !m)
                    return this._delayedOnLoad = b,
                    void (this._delayedOnError = x);
                if (this._texture = m ?? this._getFromCache(this.url, _, r, this._invertY, p, this.isCube),
                this._texture)
                    if (this._texture.isReady)
                        Vt.SetImmediate(( () => b()));
                    else {
                        const e = this._texture.onLoadedObservable.add(b);
                        this._texture.onErrorObservable.add((t => {
                            x(t.message, t.exception),
                            this._texture?.onLoadedObservable.remove(e)
                        }
                        ))
                    }
                else if (v && v.useDelayedTextureLoading)
                    this.delayLoadState = 4,
                    this._delayedOnLoad = b,
                    this._delayedOnError = x;
                else {
                    try {
                        this._texture = y.createTexture(this.url, _, this._invertY, v, r, b, x, this._buffer, void 0, this._format, this._forcedExtension, c, u, d, p)
                    } catch (e) {
                        throw x("error loading", e),
                        e
                    }
                    h && (this._buffer = null)
                }
            }
            updateURL(e, t=null, i, s) {
                this.url && (this.releaseInternalTexture(),
                this.getScene().markAllMaterialsAsDirty(1, (e => e.hasTexture(this)))),
                this.name && !this.name.startsWith("data:") || (this.name = e),
                this.url = e,
                this._buffer = t,
                this._forcedExtension = s,
                this.delayLoadState = 4,
                i && (this._delayedOnLoad = i),
                this.delayLoad()
            }
            delayLoad() {
                if (4 !== this.delayLoadState)
                    return;
                const e = this.getScene();
                e && (this.delayLoadState = 1,
                this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer, this.isCube),
                this._texture ? this._delayedOnLoad && (this._texture.isReady ? Vt.SetImmediate(this._delayedOnLoad) : this._texture.onLoadedObservable.add(this._delayedOnLoad)) : (this._texture = e.getEngine().createTexture(this.url, this._noMipmap, this._invertY, e, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, this._forcedExtension, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer),
                this._deleteBuffer && (this._buffer = null)),
                this._delayedOnLoad = null,
                this._delayedOnError = null)
            }
            _prepareRowForTextureGeneration(e, t, i, s) {
                e *= this._cachedUScale,
                t *= this._cachedVScale,
                e -= this.uRotationCenter * this._cachedUScale,
                t -= this.vRotationCenter * this._cachedVScale,
                i -= this.wRotationCenter,
                Di.TransformCoordinatesFromFloatsToRef(e, t, i, this._rowGenerationMatrix, s),
                s.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset,
                s.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset,
                s.z += this.wRotationCenter
            }
            checkTransformsAreIdentical(e) {
                return null !== e && this.uOffset === e.uOffset && this.vOffset === e.vOffset && this.uScale === e.uScale && this.vScale === e.vScale && this.uAng === e.uAng && this.vAng === e.vAng && this.wAng === e.wAng
            }
            getTextureMatrix(e=1) {
                if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * e === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform)
                    return this._cachedTextureMatrix;
                this._cachedUOffset = this.uOffset,
                this._cachedVOffset = this.vOffset,
                this._cachedUScale = this.uScale * e,
                this._cachedVScale = this.vScale,
                this._cachedUAng = this.uAng,
                this._cachedVAng = this.vAng,
                this._cachedWAng = this.wAng,
                this._cachedURotationCenter = this.uRotationCenter,
                this._cachedVRotationCenter = this.vRotationCenter,
                this._cachedWRotationCenter = this.wRotationCenter,
                this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform,
                this._cachedTextureMatrix && this._rowGenerationMatrix || (this._cachedTextureMatrix = Oi.Zero(),
                this._rowGenerationMatrix = new Oi,
                this._t0 = Di.Zero(),
                this._t1 = Di.Zero(),
                this._t2 = Di.Zero()),
                Oi.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix),
                this.homogeneousRotationInUVTransform ? (Oi.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, Bi.Matrix[0]),
                Oi.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, Bi.Matrix[1]),
                Oi.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, Bi.Matrix[2]),
                Oi.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, Bi.Matrix[3]),
                Bi.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix),
                this._cachedTextureMatrix.multiplyToRef(Bi.Matrix[1], this._cachedTextureMatrix),
                this._cachedTextureMatrix.multiplyToRef(Bi.Matrix[2], this._cachedTextureMatrix),
                this._cachedTextureMatrix.multiplyToRef(Bi.Matrix[3], this._cachedTextureMatrix),
                this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1)) : (this._prepareRowForTextureGeneration(0, 0, 0, this._t0),
                this._prepareRowForTextureGeneration(1, 0, 0, this._t1),
                this._prepareRowForTextureGeneration(0, 1, 0, this._t2),
                this._t1.subtractInPlace(this._t0),
                this._t2.subtractInPlace(this._t0),
                Oi.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix));
                const t = this.getScene();
                return t ? (this.optimizeUVAllocation && t.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))),
                this._cachedTextureMatrix) : this._cachedTextureMatrix
            }
            getReflectionTextureMatrix() {
                const e = this.getScene();
                if (!e)
                    return this._cachedReflectionTextureMatrix;
                if (this.uOffset === this._cachedReflectionUOffset && this.vOffset === this._cachedReflectionVOffset && this.uScale === this._cachedReflectionUScale && this.vScale === this._cachedReflectionVScale && this.coordinatesMode === this._cachedReflectionCoordinatesMode) {
                    if (this.coordinatesMode !== _n.PROJECTION_MODE)
                        return this._cachedReflectionTextureMatrix;
                    if (this._cachedReflectionProjectionMatrixId === e.getProjectionMatrix().updateFlag)
                        return this._cachedReflectionTextureMatrix
                }
                this._cachedReflectionTextureMatrix || (this._cachedReflectionTextureMatrix = Oi.Zero()),
                this._projectionModeMatrix || (this._projectionModeMatrix = Oi.Zero());
                const t = this._cachedReflectionCoordinatesMode !== this.coordinatesMode;
                switch (this._cachedReflectionUOffset = this.uOffset,
                this._cachedReflectionVOffset = this.vOffset,
                this._cachedReflectionUScale = this.uScale,
                this._cachedReflectionVScale = this.vScale,
                this._cachedReflectionCoordinatesMode = this.coordinatesMode,
                this.coordinatesMode) {
                case _n.PLANAR_MODE:
                    Oi.IdentityToRef(this._cachedReflectionTextureMatrix),
                    this._cachedReflectionTextureMatrix[0] = this.uScale,
                    this._cachedReflectionTextureMatrix[5] = this.vScale,
                    this._cachedReflectionTextureMatrix[12] = this.uOffset,
                    this._cachedReflectionTextureMatrix[13] = this.vOffset;
                    break;
                case _n.PROJECTION_MODE:
                    {
                        Oi.FromValuesToRef(.5, 0, 0, 0, 0, -.5, 0, 0, 0, 0, 0, 0, .5, .5, 1, 1, this._projectionModeMatrix);
                        const t = e.getProjectionMatrix();
                        this._cachedReflectionProjectionMatrixId = t.updateFlag,
                        t.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix);
                        break
                    }
                default:
                    Oi.IdentityToRef(this._cachedReflectionTextureMatrix)
                }
                return t && e.markAllMaterialsAsDirty(1, (e => e.hasTexture(this))),
                this._cachedReflectionTextureMatrix
            }
            clone() {
                const e = {
                    noMipmap: this._noMipmap,
                    invertY: this._invertY,
                    samplingMode: this.samplingMode,
                    onLoad: void 0,
                    onError: void 0,
                    buffer: this._texture ? this._texture._buffer : void 0,
                    deleteBuffer: this._deleteBuffer,
                    format: this.textureFormat,
                    mimeType: this.mimeType,
                    loaderOptions: this._loaderOptions,
                    creationFlags: this._creationFlags,
                    useSRGBBuffer: this._useSRGBBuffer
                };
                return ki.Clone(( () => new _n(this._texture ? this._texture.url : null,this.getScene(),e)), this)
            }
            serialize() {
                const e = this.name;
                _n.SerializeBuffers || this.name.startsWith("data:") && (this.name = ""),
                this.name.startsWith("data:") && this.url === this.name && (this.url = "");
                const t = super.serialize(_n._SerializeInternalTextureUniqueId);
                return t ? ((_n.SerializeBuffers || _n.ForceSerializeBuffers) && ("string" == typeof this._buffer && "data:" === this._buffer.substr(0, 5) ? (t.base64String = this._buffer,
                t.name = t.name.replace("data:", "")) : this.url && this.url.startsWith("data:") && this._buffer instanceof Uint8Array ? t.base64String = "data:image/png;base64," + et(this._buffer) : (_n.ForceSerializeBuffers || this.url && this.url.startsWith("blob:") || this._forceSerialize) && (t.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? function(e, t=0, i=0) {
                    const s = e.getInternalTexture();
                    if (!s)
                        return null;
                    const r = e._readPixelsSync(t, i);
                    return r ? fn(r, e.getSize(), s.invertY) : null
                }(this) : async function(e, t=0, i=0) {
                    const s = e.getInternalTexture();
                    if (!s)
                        return null;
                    const r = await e.readPixels(t, i);
                    return r ? fn(r, e.getSize(), s.invertY) : null
                }(this))),
                t.invertY = this._invertY,
                t.samplingMode = this.samplingMode,
                t._creationFlags = this._creationFlags,
                t._useSRGBBuffer = this._useSRGBBuffer,
                _n._SerializeInternalTextureUniqueId && (t.internalTextureUniqueId = this._texture?.uniqueId ?? void 0),
                t.noMipmap = this._noMipmap,
                this.name = e,
                t) : null
            }
            getClassName() {
                return "Texture"
            }
            dispose() {
                super.dispose(),
                this.onLoadObservable.clear(),
                this._delayedOnLoad = null,
                this._delayedOnError = null,
                this._buffer = null
            }
            static Parse(e, t, i) {
                if (e.customType) {
                    const s = ri.Instantiate(e.customType).Parse(e, t, i);
                    return e.samplingMode && s.updateSamplingMode && s._samplingMode && s._samplingMode !== e.samplingMode && s.updateSamplingMode(e.samplingMode),
                    s
                }
                if (e.isCube && !e.isRenderTarget)
                    return _n._CubeTextureParser(e, t, i);
                const s = void 0 !== e.internalTextureUniqueId;
                if (!e.name && !e.isRenderTarget && !s)
                    return null;
                let r;
                if (s) {
                    const i = t.getEngine().getLoadedTexturesCache();
                    for (const t of i)
                        if (t.uniqueId === e.internalTextureUniqueId) {
                            r = t;
                            break
                        }
                }
                const n = t => {
                    if (t && t._texture && (t._texture._cachedWrapU = null,
                    t._texture._cachedWrapV = null,
                    t._texture._cachedWrapR = null),
                    e.samplingMode) {
                        const i = e.samplingMode;
                        t && t.samplingMode !== i && t.updateSamplingMode(i)
                    }
                    if (t && e.animations)
                        for (let i = 0; i < e.animations.length; i++) {
                            const s = e.animations[i]
                              , r = Re("BABYLON.Animation");
                            r && t.animations.push(r.Parse(s))
                        }
                    s && !r && t?._texture?._setUniqueId(e.internalTextureUniqueId)
                }
                ;
                return ki.Parse(( () => {
                    let s = !0;
                    if (e.noMipmap && (s = !1),
                    e.mirrorPlane) {
                        const i = _n._CreateMirror(e.name, e.renderTargetSize, t, s);
                        return i._waitingRenderList = e.renderList,
                        i.mirrorPlane = Wi.FromArray(e.mirrorPlane),
                        n(i),
                        i
                    }
                    if (e.isRenderTarget) {
                        let i = null;
                        if (e.isCube) {
                            if (t.reflectionProbes)
                                for (let i = 0; i < t.reflectionProbes.length; i++) {
                                    const s = t.reflectionProbes[i];
                                    if (s.name === e.name)
                                        return s.cubeTexture
                                }
                        } else
                            i = _n._CreateRenderTargetTexture(e.name, e.renderTargetSize, t, s, e._creationFlags ?? 0),
                            i._waitingRenderList = e.renderList;
                        return n(i),
                        i
                    }
                    if (e.isVideo) {
                        const r = _n._CreateVideoTexture(i + (e.url || e.name), i + (e.src || e.url), t, s, e.invertY, e.samplingMode, e.settings || {});
                        return n(r),
                        r
                    }
                    {
                        let a;
                        if (e.base64String && !r)
                            a = _n.CreateFromBase64String(e.base64String, e.base64String, t, !s, e.invertY, e.samplingMode, ( () => {
                                n(a)
                            }
                            ), e._creationFlags ?? 0, e._useSRGBBuffer ?? !1),
                            a.name = e.name;
                        else {
                            let o;
                            o = e.name && (e.name.indexOf("://") > 0 || e.name.startsWith("data:")) ? e.name : i + e.name,
                            e.url && (e.url.startsWith("data:") || _n.UseSerializedUrlIfAny) && (o = e.url);
                            const h = {
                                noMipmap: !s,
                                invertY: e.invertY,
                                samplingMode: e.samplingMode,
                                onLoad: () => {
                                    n(a)
                                }
                                ,
                                internalTexture: r
                            };
                            a = new _n(o,t,h)
                        }
                        return a
                    }
                }
                ), e, t)
            }
            static CreateFromBase64String(e, t, i, s, r, n=_n.TRILINEAR_SAMPLINGMODE, a=null, o=null, h=5, l) {
                return new _n("data:" + t,i,s,r,n,a,o,e,!1,h,void 0,void 0,l)
            }
            static LoadFromDataString(e, t, i, s=!1, r, n=!0, a=_n.TRILINEAR_SAMPLINGMODE, o=null, h=null, l=5, c) {
                return "data:" !== e.substr(0, 5) && (e = "data:" + e),
                new _n(e,i,r,n,a,o,h,t,s,l,void 0,void 0,c)
            }
        }
        _n.SerializeBuffers = !0,
        _n.ForceSerializeBuffers = !1,
        _n.OnTextureLoadErrorObservable = new Ue,
        _n._SerializeInternalTextureUniqueId = !1,
        _n._CubeTextureParser = (e, t, i) => {
            throw je("CubeTexture")
        }
        ,
        _n._CreateMirror = (e, t, i, s) => {
            throw je("MirrorTexture")
        }
        ,
        _n._CreateRenderTargetTexture = (e, t, i, s, r) => {
            throw je("RenderTargetTexture")
        }
        ,
        _n.NEAREST_SAMPLINGMODE = 1,
        _n.NEAREST_NEAREST_MIPLINEAR = 8,
        _n.BILINEAR_SAMPLINGMODE = 2,
        _n.LINEAR_LINEAR_MIPNEAREST = 11,
        _n.TRILINEAR_SAMPLINGMODE = 3,
        _n.LINEAR_LINEAR_MIPLINEAR = 3,
        _n.NEAREST_NEAREST_MIPNEAREST = 4,
        _n.NEAREST_LINEAR_MIPNEAREST = 5,
        _n.NEAREST_LINEAR_MIPLINEAR = 6,
        _n.NEAREST_LINEAR = 7,
        _n.NEAREST_NEAREST = 1,
        _n.LINEAR_NEAREST_MIPNEAREST = 9,
        _n.LINEAR_NEAREST_MIPLINEAR = 10,
        _n.LINEAR_LINEAR = 2,
        _n.LINEAR_NEAREST = 12,
        _n.EXPLICIT_MODE = 0,
        _n.SPHERICAL_MODE = 1,
        _n.PLANAR_MODE = 2,
        _n.CUBIC_MODE = 3,
        _n.PROJECTION_MODE = 4,
        _n.SKYBOX_MODE = 5,
        _n.INVCUBIC_MODE = 6,
        _n.EQUIRECTANGULAR_MODE = 7,
        _n.FIXED_EQUIRECTANGULAR_MODE = 8,
        _n.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9,
        _n.CLAMP_ADDRESSMODE = 0,
        _n.WRAP_ADDRESSMODE = 1,
        _n.MIRROR_ADDRESSMODE = 2,
        _n.UseSerializedUrlIfAny = !1,
        pi([xi()], _n.prototype, "url", void 0),
        pi([xi()], _n.prototype, "uOffset", void 0),
        pi([xi()], _n.prototype, "vOffset", void 0),
        pi([xi()], _n.prototype, "uScale", void 0),
        pi([xi()], _n.prototype, "vScale", void 0),
        pi([xi()], _n.prototype, "uAng", void 0),
        pi([xi()], _n.prototype, "vAng", void 0),
        pi([xi()], _n.prototype, "wAng", void 0),
        pi([xi()], _n.prototype, "uRotationCenter", void 0),
        pi([xi()], _n.prototype, "vRotationCenter", void 0),
        pi([xi()], _n.prototype, "wRotationCenter", void 0),
        pi([xi()], _n.prototype, "homogeneousRotationInUVTransform", void 0),
        pi([xi()], _n.prototype, "isBlocking", null),
        Ie("BABYLON.Texture", _n),
        ki._TextureParser = _n.Parse;
        const pn = new RegExp("^([gimus]+)!");
        class mn {
            constructor(e) {
                this._plugins = [],
                this._activePlugins = [],
                this._activePluginsForExtraEvents = [],
                this._material = e,
                this._scene = e.getScene(),
                this._engine = this._scene.getEngine()
            }
            _addPlugin(e) {
                for (let t = 0; t < this._plugins.length; ++t)
                    if (this._plugins[t].name === e.name)
                        return !1;
                if (this._material._uniformBufferLayoutBuilt)
                    throw `The plugin "${e.name}" can't be added to the material "${this._material.name}" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;
                const t = e.getClassName();
                mn._MaterialPluginClassToMainDefine[t] || (mn._MaterialPluginClassToMainDefine[t] = "MATERIALPLUGIN_" + ++mn._MaterialPluginCounter),
                this._material._callbackPluginEventGeneric = (e, t) => this._handlePluginEvent(e, t),
                this._plugins.push(e),
                this._plugins.sort(( (e, t) => e.priority - t.priority)),
                this._codeInjectionPoints = {};
                const i = {};
                i[mn._MaterialPluginClassToMainDefine[t]] = {
                    type: "boolean",
                    default: !0
                };
                for (const e of this._plugins)
                    e.collectDefines(i),
                    this._collectPointNames("vertex", e.getCustomCode("vertex")),
                    this._collectPointNames("fragment", e.getCustomCode("fragment"));
                return this._defineNamesFromPlugins = i,
                !0
            }
            _activatePlugin(e) {
                -1 === this._activePlugins.indexOf(e) && (this._activePlugins.push(e),
                this._activePlugins.sort(( (e, t) => e.priority - t.priority)),
                this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this),
                this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this),
                this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this),
                this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this),
                e.registerForExtraEvents && (this._activePluginsForExtraEvents.push(e),
                this._activePluginsForExtraEvents.sort(( (e, t) => e.priority - t.priority)),
                this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this),
                this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this),
                this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this)))
            }
            getPlugin(e) {
                for (let t = 0; t < this._plugins.length; ++t)
                    if (this._plugins[t].name === e)
                        return this._plugins[t];
                return null
            }
            _handlePluginEventIsReadyForSubMesh(e) {
                let t = !0;
                for (const i of this._activePlugins)
                    t = t && i.isReadyForSubMesh(e.defines, this._scene, this._engine, e.subMesh);
                e.isReadyForSubMesh = t
            }
            _handlePluginEventPrepareDefinesBeforeAttributes(e) {
                for (const t of this._activePlugins)
                    t.prepareDefinesBeforeAttributes(e.defines, this._scene, e.mesh)
            }
            _handlePluginEventPrepareDefines(e) {
                for (const t of this._activePlugins)
                    t.prepareDefines(e.defines, this._scene, e.mesh)
            }
            _handlePluginEventHardBindForSubMesh(e) {
                for (const t of this._activePluginsForExtraEvents)
                    t.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, e.subMesh)
            }
            _handlePluginEventBindForSubMesh(e) {
                for (const t of this._activePlugins)
                    t.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, e.subMesh)
            }
            _handlePluginEventHasRenderTargetTextures(e) {
                let t = !1;
                for (const e of this._activePluginsForExtraEvents)
                    if (t = e.hasRenderTargetTextures(),
                    t)
                        break;
                e.hasRenderTargetTextures = t
            }
            _handlePluginEventFillRenderTargetTextures(e) {
                for (const t of this._activePluginsForExtraEvents)
                    t.fillRenderTargetTextures(e.renderTargets)
            }
            _handlePluginEvent(e, t) {
                switch (e) {
                case pr.GetActiveTextures:
                    {
                        const e = t;
                        for (const t of this._activePlugins)
                            t.getActiveTextures(e.activeTextures);
                        break
                    }
                case pr.GetAnimatables:
                    {
                        const e = t;
                        for (const t of this._activePlugins)
                            t.getAnimatables(e.animatables);
                        break
                    }
                case pr.HasTexture:
                    {
                        const e = t;
                        let i = !1;
                        for (const t of this._activePlugins)
                            if (i = t.hasTexture(e.texture),
                            i)
                                break;
                        e.hasTexture = i;
                        break
                    }
                case pr.Disposed:
                    {
                        const e = t;
                        for (const t of this._plugins)
                            t.dispose(e.forceDisposeTextures);
                        break
                    }
                case pr.GetDefineNames:
                    t.defineNames = this._defineNamesFromPlugins;
                    break;
                case pr.PrepareEffect:
                    {
                        const e = t;
                        for (const t of this._activePlugins)
                            e.fallbackRank = t.addFallbacks(e.defines, e.fallbacks, e.fallbackRank),
                            t.getAttributes(e.attributes, this._scene, e.mesh);
                        this._uniformList.length > 0 && e.uniforms.push(...this._uniformList),
                        this._samplerList.length > 0 && e.samplers.push(...this._samplerList),
                        this._uboList.length > 0 && e.uniformBuffersNames.push(...this._uboList),
                        e.customCode = this._injectCustomCode(e, e.customCode);
                        break
                    }
                case pr.PrepareUniformBuffer:
                    {
                        const e = t;
                        this._uboDeclaration = "",
                        this._vertexDeclaration = "",
                        this._fragmentDeclaration = "",
                        this._uniformList = [],
                        this._samplerList = [],
                        this._uboList = [];
                        for (const t of this._plugins) {
                            const i = t.getUniforms();
                            if (i) {
                                if (i.ubo)
                                    for (const t of i.ubo) {
                                        if (t.size && t.type) {
                                            const i = t.arraySize ?? 0;
                                            e.ubo.addUniform(t.name, t.size, i),
                                            this._uboDeclaration += `${t.type} ${t.name}${i > 0 ? `[${i}]` : ""};\n`
                                        }
                                        this._uniformList.push(t.name)
                                    }
                                i.vertex && (this._vertexDeclaration += i.vertex + "\n"),
                                i.fragment && (this._fragmentDeclaration += i.fragment + "\n")
                            }
                            t.getSamplers(this._samplerList),
                            t.getUniformBuffersNames(this._uboList)
                        }
                        break
                    }
                }
            }
            _collectPointNames(e, t) {
                if (t)
                    for (const i in t)
                        this._codeInjectionPoints[e] || (this._codeInjectionPoints[e] = {}),
                        this._codeInjectionPoints[e][i] = !0
            }
            _injectCustomCode(e, t) {
                return (i, s) => {
                    t && (s = t(i, s)),
                    this._uboDeclaration && (s = s.replace("#define ADDITIONAL_UBO_DECLARATION", this._uboDeclaration)),
                    this._vertexDeclaration && (s = s.replace("#define ADDITIONAL_VERTEX_DECLARATION", this._vertexDeclaration)),
                    this._fragmentDeclaration && (s = s.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", this._fragmentDeclaration));
                    const r = this._codeInjectionPoints?.[i];
                    if (!r)
                        return s;
                    let n = null;
                    for (let t in r) {
                        let r = "";
                        for (const s of this._activePlugins) {
                            let a = s.getCustomCode(i)?.[t];
                            if (a) {
                                if (s.resolveIncludes) {
                                    if (null === n) {
                                        const t = ut.GLSL;
                                        n = {
                                            defines: [],
                                            indexParameters: e.indexParameters,
                                            isFragment: !1,
                                            shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
                                            processor: void 0,
                                            supportsUniformBuffers: this._engine.supportsUniformBuffers,
                                            shadersRepository: bt.GetShadersRepository(t),
                                            includesShadersStore: bt.GetIncludesShadersStore(t),
                                            version: void 0,
                                            platformName: this._engine.shaderPlatformName,
                                            processingContext: void 0,
                                            isNDCHalfZRange: this._engine.isNDCHalfZRange,
                                            useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
                                            processCodeAfterIncludes: void 0
                                        }
                                    }
                                    n.isFragment = "fragment" === i,
                                    yt._ProcessIncludes(a, n, (e => a = e))
                                }
                                r += a + "\n"
                            }
                        }
                        if (r.length > 0)
                            if ("!" === t.charAt(0)) {
                                t = t.substring(1);
                                let e = "g";
                                if ("!" === t.charAt(0))
                                    e = "",
                                    t = t.substring(1);
                                else {
                                    const i = pn.exec(t);
                                    i && i.length >= 2 && (e = i[1],
                                    t = t.substring(e.length + 1))
                                }
                                e.indexOf("g") < 0 && (e += "g");
                                const i = s
                                  , n = new RegExp(t,e);
                                let a = n.exec(i);
                                for (; null !== a; ) {
                                    let e = r;
                                    for (let t = 0; t < a.length; ++t)
                                        e = e.replace("$" + t, a[t]);
                                    s = s.replace(a[0], e),
                                    a = n.exec(i)
                                }
                            } else {
                                const e = "#define " + t;
                                s = s.replace(e, "\n" + r + "\n" + e)
                            }
                    }
                    return s
                }
            }
        }
        mn._MaterialPluginClassToMainDefine = {},
        mn._MaterialPluginCounter = 0,
        Ze.OnEnginesDisposedObservable.add(( () => {
            gn.length = 0,
            vn = !1,
            Fr.OnEventObservable.remove(yn),
            yn = null
        }
        ));
        const gn = [];
        let vn = !1
          , yn = null;
        class bn {
            _enable(e) {
                e && this._pluginManager._activatePlugin(this)
            }
            constructor(e, t, i, s, r=!0, n=!1, a=!1) {
                this.priority = 500,
                this.resolveIncludes = !1,
                this.registerForExtraEvents = !1,
                this._material = e,
                this.name = t,
                this.priority = i,
                this.resolveIncludes = a,
                e.pluginManager || (e.pluginManager = new mn(e),
                e.onDisposeObservable.add(( () => {
                    e.pluginManager = void 0
                }
                ))),
                this._pluginDefineNames = s,
                this._pluginManager = e.pluginManager,
                r && this._pluginManager._addPlugin(this),
                n && this._enable(!0),
                this.markAllDefinesAsDirty = e._dirtyCallbacks[63]
            }
            getClassName() {
                return "MaterialPluginBase"
            }
            isReadyForSubMesh(e, t, i, s) {
                return !0
            }
            hardBindForSubMesh(e, t, i, s) {}
            bindForSubMesh(e, t, i, s) {}
            dispose(e) {}
            getCustomCode(e) {
                return null
            }
            collectDefines(e) {
                if (this._pluginDefineNames)
                    for (const t of Object.keys(this._pluginDefineNames)) {
                        if ("_" === t[0])
                            continue;
                        const i = typeof this._pluginDefineNames[t];
                        e[t] = {
                            type: "number" === i ? "number" : "string" === i ? "string" : "boolean" === i ? "boolean" : "object",
                            default: this._pluginDefineNames[t]
                        }
                    }
            }
            prepareDefinesBeforeAttributes(e, t, i) {}
            prepareDefines(e, t, i) {}
            hasTexture(e) {
                return !1
            }
            hasRenderTargetTextures() {
                return !1
            }
            fillRenderTargetTextures(e) {}
            getActiveTextures(e) {}
            getAnimatables(e) {}
            addFallbacks(e, t, i) {
                return i
            }
            getSamplers(e) {}
            getAttributes(e, t, i) {}
            getUniformBuffersNames(e) {}
            getUniforms() {
                return {}
            }
            copyTo(e) {
                ki.Clone(( () => e), this)
            }
            serialize() {
                return ki.Serialize(this)
            }
            parse(e, t, i) {
                ki.Parse(( () => this), e, t, i)
            }
        }
        function xn(e, t, i, s) {
            let r, n = 1;
            1 === s ? r = new Float32Array(t * i * 4) : 2 === s ? (r = new Uint16Array(t * i * 4),
            n = 15360) : r = 7 === s ? new Uint32Array(t * i * 4) : new Uint8Array(t * i * 4);
            for (let s = 0; s < t; s++)
                for (let a = 0; a < i; a++) {
                    const i = 3 * (a * t + s)
                      , o = 4 * (a * t + s);
                    r[o + 0] = e[i + 0],
                    r[o + 1] = e[i + 1],
                    r[o + 2] = e[i + 2],
                    r[o + 3] = n
                }
            return r
        }
        function Tn(e) {
            return function(t, i, s, r, n, a, o, h, l=null, c=0) {
                const u = e ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY
                  , d = e ? At.Raw3D : At.Raw2DArray
                  , f = new It(this,d);
                f.baseWidth = i,
                f.baseHeight = s,
                f.baseDepth = r,
                f.width = i,
                f.height = s,
                f.depth = r,
                f.format = n,
                f.type = c,
                f.generateMipMaps = a,
                f.samplingMode = h,
                e ? f.is3D = !0 : f.is2DArray = !0,
                this._doNotHandleContextLost || (f._bufferView = t),
                e ? this.updateRawTexture3D(f, t, n, o, l, c) : this.updateRawTexture2DArray(f, t, n, o, l, c),
                this._bindTextureDirectly(u, f, !0);
                const _ = this._getSamplingParameters(h, a);
                return this._gl.texParameteri(u, this._gl.TEXTURE_MAG_FILTER, _.mag),
                this._gl.texParameteri(u, this._gl.TEXTURE_MIN_FILTER, _.min),
                a && this._gl.generateMipmap(u),
                this._bindTextureDirectly(u, null),
                this._internalTexturesCache.push(f),
                f
            }
        }
        function En(e) {
            return function(t, i, s, r, n=null, a=0) {
                const o = e ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY
                  , h = this._getWebGLTextureType(a)
                  , l = this._getInternalFormat(s)
                  , c = this._getRGBABufferInternalSizedFormat(a, s);
                this._bindTextureDirectly(o, t, !0),
                this._unpackFlipY(void 0 === r || !!r),
                this._doNotHandleContextLost || (t._bufferView = i,
                t.format = s,
                t.invertY = r,
                t._compression = n),
                t.width % 4 != 0 && this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1),
                n && i ? this._gl.compressedTexImage3D(o, 0, this.getCaps().s3tc[n], t.width, t.height, t.depth, 0, i) : this._gl.texImage3D(o, 0, c, t.width, t.height, t.depth, 0, l, h, i),
                t.generateMipMaps && this._gl.generateMipmap(o),
                this._bindTextureDirectly(o, null),
                t.isReady = !0
            }
        }
        pi([xi()], bn.prototype, "name", void 0),
        pi([xi()], bn.prototype, "priority", void 0),
        pi([xi()], bn.prototype, "resolveIncludes", void 0),
        pi([xi()], bn.prototype, "registerForExtraEvents", void 0),
        kt.prototype.updateRawTexture = function(e, t, i, s, r=null, n=0, a=!1) {
            if (!e)
                return;
            const o = this._getRGBABufferInternalSizedFormat(n, i, a)
              , h = this._getInternalFormat(i)
              , l = this._getWebGLTextureType(n);
            this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0),
            this._unpackFlipY(void 0 === s || !!s),
            this._doNotHandleContextLost || (e._bufferView = t,
            e.format = i,
            e.type = n,
            e.invertY = s,
            e._compression = r),
            e.width % 4 != 0 && this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1),
            r && t ? this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[r], e.width, e.height, 0, t) : this._gl.texImage2D(this._gl.TEXTURE_2D, 0, o, e.width, e.height, 0, h, l, t),
            e.generateMipMaps && this._gl.generateMipmap(this._gl.TEXTURE_2D),
            this._bindTextureDirectly(this._gl.TEXTURE_2D, null),
            e.isReady = !0
        }
        ,
        kt.prototype.createRawTexture = function(e, t, i, s, r, n, a, o=null, h=0, l=0, c=!1) {
            const u = new It(this,At.Raw);
            u.baseWidth = t,
            u.baseHeight = i,
            u.width = t,
            u.height = i,
            u.format = s,
            u.generateMipMaps = r,
            u.samplingMode = a,
            u.invertY = n,
            u._compression = o,
            u.type = h,
            u._useSRGBBuffer = this._getUseSRGBBuffer(c, !r),
            this._doNotHandleContextLost || (u._bufferView = e),
            this.updateRawTexture(u, e, s, n, o, h, u._useSRGBBuffer),
            this._bindTextureDirectly(this._gl.TEXTURE_2D, u, !0);
            const d = this._getSamplingParameters(a, r);
            return this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, d.mag),
            this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, d.min),
            r && this._gl.generateMipmap(this._gl.TEXTURE_2D),
            this._bindTextureDirectly(this._gl.TEXTURE_2D, null),
            this._internalTexturesCache.push(u),
            u
        }
        ,
        kt.prototype.createRawCubeTexture = function(e, t, i, s, r, n, a, o=null) {
            const h = this._gl
              , l = new It(this,At.CubeRaw);
            l.isCube = !0,
            l.format = i,
            l.type = s,
            this._doNotHandleContextLost || (l._bufferViewArray = e);
            const c = this._getWebGLTextureType(s);
            let u = this._getInternalFormat(i);
            u === h.RGB && (u = h.RGBA),
            c !== h.FLOAT || this._caps.textureFloatLinearFiltering ? c !== this._gl.HALF_FLOAT_OES || this._caps.textureHalfFloatLinearFiltering ? c !== h.FLOAT || this._caps.textureFloatRender ? c !== h.HALF_FLOAT || this._caps.colorBufferFloat || (r = !1,
            We.Warn("Render to half float textures is not supported. Mipmap generation forced to false.")) : (r = !1,
            We.Warn("Render to float textures is not supported. Mipmap generation forced to false.")) : (r = !1,
            a = 1,
            We.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.")) : (r = !1,
            a = 1,
            We.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively."));
            const d = t
              , f = d;
            if (l.width = d,
            l.height = f,
            l.invertY = n,
            l._compression = o,
            !this.needPOTTextures || ai(l.width) && ai(l.height) || (r = !1),
            e)
                this.updateRawCubeTexture(l, e, i, s, n, o);
            else {
                const e = this._getRGBABufferInternalSizedFormat(s)
                  , t = 0;
                this._bindTextureDirectly(h.TEXTURE_CUBE_MAP, l, !0);
                for (let i = 0; i < 6; i++)
                    o ? h.compressedTexImage2D(h.TEXTURE_CUBE_MAP_POSITIVE_X + i, t, this.getCaps().s3tc[o], l.width, l.height, 0, void 0) : h.texImage2D(h.TEXTURE_CUBE_MAP_POSITIVE_X + i, t, e, l.width, l.height, 0, u, c, null);
                this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)
            }
            this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, l, !0),
            e && r && this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
            const _ = this._getSamplingParameters(a, r);
            return h.texParameteri(h.TEXTURE_CUBE_MAP, h.TEXTURE_MAG_FILTER, _.mag),
            h.texParameteri(h.TEXTURE_CUBE_MAP, h.TEXTURE_MIN_FILTER, _.min),
            h.texParameteri(h.TEXTURE_CUBE_MAP, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE),
            h.texParameteri(h.TEXTURE_CUBE_MAP, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE),
            this._bindTextureDirectly(h.TEXTURE_CUBE_MAP, null),
            l.generateMipMaps = r,
            l.samplingMode = a,
            l.isReady = !0,
            l
        }
        ,
        kt.prototype.updateRawCubeTexture = function(e, t, i, s, r, n=null, a=0) {
            e._bufferViewArray = t,
            e.format = i,
            e.type = s,
            e.invertY = r,
            e._compression = n;
            const o = this._gl
              , h = this._getWebGLTextureType(s);
            let l = this._getInternalFormat(i);
            const c = this._getRGBABufferInternalSizedFormat(s);
            let u = !1;
            l === o.RGB && (l = o.RGBA,
            u = !0),
            this._bindTextureDirectly(o.TEXTURE_CUBE_MAP, e, !0),
            this._unpackFlipY(void 0 === r || !!r),
            e.width % 4 != 0 && o.pixelStorei(o.UNPACK_ALIGNMENT, 1);
            for (let i = 0; i < 6; i++) {
                let r = t[i];
                n ? o.compressedTexImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + i, a, this.getCaps().s3tc[n], e.width, e.height, 0, r) : (u && (r = xn(r, e.width, e.height, s)),
                o.texImage2D(o.TEXTURE_CUBE_MAP_POSITIVE_X + i, a, c, e.width, e.height, 0, l, h, r))
            }
            (!this.needPOTTextures || ai(e.width) && ai(e.height)) && e.generateMipMaps && 0 === a && this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP),
            this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null),
            e.isReady = !0
        }
        ,
        kt.prototype.createRawCubeTextureFromUrl = function(e, t, i, s, r, n, a, o, h=null, l=null, c=3, u=!1) {
            const d = this._gl
              , f = this.createRawCubeTexture(null, i, s, r, !n, u, c, null);
            t?.addPendingData(f),
            f.url = e,
            f.isReady = !1,
            this._internalTexturesCache.push(f);
            const _ = e => {
                const i = f.width
                  , n = a(e);
                if (n) {
                    if (o) {
                        const e = this._getWebGLTextureType(r);
                        let t = this._getInternalFormat(s);
                        const a = this._getRGBABufferInternalSizedFormat(r);
                        let h = !1;
                        t === d.RGB && (t = d.RGBA,
                        h = !0),
                        this._bindTextureDirectly(d.TEXTURE_CUBE_MAP, f, !0),
                        this._unpackFlipY(!1);
                        const l = o(n);
                        for (let s = 0; s < l.length; s++) {
                            const n = i >> s;
                            for (let i = 0; i < 6; i++) {
                                let o = l[s][i];
                                h && (o = xn(o, n, n, r)),
                                d.texImage2D(i, s, a, n, n, 0, t, e, o)
                            }
                        }
                        this._bindTextureDirectly(d.TEXTURE_CUBE_MAP, null)
                    } else
                        this.updateRawCubeTexture(f, n, s, r, u);
                    f.isReady = !0,
                    t?.removePendingData(f),
                    f.onLoadedObservable.notifyObservers(f),
                    f.onLoadedObservable.clear(),
                    h && h()
                }
            }
            ;
            return this._loadFile(e, (e => {
                _(e)
            }
            ), void 0, t?.offlineProvider, !0, ( (e, i) => {
                t?.removePendingData(f),
                l && e && l(e.status + " " + e.statusText, i)
            }
            )),
            f
        }
        ,
        kt.prototype.createRawTexture2DArray = Tn(!1),
        kt.prototype.createRawTexture3D = Tn(!0),
        kt.prototype.updateRawTexture2DArray = En(!1),
        kt.prototype.updateRawTexture3D = En(!0);
        class Mn extends _n {
            get depth() {
                return this._depth
            }
            constructor(e, t, i, s, r, n, a=!0, o=!1, h=_n.TRILINEAR_SAMPLINGMODE, l=0, c) {
                super(null, n, !a, o),
                this.format = r,
                this._texture = n.getEngine().createRawTexture2DArray(e, t, i, s, r, a, o, h, null, l, c),
                this._depth = s,
                this.is2DArray = !0
            }
            update(e) {
                this._texture && this._getEngine().updateRawTexture2DArray(this._texture, e, this._texture.format, this._texture.invertY, null, this._texture.type)
            }
            static CreateRGBATexture(e, t, i, s, r, n=!0, a=!1, o=3, h=0) {
                return new Mn(e,t,i,s,5,r,n,a,o,h)
            }
        }
        class Sn {
            constructor(e) {
                this._defaultMat = e.rendering.makeStandardMaterial("base-terrain"),
                this._defaultMat.freeze(),
                this.allMaterials = [this._defaultMat],
                this.noa = e,
                this._idCounter = 1e3,
                this._blockMatIDtoTerrainID = {},
                this._terrainIDtoMatObject = {},
                this._texURLtoTerrainID = {},
                this._renderMatToTerrainID = new Map
            }
            getTerrainMatId(e) {
                if (e in this._blockMatIDtoTerrainID)
                    return this._blockMatIDtoTerrainID[e];
                var t = function(e, t=0) {
                    var i = e.noa.registry.getMaterialData(t);
                    if (i.renderMat) {
                        var s = i.renderMat;
                        return e._renderMatToTerrainID.has(s) || e._renderMatToTerrainID.set(s, e._idCounter++),
                        e._renderMatToTerrainID.get(s)
                    }
                    if (i.texture) {
                        var r = i.texture;
                        return r in e._texURLtoTerrainID || (e._texURLtoTerrainID[r] = e._idCounter++),
                        e._texURLtoTerrainID[r]
                    }
                    var n = i.alpha;
                    return n > 0 && n < 1 ? 10 + Math.round(100 * n) : 1
                }(this, e);
                if (!(t in this._terrainIDtoMatObject)) {
                    var i = function(e, t=0) {
                        var i = e.noa.registry.getMaterialData(t);
                        if (i.renderMat)
                            return i.renderMat;
                        if (!i.texture) {
                            if (!(i.alpha > 0 && i.alpha < 1))
                                return e._defaultMat;
                            var s = "terrain-alpha-" + t
                              , r = e.noa.rendering.makeStandardMaterial(s);
                            return r.alpha = i.alpha,
                            r.freeze(),
                            r
                        }
                        var n = e.noa.rendering.getScene()
                          , a = e.noa.rendering.makeStandardMaterial("terrain-textured-" + t)
                          , o = i.texture
                          , h = _n.NEAREST_SAMPLINGMODE
                          , l = new _n(o,n,!0,!1,h);
                        return i.texHasAlpha && (l.hasAlpha = !0),
                        a.diffuseTexture = l,
                        i.atlasIndex >= 0 && (new An(a,l),
                        e.noa.registry._textureNeedsAlpha(i.texture) && (l.hasAlpha = !0)),
                        a.freeze(),
                        a
                    }(this, e);
                    this.allMaterials.push(i),
                    this._terrainIDtoMatObject[t] = i
                }
                return this._blockMatIDtoTerrainID[e] = t,
                t
            }
            getMaterial(e=1) {
                return this._terrainIDtoMatObject[e]
            }
        }
        class An extends bn {
            constructor(e, t) {
                super(e, "TestPlugin", 200, {
                    NOA_TWOD_ARRAY_TEXTURE: !1
                }),
                this._enable(!0),
                this._atlasTextureArray = null,
                t.onLoadObservable.add((e => {
                    this.setTextureArrayData(e)
                }
                ))
            }
            setTextureArrayData(e) {
                var {width: t, height: i} = e.getSize()
                  , s = Math.round(i / t);
                i = t;
                var r = e._readPixelsSync()
                  , n = rr.TEXTUREFORMAT_RGBA
                  , a = _n.NEAREST_SAMPLINGMODE
                  , o = e.getScene();
                this._atlasTextureArray = new Mn(r,t,i,s,n,o,!0,!1,a)
            }
            prepareDefines(e, t, i) {
                e.NOA_TWOD_ARRAY_TEXTURE = !0
            }
            getClassName() {
                return "TerrainMaterialPluginName"
            }
            getSamplers(e) {
                e.push("atlasTexture")
            }
            getAttributes(e) {
                e.push("texAtlasIndices")
            }
            getUniforms() {
                return {
                    ubo: []
                }
            }
            bindForSubMesh(e, t, i, s) {
                this._atlasTextureArray && e.setTexture("atlasTexture", this._atlasTextureArray)
            }
            getCustomCode(e) {
                return "vertex" === e ? {
                    CUSTOM_VERTEX_MAIN_BEGIN: "\n                texAtlasIndex = texAtlasIndices;\n            ",
                    CUSTOM_VERTEX_DEFINITIONS: "\n                uniform highp sampler2DArray atlasTexture;\n                attribute float texAtlasIndices;\n                varying float texAtlasIndex;\n            "
                } : "fragment" === e ? {
                    "!baseColor\\=texture2D\\(diffuseSampler,vDiffuseUV\\+uvOffset\\);": "baseColor = texture(atlasTexture, vec3(vDiffuseUV, texAtlasIndex));",
                    CUSTOM_FRAGMENT_DEFINITIONS: "\n                uniform highp sampler2DArray atlasTexture;\n                varying float texAtlasIndex;\n            "
                } : null
            }
        }
        function In(e) {
            var t = new Sn(e);
            this.allTerrainMaterials = t.allMaterials,
            this._defaultMaterial = t._defaultMat;
            var i = new Cn(e,t)
              , s = new Fn(e,t);
            this.initChunk = function(e) {
                e._terrainMeshes.length = 0
            }
            ,
            this.disposeChunk = function(t) {
                t._terrainMeshes.forEach((t => {
                    e.emit("removingTerrainMesh", t),
                    t.dispose()
                }
                )),
                t._terrainMeshes.length = 0
            }
            ,
            this.meshChunk = function(t, n=!1) {
                Ln("start"),
                this.disposeChunk(t),
                Ln("cleanup");
                var a = i.mesh(t, n);
                Ln("geom");
                var o = s.buildMesh(t, a, n);
                Ln("build"),
                Ln("end"),
                o.forEach((i => {
                    i.cullingStrategy = Gr.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY,
                    e.rendering.addMeshToScene(i, !0, t.pos, this),
                    e.emit("addingTerrainMesh", i),
                    i.freezeNormals(),
                    i.freezeWorldMatrix(),
                    t._terrainMeshes.push(i),
                    i.metadata || (i.metadata = {}),
                    i.metadata[r] = !0
                }
                ))
            }
            ;
            var r = "noa_chunk_terrain_mesh"
        }
        function Rn() {
            this.terrainID = 0,
            this.numFaces = 0,
            this.matIDs = [],
            this.dirs = [],
            this.is = [],
            this.js = [],
            this.ks = [],
            this.wids = [],
            this.hts = [],
            this.packedAO = []
        }
        function Cn(e, t) {
            var i = new Int16Array(16)
              , s = new Int16Array(16)
              , r = t.getTerrainMatId.bind(t)
              , n = e => 1
              , o = r;
            function h(t, i) {
                if (l !== i) {
                    l = i,
                    c = e.registry._solidityLookup;
                    for (var s = -1; s < i + 1; s++) {
                        var r = s < 0 ? 0 : s < i ? 1 : 2;
                        f[s + 1] = [0, 1, 2][r],
                        _[s + 1] = [i - 1, s, 0][r],
                        p[s + 1] = [0, s, i - 1][r]
                    }
                }
                for (var n = t.get(0, 0, 0), a = 0; a < 3; a++)
                    for (var o = 0; o < 3; o++)
                        for (var h = 0; h < 3; h++) {
                            var m = 9 * a + 3 * o + h
                              , g = t.get(a - 1, o - 1, h - 1)
                              , v = 0;
                            g || (v = 1),
                            g === n && (v = 2),
                            d[m] = v,
                            u[m] = g || n
                        }
            }
            this.mesh = function(e, t) {
                var l = e.size;
                o = t ? n : r;
                var c = e._isEmpty || e._isFull
                  , u = {};
                wn.reset();
                for (var d = 0; d < 3; ++d) {
                    var f = 2 === d ? 0 : 2
                      , _ = 1 === d ? 0 : 1
                      , p = e._neighbors.data.map((e => e && e.voxels ? e.voxels.transpose(d, f, _) : null))
                      , m = a()(p, [3, 3, 3]).lo(1, 1, 1).transpose(d, f, _);
                    i.length < l * l && (i = new Int16Array(l * l),
                    s = new Int16Array(l * l)),
                    h(m, l);
                    var y = m.get(-1, 0, 0)
                      , b = m.get(0, 0, 0);
                    if (y) {
                        var x = y.lo(l, 0, 0)
                          , T = g(d, x, -1, b, 0);
                        T > 0 && v(0, d, f, _, l, l, T, u)
                    }
                    if (!c)
                        for (var E = 0; E < l - 1; E++) {
                            if (1 === d) {
                                var M = e._wholeLayerVoxel[E];
                                if (M >= 0 && M === e._wholeLayerVoxel[E + 1])
                                    continue
                            }
                            var S = 1 === d ? null : e._wholeLayerVoxel
                              , A = g(d, b, E, b, E + 1, S);
                            A > 0 && v(E + 1, d, f, _, l, l, A, u)
                        }
                }
                return u
            }
            ;
            var l = -1
              , c = [!1, !0]
              , u = Array(27).fill(null)
              , d = Array(27).fill(0)
              , f = [0, 1, 1, 1, 1, 1, 2]
              , _ = [3, 0, 1, 2, 3, 0]
              , p = [0, 0, 1, 2, 3, 3];
            function m(e, t, i) {
                var s = 9 * f[e + 1] + 3 * f[t + 1] + f[i + 1]
                  , r = u[s]
                  , n = d[s];
                if (2 === n)
                    return c[r.get(e, t, i)];
                var a = [_, p][n]
                  , o = a[e + 1]
                  , h = a[t + 1]
                  , l = a[i + 1];
                return c[r.get(o, h, l)]
            }
            function g(t, r, n, a, o, h=null) {
                for (var l = r.shape[1], c = i, u = s, d = e.rendering.useAO, f = e.rendering.revAoVal === e.rendering.aoVals[0], _ = e.registry._opacityLookup, p = e.registry.getBlockFaceMaterial, g = 2 * t, v = 0, y = r.index(n, 0, 0), b = r.stride[1], x = r.stride[2], T = a.index(o, 0, 0), E = a.stride[1], M = a.stride[2], S = 0, A = 0; A < l; ++A) {
                    var I = y
                      , R = T;
                    if (y += x,
                    T += M,
                    h && h[A] >= 0)
                        v += l;
                    else
                        for (var C = 0; C < l; C++,
                        v++,
                        I += b,
                        R += E) {
                            var P = r.data[I]
                              , D = a.data[R];
                            if (P !== D) {
                                var w = _[P]
                                  , F = _[D];
                                if (!w || !F) {
                                    var O = p(P, g)
                                      , L = p(D, g + 1);
                                    O !== L && (w || 0 === L ? (c[v] = O,
                                    d && (u[v] = On(m, o, n, C, A, f)),
                                    S++) : (F || 0 === O) && (c[v] = -L,
                                    d && (u[v] = On(m, n, o, C, A, f)),
                                    S++))
                                }
                            }
                        }
                }
                return S
            }
            function v(t, r, n, a, h, l, c, u) {
                var d = e.rendering.useAO
                  , f = i
                  , _ = s
                  , p = 0
                  , m = 2 * r
                  , g = [0, 0, 0];
                g[r] = t;
                for (var v = d ? y : b, x = 0; x < l; ++x)
                    for (var T = 1, E = 1, M = 0; M < h; M += T,
                    p += T) {
                        var S = 0 | f[p];
                        if (S) {
                            var A = 0 | _[p];
                            for (T = 1; T < h - M && v(p + T, f, S, _, A); ++T)
                                ;
                            e: for (E = 1; E < l - x; ++E)
                                for (var I = 0; I < T; ++I)
                                    if (!v(p + I + E * h, f, S, _, A))
                                        break e;
                            var R = Math.abs(S)
                              , C = o(R);
                            if (!(C in u)) {
                                var P = wn.get();
                                P.numFaces = 0,
                                P.terrainID = C,
                                u[C] = P
                            }
                            var D = u[C]
                              , w = D.numFaces;
                            D.numFaces++,
                            D.matIDs[w] = R,
                            g[n] = M,
                            g[a] = x,
                            D.is[w] = g[0],
                            D.js[w] = g[1],
                            D.ks[w] = g[2],
                            D.wids[w] = T,
                            D.hts[w] = E,
                            D.packedAO[w] = A,
                            D.dirs[w] = S > 0 ? m : m + 1;
                            for (var F = 0; F < E; ++F)
                                for (var O = 0; O < T; ++O)
                                    f[p + O + F * h] = 0;
                            if (0 == (c -= T * E))
                                return
                        } else
                            T = 1
                    }
            }
            function y(e, t, i, s, r) {
                return i === t[e] && r === s[e]
            }
            function b(e, t, i, s, r) {
                return i === t[e]
            }
        }
        var Pn, Dn, wn = (Pn = [],
        Dn = 0,
        {
            get: () => (Dn >= Pn.length && Pn.push(new Rn),
            Dn++,
            Pn[Dn - 1]),
            reset: () => {
                Dn = 0
            }
        });
        function Fn(e, t) {
            function i(e, t, i, s, r, n, a, o) {
                var h = 12 * t
                  , l = [i, s, r]
                  , c = [0, 0, 0]
                  , u = [0, 0, 0];
                c[2 === n ? 0 : 2] = a,
                u[1 === n ? 0 : 1] = o;
                for (var d = 0; d < 3; d++)
                    e[h + d] = l[d],
                    e[h + 3 + d] = l[d] + c[d],
                    e[h + 6 + d] = l[d] + c[d] + u[d],
                    e[h + 9 + d] = l[d] + u[d]
            }
            function s(e, t, i, s, r, n) {
                for (var a = 8 * t, o = 0; o < 8; o++)
                    e[a + o] = 0;
                0 === i ? (e[a + 1] = e[a + 3] = r - 0,
                e[a + 2] = e[a + 4] = n * s) : 1 === i ? (e[a + 1] = e[a + 7] = s - 0,
                e[a + 4] = e[a + 6] = n * r) : (e[a + 1] = e[a + 3] = r - 0,
                e[a + 2] = e[a + 4] = -n * s)
            }
            function r(e, t, i) {
                for (var s = 12 * t, r = 0; r < 12; r++)
                    e[s + r] = i[r % 3]
            }
            function n(e, t, i, s, r) {
                var n = 6 * t
                  , o = 4 * t;
                0 === i && (s = -s);
                var h = s < 0 ? 0 : 1;
                r || (h += 2);
                for (var l = a[h], c = 0; c < 6; c++)
                    e[n + c] = o + l[c]
            }
            this.buildMesh = function(a, u, d) {
                var f, _ = e.rendering.getScene(), p = e.rendering.useAO, m = e.rendering.aoVals, g = e.rendering.revAoVal, v = e.registry._matAtlasIndexLookup, y = e.registry._materialColorLookup, b = [1, 1, 1], x = [];
                for (var T in u) {
                    var E = u[T]
                      , M = E.terrainID
                      , S = !1;
                    d || (S = v[E.matIDs[0]] >= 0);
                    var A, I = E.numFaces, R = new Uint16Array(6 * I), C = new Float32Array(12 * I), P = new Float32Array(12 * I), D = new Float32Array(16 * I), w = new Float32Array(8 * I);
                    S && (A = new Float32Array(4 * I));
                    for (var F = 0; F < E.numFaces; F++) {
                        var O = E.matIDs[F]
                          , L = E.dirs[F]
                          , B = E.is[F]
                          , N = E.js[F]
                          , U = E.ks[F]
                          , k = E.wids[F]
                          , V = E.hts[F]
                          , G = L / 2 | 0
                          , z = L % 2 ? -1 : 1;
                        i(C, F, B, N, U, G, k, V),
                        s(w, F, G, k, V, z);
                        var W = [0, 0, 0];
                        W[G] = z,
                        r(P, F, W);
                        var X = E.packedAO[F]
                          , [H,K,Y,j] = [3 & (f = X), f >> 2 & 3, f >> 6 & 3, f >> 4 & 3];
                        n(R, F, G, z, h(H, K, Y, j)),
                        S && o(A, F, v[O]);
                        var q = y[O] || b;
                        p ? c(D, F, q, m, g, H, K, Y, j) : l(D, F, q)
                    }
                    var Z = `chunk_${a.requestID}_${M}`
                      , Q = new Gr(Z,_)
                      , $ = new $s;
                    $.positions = C,
                    $.indices = R,
                    $.normals = P,
                    $.colors = D,
                    $.uvs = w,
                    $.applyToMesh(Q),
                    S && Q.setVerticesData("texAtlasIndices", A, !1, 1),
                    Q.isPickable = !1,
                    Q.doNotSyncBoundingInfo = !0,
                    Q._refreshBoundingInfo = () => Q,
                    d || (Q.material = t.getMaterial(M)),
                    x.push(Q)
                }
                return x
            }
            ;
            var a = [[0, 1, 2, 0, 2, 3], [0, 2, 1, 0, 3, 2], [1, 2, 3, 1, 3, 0], [1, 3, 2, 1, 0, 3]];
            function o(e, t, i) {
                for (var s = 4 * t, r = 0; r < 4; r++)
                    e[s + r] = i
            }
            function h(e, t, i, s) {
                return e === i ? s !== t || 2 === s : s !== t && e + i > s + t
            }
            function l(e, t, i) {
                for (var s = 16 * t, r = 0; r < 16; r += 4)
                    e[s + r] = i[0],
                    e[s + r + 1] = i[1],
                    e[s + r + 2] = i[2],
                    e[s + r + 3] = 1
            }
            function c(e, t, i, s, r, n, a, o, h) {
                var l = 16 * t;
                u(e, l, i, n, s, r),
                u(e, l + 4, i, h, s, r),
                u(e, l + 8, i, o, s, r),
                u(e, l + 12, i, a, s, r)
            }
            function u(e, t, i, s, r, n) {
                var a = 0 === s ? n : r[s - 1];
                e[t] = i[0] * a,
                e[t + 1] = i[1] * a,
                e[t + 2] = i[2] * a,
                e[t + 3] = 1
            }
        }
        function On(e, t, i, s, r, n=!1) {
            var a = 1
              , o = 1
              , h = 1
              , l = 1;
            return e(t, s + 1, r) && (++h,
            ++l),
            e(t, s - 1, r) && (++a,
            ++o),
            e(t, s, r + 1) && (++o,
            ++l),
            e(t, s, r - 1) && (++a,
            ++h),
            e(t, s, r) ? (l = 3 === l || e(t, s + 1, r + 1) ? 3 : 2,
            o = 3 === o || e(t, s - 1, r + 1) ? 3 : 2,
            l << 6 | (h = 3 === h || e(t, s + 1, r - 1) ? 3 : 2) << 4 | o << 2 | (a = 3 === a || e(t, s - 1, r - 1) ? 3 : 2)) : n ? (1 === l && e(t, s + 1, r + 1) && (l = 2),
            1 === o && e(t, s - 1, r + 1) && (o = 2),
            1 === h && e(t, s + 1, r - 1) && (h = 2),
            1 === a && e(t, s - 1, r - 1) && (a = 2),
            l << 6 | h << 4 | o << 2 | a) : (1 === l && (e(t, s + 1, r + 1) ? l = 2 : e(i, s, r + 1) && e(i, s + 1, r) && e(i, s + 1, r + 1) || (l = 0)),
            1 === h && (e(t, s + 1, r - 1) ? h = 2 : e(i, s, r - 1) && e(i, s + 1, r) && e(i, s + 1, r - 1) || (h = 0)),
            1 === o && (e(t, s - 1, r + 1) ? o = 2 : e(i, s, r + 1) && e(i, s - 1, r) && e(i, s - 1, r + 1) || (o = 0)),
            1 === a && (e(t, s - 1, r - 1) ? a = 2 : e(i, s, r - 1) && e(i, s - 1, r) && e(i, s - 1, r - 1) || (a = 0)),
            l << 6 | h << 4 | o << 2 | a)
        }
        var Ln = () => {}
          , Bn = {
            texturePath: ""
        };
        class Nn {
            constructor(e, t) {
                t = Object.assign({}, Bn, t),
                this.noa = e,
                this._texturePath = t.texturePath;
                var i = {}
                  , s = [!1]
                  , r = [!1]
                  , n = [!1]
                  , a = [!1]
                  , o = [null]
                  , h = [null]
                  , l = [null]
                  , c = [!1]
                  , u = [0, 0, 0, 0, 0, 0]
                  , d = [null]
                  , f = [-1]
                  , _ = [];
                this.registerBlock = function(e=1, t=null) {
                    var d = new Vn(t && t.fluid)
                      , f = Object.assign({}, d, t || {});
                    if (e < 1 || e > 65535)
                        throw "Block id out of range: " + e;
                    for (; e > s.length; )
                        this.registerBlock(s.length, {});
                    s[e] = !!f.solid,
                    r[e] = !!f.opaque,
                    n[e] = !!f.fluid,
                    a[e] = !!f.blockMesh,
                    h[e] = f.blockMesh || null;
                    var _, p = f.material || null;
                    if (p)
                        if ("string" == typeof p)
                            _ = [p, p, p, p, p, p];
                        else if (p.length && 2 == p.length)
                            _ = [p[1], p[1], p[0], p[0], p[1], p[1]];
                        else if (p.length && 3 == p.length)
                            _ = [p[2], p[2], p[0], p[1], p[2], p[2]];
                        else {
                            if (!p.length || 6 != p.length)
                                throw "Invalid material parameter: " + p;
                            _ = p
                        }
                    else
                        _ = [null, null, null, null, null, null];
                    for (var m = 0; m < 6; ++m)
                        u[6 * e + m] = Un(this, i, _[m], !0);
                    o[e] = {},
                    n[e] && (o[e].fluidDensity = f.fluidDensity,
                    o[e].viscosity = f.viscosity);
                    var g = f.onLoad || f.onUnload || f.onSet || f.onUnset || f.onCustomMeshCreate;
                    l[e] = g ? new kn(f) : null;
                    var v = s[e] && r[e] && !g && !n[e] && !a[e];
                    return c[e] = v,
                    e
                }
                ,
                this.registerMaterial = function(e="?", t=null) {
                    if (Array.isArray(t))
                        throw 'This API changed signatures in v0.33, please use: `noa.registry.registerMaterial("name", optionsObj)`';
                    var s = Object.assign(new Gn, t || {})
                      , r = i[e] || _.length;
                    i[e] = r;
                    var n = s.textureURL ? this._texturePath + s.textureURL : ""
                      , a = 1
                      , o = s.color || [1, 1, 1];
                    return 4 === o.length && (a = o.pop()),
                    n && (o = null),
                    d[r] = o,
                    f[r] = s.atlasIndex,
                    _[r] = {
                        color: o,
                        alpha: a,
                        texture: n,
                        texHasAlpha: !!s.texHasAlpha,
                        atlasIndex: s.atlasIndex,
                        renderMat: s.renderMaterial
                    },
                    r
                }
                ,
                this.getBlockSolidity = function(e) {
                    return s[e]
                }
                ,
                this.getBlockOpacity = function(e) {
                    return r[e]
                }
                ,
                this.getBlockFluidity = function(e) {
                    return n[e]
                }
                ,
                this.getBlockProps = function(e) {
                    return o[e]
                }
                ,
                this.getBlockFaceMaterial = function(e, t) {
                    return u[6 * e + t]
                }
                ,
                this.getMaterialData = function(e) {
                    return _[e]
                }
                ,
                this._textureNeedsAlpha = function(e="") {
                    return _.some((t => t.texture === e && t.texHasAlpha))
                }
                ,
                this._solidityLookup = s,
                this._opacityLookup = r,
                this._fluidityLookup = n,
                this._objectLookup = a,
                this._blockMeshLookup = h,
                this._blockHandlerLookup = l,
                this._blockIsPlainLookup = c,
                this._materialColorLookup = d,
                this._matAtlasIndexLookup = f,
                this.registerMaterial("dirt", {
                    color: [.4, .3, 0]
                }),
                this.registerBlock(1, {
                    material: "dirt"
                })
            }
        }
        function Un(e, t, i, s) {
            if (!i)
                return 0;
            var r = t[i];
            return void 0 === r && s && (r = e.registerMaterial(i)),
            r
        }
        function kn(e) {
            this.onLoad = e.onLoad || null,
            this.onUnload = e.onUnload || null,
            this.onSet = e.onSet || null,
            this.onUnset = e.onUnset || null,
            this.onCustomMeshCreate = e.onCustomMeshCreate || null
        }
        function Vn(e=!1) {
            this.solid = !e,
            this.opaque = !e,
            this.fluid = !1,
            this.material = null,
            this.blockMesh = null,
            this.fluidDensity = 1,
            this.viscosity = .5,
            this.onLoad = null,
            this.onUnload = null,
            this.onSet = null,
            this.onUnset = null,
            this.onCustomMeshCreate = null
        }
        function Gn() {
            this.color = null,
            this.textureURL = null,
            this.texHasAlpha = !1,
            this.atlasIndex = -1,
            this.renderMaterial = null
        }
        class zn {
            constructor(e, t, i, s, r, n) {
                this.entries = [],
                this._boundingVectors = new Array,
                this._capacity = i,
                this._depth = s,
                this._maxDepth = r,
                this._creationFunc = n,
                this._minPoint = e,
                this._maxPoint = t,
                this._boundingVectors.push(e.clone()),
                this._boundingVectors.push(t.clone()),
                this._boundingVectors.push(e.clone()),
                this._boundingVectors[2].x = t.x,
                this._boundingVectors.push(e.clone()),
                this._boundingVectors[3].y = t.y,
                this._boundingVectors.push(e.clone()),
                this._boundingVectors[4].z = t.z,
                this._boundingVectors.push(t.clone()),
                this._boundingVectors[5].z = e.z,
                this._boundingVectors.push(t.clone()),
                this._boundingVectors[6].x = e.x,
                this._boundingVectors.push(t.clone()),
                this._boundingVectors[7].y = e.y
            }
            get capacity() {
                return this._capacity
            }
            get minPoint() {
                return this._minPoint
            }
            get maxPoint() {
                return this._maxPoint
            }
            addEntry(e) {
                if (this.blocks)
                    for (let t = 0; t < this.blocks.length; t++)
                        this.blocks[t].addEntry(e);
                else
                    this._creationFunc(e, this),
                    this.entries.length > this.capacity && this._depth < this._maxDepth && this.createInnerBlocks()
            }
            removeEntry(e) {
                if (this.blocks) {
                    for (let t = 0; t < this.blocks.length; t++)
                        this.blocks[t].removeEntry(e);
                    return
                }
                const t = this.entries.indexOf(e);
                t > -1 && this.entries.splice(t, 1)
            }
            addEntries(e) {
                for (let t = 0; t < e.length; t++) {
                    const i = e[t];
                    this.addEntry(i)
                }
            }
            select(e, t, i) {
                if (Gs.IsInFrustum(this._boundingVectors, e)) {
                    if (this.blocks) {
                        for (let s = 0; s < this.blocks.length; s++)
                            this.blocks[s].select(e, t, i);
                        return
                    }
                    i ? t.concat(this.entries) : t.concatWithNoDuplicate(this.entries)
                }
            }
            intersects(e, t, i, s) {
                if (Gs.IntersectsSphere(this._minPoint, this._maxPoint, e, t)) {
                    if (this.blocks) {
                        for (let r = 0; r < this.blocks.length; r++)
                            this.blocks[r].intersects(e, t, i, s);
                        return
                    }
                    s ? i.concat(this.entries) : i.concatWithNoDuplicate(this.entries)
                }
            }
            intersectsRay(e, t) {
                if (e.intersectsBoxMinMax(this._minPoint, this._maxPoint)) {
                    if (this.blocks) {
                        for (let i = 0; i < this.blocks.length; i++)
                            this.blocks[i].intersectsRay(e, t);
                        return
                    }
                    t.concatWithNoDuplicate(this.entries)
                }
            }
            createInnerBlocks() {
                zn._CreateBlocks(this._minPoint, this._maxPoint, this.entries, this._capacity, this._depth, this._maxDepth, this, this._creationFunc),
                this.entries.splice(0)
            }
            static _CreateBlocks(e, t, i, s, r, n, a, o) {
                a.blocks = new Array;
                const h = new Di((t.x - e.x) / 2,(t.y - e.y) / 2,(t.z - e.z) / 2);
                for (let t = 0; t < 2; t++)
                    for (let l = 0; l < 2; l++)
                        for (let c = 0; c < 2; c++) {
                            const u = e.add(h.multiplyByFloats(t, l, c))
                              , d = e.add(h.multiplyByFloats(t + 1, l + 1, c + 1))
                              , f = new zn(u,d,s,r + 1,n,o);
                            f.addEntries(i),
                            a.blocks.push(f)
                        }
            }
        }
        class Wn {
            constructor(e, t, i=2) {
                this.maxDepth = i,
                this.dynamicContent = [],
                this._maxBlockCapacity = t || 64,
                this._selectionContent = new Ri(1024),
                this._creationFunc = e
            }
            update(e, t, i) {
                zn._CreateBlocks(e, t, i, this._maxBlockCapacity, 0, this.maxDepth, this, this._creationFunc)
            }
            addMesh(e) {
                for (let t = 0; t < this.blocks.length; t++)
                    this.blocks[t].addEntry(e)
            }
            removeMesh(e) {
                for (let t = 0; t < this.blocks.length; t++)
                    this.blocks[t].removeEntry(e)
            }
            select(e, t) {
                this._selectionContent.reset();
                for (let i = 0; i < this.blocks.length; i++)
                    this.blocks[i].select(e, this._selectionContent, t);
                return t ? this._selectionContent.concat(this.dynamicContent) : this._selectionContent.concatWithNoDuplicate(this.dynamicContent),
                this._selectionContent
            }
            intersects(e, t, i) {
                this._selectionContent.reset();
                for (let s = 0; s < this.blocks.length; s++)
                    this.blocks[s].intersects(e, t, this._selectionContent, i);
                return i ? this._selectionContent.concat(this.dynamicContent) : this._selectionContent.concatWithNoDuplicate(this.dynamicContent),
                this._selectionContent
            }
            intersectsRay(e) {
                this._selectionContent.reset();
                for (let t = 0; t < this.blocks.length; t++)
                    this.blocks[t].intersectsRay(e, this._selectionContent);
                return this._selectionContent.concatWithNoDuplicate(this.dynamicContent),
                this._selectionContent
            }
        }
        Wn.CreationFuncForMeshes = (e, t) => {
            const i = e.getBoundingInfo();
            !e.isBlocked && i.boundingBox.intersectsMinMax(t.minPoint, t.maxPoint) && t.entries.push(e)
        }
        ,
        Wn.CreationFuncForSubMeshes = (e, t) => {
            e.getBoundingInfo().boundingBox.intersectsMinMax(t.minPoint, t.maxPoint) && t.entries.push(e)
        }
        ;
        class Xn {
            constructor(e, t, i=Number.MAX_VALUE, s=.001) {
                this.origin = e,
                this.direction = t,
                this.length = i,
                this.epsilon = s
            }
            clone() {
                return new Xn(this.origin.clone(),this.direction.clone(),this.length)
            }
            intersectsBoxMinMax(e, t, i=0) {
                const s = Xn._TmpVector3[0].copyFromFloats(e.x - i, e.y - i, e.z - i)
                  , r = Xn._TmpVector3[1].copyFromFloats(t.x + i, t.y + i, t.z + i);
                let n, a, o, h, l = 0, c = Number.MAX_VALUE;
                if (Math.abs(this.direction.x) < 1e-7) {
                    if (this.origin.x < s.x || this.origin.x > r.x)
                        return !1
                } else if (n = 1 / this.direction.x,
                a = (s.x - this.origin.x) * n,
                o = (r.x - this.origin.x) * n,
                o === -1 / 0 && (o = 1 / 0),
                a > o && (h = a,
                a = o,
                o = h),
                l = Math.max(a, l),
                c = Math.min(o, c),
                l > c)
                    return !1;
                if (Math.abs(this.direction.y) < 1e-7) {
                    if (this.origin.y < s.y || this.origin.y > r.y)
                        return !1
                } else if (n = 1 / this.direction.y,
                a = (s.y - this.origin.y) * n,
                o = (r.y - this.origin.y) * n,
                o === -1 / 0 && (o = 1 / 0),
                a > o && (h = a,
                a = o,
                o = h),
                l = Math.max(a, l),
                c = Math.min(o, c),
                l > c)
                    return !1;
                if (Math.abs(this.direction.z) < 1e-7) {
                    if (this.origin.z < s.z || this.origin.z > r.z)
                        return !1
                } else if (n = 1 / this.direction.z,
                a = (s.z - this.origin.z) * n,
                o = (r.z - this.origin.z) * n,
                o === -1 / 0 && (o = 1 / 0),
                a > o && (h = a,
                a = o,
                o = h),
                l = Math.max(a, l),
                c = Math.min(o, c),
                l > c)
                    return !1;
                return !0
            }
            intersectsBox(e, t=0) {
                return this.intersectsBoxMinMax(e.minimum, e.maximum, t)
            }
            intersectsSphere(e, t=0) {
                const i = e.center.x - this.origin.x
                  , s = e.center.y - this.origin.y
                  , r = e.center.z - this.origin.z
                  , n = i * i + s * s + r * r
                  , a = e.radius + t
                  , o = a * a;
                if (n <= o)
                    return !0;
                const h = i * this.direction.x + s * this.direction.y + r * this.direction.z;
                return !(h < 0) && n - h * h <= o
            }
            intersectsTriangle(e, t, i) {
                const s = Xn._TmpVector3[0]
                  , r = Xn._TmpVector3[1]
                  , n = Xn._TmpVector3[2]
                  , a = Xn._TmpVector3[3]
                  , o = Xn._TmpVector3[4];
                t.subtractToRef(e, s),
                i.subtractToRef(e, r),
                Di.CrossToRef(this.direction, r, n);
                const h = Di.Dot(s, n);
                if (0 === h)
                    return null;
                const l = 1 / h;
                this.origin.subtractToRef(e, a);
                const c = Di.Dot(a, n) * l;
                if (c < -this.epsilon || c > 1 + this.epsilon)
                    return null;
                Di.CrossToRef(a, s, o);
                const u = Di.Dot(this.direction, o) * l;
                if (u < -this.epsilon || c + u > 1 + this.epsilon)
                    return null;
                const d = Di.Dot(r, o) * l;
                return d > this.length ? null : new Vs(1 - c - u,c,d)
            }
            intersectsPlane(e) {
                let t;
                const i = Di.Dot(e.normal, this.direction);
                if (Math.abs(i) < 9.99999997475243e-7)
                    return null;
                {
                    const s = Di.Dot(e.normal, this.origin);
                    return t = (-e.d - s) / i,
                    t < 0 ? t < -9.99999997475243e-7 ? null : 0 : t
                }
            }
            intersectsAxis(e, t=0) {
                switch (e) {
                case "y":
                    {
                        const e = (this.origin.y - t) / this.direction.y;
                        return e > 0 ? null : new Di(this.origin.x + this.direction.x * -e,t,this.origin.z + this.direction.z * -e)
                    }
                case "x":
                    {
                        const e = (this.origin.x - t) / this.direction.x;
                        return e > 0 ? null : new Di(t,this.origin.y + this.direction.y * -e,this.origin.z + this.direction.z * -e)
                    }
                case "z":
                    {
                        const e = (this.origin.z - t) / this.direction.z;
                        return e > 0 ? null : new Di(this.origin.x + this.direction.x * -e,this.origin.y + this.direction.y * -e,t)
                    }
                default:
                    return null
                }
            }
            intersectsMesh(e, t, i, s=!1, r, n=!1) {
                const a = Bi.Matrix[0];
                return e.getWorldMatrix().invertToRef(a),
                this._tmpRay ? Xn.TransformToRef(this, a, this._tmpRay) : this._tmpRay = Xn.Transform(this, a),
                e.intersects(this._tmpRay, t, i, s, r, n)
            }
            intersectsMeshes(e, t, i) {
                i ? i.length = 0 : i = [];
                for (let s = 0; s < e.length; s++) {
                    const r = this.intersectsMesh(e[s], t);
                    r.hit && i.push(r)
                }
                return i.sort(this._comparePickingInfo),
                i
            }
            _comparePickingInfo(e, t) {
                return e.distance < t.distance ? -1 : e.distance > t.distance ? 1 : 0
            }
            intersectionSegment(e, t, i) {
                const s = this.origin
                  , r = Bi.Vector3[0]
                  , n = Bi.Vector3[1]
                  , a = Bi.Vector3[2]
                  , o = Bi.Vector3[3];
                t.subtractToRef(e, r),
                this.direction.scaleToRef(Xn._Rayl, a),
                s.addToRef(a, n),
                e.subtractToRef(s, o);
                const h = Di.Dot(r, r)
                  , l = Di.Dot(r, a)
                  , c = Di.Dot(a, a)
                  , u = Di.Dot(r, o)
                  , d = Di.Dot(a, o)
                  , f = h * c - l * l;
                let _, p, m = f, g = f;
                f < Xn._Smallnum ? (_ = 0,
                m = 1,
                p = d,
                g = c) : (_ = l * d - c * u,
                p = h * d - l * u,
                _ < 0 ? (_ = 0,
                p = d,
                g = c) : _ > m && (_ = m,
                p = d + l,
                g = c)),
                p < 0 ? (p = 0,
                -u < 0 ? _ = 0 : -u > h ? _ = m : (_ = -u,
                m = h)) : p > g && (p = g,
                -u + l < 0 ? _ = 0 : -u + l > h ? _ = m : (_ = -u + l,
                m = h));
                const v = Math.abs(_) < Xn._Smallnum ? 0 : _ / m
                  , y = Math.abs(p) < Xn._Smallnum ? 0 : p / g
                  , b = Bi.Vector3[4];
                a.scaleToRef(y, b);
                const x = Bi.Vector3[5];
                r.scaleToRef(v, x),
                x.addInPlace(o);
                const T = Bi.Vector3[6];
                return x.subtractToRef(b, T),
                y > 0 && y <= this.length && T.lengthSquared() < i * i ? x.length() : -1
            }
            update(e, t, i, s, r, n, a, o=!1) {
                if (o) {
                    Xn._RayDistant || (Xn._RayDistant = Xn.Zero()),
                    Xn._RayDistant.unprojectRayToRef(e, t, i, s, Oi.IdentityReadOnly, n, a);
                    const o = Bi.Matrix[0];
                    r.invertToRef(o),
                    Xn.TransformToRef(Xn._RayDistant, o, this)
                } else
                    this.unprojectRayToRef(e, t, i, s, r, n, a);
                return this
            }
            static Zero() {
                return new Xn(Di.Zero(),Di.Zero())
            }
            static CreateNew(e, t, i, s, r, n, a) {
                return Xn.Zero().update(e, t, i, s, r, n, a)
            }
            static CreateNewFromTo(e, t, i=Oi.IdentityReadOnly) {
                const s = new Xn(new Di(0,0,0),new Di(0,0,0));
                return Xn.CreateFromToToRef(e, t, s, i)
            }
            static CreateFromToToRef(e, t, i, s=Oi.IdentityReadOnly) {
                i.origin.copyFrom(e);
                const r = t.subtractToRef(e, i.direction)
                  , n = Math.sqrt(r.x * r.x + r.y * r.y + r.z * r.z);
                return i.length = n,
                i.direction.normalize(),
                Xn.TransformToRef(i, s, i)
            }
            static Transform(e, t) {
                const i = new Xn(new Di(0,0,0),new Di(0,0,0));
                return Xn.TransformToRef(e, t, i),
                i
            }
            static TransformToRef(e, t, i) {
                Di.TransformCoordinatesToRef(e.origin, t, i.origin),
                Di.TransformNormalToRef(e.direction, t, i.direction),
                i.length = e.length,
                i.epsilon = e.epsilon;
                const s = i.direction
                  , r = s.length();
                if (0 !== r && 1 !== r) {
                    const e = 1 / r;
                    s.x *= e,
                    s.y *= e,
                    s.z *= e,
                    i.length *= r
                }
                return i
            }
            unprojectRayToRef(e, t, i, s, r, n, a) {
                const o = Bi.Matrix[0];
                r.multiplyToRef(n, o),
                o.multiplyToRef(a, o),
                o.invert();
                const h = Ze.LastCreatedEngine
                  , l = Bi.Vector3[0];
                l.x = e / i * 2 - 1,
                l.y = -(t / s * 2 - 1),
                l.z = h?.useReverseDepthBuffer ? 1 : h?.isNDCHalfZRange ? 0 : -1;
                const c = Bi.Vector3[1].copyFromFloats(l.x, l.y, 1 - 1e-8)
                  , u = Bi.Vector3[2]
                  , d = Bi.Vector3[3];
                Di._UnprojectFromInvertedMatrixToRef(l, o, u),
                Di._UnprojectFromInvertedMatrixToRef(c, o, d),
                this.origin.copyFrom(u),
                d.subtractToRef(u, this.direction),
                this.direction.normalize()
            }
        }
        Xn._TmpVector3 = Me.BuildArray(6, Di.Zero),
        Xn._RayDistant = Xn.Zero(),
        Xn._Smallnum = 1e-8,
        Xn._Rayl = 1e9,
        ks.prototype.createPickingRay = function(e, t, i, s, r=!1) {
            const n = Xn.Zero();
            return this.createPickingRayToRef(e, t, i, n, s, r),
            n
        }
        ,
        ks.prototype.createPickingRayToRef = function(e, t, i, s, r, n=!1, a=!1) {
            const o = this.getEngine();
            if (!r && !(r = this.activeCamera))
                return this;
            const h = r.viewport
              , l = o.getRenderHeight()
              , {x: c, y: u, width: d, height: f} = h.toGlobal(o.getRenderWidth(), l)
              , _ = 1 / o.getHardwareScalingLevel();
            return e = e * _ - c,
            t = t * _ - (l - u - f),
            s.update(e, t, d, f, i || Oi.IdentityReadOnly, n ? Oi.IdentityReadOnly : r.getViewMatrix(), r.getProjectionMatrix(), a),
            this
        }
        ,
        ks.prototype.createPickingRayInCameraSpace = function(e, t, i) {
            const s = Xn.Zero();
            return this.createPickingRayInCameraSpaceToRef(e, t, s, i),
            s
        }
        ,
        ks.prototype.createPickingRayInCameraSpaceToRef = function(e, t, i, s) {
            if (!hs)
                return this;
            const r = this.getEngine();
            if (!s && !(s = this.activeCamera))
                throw new Error("Active camera not set");
            const n = s.viewport
              , a = r.getRenderHeight()
              , {x: o, y: h, width: l, height: c} = n.toGlobal(r.getRenderWidth(), a)
              , u = Oi.Identity()
              , d = 1 / r.getHardwareScalingLevel();
            return e = e * d - o,
            t = t * d - (a - h - c),
            i.update(e, t, l, c, u, u, s.getProjectionMatrix()),
            this
        }
        ,
        ks.prototype._internalPickForMesh = function(e, t, i, s, r, n, a, o) {
            const h = t(s, i.enableDistantPicking)
              , l = i.intersects(h, r, a, n, s, o);
            return l && l.hit ? !r && null != e && l.distance >= e.distance ? null : l : null
        }
        ,
        ks.prototype._internalPick = function(e, t, i, s, r) {
            let n = null;
            const a = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera)
              , o = this.cameraToUseForPointers || this.activeCamera;
            for (let h = 0; h < this.meshes.length; h++) {
                const l = this.meshes[h];
                if (t) {
                    if (!t(l))
                        continue
                } else if (!l.isEnabled() || !l.isVisible || !l.isPickable)
                    continue;
                const c = a && l.isWorldMatrixCameraDependent()
                  , u = l.computeWorldMatrix(c, o);
                if (l.hasThinInstances && l.thinInstanceEnablePicking) {
                    const t = this._internalPickForMesh(n, e, l, u, !0, !0, r);
                    if (t) {
                        if (s)
                            return t;
                        const a = Bi.Matrix[1]
                          , o = l.thinInstanceGetWorldMatrices();
                        for (let t = 0; t < o.length; t++) {
                            o[t].multiplyToRef(u, a);
                            const h = this._internalPickForMesh(n, e, l, a, i, s, r, !0);
                            if (h && (n = h,
                            n.thinInstanceIndex = t,
                            i))
                                return n
                        }
                    }
                } else {
                    const t = this._internalPickForMesh(n, e, l, u, i, s, r);
                    if (t && (n = t,
                    i))
                        return n
                }
            }
            return n || new hs
        }
        ,
        ks.prototype._internalMultiPick = function(e, t, i) {
            if (!hs)
                return null;
            const s = []
              , r = !!(this.activeCameras && this.activeCameras.length > 1 && this.cameraToUseForPointers !== this.activeCamera)
              , n = this.cameraToUseForPointers || this.activeCamera;
            for (let a = 0; a < this.meshes.length; a++) {
                const o = this.meshes[a];
                if (t) {
                    if (!t(o))
                        continue
                } else if (!o.isEnabled() || !o.isVisible || !o.isPickable)
                    continue;
                const h = r && o.isWorldMatrixCameraDependent()
                  , l = o.computeWorldMatrix(h, n);
                if (o.hasThinInstances && o.thinInstanceEnablePicking) {
                    if (this._internalPickForMesh(null, e, o, l, !0, !0, i)) {
                        const t = Bi.Matrix[1]
                          , r = o.thinInstanceGetWorldMatrices();
                        for (let n = 0; n < r.length; n++) {
                            r[n].multiplyToRef(l, t);
                            const a = this._internalPickForMesh(null, e, o, t, !1, !1, i, !0);
                            a && (a.thinInstanceIndex = n,
                            s.push(a))
                        }
                    }
                } else {
                    const t = this._internalPickForMesh(null, e, o, l, !1, !1, i);
                    t && s.push(t)
                }
            }
            return s
        }
        ,
        ks.prototype.pickWithBoundingInfo = function(e, t, i, s, r) {
            if (!hs)
                return null;
            const n = this._internalPick((i => (this._tempPickingRay || (this._tempPickingRay = Xn.Zero()),
            this.createPickingRayToRef(e, t, i, this._tempPickingRay, r || null),
            this._tempPickingRay)), i, s, !0);
            return n && (n.ray = this.createPickingRay(e, t, Oi.Identity(), r || null)),
            n
        }
        ,
        Object.defineProperty(ks.prototype, "_pickingAvailable", {
            get: () => !0,
            enumerable: !1,
            configurable: !1
        }),
        ks.prototype.pick = function(e, t, i, s, r, n, a=!1) {
            const o = this._internalPick(( (i, s) => (this._tempPickingRay || (this._tempPickingRay = Xn.Zero()),
            this.createPickingRayToRef(e, t, i, this._tempPickingRay, r || null, !1, s),
            this._tempPickingRay)), i, s, !1, n);
            return o && (o.ray = this.createPickingRay(e, t, Oi.Identity(), r || null)),
            o
        }
        ,
        ks.prototype.pickWithRay = function(e, t, i, s) {
            const r = this._internalPick((t => (this._pickWithRayInverseMatrix || (this._pickWithRayInverseMatrix = Oi.Identity()),
            t.invertToRef(this._pickWithRayInverseMatrix),
            this._cachedRayForTransform || (this._cachedRayForTransform = Xn.Zero()),
            Xn.TransformToRef(e, this._pickWithRayInverseMatrix, this._cachedRayForTransform),
            this._cachedRayForTransform)), t, i, !1, s);
            return r && (r.ray = e),
            r
        }
        ,
        ks.prototype.multiPick = function(e, t, i, s, r) {
            return this._internalMultiPick((i => this.createPickingRay(e, t, i, s || null)), i, r)
        }
        ,
        ks.prototype.multiPickWithRay = function(e, t, i) {
            return this._internalMultiPick((t => (this._pickWithRayInverseMatrix || (this._pickWithRayInverseMatrix = Oi.Identity()),
            t.invertToRef(this._pickWithRayInverseMatrix),
            this._cachedRayForTransform || (this._cachedRayForTransform = Xn.Zero()),
            Xn.TransformToRef(e, this._pickWithRayInverseMatrix, this._cachedRayForTransform),
            this._cachedRayForTransform)), t, i)
        }
        ,
        Hi.prototype.getForwardRay = function(e=100, t, i) {
            return this.getForwardRayToRef(new Xn(Di.Zero(),Di.Zero(),e), e, t, i)
        }
        ,
        Hi.prototype.getForwardRayToRef = function(e, t=100, i, s) {
            i || (i = this.getWorldMatrix()),
            e.length = t,
            s ? e.origin.copyFrom(s) : e.origin.copyFrom(this.position);
            const r = Bi.Vector3[2];
            r.set(0, 0, this._scene.useRightHandedSystem ? -1 : 1);
            const n = Bi.Vector3[3];
            return Di.TransformNormalToRef(r, i, n),
            Di.NormalizeToRef(n, e.direction),
            e
        }
        ,
        ks.prototype.createOrUpdateSelectionOctree = function(e=64, t=2) {
            let i = this._getComponent(_s.NAME_OCTREE);
            i || (i = new Hn(this),
            this._addComponent(i)),
            this._selectionOctree || (this._selectionOctree = new Wn(Wn.CreationFuncForMeshes,e,t));
            const s = this.getWorldExtends();
            return this._selectionOctree.update(s.min, s.max, this.meshes),
            this._selectionOctree
        }
        ,
        Object.defineProperty(ks.prototype, "selectionOctree", {
            get: function() {
                return this._selectionOctree
            },
            enumerable: !0,
            configurable: !0
        }),
        fr.prototype.createOrUpdateSubmeshesOctree = function(e=64, t=2) {
            const i = this.getScene();
            let s = i._getComponent(_s.NAME_OCTREE);
            s || (s = new Hn(i),
            i._addComponent(s)),
            this._submeshesOctree || (this._submeshesOctree = new Wn(Wn.CreationFuncForSubMeshes,e,t)),
            this.computeWorldMatrix(!0);
            const r = this.getBoundingInfo().boundingBox;
            return this._submeshesOctree.update(r.minimumWorld, r.maximumWorld, this.subMeshes),
            this._submeshesOctree
        }
        ;
        class Hn {
            constructor(e) {
                this.name = _s.NAME_OCTREE,
                this.checksIsEnabled = !0,
                this._tempRay = new Xn(Di.Zero(),new Di(1,1,1)),
                (e = e || Ze.LastCreatedScene) && (this.scene = e,
                this.scene.getActiveMeshCandidates = () => this.getActiveMeshCandidates(),
                this.scene.getActiveSubMeshCandidates = e => this.getActiveSubMeshCandidates(e),
                this.scene.getCollidingSubMeshCandidates = (e, t) => this.getCollidingSubMeshCandidates(e, t),
                this.scene.getIntersectingSubMeshCandidates = (e, t) => this.getIntersectingSubMeshCandidates(e, t))
            }
            register() {
                this.scene.onMeshRemovedObservable.add((e => {
                    const t = this.scene.selectionOctree;
                    if (null != t) {
                        const i = t.dynamicContent.indexOf(e);
                        -1 !== i && t.dynamicContent.splice(i, 1)
                    }
                }
                )),
                this.scene.onMeshImportedObservable.add((e => {
                    const t = this.scene.selectionOctree;
                    null != t && t.addMesh(e)
                }
                ))
            }
            getActiveMeshCandidates() {
                return this.scene._selectionOctree?.select(this.scene.frustumPlanes) || this.scene._getDefaultMeshCandidates()
            }
            getActiveSubMeshCandidates(e) {
                return e._submeshesOctree && e.useOctreeForRenderingSelection ? e._submeshesOctree.select(this.scene.frustumPlanes) : this.scene._getDefaultSubMeshCandidates(e)
            }
            getIntersectingSubMeshCandidates(e, t) {
                return e._submeshesOctree && e.useOctreeForPicking ? (Xn.TransformToRef(t, e.getWorldMatrix(), this._tempRay),
                e._submeshesOctree.intersectsRay(this._tempRay)) : this.scene._getDefaultSubMeshCandidates(e)
            }
            getCollidingSubMeshCandidates(e, t) {
                if (e._submeshesOctree && e.useOctreeForCollisions) {
                    const i = t._velocityWorldLength + Math.max(t._radius.x, t._radius.y, t._radius.z);
                    return e._submeshesOctree.intersects(t._basePointWorld, i)
                }
                return this.scene._getDefaultSubMeshCandidates(e)
            }
            rebuild() {}
            dispose() {}
        }
        class Kn {
            constructor(e, t) {
                var i = e.scene;
                i._addComponent(new Hn(i));
                var s = "noa_octree_block"
                  , r = "noa_in_dynamic_list"
                  , n = "noa_in_octree_block"
                  , a = new Wn(h);
                i._selectionOctree = a,
                a.blocks = [];
                var o = {};
                this.rebase = e => {
                    c(a, e)
                }
                ,
                this.addMesh = (t, i, h, c) => {
                    if (t.metadata || (t.metadata = {}),
                    !i) {
                        if (t.metadata[r])
                            return;
                        return a.dynamicContent.push(t),
                        void (t.metadata[r] = !0)
                    }
                    var d = Math.floor(h[0] / l)
                      , f = Math.floor(h[1] / l)
                      , _ = Math.floor(h[2] / l)
                      , p = tn(d, f, _)
                      , m = o[p];
                    if (!m) {
                        var g = [d * l, f * l, _ * l]
                          , v = [0, 0, 0];
                        e.noa.globalToLocal(g, null, v),
                        m = u(v, l),
                        a.blocks.push(m),
                        o[p] = m,
                        m._noaMapKey = p
                    }
                    m.entries.push(t),
                    t.metadata[s] = m,
                    t.metadata[n] = !0,
                    t.alwaysSelectAsActiveMesh = !0
                }
                ,
                this.removeMesh = e => {
                    if (e.metadata && (e.metadata[r] && (en(a.dynamicContent, e),
                    e.metadata[r] = !1),
                    e.metadata[n])) {
                        var t = e.metadata[s];
                        t && t.entries && (en(t.entries, e),
                        0 === t.entries.length && (delete o[t._noaMapKey],
                        en(a.blocks, t))),
                        e.metadata[s] = null,
                        e.metadata[n] = !1
                    }
                }
                ,
                this.setMeshVisibility = (e, t=!1) => {
                    if (e.metadata[s]) {
                        if (e.metadata[n] === t)
                            return;
                        var i = e.metadata[s];
                        i && i.entries && (t ? i.entries.push(e) : en(i.entries, e)),
                        e.metadata[n] = t
                    } else {
                        if (e.metadata[r] === t)
                            return;
                        t ? a.dynamicContent.push(e) : en(a.dynamicContent, e),
                        e.metadata[r] = t
                    }
                }
                ;
                var h = () => {}
                  , l = t * e.noa.world._chunkSize
                  , c = (e, t) => {
                    e.blocks.forEach((e => {
                        e.minPoint.subtractInPlace(t),
                        e.maxPoint.subtractInPlace(t),
                        e._boundingVectors.forEach((e => e.subtractInPlace(t))),
                        e.blocks && c(e, t)
                    }
                    ))
                }
                  , u = (e, t) => {
                    var i = new Di(e[0],e[1],e[2])
                      , s = new Di(e[0] + t,e[1] + t,e[2] + t);
                    return new zn(i,s,void 0,void 0,void 0,h)
                }
            }
        }
        Gi.AddNodeConstructor("TargetCamera", ( (e, t) => () => new Yn(e,Di.Zero(),t)));
        class Yn extends Hi {
            constructor(e, t, i, s=!0) {
                super(e, t, i, s),
                this._tmpUpVector = Di.Zero(),
                this._tmpTargetVector = Di.Zero(),
                this.cameraDirection = new Di(0,0,0),
                this.cameraRotation = new Pi(0,0),
                this.ignoreParentScaling = !1,
                this.updateUpVectorFromRotation = !1,
                this._tmpQuaternion = new Fi,
                this.rotation = new Di(0,0,0),
                this.speed = 2,
                this.noRotationConstraint = !1,
                this.invertRotation = !1,
                this.inverseRotationSpeed = .2,
                this.lockedTarget = null,
                this._currentTarget = Di.Zero(),
                this._initialFocalDistance = 1,
                this._viewMatrix = Oi.Zero(),
                this._camMatrix = Oi.Zero(),
                this._cameraTransformMatrix = Oi.Zero(),
                this._cameraRotationMatrix = Oi.Zero(),
                this._referencePoint = new Di(0,0,1),
                this._transformedReferencePoint = Di.Zero(),
                this._deferredPositionUpdate = new Di,
                this._deferredRotationQuaternionUpdate = new Fi,
                this._deferredRotationUpdate = new Di,
                this._deferredUpdated = !1,
                this._deferOnly = !1,
                this._defaultUp = Di.Up(),
                this._cachedRotationZ = 0,
                this._cachedQuaternionRotationZ = 0
            }
            getFrontPosition(e) {
                this.getWorldMatrix();
                const t = this.getTarget().subtract(this.position);
                return t.normalize(),
                t.scaleInPlace(e),
                this.globalPosition.add(t)
            }
            _getLockedTargetPosition() {
                if (!this.lockedTarget)
                    return null;
                if (this.lockedTarget.absolutePosition) {
                    const e = this.lockedTarget;
                    e.computeWorldMatrix().getTranslationToRef(e.absolutePosition)
                }
                return this.lockedTarget.absolutePosition || this.lockedTarget
            }
            storeState() {
                return this._storedPosition = this.position.clone(),
                this._storedRotation = this.rotation.clone(),
                this.rotationQuaternion && (this._storedRotationQuaternion = this.rotationQuaternion.clone()),
                super.storeState()
            }
            _restoreStateValues() {
                return !!super._restoreStateValues() && (this.position = this._storedPosition.clone(),
                this.rotation = this._storedRotation.clone(),
                this.rotationQuaternion && (this.rotationQuaternion = this._storedRotationQuaternion.clone()),
                this.cameraDirection.copyFromFloats(0, 0, 0),
                this.cameraRotation.copyFromFloats(0, 0),
                !0)
            }
            _initCache() {
                super._initCache(),
                this._cache.lockedTarget = new Di(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),
                this._cache.rotation = new Di(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),
                this._cache.rotationQuaternion = new Fi(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)
            }
            _updateCache(e) {
                e || super._updateCache();
                const t = this._getLockedTargetPosition();
                t ? this._cache.lockedTarget ? this._cache.lockedTarget.copyFrom(t) : this._cache.lockedTarget = t.clone() : this._cache.lockedTarget = null,
                this._cache.rotation.copyFrom(this.rotation),
                this.rotationQuaternion && this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion)
            }
            _isSynchronizedViewMatrix() {
                if (!super._isSynchronizedViewMatrix())
                    return !1;
                const e = this._getLockedTargetPosition();
                return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(e) : !e) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation))
            }
            _computeLocalCameraSpeed() {
                const e = this.getEngine();
                return this.speed * Math.sqrt(e.getDeltaTime() / (100 * e.getFps()))
            }
            setTarget(e) {
                this.upVector.normalize(),
                this._initialFocalDistance = e.subtract(this.position).length(),
                this.position.z === e.z && (this.position.z += Ee),
                this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance),
                Oi.LookAtLHToRef(this.position, e, this._defaultUp, this._camMatrix),
                this._camMatrix.invert(),
                this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);
                const t = e.subtract(this.position);
                t.x >= 0 ? this.rotation.y = -Math.atan(t.z / t.x) + Math.PI / 2 : this.rotation.y = -Math.atan(t.z / t.x) - Math.PI / 2,
                this.rotation.z = 0,
                isNaN(this.rotation.x) && (this.rotation.x = 0),
                isNaN(this.rotation.y) && (this.rotation.y = 0),
                isNaN(this.rotation.z) && (this.rotation.z = 0),
                this.rotationQuaternion && Fi.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion)
            }
            get target() {
                return this.getTarget()
            }
            set target(e) {
                this.setTarget(e)
            }
            getTarget() {
                return this._currentTarget
            }
            _decideIfNeedsToMove() {
                return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0
            }
            _updatePosition() {
                if (this.parent)
                    return this.parent.getWorldMatrix().invertToRef(Bi.Matrix[0]),
                    Di.TransformNormalToRef(this.cameraDirection, Bi.Matrix[0], Bi.Vector3[0]),
                    this._deferredPositionUpdate.addInPlace(Bi.Vector3[0]),
                    void (this._deferOnly ? this._deferredUpdated = !0 : this.position.copyFrom(this._deferredPositionUpdate));
                this._deferredPositionUpdate.addInPlace(this.cameraDirection),
                this._deferOnly ? this._deferredUpdated = !0 : this.position.copyFrom(this._deferredPositionUpdate)
            }
            _checkInputs() {
                const e = this.invertRotation ? -this.inverseRotationSpeed : 1
                  , t = this._decideIfNeedsToMove()
                  , i = this.cameraRotation.x || this.cameraRotation.y;
                if (this._deferredUpdated = !1,
                this._deferredRotationUpdate.copyFrom(this.rotation),
                this._deferredPositionUpdate.copyFrom(this.position),
                this.rotationQuaternion && this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion),
                t && this._updatePosition(),
                i) {
                    if (this.rotationQuaternion && this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate),
                    this._deferredRotationUpdate.x += this.cameraRotation.x * e,
                    this._deferredRotationUpdate.y += this.cameraRotation.y * e,
                    !this.noRotationConstraint) {
                        const e = 1.570796;
                        this._deferredRotationUpdate.x > e && (this._deferredRotationUpdate.x = e),
                        this._deferredRotationUpdate.x < -e && (this._deferredRotationUpdate.x = -e)
                    }
                    this._deferOnly ? this._deferredUpdated = !0 : this.rotation.copyFrom(this._deferredRotationUpdate),
                    this.rotationQuaternion && this._deferredRotationUpdate.lengthSquared() && (Fi.RotationYawPitchRollToRef(this._deferredRotationUpdate.y, this._deferredRotationUpdate.x, this._deferredRotationUpdate.z, this._deferredRotationQuaternionUpdate),
                    this._deferOnly ? this._deferredUpdated = !0 : this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate))
                }
                t && (Math.abs(this.cameraDirection.x) < this.speed * Ee && (this.cameraDirection.x = 0),
                Math.abs(this.cameraDirection.y) < this.speed * Ee && (this.cameraDirection.y = 0),
                Math.abs(this.cameraDirection.z) < this.speed * Ee && (this.cameraDirection.z = 0),
                this.cameraDirection.scaleInPlace(this.inertia)),
                i && (Math.abs(this.cameraRotation.x) < this.speed * Ee && (this.cameraRotation.x = 0),
                Math.abs(this.cameraRotation.y) < this.speed * Ee && (this.cameraRotation.y = 0),
                this.cameraRotation.scaleInPlace(this.inertia)),
                super._checkInputs()
            }
            _updateCameraRotationMatrix() {
                this.rotationQuaternion ? this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix) : Oi.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix)
            }
            _rotateUpVectorWithCameraRotationMatrix() {
                return Di.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector),
                this
            }
            _getViewMatrix() {
                return this.lockedTarget && this.setTarget(this._getLockedTargetPosition()),
                this._updateCameraRotationMatrix(),
                this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z ? (this._rotateUpVectorWithCameraRotationMatrix(),
                this._cachedQuaternionRotationZ = this.rotationQuaternion.z) : this._cachedRotationZ !== this.rotation.z && (this._rotateUpVectorWithCameraRotationMatrix(),
                this._cachedRotationZ = this.rotation.z),
                Di.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint),
                this.position.addToRef(this._transformedReferencePoint, this._currentTarget),
                this.updateUpVectorFromRotation && (this.rotationQuaternion ? or.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector) : (Fi.FromEulerVectorToRef(this.rotation, this._tmpQuaternion),
                or.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector))),
                this._computeViewMatrix(this.position, this._currentTarget, this.upVector),
                this._viewMatrix
            }
            _computeViewMatrix(e, t, i) {
                if (this.ignoreParentScaling) {
                    if (this.parent) {
                        const s = this.parent.getWorldMatrix();
                        Di.TransformCoordinatesToRef(e, s, this._globalPosition),
                        Di.TransformCoordinatesToRef(t, s, this._tmpTargetVector),
                        Di.TransformNormalToRef(i, s, this._tmpUpVector),
                        this._markSyncedWithParent()
                    } else
                        this._globalPosition.copyFrom(e),
                        this._tmpTargetVector.copyFrom(t),
                        this._tmpUpVector.copyFrom(i);
                    this.getScene().useRightHandedSystem ? Oi.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix) : Oi.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix)
                } else if (this.getScene().useRightHandedSystem ? Oi.LookAtRHToRef(e, t, i, this._viewMatrix) : Oi.LookAtLHToRef(e, t, i, this._viewMatrix),
                this.parent) {
                    const e = this.parent.getWorldMatrix();
                    this._viewMatrix.invert(),
                    this._viewMatrix.multiplyToRef(e, this._viewMatrix),
                    this._viewMatrix.getTranslationToRef(this._globalPosition),
                    this._viewMatrix.invert(),
                    this._markSyncedWithParent()
                } else
                    this._globalPosition.copyFrom(e)
            }
            createRigCamera(e, t) {
                if (this.cameraRigMode !== Hi.RIG_MODE_NONE) {
                    const t = new Yn(e,this.position.clone(),this.getScene());
                    return t.isRigCamera = !0,
                    t.rigParent = this,
                    this.cameraRigMode === Hi.RIG_MODE_VR && (this.rotationQuaternion || (this.rotationQuaternion = new Fi),
                    t._cameraRigParams = {},
                    t.rotationQuaternion = new Fi),
                    t.mode = this.mode,
                    t.orthoLeft = this.orthoLeft,
                    t.orthoRight = this.orthoRight,
                    t.orthoTop = this.orthoTop,
                    t.orthoBottom = this.orthoBottom,
                    t
                }
                return null
            }
            _updateRigCameras() {
                const e = this._rigCameras[0]
                  , t = this._rigCameras[1];
                switch (this.computeWorldMatrix(),
                this.cameraRigMode) {
                case Hi.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
                case Hi.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
                case Hi.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
                case Hi.RIG_MODE_STEREOSCOPIC_OVERUNDER:
                case Hi.RIG_MODE_STEREOSCOPIC_INTERLACED:
                    {
                        const i = this.cameraRigMode === Hi.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1
                          , s = this.cameraRigMode === Hi.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
                        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * i, e),
                        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * s, t);
                        break
                    }
                case Hi.RIG_MODE_VR:
                    e.rotationQuaternion ? (e.rotationQuaternion.copyFrom(this.rotationQuaternion),
                    t.rotationQuaternion.copyFrom(this.rotationQuaternion)) : (e.rotation.copyFrom(this.rotation),
                    t.rotation.copyFrom(this.rotation)),
                    e.position.copyFrom(this.position),
                    t.position.copyFrom(this.position)
                }
                super._updateRigCameras()
            }
            _getRigCamPositionAndTarget(e, t) {
                this.getTarget().subtractToRef(this.position, Yn._TargetFocalPoint),
                Yn._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
                const i = Yn._TargetFocalPoint.addInPlace(this.position);
                Oi.TranslationToRef(-i.x, -i.y, -i.z, Yn._TargetTransformMatrix),
                Yn._TargetTransformMatrix.multiplyToRef(Oi.RotationAxis(t.upVector, e), Yn._RigCamTransformMatrix),
                Oi.TranslationToRef(i.x, i.y, i.z, Yn._TargetTransformMatrix),
                Yn._RigCamTransformMatrix.multiplyToRef(Yn._TargetTransformMatrix, Yn._RigCamTransformMatrix),
                Di.TransformCoordinatesToRef(this.position, Yn._RigCamTransformMatrix, t.position),
                t.setTarget(i)
            }
            getClassName() {
                return "TargetCamera"
            }
        }
        Yn._RigCamTransformMatrix = new Oi,
        Yn._TargetTransformMatrix = new Oi,
        Yn._TargetFocalPoint = new Di,
        pi([Si()], Yn.prototype, "rotation", void 0),
        pi([xi()], Yn.prototype, "speed", void 0),
        pi([yi(6, "lockedTargetId")], Yn.prototype, "lockedTarget", void 0);
        var jn, qn = {};
        class Zn {
            constructor(e) {
                this.attachedToElement = !1,
                this.attached = {},
                this.camera = e,
                this.checkInputs = () => {}
            }
            add(e) {
                const t = e.getSimpleName();
                this.attached[t] ? We.Warn("camera input of type " + t + " already exists on camera") : (this.attached[t] = e,
                e.camera = this.camera,
                e.checkInputs && (this.checkInputs = this._addCheckInputs(e.checkInputs.bind(e))),
                this.attachedToElement && e.attachControl(this.noPreventDefault))
            }
            remove(e) {
                for (const t in this.attached) {
                    const i = this.attached[t];
                    if (i === e)
                        return i.detachControl(),
                        i.camera = null,
                        delete this.attached[t],
                        void this.rebuildInputCheck()
                }
            }
            removeByType(e) {
                for (const t in this.attached) {
                    const i = this.attached[t];
                    i.getClassName() === e && (i.detachControl(),
                    i.camera = null,
                    delete this.attached[t],
                    this.rebuildInputCheck())
                }
            }
            _addCheckInputs(e) {
                const t = this.checkInputs;
                return () => {
                    t(),
                    e()
                }
            }
            attachInput(e) {
                this.attachedToElement && e.attachControl(this.noPreventDefault)
            }
            attachElement(e=!1) {
                if (!this.attachedToElement) {
                    e = !Hi.ForceAttachControlToAlwaysPreventDefault && e,
                    this.attachedToElement = !0,
                    this.noPreventDefault = e;
                    for (const t in this.attached)
                        this.attached[t].attachControl(e)
                }
            }
            detachElement(e=!1) {
                for (const t in this.attached)
                    this.attached[t].detachControl(),
                    e && (this.attached[t].camera = null);
                this.attachedToElement = !1
            }
            rebuildInputCheck() {
                this.checkInputs = () => {}
                ;
                for (const e in this.attached) {
                    const t = this.attached[e];
                    t.checkInputs && (this.checkInputs = this._addCheckInputs(t.checkInputs.bind(t)))
                }
            }
            clear() {
                this.attachedToElement && this.detachElement(!0),
                this.attached = {},
                this.attachedToElement = !1,
                this.checkInputs = () => {}
            }
            serialize(e) {
                const t = {};
                for (const e in this.attached) {
                    const i = this.attached[e]
                      , s = ki.Serialize(i);
                    t[i.getClassName()] = s
                }
                e.inputsmgr = t
            }
            parse(e) {
                const t = e.inputsmgr;
                if (t) {
                    this.clear();
                    for (const e in t) {
                        const i = qn[e];
                        if (i) {
                            const s = t[e]
                              , r = ki.Parse(( () => new i), s, null);
                            this.add(r)
                        }
                    }
                } else
                    for (const t in this.attached) {
                        const i = qn[this.attached[t].getClassName()];
                        if (i) {
                            const s = ki.Parse(( () => new i), e, null);
                            this.remove(this.attached[t]),
                            this.add(s)
                        }
                    }
            }
        }
        class Qn {
            constructor() {
                this.keysUp = [38],
                this.keysUpward = [33],
                this.keysDown = [40],
                this.keysDownward = [34],
                this.keysLeft = [37],
                this.keysRight = [39],
                this.rotationSpeed = .5,
                this.keysRotateLeft = [],
                this.keysRotateRight = [],
                this.keysRotateUp = [],
                this.keysRotateDown = [],
                this._keys = new Array
            }
            attachControl(e) {
                e = hi.BackCompatCameraNoPreventDefault(arguments),
                this._onCanvasBlurObserver || (this._scene = this.camera.getScene(),
                this._engine = this._scene.getEngine(),
                this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(( () => {
                    this._keys.length = 0
                }
                )),
                this._onKeyboardObserver = this._scene.onKeyboardObservable.add((t => {
                    const i = t.event;
                    if (!i.metaKey)
                        if (t.type === xs.KEYDOWN)
                            -1 === this.keysUp.indexOf(i.keyCode) && -1 === this.keysDown.indexOf(i.keyCode) && -1 === this.keysLeft.indexOf(i.keyCode) && -1 === this.keysRight.indexOf(i.keyCode) && -1 === this.keysUpward.indexOf(i.keyCode) && -1 === this.keysDownward.indexOf(i.keyCode) && -1 === this.keysRotateLeft.indexOf(i.keyCode) && -1 === this.keysRotateRight.indexOf(i.keyCode) && -1 === this.keysRotateUp.indexOf(i.keyCode) && -1 === this.keysRotateDown.indexOf(i.keyCode) || (-1 === this._keys.indexOf(i.keyCode) && this._keys.push(i.keyCode),
                            e || i.preventDefault());
                        else if (-1 !== this.keysUp.indexOf(i.keyCode) || -1 !== this.keysDown.indexOf(i.keyCode) || -1 !== this.keysLeft.indexOf(i.keyCode) || -1 !== this.keysRight.indexOf(i.keyCode) || -1 !== this.keysUpward.indexOf(i.keyCode) || -1 !== this.keysDownward.indexOf(i.keyCode) || -1 !== this.keysRotateLeft.indexOf(i.keyCode) || -1 !== this.keysRotateRight.indexOf(i.keyCode) || -1 !== this.keysRotateUp.indexOf(i.keyCode) || -1 !== this.keysRotateDown.indexOf(i.keyCode)) {
                            const t = this._keys.indexOf(i.keyCode);
                            t >= 0 && this._keys.splice(t, 1),
                            e || i.preventDefault()
                        }
                }
                )))
            }
            detachControl() {
                this._scene && (this._onKeyboardObserver && this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),
                this._onCanvasBlurObserver && this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),
                this._onKeyboardObserver = null,
                this._onCanvasBlurObserver = null),
                this._keys.length = 0
            }
            checkInputs() {
                if (this._onKeyboardObserver) {
                    const e = this.camera;
                    for (let t = 0; t < this._keys.length; t++) {
                        const i = this._keys[t]
                          , s = e._computeLocalCameraSpeed();
                        -1 !== this.keysLeft.indexOf(i) ? e._localDirection.copyFromFloats(-s, 0, 0) : -1 !== this.keysUp.indexOf(i) ? e._localDirection.copyFromFloats(0, 0, s) : -1 !== this.keysRight.indexOf(i) ? e._localDirection.copyFromFloats(s, 0, 0) : -1 !== this.keysDown.indexOf(i) ? e._localDirection.copyFromFloats(0, 0, -s) : -1 !== this.keysUpward.indexOf(i) ? e._localDirection.copyFromFloats(0, s, 0) : -1 !== this.keysDownward.indexOf(i) ? e._localDirection.copyFromFloats(0, -s, 0) : -1 !== this.keysRotateLeft.indexOf(i) ? (e._localDirection.copyFromFloats(0, 0, 0),
                        e.cameraRotation.y -= this._getLocalRotation()) : -1 !== this.keysRotateRight.indexOf(i) ? (e._localDirection.copyFromFloats(0, 0, 0),
                        e.cameraRotation.y += this._getLocalRotation()) : -1 !== this.keysRotateUp.indexOf(i) ? (e._localDirection.copyFromFloats(0, 0, 0),
                        e.cameraRotation.x -= this._getLocalRotation()) : -1 !== this.keysRotateDown.indexOf(i) && (e._localDirection.copyFromFloats(0, 0, 0),
                        e.cameraRotation.x += this._getLocalRotation()),
                        e.getScene().useRightHandedSystem && (e._localDirection.z *= -1),
                        e.getViewMatrix().invertToRef(e._cameraTransformMatrix),
                        Di.TransformNormalToRef(e._localDirection, e._cameraTransformMatrix, e._transformedDirection),
                        e.cameraDirection.addInPlace(e._transformedDirection)
                    }
                }
            }
            getClassName() {
                return "FreeCameraKeyboardMoveInput"
            }
            _onLostFocus() {
                this._keys.length = 0
            }
            getSimpleName() {
                return "keyboard"
            }
            _getLocalRotation() {
                const e = this.camera._calculateHandednessMultiplier();
                return this.rotationSpeed * this._engine.getDeltaTime() / 1e3 * e
            }
        }
        pi([xi()], Qn.prototype, "keysUp", void 0),
        pi([xi()], Qn.prototype, "keysUpward", void 0),
        pi([xi()], Qn.prototype, "keysDown", void 0),
        pi([xi()], Qn.prototype, "keysDownward", void 0),
        pi([xi()], Qn.prototype, "keysLeft", void 0),
        pi([xi()], Qn.prototype, "keysRight", void 0),
        pi([xi()], Qn.prototype, "rotationSpeed", void 0),
        pi([xi()], Qn.prototype, "keysRotateLeft", void 0),
        pi([xi()], Qn.prototype, "keysRotateRight", void 0),
        pi([xi()], Qn.prototype, "keysRotateUp", void 0),
        pi([xi()], Qn.prototype, "keysRotateDown", void 0),
        qn.FreeCameraKeyboardMoveInput = Qn;
        class $n {
            constructor(e=!0) {
                this.touchEnabled = e,
                this.buttons = [0, 1, 2],
                this.angularSensibility = 2e3,
                this._previousPosition = null,
                this.onPointerMovedObservable = new Ue,
                this._allowCameraRotation = !0,
                this._currentActiveButton = -1,
                this._activePointerId = -1
            }
            attachControl(e) {
                e = hi.BackCompatCameraNoPreventDefault(arguments);
                const t = this.camera.getEngine()
                  , i = t.getInputElement();
                this._pointerInput || (this._pointerInput = s => {
                    const r = s.event
                      , n = "touch" === r.pointerType;
                    if (!this.touchEnabled && n)
                        return;
                    if (s.type !== ms.POINTERMOVE && -1 === this.buttons.indexOf(r.button))
                        return;
                    const a = r.target;
                    if (s.type === ms.POINTERDOWN) {
                        if (n && -1 !== this._activePointerId || !n && -1 !== this._currentActiveButton)
                            return;
                        this._activePointerId = r.pointerId;
                        try {
                            a?.setPointerCapture(r.pointerId)
                        } catch (e) {}
                        -1 === this._currentActiveButton && (this._currentActiveButton = r.button),
                        this._previousPosition = {
                            x: r.clientX,
                            y: r.clientY
                        },
                        e || (r.preventDefault(),
                        i && i.focus()),
                        t.isPointerLock && this._onMouseMove && this._onMouseMove(s.event)
                    } else if (s.type === ms.POINTERUP) {
                        if (n && this._activePointerId !== r.pointerId || !n && this._currentActiveButton !== r.button)
                            return;
                        try {
                            a?.releasePointerCapture(r.pointerId)
                        } catch (e) {}
                        this._currentActiveButton = -1,
                        this._previousPosition = null,
                        e || r.preventDefault(),
                        this._activePointerId = -1
                    } else if (s.type === ms.POINTERMOVE && (this._activePointerId === r.pointerId || !n))
                        if (t.isPointerLock && this._onMouseMove)
                            this._onMouseMove(s.event);
                        else if (this._previousPosition) {
                            const t = this.camera._calculateHandednessMultiplier()
                              , i = (r.clientX - this._previousPosition.x) * t
                              , s = r.clientY - this._previousPosition.y;
                            this._allowCameraRotation && (this.camera.cameraRotation.y += i / this.angularSensibility,
                            this.camera.cameraRotation.x += s / this.angularSensibility),
                            this.onPointerMovedObservable.notifyObservers({
                                offsetX: i,
                                offsetY: s
                            }),
                            this._previousPosition = {
                                x: r.clientX,
                                y: r.clientY
                            },
                            e || r.preventDefault()
                        }
                }
                ),
                this._onMouseMove = i => {
                    if (!t.isPointerLock)
                        return;
                    const s = this.camera._calculateHandednessMultiplier()
                      , r = i.movementX * s;
                    this.camera.cameraRotation.y += r / this.angularSensibility;
                    const n = i.movementY;
                    this.camera.cameraRotation.x += n / this.angularSensibility,
                    this._previousPosition = null,
                    e || i.preventDefault()
                }
                ,
                this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, ms.POINTERDOWN | ms.POINTERUP | ms.POINTERMOVE),
                i && (this._contextMenuBind = e => this.onContextMenu(e),
                i.addEventListener("contextmenu", this._contextMenuBind, !1))
            }
            onContextMenu(e) {
                e.preventDefault()
            }
            detachControl() {
                if (this._observer) {
                    if (this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),
                    this._contextMenuBind) {
                        const e = this.camera.getEngine().getInputElement();
                        e && e.removeEventListener("contextmenu", this._contextMenuBind)
                    }
                    this.onPointerMovedObservable && this.onPointerMovedObservable.clear(),
                    this._observer = null,
                    this._onMouseMove = null,
                    this._previousPosition = null
                }
                this._activePointerId = -1,
                this._currentActiveButton = -1
            }
            getClassName() {
                return "FreeCameraMouseInput"
            }
            getSimpleName() {
                return "mouse"
            }
        }
        pi([xi()], $n.prototype, "buttons", void 0),
        pi([xi()], $n.prototype, "angularSensibility", void 0),
        qn.FreeCameraMouseInput = $n;
        class Jn {
            constructor() {
                this.wheelPrecisionX = 3,
                this.wheelPrecisionY = 3,
                this.wheelPrecisionZ = 3,
                this.onChangedObservable = new Ue,
                this._wheelDeltaX = 0,
                this._wheelDeltaY = 0,
                this._wheelDeltaZ = 0,
                this._ffMultiplier = 12,
                this._normalize = 120
            }
            attachControl(e) {
                e = hi.BackCompatCameraNoPreventDefault(arguments),
                this._wheel = t => {
                    if (t.type !== ms.POINTERWHEEL)
                        return;
                    const i = t.event
                      , s = i.deltaMode === Ms.DOM_DELTA_LINE ? this._ffMultiplier : 1;
                    this._wheelDeltaX += this.wheelPrecisionX * s * i.deltaX / this._normalize,
                    this._wheelDeltaY -= this.wheelPrecisionY * s * i.deltaY / this._normalize,
                    this._wheelDeltaZ += this.wheelPrecisionZ * s * i.deltaZ / this._normalize,
                    i.preventDefault && (e || i.preventDefault())
                }
                ,
                this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, ms.POINTERWHEEL)
            }
            detachControl() {
                this._observer && (this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),
                this._observer = null,
                this._wheel = null),
                this.onChangedObservable && this.onChangedObservable.clear()
            }
            checkInputs() {
                this.onChangedObservable.notifyObservers({
                    wheelDeltaX: this._wheelDeltaX,
                    wheelDeltaY: this._wheelDeltaY,
                    wheelDeltaZ: this._wheelDeltaZ
                }),
                this._wheelDeltaX = 0,
                this._wheelDeltaY = 0,
                this._wheelDeltaZ = 0
            }
            getClassName() {
                return "BaseCameraMouseWheelInput"
            }
            getSimpleName() {
                return "mousewheel"
            }
        }
        pi([xi()], Jn.prototype, "wheelPrecisionX", void 0),
        pi([xi()], Jn.prototype, "wheelPrecisionY", void 0),
        pi([xi()], Jn.prototype, "wheelPrecisionZ", void 0),
        function(e) {
            e[e.MoveRelative = 0] = "MoveRelative",
            e[e.RotateRelative = 1] = "RotateRelative",
            e[e.MoveScene = 2] = "MoveScene"
        }(jn || (jn = {}));
        class ea extends Jn {
            constructor() {
                super(...arguments),
                this._moveRelative = Di.Zero(),
                this._rotateRelative = Di.Zero(),
                this._moveScene = Di.Zero(),
                this._wheelXAction = jn.MoveRelative,
                this._wheelXActionCoordinate = ar.X,
                this._wheelYAction = jn.MoveRelative,
                this._wheelYActionCoordinate = ar.Z,
                this._wheelZAction = null,
                this._wheelZActionCoordinate = null
            }
            getClassName() {
                return "FreeCameraMouseWheelInput"
            }
            set wheelXMoveRelative(e) {
                null === e && this._wheelXAction !== jn.MoveRelative || (this._wheelXAction = jn.MoveRelative,
                this._wheelXActionCoordinate = e)
            }
            get wheelXMoveRelative() {
                return this._wheelXAction !== jn.MoveRelative ? null : this._wheelXActionCoordinate
            }
            set wheelYMoveRelative(e) {
                null === e && this._wheelYAction !== jn.MoveRelative || (this._wheelYAction = jn.MoveRelative,
                this._wheelYActionCoordinate = e)
            }
            get wheelYMoveRelative() {
                return this._wheelYAction !== jn.MoveRelative ? null : this._wheelYActionCoordinate
            }
            set wheelZMoveRelative(e) {
                null === e && this._wheelZAction !== jn.MoveRelative || (this._wheelZAction = jn.MoveRelative,
                this._wheelZActionCoordinate = e)
            }
            get wheelZMoveRelative() {
                return this._wheelZAction !== jn.MoveRelative ? null : this._wheelZActionCoordinate
            }
            set wheelXRotateRelative(e) {
                null === e && this._wheelXAction !== jn.RotateRelative || (this._wheelXAction = jn.RotateRelative,
                this._wheelXActionCoordinate = e)
            }
            get wheelXRotateRelative() {
                return this._wheelXAction !== jn.RotateRelative ? null : this._wheelXActionCoordinate
            }
            set wheelYRotateRelative(e) {
                null === e && this._wheelYAction !== jn.RotateRelative || (this._wheelYAction = jn.RotateRelative,
                this._wheelYActionCoordinate = e)
            }
            get wheelYRotateRelative() {
                return this._wheelYAction !== jn.RotateRelative ? null : this._wheelYActionCoordinate
            }
            set wheelZRotateRelative(e) {
                null === e && this._wheelZAction !== jn.RotateRelative || (this._wheelZAction = jn.RotateRelative,
                this._wheelZActionCoordinate = e)
            }
            get wheelZRotateRelative() {
                return this._wheelZAction !== jn.RotateRelative ? null : this._wheelZActionCoordinate
            }
            set wheelXMoveScene(e) {
                null === e && this._wheelXAction !== jn.MoveScene || (this._wheelXAction = jn.MoveScene,
                this._wheelXActionCoordinate = e)
            }
            get wheelXMoveScene() {
                return this._wheelXAction !== jn.MoveScene ? null : this._wheelXActionCoordinate
            }
            set wheelYMoveScene(e) {
                null === e && this._wheelYAction !== jn.MoveScene || (this._wheelYAction = jn.MoveScene,
                this._wheelYActionCoordinate = e)
            }
            get wheelYMoveScene() {
                return this._wheelYAction !== jn.MoveScene ? null : this._wheelYActionCoordinate
            }
            set wheelZMoveScene(e) {
                null === e && this._wheelZAction !== jn.MoveScene || (this._wheelZAction = jn.MoveScene,
                this._wheelZActionCoordinate = e)
            }
            get wheelZMoveScene() {
                return this._wheelZAction !== jn.MoveScene ? null : this._wheelZActionCoordinate
            }
            checkInputs() {
                if (0 === this._wheelDeltaX && 0 === this._wheelDeltaY && 0 == this._wheelDeltaZ)
                    return;
                this._moveRelative.setAll(0),
                this._rotateRelative.setAll(0),
                this._moveScene.setAll(0),
                this._updateCamera(),
                this.camera.getScene().useRightHandedSystem && (this._moveRelative.z *= -1);
                const e = Oi.Zero();
                this.camera.getViewMatrix().invertToRef(e);
                const t = Di.Zero();
                Di.TransformNormalToRef(this._moveRelative, e, t),
                this.camera.cameraRotation.x += this._rotateRelative.x / 200,
                this.camera.cameraRotation.y += this._rotateRelative.y / 200,
                this.camera.cameraDirection.addInPlace(t),
                this.camera.cameraDirection.addInPlace(this._moveScene),
                super.checkInputs()
            }
            _updateCamera() {
                this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate),
                this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate),
                this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate)
            }
            _updateCameraProperty(e, t, i) {
                if (0 === e)
                    return;
                if (null === t || null === i)
                    return;
                let s = null;
                switch (t) {
                case jn.MoveRelative:
                    s = this._moveRelative;
                    break;
                case jn.RotateRelative:
                    s = this._rotateRelative;
                    break;
                case jn.MoveScene:
                    s = this._moveScene
                }
                switch (i) {
                case ar.X:
                    s.set(e, 0, 0);
                    break;
                case ar.Y:
                    s.set(0, e, 0);
                    break;
                case ar.Z:
                    s.set(0, 0, e)
                }
            }
        }
        pi([xi()], ea.prototype, "wheelXMoveRelative", null),
        pi([xi()], ea.prototype, "wheelYMoveRelative", null),
        pi([xi()], ea.prototype, "wheelZMoveRelative", null),
        pi([xi()], ea.prototype, "wheelXRotateRelative", null),
        pi([xi()], ea.prototype, "wheelYRotateRelative", null),
        pi([xi()], ea.prototype, "wheelZRotateRelative", null),
        pi([xi()], ea.prototype, "wheelXMoveScene", null),
        pi([xi()], ea.prototype, "wheelYMoveScene", null),
        pi([xi()], ea.prototype, "wheelZMoveScene", null),
        qn.FreeCameraMouseWheelInput = ea;
        class ta {
            constructor(e=!1) {
                this.allowMouse = e,
                this.touchAngularSensibility = 2e5,
                this.touchMoveSensibility = 250,
                this.singleFingerRotate = !1,
                this._offsetX = null,
                this._offsetY = null,
                this._pointerPressed = new Array,
                this._isSafari = hi.IsSafari()
            }
            attachControl(e) {
                e = hi.BackCompatCameraNoPreventDefault(arguments);
                let t = null;
                if (void 0 === this._pointerInput && (this._onLostFocus = () => {
                    this._offsetX = null,
                    this._offsetY = null
                }
                ,
                this._pointerInput = i => {
                    const s = i.event
                      , r = "mouse" === s.pointerType || this._isSafari && void 0 === s.pointerType;
                    if (this.allowMouse || !r)
                        if (i.type === ms.POINTERDOWN) {
                            if (e || s.preventDefault(),
                            this._pointerPressed.push(s.pointerId),
                            1 !== this._pointerPressed.length)
                                return;
                            t = {
                                x: s.clientX,
                                y: s.clientY
                            }
                        } else if (i.type === ms.POINTERUP) {
                            e || s.preventDefault();
                            const i = this._pointerPressed.indexOf(s.pointerId);
                            if (-1 === i)
                                return;
                            if (this._pointerPressed.splice(i, 1),
                            0 != i)
                                return;
                            t = null,
                            this._offsetX = null,
                            this._offsetY = null
                        } else if (i.type === ms.POINTERMOVE) {
                            if (e || s.preventDefault(),
                            !t)
                                return;
                            if (0 != this._pointerPressed.indexOf(s.pointerId))
                                return;
                            this._offsetX = s.clientX - t.x,
                            this._offsetY = -(s.clientY - t.y)
                        }
                }
                ),
                this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, ms.POINTERDOWN | ms.POINTERUP | ms.POINTERMOVE),
                this._onLostFocus) {
                    const e = this.camera.getEngine().getInputElement();
                    e && e.addEventListener("blur", this._onLostFocus)
                }
            }
            detachControl() {
                if (this._pointerInput) {
                    if (this._observer && (this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),
                    this._observer = null),
                    this._onLostFocus) {
                        const e = this.camera.getEngine().getInputElement();
                        e && e.removeEventListener("blur", this._onLostFocus),
                        this._onLostFocus = null
                    }
                    this._pointerPressed.length = 0,
                    this._offsetX = null,
                    this._offsetY = null
                }
            }
            checkInputs() {
                if (null === this._offsetX || null === this._offsetY)
                    return;
                if (0 === this._offsetX && 0 === this._offsetY)
                    return;
                const e = this.camera
                  , t = e._calculateHandednessMultiplier();
                if (e.cameraRotation.y = t * this._offsetX / this.touchAngularSensibility,
                this.singleFingerRotate && 1 === this._pointerPressed.length || !this.singleFingerRotate && this._pointerPressed.length > 1)
                    e.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;
                else {
                    const t = e._computeLocalCameraSpeed()
                      , i = new Di(0,0,0 !== this.touchMoveSensibility ? t * this._offsetY / this.touchMoveSensibility : 0);
                    Oi.RotationYawPitchRollToRef(e.rotation.y, e.rotation.x, 0, e._cameraRotationMatrix),
                    e.cameraDirection.addInPlace(Di.TransformCoordinates(i, e._cameraRotationMatrix))
                }
            }
            getClassName() {
                return "FreeCameraTouchInput"
            }
            getSimpleName() {
                return "touch"
            }
        }
        pi([xi()], ta.prototype, "touchAngularSensibility", void 0),
        pi([xi()], ta.prototype, "touchMoveSensibility", void 0),
        qn.FreeCameraTouchInput = ta;
        class ia extends Zn {
            constructor(e) {
                super(e),
                this._mouseInput = null,
                this._mouseWheelInput = null
            }
            addKeyboard() {
                return this.add(new Qn),
                this
            }
            addMouse(e=!0) {
                return this._mouseInput || (this._mouseInput = new $n(e),
                this.add(this._mouseInput)),
                this
            }
            removeMouse() {
                return this._mouseInput && this.remove(this._mouseInput),
                this
            }
            addMouseWheel() {
                return this._mouseWheelInput || (this._mouseWheelInput = new ea,
                this.add(this._mouseWheelInput)),
                this
            }
            removeMouseWheel() {
                return this._mouseWheelInput && this.remove(this._mouseWheelInput),
                this
            }
            addTouch() {
                return this.add(new ta),
                this
            }
            clear() {
                super.clear(),
                this._mouseInput = null
            }
        }
        class sa extends Yn {
            get angularSensibility() {
                const e = this.inputs.attached.mouse;
                return e ? e.angularSensibility : 0
            }
            set angularSensibility(e) {
                const t = this.inputs.attached.mouse;
                t && (t.angularSensibility = e)
            }
            get keysUp() {
                const e = this.inputs.attached.keyboard;
                return e ? e.keysUp : []
            }
            set keysUp(e) {
                const t = this.inputs.attached.keyboard;
                t && (t.keysUp = e)
            }
            get keysUpward() {
                const e = this.inputs.attached.keyboard;
                return e ? e.keysUpward : []
            }
            set keysUpward(e) {
                const t = this.inputs.attached.keyboard;
                t && (t.keysUpward = e)
            }
            get keysDown() {
                const e = this.inputs.attached.keyboard;
                return e ? e.keysDown : []
            }
            set keysDown(e) {
                const t = this.inputs.attached.keyboard;
                t && (t.keysDown = e)
            }
            get keysDownward() {
                const e = this.inputs.attached.keyboard;
                return e ? e.keysDownward : []
            }
            set keysDownward(e) {
                const t = this.inputs.attached.keyboard;
                t && (t.keysDownward = e)
            }
            get keysLeft() {
                const e = this.inputs.attached.keyboard;
                return e ? e.keysLeft : []
            }
            set keysLeft(e) {
                const t = this.inputs.attached.keyboard;
                t && (t.keysLeft = e)
            }
            get keysRight() {
                const e = this.inputs.attached.keyboard;
                return e ? e.keysRight : []
            }
            set keysRight(e) {
                const t = this.inputs.attached.keyboard;
                t && (t.keysRight = e)
            }
            get keysRotateLeft() {
                const e = this.inputs.attached.keyboard;
                return e ? e.keysRotateLeft : []
            }
            set keysRotateLeft(e) {
                const t = this.inputs.attached.keyboard;
                t && (t.keysRotateLeft = e)
            }
            get keysRotateRight() {
                const e = this.inputs.attached.keyboard;
                return e ? e.keysRotateRight : []
            }
            set keysRotateRight(e) {
                const t = this.inputs.attached.keyboard;
                t && (t.keysRotateRight = e)
            }
            get keysRotateUp() {
                const e = this.inputs.attached.keyboard;
                return e ? e.keysRotateUp : []
            }
            set keysRotateUp(e) {
                const t = this.inputs.attached.keyboard;
                t && (t.keysRotateUp = e)
            }
            get keysRotateDown() {
                const e = this.inputs.attached.keyboard;
                return e ? e.keysRotateDown : []
            }
            set keysRotateDown(e) {
                const t = this.inputs.attached.keyboard;
                t && (t.keysRotateDown = e)
            }
            constructor(e, t, i, s=!0) {
                super(e, t, i, s),
                this.ellipsoid = new Di(.5,1,.5),
                this.ellipsoidOffset = new Di(0,0,0),
                this.checkCollisions = !1,
                this.applyGravity = !1,
                this._needMoveForGravity = !1,
                this._oldPosition = Di.Zero(),
                this._diffPosition = Di.Zero(),
                this._newPosition = Di.Zero(),
                this._collisionMask = -1,
                this._onCollisionPositionChange = (e, t, i=null) => {
                    this._newPosition.copyFrom(t),
                    this._newPosition.subtractToRef(this._oldPosition, this._diffPosition),
                    this._diffPosition.length() > rr.CollisionsEpsilon && (this.position.addToRef(this._diffPosition, this._deferredPositionUpdate),
                    this._deferOnly ? this._deferredUpdated = !0 : this.position.copyFrom(this._deferredPositionUpdate),
                    this.onCollide && i && this.onCollide(i))
                }
                ,
                this.inputs = new ia(this),
                this.inputs.addKeyboard().addMouse()
            }
            attachControl(e, t) {
                t = hi.BackCompatCameraNoPreventDefault(arguments),
                this.inputs.attachElement(t)
            }
            detachControl() {
                this.inputs.detachElement(),
                this.cameraDirection = new Di(0,0,0),
                this.cameraRotation = new Pi(0,0)
            }
            get collisionMask() {
                return this._collisionMask
            }
            set collisionMask(e) {
                this._collisionMask = isNaN(e) ? -1 : e
            }
            _collideWithWorld(e) {
                let t;
                t = this.parent ? Di.TransformCoordinates(this.position, this.parent.getWorldMatrix()) : this.position,
                t.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition),
                this._oldPosition.addInPlace(this.ellipsoidOffset);
                const i = this.getScene().collisionCoordinator;
                this._collider || (this._collider = i.createCollider()),
                this._collider._radius = this.ellipsoid,
                this._collider.collisionMask = this._collisionMask;
                let s = e;
                this.applyGravity && (s = e.add(this.getScene().gravity)),
                i.getNewPosition(this._oldPosition, s, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId)
            }
            _checkInputs() {
                this._localDirection || (this._localDirection = Di.Zero(),
                this._transformedDirection = Di.Zero()),
                this.inputs.checkInputs(),
                super._checkInputs()
            }
            set needMoveForGravity(e) {
                this._needMoveForGravity = e
            }
            get needMoveForGravity() {
                return this._needMoveForGravity
            }
            _decideIfNeedsToMove() {
                return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0
            }
            _updatePosition() {
                this.checkCollisions && this.getScene().collisionsEnabled ? this._collideWithWorld(this.cameraDirection) : super._updatePosition()
            }
            dispose() {
                this.inputs.clear(),
                super.dispose()
            }
            getClassName() {
                return "FreeCamera"
            }
        }
        pi([Si()], sa.prototype, "ellipsoid", void 0),
        pi([Si()], sa.prototype, "ellipsoidOffset", void 0),
        pi([xi()], sa.prototype, "checkCollisions", void 0),
        pi([xi()], sa.prototype, "applyGravity", void 0);
        class ra extends Gi {
            get range() {
                return this._range
            }
            set range(e) {
                this._range = e,
                this._inverseSquaredRange = 1 / (this.range * this.range)
            }
            get intensityMode() {
                return this._intensityMode
            }
            set intensityMode(e) {
                this._intensityMode = e,
                this._computePhotometricScale()
            }
            get radius() {
                return this._radius
            }
            set radius(e) {
                this._radius = e,
                this._computePhotometricScale()
            }
            get shadowEnabled() {
                return this._shadowEnabled
            }
            set shadowEnabled(e) {
                this._shadowEnabled !== e && (this._shadowEnabled = e,
                this._markMeshesAsLightDirty())
            }
            get includedOnlyMeshes() {
                return this._includedOnlyMeshes
            }
            set includedOnlyMeshes(e) {
                this._includedOnlyMeshes = e,
                this._hookArrayForIncludedOnly(e)
            }
            get excludedMeshes() {
                return this._excludedMeshes
            }
            set excludedMeshes(e) {
                this._excludedMeshes = e,
                this._hookArrayForExcluded(e)
            }
            get excludeWithLayerMask() {
                return this._excludeWithLayerMask
            }
            set excludeWithLayerMask(e) {
                this._excludeWithLayerMask = e,
                this._resyncMeshes()
            }
            get includeOnlyWithLayerMask() {
                return this._includeOnlyWithLayerMask
            }
            set includeOnlyWithLayerMask(e) {
                this._includeOnlyWithLayerMask = e,
                this._resyncMeshes()
            }
            get lightmapMode() {
                return this._lightmapMode
            }
            set lightmapMode(e) {
                this._lightmapMode !== e && (this._lightmapMode = e,
                this._markMeshesAsLightDirty())
            }
            getViewMatrix(e) {
                return null
            }
            getProjectionMatrix(e, t) {
                return null
            }
            constructor(e, t) {
                super(e, t),
                this.diffuse = new Fe(1,1,1),
                this.specular = new Fe(1,1,1),
                this.falloffType = ra.FALLOFF_DEFAULT,
                this.intensity = 1,
                this._range = Number.MAX_VALUE,
                this._inverseSquaredRange = 0,
                this._photometricScale = 1,
                this._intensityMode = ra.INTENSITYMODE_AUTOMATIC,
                this._radius = 1e-5,
                this.renderPriority = 0,
                this._shadowEnabled = !0,
                this._excludeWithLayerMask = 0,
                this._includeOnlyWithLayerMask = 0,
                this._lightmapMode = 0,
                this._shadowGenerators = null,
                this._excludedMeshesIds = new Array,
                this._includedOnlyMeshesIds = new Array,
                this._isLight = !0,
                this.getScene().addLight(this),
                this._uniformBuffer = new ns(this.getScene().getEngine(),void 0,void 0,e),
                this._buildUniformLayout(),
                this.includedOnlyMeshes = [],
                this.excludedMeshes = [],
                this._resyncMeshes()
            }
            transferTexturesToEffect(e, t) {
                return this
            }
            _bindLight(e, t, i, s, r=!0) {
                const n = e.toString();
                let a = !1;
                if (this._uniformBuffer.bindToEffect(i, "Light" + n),
                this._renderId !== t.getRenderId() || this._lastUseSpecular !== s || !this._uniformBuffer.useUbo) {
                    this._renderId = t.getRenderId(),
                    this._lastUseSpecular = s;
                    const e = this.getScaledIntensity();
                    this.transferToEffect(i, n),
                    this.diffuse.scaleToRef(e, Le.Color3[0]),
                    this._uniformBuffer.updateColor4("vLightDiffuse", Le.Color3[0], this.range, n),
                    s && (this.specular.scaleToRef(e, Le.Color3[1]),
                    this._uniformBuffer.updateColor4("vLightSpecular", Le.Color3[1], this.radius, n)),
                    a = !0
                }
                if (this.transferTexturesToEffect(i, n),
                t.shadowsEnabled && this.shadowEnabled && r) {
                    const e = this.getShadowGenerator(t.activeCamera) ?? this.getShadowGenerator();
                    e && (e.bindShadowLight(n, i),
                    a = !0)
                }
                a ? this._uniformBuffer.update() : this._uniformBuffer.bindUniformBuffer()
            }
            getClassName() {
                return "Light"
            }
            toString(e) {
                let t = "Name: " + this.name;
                if (t += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()],
                this.animations)
                    for (let i = 0; i < this.animations.length; i++)
                        t += ", animation[0]: " + this.animations[i].toString(e);
                return t
            }
            _syncParentEnabledState() {
                super._syncParentEnabledState(),
                this.isDisposed() || this._resyncMeshes()
            }
            setEnabled(e) {
                super.setEnabled(e),
                this._resyncMeshes()
            }
            getShadowGenerator(e=null) {
                return null === this._shadowGenerators ? null : this._shadowGenerators.get(e) ?? null
            }
            getShadowGenerators() {
                return this._shadowGenerators
            }
            getAbsolutePosition() {
                return Di.Zero()
            }
            canAffectMesh(e) {
                return !(e && (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && -1 === this.includedOnlyMeshes.indexOf(e) || this.excludedMeshes && this.excludedMeshes.length > 0 && -1 !== this.excludedMeshes.indexOf(e) || !(0 === this.includeOnlyWithLayerMask || this.includeOnlyWithLayerMask & e.layerMask) || 0 !== this.excludeWithLayerMask && this.excludeWithLayerMask & e.layerMask))
            }
            dispose(e, t=!1) {
                if (this._shadowGenerators) {
                    const e = this._shadowGenerators.values();
                    for (let t = e.next(); !0 !== t.done; t = e.next())
                        t.value.dispose();
                    this._shadowGenerators = null
                }
                if (this.getScene().stopAnimation(this),
                this._parentContainer) {
                    const e = this._parentContainer.lights.indexOf(this);
                    e > -1 && this._parentContainer.lights.splice(e, 1),
                    this._parentContainer = null
                }
                for (const e of this.getScene().meshes)
                    e._removeLightSource(this, !0);
                this._uniformBuffer.dispose(),
                this.getScene().removeLight(this),
                super.dispose(e, t)
            }
            getTypeID() {
                return 0
            }
            getScaledIntensity() {
                return this._photometricScale * this.intensity
            }
            clone(e, t=null) {
                const i = ra.GetConstructorFromName(this.getTypeID(), e, this.getScene());
                if (!i)
                    return null;
                const s = ki.Clone(i, this);
                return e && (s.name = e),
                t && (s.parent = t),
                s.setEnabled(this.isEnabled()),
                this.onClonedObservable.notifyObservers(s),
                s
            }
            serialize() {
                const e = ki.Serialize(this);
                return e.uniqueId = this.uniqueId,
                e.type = this.getTypeID(),
                this.parent && this.parent._serializeAsParent(e),
                this.excludedMeshes.length > 0 && (e.excludedMeshesIds = [],
                this.excludedMeshes.forEach((t => {
                    e.excludedMeshesIds.push(t.id)
                }
                ))),
                this.includedOnlyMeshes.length > 0 && (e.includedOnlyMeshesIds = [],
                this.includedOnlyMeshes.forEach((t => {
                    e.includedOnlyMeshesIds.push(t.id)
                }
                ))),
                ki.AppendSerializedAnimations(this, e),
                e.ranges = this.serializeAnimationRanges(),
                e.isEnabled = this.isEnabled(),
                e
            }
            static GetConstructorFromName(e, t, i) {
                return Gi.Construct("Light_Type_" + e, t, i) || null
            }
            static Parse(e, t) {
                const i = ra.GetConstructorFromName(e.type, e.name, t);
                if (!i)
                    return null;
                const s = ki.Parse(i, e, t);
                if (e.excludedMeshesIds && (s._excludedMeshesIds = e.excludedMeshesIds),
                e.includedOnlyMeshesIds && (s._includedOnlyMeshesIds = e.includedOnlyMeshesIds),
                void 0 !== e.parentId && (s._waitingParentId = e.parentId),
                void 0 !== e.parentInstanceIndex && (s._waitingParentInstanceIndex = e.parentInstanceIndex),
                void 0 !== e.falloffType && (s.falloffType = e.falloffType),
                void 0 !== e.lightmapMode && (s.lightmapMode = e.lightmapMode),
                e.animations) {
                    for (let t = 0; t < e.animations.length; t++) {
                        const i = e.animations[t]
                          , r = Re("BABYLON.Animation");
                        r && s.animations.push(r.Parse(i))
                    }
                    Gi.ParseAnimationRanges(s, e, t)
                }
                return e.autoAnimate && t.beginAnimation(s, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1),
                void 0 !== e.isEnabled && s.setEnabled(e.isEnabled),
                s
            }
            _hookArrayForExcluded(e) {
                const t = e.push;
                e.push = (...i) => {
                    const s = t.apply(e, i);
                    for (const e of i)
                        e._resyncLightSource(this);
                    return s
                }
                ;
                const i = e.splice;
                e.splice = (t, s) => {
                    const r = i.apply(e, [t, s]);
                    for (const e of r)
                        e._resyncLightSource(this);
                    return r
                }
                ;
                for (const t of e)
                    t._resyncLightSource(this)
            }
            _hookArrayForIncludedOnly(e) {
                const t = e.push;
                e.push = (...i) => {
                    const s = t.apply(e, i);
                    return this._resyncMeshes(),
                    s
                }
                ;
                const i = e.splice;
                e.splice = (t, s) => {
                    const r = i.apply(e, [t, s]);
                    return this._resyncMeshes(),
                    r
                }
                ,
                this._resyncMeshes()
            }
            _resyncMeshes() {
                for (const e of this.getScene().meshes)
                    e._resyncLightSource(this)
            }
            _markMeshesAsLightDirty() {
                for (const e of this.getScene().meshes)
                    -1 !== e.lightSources.indexOf(this) && e._markSubMeshesAsLightDirty()
            }
            _computePhotometricScale() {
                this._photometricScale = this._getPhotometricScale(),
                this.getScene().resetCachedMaterial()
            }
            _getPhotometricScale() {
                let e = 0;
                const t = this.getTypeID();
                let i = this.intensityMode;
                switch (i === ra.INTENSITYMODE_AUTOMATIC && (i = t === ra.LIGHTTYPEID_DIRECTIONALLIGHT ? ra.INTENSITYMODE_ILLUMINANCE : ra.INTENSITYMODE_LUMINOUSINTENSITY),
                t) {
                case ra.LIGHTTYPEID_POINTLIGHT:
                case ra.LIGHTTYPEID_SPOTLIGHT:
                    switch (i) {
                    case ra.INTENSITYMODE_LUMINOUSPOWER:
                        e = 1 / (4 * Math.PI);
                        break;
                    case ra.INTENSITYMODE_LUMINOUSINTENSITY:
                        e = 1;
                        break;
                    case ra.INTENSITYMODE_LUMINANCE:
                        e = this.radius * this.radius
                    }
                    break;
                case ra.LIGHTTYPEID_DIRECTIONALLIGHT:
                    switch (i) {
                    case ra.INTENSITYMODE_ILLUMINANCE:
                        e = 1;
                        break;
                    case ra.INTENSITYMODE_LUMINANCE:
                        {
                            let t = this.radius;
                            t = Math.max(t, .001),
                            e = 2 * Math.PI * (1 - Math.cos(t));
                            break
                        }
                    }
                    break;
                case ra.LIGHTTYPEID_HEMISPHERICLIGHT:
                    e = 1
                }
                return e
            }
            _reorderLightsInScene() {
                const e = this.getScene();
                0 != this._renderPriority && (e.requireLightSorting = !0),
                this.getScene().sortLightsByPriority()
            }
        }
        ra.FALLOFF_DEFAULT = Bs.FALLOFF_DEFAULT,
        ra.FALLOFF_PHYSICAL = Bs.FALLOFF_PHYSICAL,
        ra.FALLOFF_GLTF = Bs.FALLOFF_GLTF,
        ra.FALLOFF_STANDARD = Bs.FALLOFF_STANDARD,
        ra.LIGHTMAP_DEFAULT = Bs.LIGHTMAP_DEFAULT,
        ra.LIGHTMAP_SPECULAR = Bs.LIGHTMAP_SPECULAR,
        ra.LIGHTMAP_SHADOWSONLY = Bs.LIGHTMAP_SHADOWSONLY,
        ra.INTENSITYMODE_AUTOMATIC = Bs.INTENSITYMODE_AUTOMATIC,
        ra.INTENSITYMODE_LUMINOUSPOWER = Bs.INTENSITYMODE_LUMINOUSPOWER,
        ra.INTENSITYMODE_LUMINOUSINTENSITY = Bs.INTENSITYMODE_LUMINOUSINTENSITY,
        ra.INTENSITYMODE_ILLUMINANCE = Bs.INTENSITYMODE_ILLUMINANCE,
        ra.INTENSITYMODE_LUMINANCE = Bs.INTENSITYMODE_LUMINANCE,
        ra.LIGHTTYPEID_POINTLIGHT = Bs.LIGHTTYPEID_POINTLIGHT,
        ra.LIGHTTYPEID_DIRECTIONALLIGHT = Bs.LIGHTTYPEID_DIRECTIONALLIGHT,
        ra.LIGHTTYPEID_SPOTLIGHT = Bs.LIGHTTYPEID_SPOTLIGHT,
        ra.LIGHTTYPEID_HEMISPHERICLIGHT = Bs.LIGHTTYPEID_HEMISPHERICLIGHT,
        pi([Ei()], ra.prototype, "diffuse", void 0),
        pi([Ei()], ra.prototype, "specular", void 0),
        pi([xi()], ra.prototype, "falloffType", void 0),
        pi([xi()], ra.prototype, "intensity", void 0),
        pi([xi()], ra.prototype, "range", null),
        pi([xi()], ra.prototype, "intensityMode", null),
        pi([xi()], ra.prototype, "radius", null),
        pi([xi()], ra.prototype, "_renderPriority", void 0),
        pi([bi("_reorderLightsInScene")], ra.prototype, "renderPriority", void 0),
        pi([xi("shadowEnabled")], ra.prototype, "_shadowEnabled", void 0),
        pi([xi("excludeWithLayerMask")], ra.prototype, "_excludeWithLayerMask", void 0),
        pi([xi("includeOnlyWithLayerMask")], ra.prototype, "_includeOnlyWithLayerMask", void 0),
        pi([xi("lightmapMode")], ra.prototype, "_lightmapMode", void 0);
        class na extends ra {
            constructor() {
                super(...arguments),
                this._needProjectionMatrixCompute = !0,
                this._viewMatrix = Oi.Identity(),
                this._projectionMatrix = Oi.Identity()
            }
            _setPosition(e) {
                this._position = e
            }
            get position() {
                return this._position
            }
            set position(e) {
                this._setPosition(e)
            }
            _setDirection(e) {
                this._direction = e
            }
            get direction() {
                return this._direction
            }
            set direction(e) {
                this._setDirection(e)
            }
            get shadowMinZ() {
                return this._shadowMinZ
            }
            set shadowMinZ(e) {
                this._shadowMinZ = e,
                this.forceProjectionMatrixCompute()
            }
            get shadowMaxZ() {
                return this._shadowMaxZ
            }
            set shadowMaxZ(e) {
                this._shadowMaxZ = e,
                this.forceProjectionMatrixCompute()
            }
            computeTransformedInformation() {
                return !(!this.parent || !this.parent.getWorldMatrix || (this.transformedPosition || (this.transformedPosition = Di.Zero()),
                Di.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition),
                this.direction && (this.transformedDirection || (this.transformedDirection = Di.Zero()),
                Di.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection)),
                0))
            }
            getDepthScale() {
                return 50
            }
            getShadowDirection(e) {
                return this.transformedDirection ? this.transformedDirection : this.direction
            }
            getAbsolutePosition() {
                return this.transformedPosition ? this.transformedPosition : this.position
            }
            setDirectionToTarget(e) {
                return this.direction = Di.Normalize(e.subtract(this.position)),
                this.direction
            }
            getRotation() {
                this.direction.normalize();
                const e = Di.Cross(this.direction, or.Y)
                  , t = Di.Cross(e, this.direction);
                return Di.RotationFromAxis(e, t, this.direction)
            }
            needCube() {
                return !1
            }
            needProjectionMatrixCompute() {
                return this._needProjectionMatrixCompute
            }
            forceProjectionMatrixCompute() {
                this._needProjectionMatrixCompute = !0
            }
            _initCache() {
                super._initCache(),
                this._cache.position = Di.Zero()
            }
            _isSynchronized() {
                return !!this._cache.position.equals(this.position)
            }
            computeWorldMatrix(e) {
                return !e && this.isSynchronized() ? (this._currentRenderId = this.getScene().getRenderId(),
                this._worldMatrix) : (this._updateCache(),
                this._cache.position.copyFrom(this.position),
                this._worldMatrix || (this._worldMatrix = Oi.Identity()),
                Oi.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix),
                this.parent && this.parent.getWorldMatrix && (this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix),
                this._markSyncedWithParent()),
                this._worldMatrixDeterminantIsDirty = !0,
                this._worldMatrix)
            }
            getDepthMinZ(e) {
                return void 0 !== this.shadowMinZ ? this.shadowMinZ : e.minZ
            }
            getDepthMaxZ(e) {
                return void 0 !== this.shadowMaxZ ? this.shadowMaxZ : e.maxZ
            }
            setShadowProjectionMatrix(e, t, i) {
                return this.customProjectionMatrixBuilder ? this.customProjectionMatrixBuilder(t, i, e) : this._setDefaultShadowProjectionMatrix(e, t, i),
                this
            }
            _syncParentEnabledState() {
                super._syncParentEnabledState(),
                this.parent && this.parent.getWorldMatrix || (this.transformedPosition = null,
                this.transformedDirection = null)
            }
            getViewMatrix(e) {
                const t = Bi.Vector3[0];
                let i = this.position;
                this.computeTransformedInformation() && (i = this.transformedPosition),
                Di.NormalizeToRef(this.getShadowDirection(e), t),
                1 === Math.abs(Di.Dot(t, Di.Up())) && (t.z = 1e-13);
                const s = Bi.Vector3[1];
                return i.addToRef(t, s),
                Oi.LookAtLHToRef(i, s, Di.Up(), this._viewMatrix),
                this._viewMatrix
            }
            getProjectionMatrix(e, t) {
                return this.setShadowProjectionMatrix(this._projectionMatrix, e ?? this._viewMatrix, t ?? []),
                this._projectionMatrix
            }
        }
        pi([Si()], na.prototype, "position", null),
        pi([Si()], na.prototype, "direction", null),
        pi([xi()], na.prototype, "shadowMinZ", null),
        pi([xi()], na.prototype, "shadowMaxZ", null),
        Gi.AddNodeConstructor("Light_Type_1", ( (e, t) => () => new aa(e,Di.Zero(),t)));
        class aa extends na {
            get shadowFrustumSize() {
                return this._shadowFrustumSize
            }
            set shadowFrustumSize(e) {
                this._shadowFrustumSize = e,
                this.forceProjectionMatrixCompute()
            }
            get shadowOrthoScale() {
                return this._shadowOrthoScale
            }
            set shadowOrthoScale(e) {
                this._shadowOrthoScale = e,
                this.forceProjectionMatrixCompute()
            }
            get orthoLeft() {
                return this._orthoLeft
            }
            set orthoLeft(e) {
                this._orthoLeft = e
            }
            get orthoRight() {
                return this._orthoRight
            }
            set orthoRight(e) {
                this._orthoRight = e
            }
            get orthoTop() {
                return this._orthoTop
            }
            set orthoTop(e) {
                this._orthoTop = e
            }
            get orthoBottom() {
                return this._orthoBottom
            }
            set orthoBottom(e) {
                this._orthoBottom = e
            }
            constructor(e, t, i) {
                super(e, i),
                this._shadowFrustumSize = 0,
                this._shadowOrthoScale = .1,
                this.autoUpdateExtends = !0,
                this.autoCalcShadowZBounds = !1,
                this._orthoLeft = Number.MAX_VALUE,
                this._orthoRight = Number.MIN_VALUE,
                this._orthoTop = Number.MIN_VALUE,
                this._orthoBottom = Number.MAX_VALUE,
                this.position = t.scale(-1),
                this.direction = t
            }
            getClassName() {
                return "DirectionalLight"
            }
            getTypeID() {
                return ra.LIGHTTYPEID_DIRECTIONALLIGHT
            }
            _setDefaultShadowProjectionMatrix(e, t, i) {
                this.shadowFrustumSize > 0 ? this._setDefaultFixedFrustumShadowProjectionMatrix(e) : this._setDefaultAutoExtendShadowProjectionMatrix(e, t, i)
            }
            _setDefaultFixedFrustumShadowProjectionMatrix(e) {
                const t = this.getScene().activeCamera;
                t && Oi.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, void 0 !== this.shadowMinZ ? this.shadowMinZ : t.minZ, void 0 !== this.shadowMaxZ ? this.shadowMaxZ : t.maxZ, e, this.getScene().getEngine().isNDCHalfZRange)
            }
            _setDefaultAutoExtendShadowProjectionMatrix(e, t, i) {
                const s = this.getScene().activeCamera;
                if (!s)
                    return;
                if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
                    const e = Di.Zero();
                    this._orthoLeft = Number.MAX_VALUE,
                    this._orthoRight = -Number.MAX_VALUE,
                    this._orthoTop = -Number.MAX_VALUE,
                    this._orthoBottom = Number.MAX_VALUE;
                    let s = Number.MAX_VALUE
                      , r = -Number.MAX_VALUE;
                    for (let n = 0; n < i.length; n++) {
                        const a = i[n];
                        if (!a)
                            continue;
                        const o = a.getBoundingInfo().boundingBox;
                        for (let i = 0; i < o.vectorsWorld.length; i++)
                            Di.TransformCoordinatesToRef(o.vectorsWorld[i], t, e),
                            e.x < this._orthoLeft && (this._orthoLeft = e.x),
                            e.y < this._orthoBottom && (this._orthoBottom = e.y),
                            e.x > this._orthoRight && (this._orthoRight = e.x),
                            e.y > this._orthoTop && (this._orthoTop = e.y),
                            this.autoCalcShadowZBounds && (e.z < s && (s = e.z),
                            e.z > r && (r = e.z))
                    }
                    this.autoCalcShadowZBounds && (this._shadowMinZ = s,
                    this._shadowMaxZ = r)
                }
                const r = this._orthoRight - this._orthoLeft
                  , n = this._orthoTop - this._orthoBottom
                  , a = void 0 !== this.shadowMinZ ? this.shadowMinZ : s.minZ
                  , o = void 0 !== this.shadowMaxZ ? this.shadowMaxZ : s.maxZ
                  , h = this.getScene().getEngine().useReverseDepthBuffer;
                Oi.OrthoOffCenterLHToRef(this._orthoLeft - r * this.shadowOrthoScale, this._orthoRight + r * this.shadowOrthoScale, this._orthoBottom - n * this.shadowOrthoScale, this._orthoTop + n * this.shadowOrthoScale, h ? o : a, h ? a : o, e, this.getScene().getEngine().isNDCHalfZRange)
            }
            _buildUniformLayout() {
                this._uniformBuffer.addUniform("vLightData", 4),
                this._uniformBuffer.addUniform("vLightDiffuse", 4),
                this._uniformBuffer.addUniform("vLightSpecular", 4),
                this._uniformBuffer.addUniform("shadowsInfo", 3),
                this._uniformBuffer.addUniform("depthValues", 2),
                this._uniformBuffer.create()
            }
            transferToEffect(e, t) {
                return this.computeTransformedInformation() ? (this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, t),
                this) : (this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, t),
                this)
            }
            transferToNodeMaterialEffect(e, t) {
                return this.computeTransformedInformation() ? (e.setFloat3(t, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z),
                this) : (e.setFloat3(t, this.direction.x, this.direction.y, this.direction.z),
                this)
            }
            getDepthMinZ(e) {
                const t = this._scene.getEngine();
                return !t.useReverseDepthBuffer && t.isNDCHalfZRange ? 0 : 1
            }
            getDepthMaxZ(e) {
                const t = this._scene.getEngine();
                return t.useReverseDepthBuffer && t.isNDCHalfZRange ? 0 : 1
            }
            prepareLightSpecificDefines(e, t) {
                e["DIRLIGHT" + t] = !0
            }
        }
        pi([xi()], aa.prototype, "shadowFrustumSize", null),
        pi([xi()], aa.prototype, "shadowOrthoScale", null),
        pi([xi()], aa.prototype, "autoUpdateExtends", void 0),
        pi([xi()], aa.prototype, "autoCalcShadowZBounds", void 0),
        pi([xi("orthoLeft")], aa.prototype, "_orthoLeft", void 0),
        pi([xi("orthoRight")], aa.prototype, "_orthoRight", void 0),
        pi([xi("orthoTop")], aa.prototype, "_orthoTop", void 0),
        pi([xi("orthoBottom")], aa.prototype, "_orthoBottom", void 0);
        class oa {
            constructor() {
                this.previousWorldMatrices = {},
                this.previousBones = {}
            }
            static AddUniforms(e) {
                e.push("previousWorld", "previousViewProjection", "mPreviousBones")
            }
            static AddSamplers(e) {}
            bindForSubMesh(e, t, i, s, r) {
                if (t.prePassRenderer && t.prePassRenderer.enabled && t.prePassRenderer.currentRTisSceneRT && -1 !== t.prePassRenderer.getIndex(2)) {
                    this.previousWorldMatrices[i.uniqueId] || (this.previousWorldMatrices[i.uniqueId] = s.clone()),
                    this.previousViewProjection || (this.previousViewProjection = t.getTransformMatrix().clone(),
                    this.currentViewProjection = t.getTransformMatrix().clone());
                    const r = t.getEngine();
                    this.currentViewProjection.updateFlag !== t.getTransformMatrix().updateFlag ? (this._lastUpdateFrameId = r.frameId,
                    this.previousViewProjection.copyFrom(this.currentViewProjection),
                    this.currentViewProjection.copyFrom(t.getTransformMatrix())) : this._lastUpdateFrameId !== r.frameId && (this._lastUpdateFrameId = r.frameId,
                    this.previousViewProjection.copyFrom(this.currentViewProjection)),
                    e.setMatrix("previousWorld", this.previousWorldMatrices[i.uniqueId]),
                    e.setMatrix("previousViewProjection", this.previousViewProjection),
                    this.previousWorldMatrices[i.uniqueId] = s.clone()
                }
            }
        }
        class ha {
            constructor(e) {
                if (this._keys = [],
                this._isDirty = !0,
                this._areLightsDirty = !0,
                this._areLightsDisposed = !1,
                this._areAttributesDirty = !0,
                this._areTexturesDirty = !0,
                this._areFresnelDirty = !0,
                this._areMiscDirty = !0,
                this._arePrePassDirty = !0,
                this._areImageProcessingDirty = !0,
                this._normals = !1,
                this._uvs = !1,
                this._needNormals = !1,
                this._needUVs = !1,
                this._externalProperties = e,
                e)
                    for (const t in e)
                        Object.prototype.hasOwnProperty.call(e, t) && this._setDefaultValue(t)
            }
            get isDirty() {
                return this._isDirty
            }
            markAsProcessed() {
                this._isDirty = !1,
                this._areAttributesDirty = !1,
                this._areTexturesDirty = !1,
                this._areFresnelDirty = !1,
                this._areLightsDirty = !1,
                this._areLightsDisposed = !1,
                this._areMiscDirty = !1,
                this._arePrePassDirty = !1,
                this._areImageProcessingDirty = !1
            }
            markAsUnprocessed() {
                this._isDirty = !0
            }
            markAllAsDirty() {
                this._areTexturesDirty = !0,
                this._areAttributesDirty = !0,
                this._areLightsDirty = !0,
                this._areFresnelDirty = !0,
                this._areMiscDirty = !0,
                this._arePrePassDirty = !1,
                this._areImageProcessingDirty = !0,
                this._isDirty = !0
            }
            markAsImageProcessingDirty() {
                this._areImageProcessingDirty = !0,
                this._isDirty = !0
            }
            markAsLightDirty(e=!1) {
                this._areLightsDirty = !0,
                this._areLightsDisposed = this._areLightsDisposed || e,
                this._isDirty = !0
            }
            markAsAttributesDirty() {
                this._areAttributesDirty = !0,
                this._isDirty = !0
            }
            markAsTexturesDirty() {
                this._areTexturesDirty = !0,
                this._isDirty = !0
            }
            markAsFresnelDirty() {
                this._areFresnelDirty = !0,
                this._isDirty = !0
            }
            markAsMiscDirty() {
                this._areMiscDirty = !0,
                this._isDirty = !0
            }
            markAsPrePassDirty() {
                this._arePrePassDirty = !0,
                this._isDirty = !0
            }
            rebuild() {
                this._keys.length = 0;
                for (const e of Object.keys(this))
                    "_" !== e[0] && this._keys.push(e);
                if (this._externalProperties)
                    for (const e in this._externalProperties)
                        -1 === this._keys.indexOf(e) && this._keys.push(e)
            }
            isEqual(e) {
                if (this._keys.length !== e._keys.length)
                    return !1;
                for (let t = 0; t < this._keys.length; t++) {
                    const i = this._keys[t];
                    if (this[i] !== e[i])
                        return !1
                }
                return !0
            }
            cloneTo(e) {
                this._keys.length !== e._keys.length && (e._keys = this._keys.slice(0));
                for (let t = 0; t < this._keys.length; t++) {
                    const i = this._keys[t];
                    e[i] = this[i]
                }
            }
            reset() {
                this._keys.forEach((e => this._setDefaultValue(e)))
            }
            _setDefaultValue(e) {
                const t = this._externalProperties?.[e]?.type ?? typeof this[e]
                  , i = this._externalProperties?.[e]?.default;
                switch (t) {
                case "number":
                    this[e] = i ?? 0;
                    break;
                case "string":
                    this[e] = i ?? "";
                    break;
                default:
                    this[e] = i ?? !1
                }
            }
            toString() {
                let e = "";
                for (let t = 0; t < this._keys.length; t++) {
                    const i = this._keys[t]
                      , s = this[i];
                    switch (typeof s) {
                    case "number":
                    case "string":
                        e += "#define " + i + " " + s + "\n";
                        break;
                    default:
                        s && (e += "#define " + i + "\n")
                    }
                }
                return e
            }
        }
        class la extends Fr {
            constructor(e, t, i=!0) {
                super(e, t),
                this._normalMatrix = new Oi,
                this._storeEffectOnSubMeshes = i
            }
            getEffect() {
                return this._storeEffectOnSubMeshes ? this._activeEffect : super.getEffect()
            }
            isReady(e, t) {
                return !!e && (!this._storeEffectOnSubMeshes || !e.subMeshes || 0 === e.subMeshes.length || this.isReadyForSubMesh(e, e.subMeshes[0], t))
            }
            _isReadyForSubMesh(e) {
                const t = e.materialDefines;
                return !(this.checkReadyOnEveryCall || !e.effect || !t || t._renderId !== this.getScene().getRenderId())
            }
            bindOnlyWorldMatrix(e) {
                this._activeEffect.setMatrix("world", e)
            }
            bindOnlyNormalMatrix(e) {
                this._activeEffect.setMatrix("normalMatrix", e)
            }
            bind(e, t) {
                t && this.bindForSubMesh(e, t, t.subMeshes[0])
            }
            _afterBind(e, t=null, i) {
                super._afterBind(e, t, i),
                this.getScene()._cachedEffect = t,
                i ? i._drawWrapper._forceRebindOnNextCall = !1 : this._drawWrapper._forceRebindOnNextCall = !1
            }
            _mustRebind(e, t, i, s=1) {
                return i._drawWrapper._forceRebindOnNextCall || e.isCachedMaterialInvalid(this, t, s)
            }
            dispose(e, t, i) {
                this._activeEffect = void 0,
                super.dispose(e, t, i)
            }
        }
        class ca {
            static get DiffuseTextureEnabled() {
                return this._DiffuseTextureEnabled
            }
            static set DiffuseTextureEnabled(e) {
                this._DiffuseTextureEnabled !== e && (this._DiffuseTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get DetailTextureEnabled() {
                return this._DetailTextureEnabled
            }
            static set DetailTextureEnabled(e) {
                this._DetailTextureEnabled !== e && (this._DetailTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get DecalMapEnabled() {
                return this._DecalMapEnabled
            }
            static set DecalMapEnabled(e) {
                this._DecalMapEnabled !== e && (this._DecalMapEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get AmbientTextureEnabled() {
                return this._AmbientTextureEnabled
            }
            static set AmbientTextureEnabled(e) {
                this._AmbientTextureEnabled !== e && (this._AmbientTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get OpacityTextureEnabled() {
                return this._OpacityTextureEnabled
            }
            static set OpacityTextureEnabled(e) {
                this._OpacityTextureEnabled !== e && (this._OpacityTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get ReflectionTextureEnabled() {
                return this._ReflectionTextureEnabled
            }
            static set ReflectionTextureEnabled(e) {
                this._ReflectionTextureEnabled !== e && (this._ReflectionTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get EmissiveTextureEnabled() {
                return this._EmissiveTextureEnabled
            }
            static set EmissiveTextureEnabled(e) {
                this._EmissiveTextureEnabled !== e && (this._EmissiveTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get SpecularTextureEnabled() {
                return this._SpecularTextureEnabled
            }
            static set SpecularTextureEnabled(e) {
                this._SpecularTextureEnabled !== e && (this._SpecularTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get BumpTextureEnabled() {
                return this._BumpTextureEnabled
            }
            static set BumpTextureEnabled(e) {
                this._BumpTextureEnabled !== e && (this._BumpTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get LightmapTextureEnabled() {
                return this._LightmapTextureEnabled
            }
            static set LightmapTextureEnabled(e) {
                this._LightmapTextureEnabled !== e && (this._LightmapTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get RefractionTextureEnabled() {
                return this._RefractionTextureEnabled
            }
            static set RefractionTextureEnabled(e) {
                this._RefractionTextureEnabled !== e && (this._RefractionTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get ColorGradingTextureEnabled() {
                return this._ColorGradingTextureEnabled
            }
            static set ColorGradingTextureEnabled(e) {
                this._ColorGradingTextureEnabled !== e && (this._ColorGradingTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get FresnelEnabled() {
                return this._FresnelEnabled
            }
            static set FresnelEnabled(e) {
                this._FresnelEnabled !== e && (this._FresnelEnabled = e,
                rr.MarkAllMaterialsAsDirty(4))
            }
            static get ClearCoatTextureEnabled() {
                return this._ClearCoatTextureEnabled
            }
            static set ClearCoatTextureEnabled(e) {
                this._ClearCoatTextureEnabled !== e && (this._ClearCoatTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get ClearCoatBumpTextureEnabled() {
                return this._ClearCoatBumpTextureEnabled
            }
            static set ClearCoatBumpTextureEnabled(e) {
                this._ClearCoatBumpTextureEnabled !== e && (this._ClearCoatBumpTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get ClearCoatTintTextureEnabled() {
                return this._ClearCoatTintTextureEnabled
            }
            static set ClearCoatTintTextureEnabled(e) {
                this._ClearCoatTintTextureEnabled !== e && (this._ClearCoatTintTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get SheenTextureEnabled() {
                return this._SheenTextureEnabled
            }
            static set SheenTextureEnabled(e) {
                this._SheenTextureEnabled !== e && (this._SheenTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get AnisotropicTextureEnabled() {
                return this._AnisotropicTextureEnabled
            }
            static set AnisotropicTextureEnabled(e) {
                this._AnisotropicTextureEnabled !== e && (this._AnisotropicTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get ThicknessTextureEnabled() {
                return this._ThicknessTextureEnabled
            }
            static set ThicknessTextureEnabled(e) {
                this._ThicknessTextureEnabled !== e && (this._ThicknessTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get RefractionIntensityTextureEnabled() {
                return this._ThicknessTextureEnabled
            }
            static set RefractionIntensityTextureEnabled(e) {
                this._RefractionIntensityTextureEnabled !== e && (this._RefractionIntensityTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get TranslucencyIntensityTextureEnabled() {
                return this._ThicknessTextureEnabled
            }
            static set TranslucencyIntensityTextureEnabled(e) {
                this._TranslucencyIntensityTextureEnabled !== e && (this._TranslucencyIntensityTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
            static get IridescenceTextureEnabled() {
                return this._IridescenceTextureEnabled
            }
            static set IridescenceTextureEnabled(e) {
                this._IridescenceTextureEnabled !== e && (this._IridescenceTextureEnabled = e,
                rr.MarkAllMaterialsAsDirty(1))
            }
        }
        ca._DiffuseTextureEnabled = !0,
        ca._DetailTextureEnabled = !0,
        ca._DecalMapEnabled = !0,
        ca._AmbientTextureEnabled = !0,
        ca._OpacityTextureEnabled = !0,
        ca._ReflectionTextureEnabled = !0,
        ca._EmissiveTextureEnabled = !0,
        ca._SpecularTextureEnabled = !0,
        ca._BumpTextureEnabled = !0,
        ca._LightmapTextureEnabled = !0,
        ca._RefractionTextureEnabled = !0,
        ca._ColorGradingTextureEnabled = !0,
        ca._FresnelEnabled = !0,
        ca._ClearCoatTextureEnabled = !0,
        ca._ClearCoatBumpTextureEnabled = !0,
        ca._ClearCoatTintTextureEnabled = !0,
        ca._SheenTextureEnabled = !0,
        ca._AnisotropicTextureEnabled = !0,
        ca._ThicknessTextureEnabled = !0,
        ca._RefractionIntensityTextureEnabled = !0,
        ca._TranslucencyIntensityTextureEnabled = !0,
        ca._IridescenceTextureEnabled = !0;
        bt.IncludesShadersStore.decalFragmentDeclaration = "#ifdef DECAL\nuniform vec4 vDecalInfos;\n#endif\n";
        bt.IncludesShadersStore.defaultFragmentDeclaration = "uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;\n#ifdef SPECULARTERM\nuniform vec4 vSpecularColor;\n#endif\nuniform vec3 vEmissiveColor;uniform vec3 vAmbientColor;uniform float visibility;\n#ifdef DIFFUSE\nuniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY \nuniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;\n#endif\n#ifdef ALPHATEST\nuniform float alphaCutOff;\n#endif\n#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)\nuniform mat4 view;\n#endif\n#ifdef REFRACTION\nuniform vec4 vRefractionInfos;\n#ifndef REFRACTIONMAP_3D\nuniform mat4 refractionMatrix;\n#endif\n#ifdef REFRACTIONFRESNEL\nuniform vec4 refractionLeftColor;uniform vec4 refractionRightColor;\n#endif\n#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)\nuniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; \n#endif\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;\n#endif\n#ifdef DIFFUSEFRESNEL\nuniform vec4 diffuseLeftColor;uniform vec4 diffuseRightColor;\n#endif\n#ifdef OPACITYFRESNEL\nuniform vec4 opacityParts;\n#endif\n#ifdef EMISSIVEFRESNEL\nuniform vec4 emissiveLeftColor;uniform vec4 emissiveRightColor;\n#endif\n#ifdef REFLECTION\nuniform vec2 vReflectionInfos;\n#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)\nuniform mat4 reflectionMatrix;\n#endif\n#ifndef REFLECTIONMAP_SKYBOX\n#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)\nuniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; \n#endif\n#endif\n#ifdef REFLECTIONFRESNEL\nuniform vec4 reflectionLeftColor;uniform vec4 reflectionRightColor;\n#endif\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;\n#endif\n#include<decalFragmentDeclaration>\n#define ADDITIONAL_FRAGMENT_DECLARATION\n";
        bt.IncludesShadersStore.sceneUboDeclaration = "layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif \nmat4 view;mat4 projection;vec4 vEyePosition;};\n";
        bt.IncludesShadersStore.meshUboDeclaration = "#ifdef WEBGL2\nuniform mat4 world;uniform float visibility;\n#else\nlayout(std140,column_major) uniform;uniform Mesh\n{mat4 world;float visibility;};\n#endif\n#define WORLD_UBO\n";
        bt.IncludesShadersStore.defaultUboDeclaration = "layout(std140,column_major) uniform;uniform Material\n{vec4 diffuseLeftColor;vec4 diffuseRightColor;vec4 opacityParts;vec4 reflectionLeftColor;vec4 reflectionRightColor;vec4 refractionLeftColor;vec4 refractionRightColor;vec4 emissiveLeftColor;vec4 emissiveRightColor;vec2 vDiffuseInfos;vec2 vAmbientInfos;vec2 vOpacityInfos;vec2 vReflectionInfos;vec3 vReflectionPosition;vec3 vReflectionSize;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec2 vSpecularInfos;vec3 vBumpInfos;mat4 diffuseMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 reflectionMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 specularMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;float pointSize;float alphaCutOff;mat4 refractionMatrix;vec4 vRefractionInfos;vec3 vRefractionPosition;vec3 vRefractionSize;vec4 vSpecularColor;vec3 vEmissiveColor;vec4 vDiffuseColor;vec3 vAmbientColor;\n#define ADDITIONAL_UBO_DECLARATION\n};\n#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n";
        bt.IncludesShadersStore.prePassDeclaration = "#ifdef PREPASS\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;\n#ifdef PREPASS_DEPTH\nvarying highp vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nvarying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;\n#endif\n#endif\n";
        bt.IncludesShadersStore.oitDeclaration = "#ifdef ORDER_INDEPENDENT_TRANSPARENCY\n#extension GL_EXT_draw_buffers : require\nlayout(location=0) out vec2 depth; \nlayout(location=1) out vec4 frontColor;layout(location=2) out vec4 backColor;\n#define MAX_DEPTH 99999.0\nhighp vec4 gl_FragColor;uniform sampler2D oitDepthSampler;uniform sampler2D oitFrontColorSampler;\n#endif\n";
        bt.IncludesShadersStore.mainUVVaryingDeclaration = "#ifdef MAINUV{X}\nvarying vec2 vMainUV{X};\n#endif\n";
        bt.IncludesShadersStore.helperFunctions = "const float PI=3.1415926535897932384626433832795;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float HALF_MIN=5.96046448e-08; \nconst float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);return outMatrix;}\nmat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}\n#if USE_EXACT_SRGB_CONVERSIONS\nvec3 toLinearSpaceExact(vec3 color)\n{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));\n#else\nreturn\nvec3(\ncolor.r<=0.04045 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.04045 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.04045 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\nvec3 toGammaSpaceExact(vec3 color)\n{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));\n#else\nreturn\nvec3(\ncolor.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\n#endif\nfloat toLinearSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,LinearEncodePowerApprox);\n#endif\n}\nvec3 toLinearSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\n#else\nreturn pow(color,vec3(LinearEncodePowerApprox));\n#endif\n}\nvec4 toLinearSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toLinearSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n#endif\n}\nfloat toGammaSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,GammaEncodePowerApprox);\n#endif\n}\nvec3 toGammaSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\n#else\nreturn pow(color,vec3(GammaEncodePowerApprox));\n#endif\n}\nvec4 toGammaSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toGammaSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n#endif\n}\nfloat square(float value)\n{return value*value;}\nvec3 square(vec3 value)\n{return value*value;}\nfloat pow5(float value) {float sq=value*value;return sq*sq*value;}\nfloat getLuminance(vec3 color)\n{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}\nfloat getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}\nfloat dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}\nconst float rgbdMaxRange=255.0;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(clamp(rgb,0.,1.),D); }\nvec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}\n";
        bt.IncludesShadersStore.lightFragmentDeclaration = "#ifdef LIGHT{X}\nuniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);vec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X};\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};\n#endif\n#endif\n";
        bt.IncludesShadersStore.lightUboDeclaration = "#ifdef LIGHT{X}\nuniform Light{X}\n{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;vec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;vec2 depthValues;} light{X};\n#ifdef PROJECTEDLIGHTTEXTURE{X}\nuniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DArrayShadow shadowSampler{X};\n#else\nuniform highp sampler2DArray shadowSampler{X};\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nconst vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]\n(\nvec3 ( 1.5,0.0,0.0 ),\nvec3 ( 0.0,1.5,0.0 ),\nvec3 ( 0.0,0.0,5.5 ),\nvec3 ( 1.5,0.0,5.5 ),\nvec3 ( 1.5,1.5,0.0 ),\nvec3 ( 1.0,1.0,1.0 ),\nvec3 ( 0.0,1.0,5.5 ),\nvec3 ( 0.5,3.5,0.75 )\n);vec3 shadowDebug{X};\n#endif\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nint index{X}=-1;\n#else\nint index{X}=SHADOWCSMNUM_CASCADES{X}-1;\n#endif\nfloat diff{X}=0.;\n#elif defined(SHADOWCUBE{X})\nuniform samplerCube shadowSampler{X}; \n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};\n#if defined(SHADOWPCSS{X})\nuniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};\n#elif defined(SHADOWPCF{X})\nuniform highp sampler2DShadow shadowSampler{X};\n#else\nuniform sampler2D shadowSampler{X};\n#endif\nuniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n";
        bt.IncludesShadersStore.lightsFragmentFunctions = "struct lightingInfo\n{vec3 diffuse;\n#ifdef SPECULARTERM\nvec3 specular;\n#endif\n#ifdef NDOTL\nfloat ndl;\n#endif\n};lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 lightVectorW;float attenuation=1.0;if (lightData.w==0.)\n{vec3 direction=lightData.xyz-vPositionW;attenuation=max(0.,1.0-length(direction)/range);lightVectorW=normalize(direction);}\nelse\n{lightVectorW=normalize(-lightData.xyz);}\nfloat ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;}\nlightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 direction=lightData.xyz-vPositionW;vec3 lightVectorW=normalize(direction);float attenuation=max(0.,1.0-length(direction)/range);float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));if (cosAngle>=lightDirection.w)\n{cosAngle=max(0.,pow(cosAngle,lightData.w));attenuation*=cosAngle;float ndl=max(0.,dot(vNormal,lightVectorW));\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=ndl*diffuseColor*attenuation;\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;\n#endif\nreturn result;}\nresult.diffuse=vec3(0.);\n#ifdef SPECULARTERM\nresult.specular=vec3(0.);\n#endif\n#ifdef NDOTL\nresult.ndl=0.;\n#endif\nreturn result;}\nlightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {lightingInfo result;float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;\n#ifdef NDOTL\nresult.ndl=ndl;\n#endif\nresult.diffuse=mix(groundColor,diffuseColor,ndl);\n#ifdef SPECULARTERM\nvec3 angleW=normalize(viewDirectionW+lightData.xyz);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor;\n#endif\nreturn result;}\n#define inline\nvec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return textureColor;}";
        bt.IncludesShadersStore.shadowsFragmentFunctions = "#ifdef SHADOWS\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)\n#else\n#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)\n#endif\n#ifndef SHADOWFLOAT\nfloat unpack(vec4 color)\n{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}\n#endif\nfloat computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)\n{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}\n#define inline\nfloat computeShadowCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadow=textureCube(shadowSampler,directionToLight).x;\n#endif\nreturn depth>shadow ? darkness : 1.0;}\n#define inline\nfloat computeShadowWithPoissonSamplingCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);\n#ifndef SHADOWFLOAT\nif (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;\n#else\nif (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;\n#endif\nreturn min(1.0,visibility+darkness);}\n#define inline\nfloat computeShadowWithESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return esm;}\n#define inline\nfloat computeShadowWithCloseESMCube(vec3 worldPos,vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)\n{vec3 directionToLight=worldPos-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));\n#else\nfloat shadowMapSample=textureCube(shadowSampler,directionToLight).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define inline\nfloat computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(texture2D(shadowSampler,uvLayer));\n#else\nfloat shadow=texture2D(shadowSampler,uvLayer).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}\n#endif\n#define inline\nfloat computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nreturn shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}\n#define inline\nfloat computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);\n#ifndef SHADOWFLOAT\nif (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;\n#else\nif (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;\n#endif\nreturn computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0);\n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nfloat esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)\n{return 1.0;}\nelse\n{float shadowPixelDepth=clamp(depthMetric,0.,1.0); \n#ifndef SHADOWFLOAT\nfloat shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));\n#else\nfloat shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;\n#endif\nfloat esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}\n#ifdef IS_NDC_HALF_ZRANGE\n#define ZINCLIP clipSpace.z\n#else\n#define ZINCLIP uvDepth.z\n#endif\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\n#define GREATEST_LESS_THAN_ONE 0.99999994\n/* disable_uniformity_analysis */\n#define inline\nfloat computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}\n#define inline\nfloat computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; \nuv+=0.5; \nvec2 st=fract(uv); \nvec2 base_uv=floor(uv)-0.5; \nbase_uv*=shadowMapSizeAndInverse.y; \nvec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\nconst vec3 PoissonSamplers32[64]=vec3[64](\nvec3(0.06407013,0.05409927,0.),\nvec3(0.7366577,0.5789394,0.),\nvec3(-0.6270542,-0.5320278,0.),\nvec3(-0.4096107,0.8411095,0.),\nvec3(0.6849564,-0.4990818,0.),\nvec3(-0.874181,-0.04579735,0.),\nvec3(0.9989998,0.0009880066,0.),\nvec3(-0.004920578,-0.9151649,0.),\nvec3(0.1805763,0.9747483,0.),\nvec3(-0.2138451,0.2635818,0.),\nvec3(0.109845,0.3884785,0.),\nvec3(0.06876755,-0.3581074,0.),\nvec3(0.374073,-0.7661266,0.),\nvec3(0.3079132,-0.1216763,0.),\nvec3(-0.3794335,-0.8271583,0.),\nvec3(-0.203878,-0.07715034,0.),\nvec3(0.5912697,0.1469799,0.),\nvec3(-0.88069,0.3031784,0.),\nvec3(0.5040108,0.8283722,0.),\nvec3(-0.5844124,0.5494877,0.),\nvec3(0.6017799,-0.1726654,0.),\nvec3(-0.5554981,0.1559997,0.),\nvec3(-0.3016369,-0.3900928,0.),\nvec3(-0.5550632,-0.1723762,0.),\nvec3(0.925029,0.2995041,0.),\nvec3(-0.2473137,0.5538505,0.),\nvec3(0.9183037,-0.2862392,0.),\nvec3(0.2469421,0.6718712,0.),\nvec3(0.3916397,-0.4328209,0.),\nvec3(-0.03576927,-0.6220032,0.),\nvec3(-0.04661255,0.7995201,0.),\nvec3(0.4402924,0.3640312,0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.),\nvec3(0.)\n);const vec3 PoissonSamplers64[64]=vec3[64](\nvec3(-0.613392,0.617481,0.),\nvec3(0.170019,-0.040254,0.),\nvec3(-0.299417,0.791925,0.),\nvec3(0.645680,0.493210,0.),\nvec3(-0.651784,0.717887,0.),\nvec3(0.421003,0.027070,0.),\nvec3(-0.817194,-0.271096,0.),\nvec3(-0.705374,-0.668203,0.),\nvec3(0.977050,-0.108615,0.),\nvec3(0.063326,0.142369,0.),\nvec3(0.203528,0.214331,0.),\nvec3(-0.667531,0.326090,0.),\nvec3(-0.098422,-0.295755,0.),\nvec3(-0.885922,0.215369,0.),\nvec3(0.566637,0.605213,0.),\nvec3(0.039766,-0.396100,0.),\nvec3(0.751946,0.453352,0.),\nvec3(0.078707,-0.715323,0.),\nvec3(-0.075838,-0.529344,0.),\nvec3(0.724479,-0.580798,0.),\nvec3(0.222999,-0.215125,0.),\nvec3(-0.467574,-0.405438,0.),\nvec3(-0.248268,-0.814753,0.),\nvec3(0.354411,-0.887570,0.),\nvec3(0.175817,0.382366,0.),\nvec3(0.487472,-0.063082,0.),\nvec3(-0.084078,0.898312,0.),\nvec3(0.488876,-0.783441,0.),\nvec3(0.470016,0.217933,0.),\nvec3(-0.696890,-0.549791,0.),\nvec3(-0.149693,0.605762,0.),\nvec3(0.034211,0.979980,0.),\nvec3(0.503098,-0.308878,0.),\nvec3(-0.016205,-0.872921,0.),\nvec3(0.385784,-0.393902,0.),\nvec3(-0.146886,-0.859249,0.),\nvec3(0.643361,0.164098,0.),\nvec3(0.634388,-0.049471,0.),\nvec3(-0.688894,0.007843,0.),\nvec3(0.464034,-0.188818,0.),\nvec3(-0.440840,0.137486,0.),\nvec3(0.364483,0.511704,0.),\nvec3(0.034028,0.325968,0.),\nvec3(0.099094,-0.308023,0.),\nvec3(0.693960,-0.366253,0.),\nvec3(0.678884,-0.204688,0.),\nvec3(0.001801,0.780328,0.),\nvec3(0.145177,-0.898984,0.),\nvec3(0.062655,-0.611866,0.),\nvec3(0.315226,-0.604297,0.),\nvec3(-0.780145,0.486251,0.),\nvec3(-0.371868,0.882138,0.),\nvec3(0.200476,0.494430,0.),\nvec3(-0.494552,-0.711051,0.),\nvec3(0.612476,0.705252,0.),\nvec3(-0.578845,-0.768792,0.),\nvec3(-0.772454,-0.090976,0.),\nvec3(0.504440,0.372295,0.),\nvec3(0.155736,0.065157,0.),\nvec3(0.391522,0.849605,0.),\nvec3(-0.620106,-0.328104,0.),\nvec3(0.789239,-0.419965,0.),\nvec3(-0.545396,0.538133,0.),\nvec3(-0.178564,-0.596057,0.)\n);\n#define inline\nfloat computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}\nfloat avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}\nshadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}\nelse\n{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}\n#define inline\nfloat computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)\n{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}\nelse\n{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}\nif (numBlocker<1.0) {return 1.0;}\nelse\n{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}\nshadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}\n#define inline\nfloat computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}\n#define inline\nfloat computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}\n#define inline\nfloat computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)\n{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}\n#define inline\nfloat computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#define inline\nfloat computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#define inline\nfloat computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)\n{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}\n#endif\n#endif\n";
        bt.IncludesShadersStore.samplerFragmentDeclaration = "#ifdef _DEFINENAME_\n#if _DEFINENAME_DIRECTUV==1\n#define v_VARYINGNAME_UV vMainUV1\n#elif _DEFINENAME_DIRECTUV==2\n#define v_VARYINGNAME_UV vMainUV2\n#elif _DEFINENAME_DIRECTUV==3\n#define v_VARYINGNAME_UV vMainUV3\n#elif _DEFINENAME_DIRECTUV==4\n#define v_VARYINGNAME_UV vMainUV4\n#elif _DEFINENAME_DIRECTUV==5\n#define v_VARYINGNAME_UV vMainUV5\n#elif _DEFINENAME_DIRECTUV==6\n#define v_VARYINGNAME_UV vMainUV6\n#else\nvarying vec2 v_VARYINGNAME_UV;\n#endif\nuniform sampler2D _SAMPLERNAME_Sampler;\n#endif\n";
        bt.IncludesShadersStore.fresnelFunction = "#ifdef FRESNEL\nfloat computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)\n{float fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);return clamp(fresnelTerm,0.,1.);}\n#endif\n";
        bt.IncludesShadersStore.reflectionFunction = "vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0); }\nvec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)\n{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(1.0-s,t,0); }\nvec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);vec3 r=normalize(reflect(cameraToVertex,worldNormal));r=vec3(reflectionMatrix*vec4(r,0));float lon=atan(r.z,r.x);float lat=acos(r.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0);}\nvec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)\n{vec3 viewDir=normalize(vec3(view*worldPos));vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));vec3 r=reflect(viewDir,viewNormal);r=vec3(reflectionMatrix*vec4(r,0));r.z=r.z-1.0;float m=2.0*length(r);return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);}\nvec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{vec3 viewDir=worldPos.xyz-eyePosition;vec3 coords=normalize(reflect(viewDir,worldNormal));return vec3(reflectionMatrix*vec4(coords,1));}\nvec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)\n{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;}\nvec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)\n{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=vec3(reflectionMatrix*vec4(coords,0));\n#ifdef INVERTCUBICMAP\ncoords.y*=-1.0;\n#endif\nreturn coords;}\nvec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)\n{return vec3(reflectionMatrix*(view*worldPos));}\nvec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)\n{return vec3(reflectionMatrix*vec4(positionW,1.));}\n#ifdef REFLECTION\nvec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)\n{\n#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED\nvec3 direction=normalize(vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);\n#endif\n#ifdef REFLECTIONMAP_EQUIRECTANGULAR\nreturn computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SPHERICAL\nreturn computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_PLANAR\nreturn computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_CUBIC\n#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC\nreturn computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);\n#else\nreturn computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);\n#endif\n#endif\n#ifdef REFLECTIONMAP_PROJECTION\nreturn computeProjectionCoords(worldPos,view,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nreturn computeSkyBoxCoords(vPositionUVW,reflectionMatrix);\n#endif\n#ifdef REFLECTIONMAP_EXPLICIT\nreturn vec3(0,0,0);\n#endif\n}\n#endif\n";
        bt.IncludesShadersStore.imageProcessingDeclaration = "#ifdef EXPOSURE\nuniform float exposureLinear;\n#endif\n#ifdef CONTRAST\nuniform float contrast;\n#endif\n#if defined(VIGNETTE) || defined(DITHER)\nuniform vec2 vInverseScreenSize;\n#endif\n#ifdef VIGNETTE\nuniform vec4 vignetteSettings1;uniform vec4 vignetteSettings2;\n#endif\n#ifdef COLORCURVES\nuniform vec4 vCameraColorCurveNegative;uniform vec4 vCameraColorCurveNeutral;uniform vec4 vCameraColorCurvePositive;\n#endif\n#ifdef COLORGRADING\n#ifdef COLORGRADING3D\nuniform highp sampler3D txColorTransform;\n#else\nuniform sampler2D txColorTransform;\n#endif\nuniform vec4 colorTransformSettings;\n#endif\n#ifdef DITHER\nuniform float ditherIntensity;\n#endif\n";
        bt.IncludesShadersStore.imageProcessingFunctions = "#if defined(COLORGRADING) && !defined(COLORGRADING3D)\n/** \n* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.\n* sampler3dSetting.x=textureOffset (0.5/textureSize).\n* sampler3dSetting.y=textureSize.\n*/\n#define inline\nvec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)\n{float sliceSize=2.0*sampler3dSetting.x; \n#ifdef SAMPLER3DGREENDEPTH\nfloat sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;\n#else\nfloat sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;\n#endif\nfloat sliceInteger=floor(sliceContinuous);float sliceFraction=sliceContinuous-sliceInteger;\n#ifdef SAMPLER3DGREENDEPTH\nvec2 sliceUV=color.rb;\n#else\nvec2 sliceUV=color.rg;\n#endif\nsliceUV.x*=sliceSize;sliceUV.x+=sliceInteger*sliceSize;sliceUV=saturate(sliceUV);vec4 slice0Color=texture2D(colorTransform,sliceUV);sliceUV.x+=sliceSize;sliceUV=saturate(sliceUV);vec4 slice1Color=texture2D(colorTransform,sliceUV);vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);\n#ifdef SAMPLER3DBGRMAP\ncolor.rgb=result.rgb;\n#else\ncolor.rgb=result.bgr;\n#endif\nreturn color;}\n#endif\n#ifdef TONEMAPPING_ACES\nconst mat3 ACESInputMat=mat3(\nvec3(0.59719,0.07600,0.02840),\nvec3(0.35458,0.90834,0.13383),\nvec3(0.04823,0.01566,0.83777)\n);const mat3 ACESOutputMat=mat3(\nvec3( 1.60475,-0.10208,-0.00327),\nvec3(-0.53108, 1.10813,-0.07276),\nvec3(-0.07367,-0.00605, 1.07602)\n);vec3 RRTAndODTFit(vec3 v)\n{vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}\nvec3 ACESFitted(vec3 color)\n{color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=saturate(color);return color;}\n#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS\nvec4 applyImageProcessing(vec4 result) {\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART\n#ifdef EXPOSURE\nresult.rgb*=exposureLinear;\n#endif\n#ifdef VIGNETTE\nvec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);float vignetteTerm=dot(vignetteXY1,vignetteXY1);float vignette=pow(vignetteTerm,vignetteSettings2.w);vec3 vignetteColor=vignetteSettings2.rgb;\n#ifdef VIGNETTEBLENDMODEMULTIPLY\nvec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);result.rgb*=vignetteColorMultiplier;\n#endif\n#ifdef VIGNETTEBLENDMODEOPAQUE\nresult.rgb=mix(vignetteColor,result.rgb,vignette);\n#endif\n#endif\n#ifdef TONEMAPPING\n#ifdef TONEMAPPING_ACES\nresult.rgb=ACESFitted(result.rgb);\n#else\nconst float tonemappingCalibration=1.590579;result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);\n#endif\n#endif\nresult.rgb=toGammaSpace(result.rgb);result.rgb=saturate(result.rgb);\n#ifdef CONTRAST\nvec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);if (contrast<1.0) {result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);} else {result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);}\n#endif\n#ifdef COLORGRADING\nvec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;\n#ifdef COLORGRADING3D\nvec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;\n#else\nvec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;\n#endif\nresult.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);\n#endif\n#ifdef COLORCURVES\nfloat luma=getLuminance(result.rgb);vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;result.rgb*=colorCurve.rgb;result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);\n#endif\n#ifdef DITHER\nfloat rand=getRand(gl_FragCoord.xy*vInverseScreenSize);float dither=mix(-ditherIntensity,ditherIntensity,rand);result.rgb=saturate(result.rgb+vec3(dither));\n#endif\n#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND\nreturn result;}";
        bt.IncludesShadersStore.bumpFragmentMainFunctions = "#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\nuniform mat4 normalMatrix;\n#if defined(WEBGL2) || defined(WEBGPU)\nmat4 toNormalMatrix(mat4 wMatrix)\n{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}\n#else\nmat4 toNormalMatrix(mat4 m)\n{float\na00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],\na10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],\na20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],\na30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],\nb00=a00*a11-a01*a10,\nb01=a00*a12-a02*a10,\nb02=a00*a13-a03*a10,\nb03=a01*a12-a02*a11,\nb04=a01*a13-a03*a11,\nb05=a02*a13-a03*a12,\nb06=a20*a31-a21*a30,\nb07=a20*a32-a22*a30,\nb08=a20*a33-a23*a30,\nb09=a21*a32-a22*a31,\nb10=a21*a33-a23*a31,\nb11=a22*a33-a23*a32,\ndet=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(\na11*b11-a12*b10+a13*b09,\na02*b10-a01*b11-a03*b09,\na31*b05-a32*b04+a33*b03,\na22*b04-a21*b05-a23*b03,\na12*b08-a10*b11-a13*b07,\na00*b11-a02*b08+a03*b07,\na32*b02-a30*b05-a33*b01,\na20*b05-a22*b02+a23*b01,\na10*b10-a11*b08+a13*b06,\na01*b08-a00*b10-a03*b06,\na30*b04-a31*b02+a33*b00,\na21*b02-a20*b04-a23*b00,\na11*b07-a10*b09-a12*b06,\na00*b09-a01*b07+a02*b06,\na31*b01-a30*b03-a32*b00,\na20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],\nmi[0][1],mi[1][1],mi[2][1],mi[3][1],\nmi[0][2],mi[1][2],mi[2][2],mi[3][2],\nmi[0][3],mi[1][3],mi[2][3],mi[3][3]);}\n#endif\n#endif\nvec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)\n{\n#ifdef NORMALXYSCALE\nnormal=normalize(normal*vec3(scale,scale,1.0));\n#endif\nreturn normalize(cotangentFrame*normal);}\nvec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)\n{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}\nmat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)\n{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}\n#endif\n";
        bt.IncludesShadersStore.bumpFragmentFunctions = "#if defined(BUMP)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)\n#endif\n#if defined(DETAIL)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)\n#endif\n#if defined(BUMP) && defined(PARALLAX)\nconst float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)\n{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)\n{}\nelse if (currSampledHeight>currRayHeight)\n{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}\nelse\n{currRayHeight-=stepSize;vLastOffset=vCurrOffset;\n#ifdef PARALLAX_RHS\nvCurrOffset-=stepSize*vMaxOffset;\n#else\nvCurrOffset+=stepSize*vMaxOffset;\n#endif\nlastSampledHeight=currSampledHeight;}}\nreturn vCurrOffset;}\nvec2 parallaxOffset(vec3 viewDir,float heightScale)\n{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;\n#ifdef PARALLAX_RHS\nreturn texCoordOffset;\n#else\nreturn -texCoordOffset;\n#endif\n}\n#endif\n";
        bt.IncludesShadersStore.clipPlaneFragmentDeclaration = "#ifdef CLIPPLANE\nvarying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nvarying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nvarying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nvarying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nvarying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nvarying float fClipDistance6;\n#endif\n";
        bt.IncludesShadersStore.logDepthDeclaration = "#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;varying float vFragmentDepth;\n#endif\n";
        bt.IncludesShadersStore.fogFragmentDeclaration = "#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()\n{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n";
        bt.IncludesShadersStore.clipPlaneFragment = "#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fClipDistance6>0.0)\n{discard;}\n#endif\n";
        bt.IncludesShadersStore.bumpFragment = "vec2 uvOffset=vec2(0.0,0.0);\n#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)\n#ifdef NORMALXYSCALE\nfloat normalScale=1.0;\n#elif defined(BUMP)\nfloat normalScale=vBumpInfos.y;\n#else\nfloat normalScale=1.0;\n#endif\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#elif defined(BUMP)\nvec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);\n#else\nvec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#elif defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nmat3 TBN=vTBN;\n#else\nvec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));\n#endif\n#endif\n#ifdef PARALLAX\nmat3 invTBN=transposeMat3(TBN);\n#ifdef PARALLAXOCCLUSION\nuvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);\n#else\nuvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);\n#endif\n#endif\n#ifdef DETAIL\nvec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);\n#endif\n#ifdef BUMP\n#ifdef OBJECTSPACE_NORMALMAP\n#define CUSTOM_FRAGMENT_BUMP_FRAGMENT\nnormalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);\n#elif !defined(DETAIL)\nnormalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);\n#else\nvec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;\n#if DETAIL_NORMALBLENDMETHOD==0 \ndetailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));\n#elif DETAIL_NORMALBLENDMETHOD==1 \ndetailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;\n#endif\nnormalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);\n#endif\n#elif defined(DETAIL)\ndetailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);\n#endif\n";
        bt.IncludesShadersStore.decalFragment = "#ifdef DECAL\n#ifdef GAMMADECAL\ndecalColor.rgb=toLinearSpace(decalColor.rgb);\n#endif\n#ifdef DECAL_SMOOTHALPHA\ndecalColor.a*=decalColor.a;\n#endif\nsurfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);\n#endif\n";
        bt.IncludesShadersStore.depthPrePass = "#ifdef DEPTHPREPASS\ngl_FragColor=vec4(0.,0.,0.,1.0);return;\n#endif\n";
        bt.IncludesShadersStore.lightFragment = "#ifdef LIGHT{X}\n#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})\n#else\n#ifdef PBR\n#ifdef SPOTLIGHT{X}\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(POINTLIGHT{X})\npreInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(HEMILIGHT{X})\npreInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#elif defined(DIRLIGHT{X})\npreInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);\n#endif\npreInfo.NdotV=NdotV;\n#ifdef SPOTLIGHT{X}\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);\n#endif\n#elif defined(POINTLIGHT{X})\n#ifdef LIGHT_FALLOFF_GLTF{X}\npreInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);\n#elif defined(LIGHT_FALLOFF_PHYSICAL{X})\npreInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);\n#elif defined(LIGHT_FALLOFF_STANDARD{X})\npreInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);\n#else\npreInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);\n#endif\n#else\npreInfo.attenuation=1.0;\n#endif\n#ifdef HEMILIGHT{X}\npreInfo.roughness=roughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#ifdef IRIDESCENCE\npreInfo.iridescenceIntensity=iridescenceIntensity;\n#endif\n#ifdef HEMILIGHT{X}\ninfo.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);\n#elif defined(SS_TRANSLUCENCY)\ninfo.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);\n#else\ninfo.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef SPECULARTERM\n#ifdef ANISOTROPIC\ninfo.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#else\ninfo.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#endif\n#ifdef SHEEN\n#ifdef SHEEN_LINKWITHALBEDO\npreInfo.roughness=sheenOut.sheenIntensity;\n#else\n#ifdef HEMILIGHT{X}\npreInfo.roughness=sheenOut.sheenRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\n#endif\ninfo.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);\n#endif\n#ifdef CLEARCOAT\n#ifdef HEMILIGHT{X}\npreInfo.roughness=clearcoatOut.clearCoatRoughness;\n#else\npreInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);\n#endif\ninfo.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);\n#ifdef CLEARCOAT_TINT\nabsorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;\n#ifdef SPECULARTERM\ninfo.specular*=absorption;\n#endif\n#endif\ninfo.diffuse*=info.clearCoat.w;\n#ifdef SPECULARTERM\ninfo.specular*=info.clearCoat.w;\n#endif\n#ifdef SHEEN\ninfo.sheen*=info.clearCoat.w;\n#endif\n#endif\n#else\n#ifdef SPOTLIGHT{X}\ninfo=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#elif defined(HEMILIGHT{X})\ninfo=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);\n#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})\ninfo=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);\n#endif\n#endif\n#ifdef PROJECTEDLIGHTTEXTURE{X}\ninfo.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});\n#endif\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nfor (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) \n{\n#ifdef SHADOWCSM_RIGHTHANDED{X}\ndiff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;\n#else\ndiff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;\n#endif\nif (diff{X}>=0.) {index{X}=i;break;}}\n#ifdef SHADOWCSMUSESHADOWMAXZ{X}\nif (index{X}>=0)\n#endif\n{\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nshadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nshadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];\n#endif\n#ifndef SHADOWCSMNOBLEND{X}\nfloat frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)\n{index{X}+=1;float nextShadow=0.;\n#if defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nnextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#elif defined(SHADOWMEDIUMQUALITY{X})\nnextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#else\nnextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});\n#endif\n#else\nnextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\nshadow=mix(nextShadow,shadow,diffRatio);\n#ifdef SHADOWCSMDEBUG{X}\nshadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);\n#endif\n}\n#endif\n}\n#elif defined(SHADOWCLOSEESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithCloseESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWESM{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithESMCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);\n#else\nshadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPOISSON{X})\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowWithPoissonSamplingCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCF{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#elif defined(SHADOWPCSS{X})\n#if defined(SHADOWLOWQUALITY{X})\nshadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#elif defined(SHADOWMEDIUMQUALITY{X})\nshadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#else\nshadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#else\n#if defined(SHADOWCUBE{X})\nshadow=computeShadowCube(vPositionW,light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);\n#else\nshadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);\n#endif\n#endif\n#ifdef SHADOWONLY\n#ifndef SHADOWINUSE\n#define SHADOWINUSE\n#endif\nglobalShadow+=shadow;shadowLightCount+=1.0;\n#endif\n#else\nshadow=1.;\n#endif\naggShadow+=shadow;numLights+=1.0;\n#ifndef SHADOWONLY\n#ifdef CUSTOMUSERLIGHTING\ndiffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);\n#ifdef SPECULARTERM\nspecularBase+=computeCustomSpecularLighting(info,specularBase,shadow);\n#endif\n#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})\ndiffuseBase+=lightmapColor.rgb*shadow;\n#ifdef SPECULARTERM\n#ifndef LIGHTMAPNOSPECULAR{X}\nspecularBase+=info.specular*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef CLEARCOAT\n#ifndef LIGHTMAPNOSPECULAR{X}\nclearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;\n#endif\n#endif\n#ifdef SHEEN\n#ifndef LIGHTMAPNOSPECULAR{X}\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#else\n#ifdef SHADOWCSMDEBUG{X}\ndiffuseBase+=info.diffuse*shadowDebug{X};\n#else \ndiffuseBase+=info.diffuse*shadow;\n#endif\n#ifdef SPECULARTERM\nspecularBase+=info.specular*shadow;\n#endif\n#ifdef CLEARCOAT\nclearCoatBase+=info.clearCoat.rgb*shadow;\n#endif\n#ifdef SHEEN\nsheenBase+=info.sheen.rgb*shadow;\n#endif\n#endif\n#endif\n#endif\n";
        bt.IncludesShadersStore.logDepthFragment = "#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif\n";
        bt.IncludesShadersStore.fogFragment = "#ifdef FOG\nfloat fog=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\n#endif\n";
        bt.IncludesShadersStore.oitFragment = "#ifdef ORDER_INDEPENDENT_TRANSPARENCY\nfloat fragDepth=gl_FragCoord.z; \n#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS\nuint halfFloat=packHalf2x16(vec2(fragDepth));vec2 full=unpackHalf2x16(halfFloat);fragDepth=full.x;\n#endif\nivec2 fragCoord=ivec2(gl_FragCoord.xy);vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);depth.rg=vec2(-MAX_DEPTH);frontColor=lastFrontColor;backColor=vec4(0.0);\n#ifdef USE_REVERSE_DEPTHBUFFER\nfloat furthestDepth=-lastDepth.x;float nearestDepth=lastDepth.y;\n#else\nfloat nearestDepth=-lastDepth.x;float furthestDepth=lastDepth.y;\n#endif\nfloat alphaMultiplier=1.0-lastFrontColor.a;\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth>nearestDepth || fragDepth<furthestDepth) {\n#else\nif (fragDepth<nearestDepth || fragDepth>furthestDepth) {\n#endif\nreturn;}\n#ifdef USE_REVERSE_DEPTHBUFFER\nif (fragDepth<nearestDepth && fragDepth>furthestDepth) {\n#else\nif (fragDepth>nearestDepth && fragDepth<furthestDepth) {\n#endif\ndepth.rg=vec2(-fragDepth,fragDepth);return;}\n#endif\n";
        bt.ShadersStore.defaultPixelShader = "#include<__decl__defaultFragment>\n#if defined(BUMP) || !defined(NORMAL)\n#extension GL_OES_standard_derivatives : enable\n#endif\n#include<prePassDeclaration>[SCENE_MRT_COUNT]\n#include<oitDeclaration>\n#define CUSTOM_FRAGMENT_BEGIN\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<mainUVVaryingDeclaration>[1..7]\n#include<helperFunctions>\n#include<__decl__lightFragment>[0..maxSimultaneousLights]\n#include<lightsFragmentFunctions>\n#include<shadowsFragmentFunctions>\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)\n#ifdef REFRACTION\n#ifdef REFRACTIONMAP_3D\nuniform samplerCube refractionCubeSampler;\n#else\nuniform sampler2D refraction2DSampler;\n#endif\n#endif\n#if defined(SPECULARTERM)\n#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)\n#endif\n#include<fresnelFunction>\n#ifdef REFLECTION\n#ifdef REFLECTIONMAP_3D\nuniform samplerCube reflectionCubeSampler;\n#else\nuniform sampler2D reflection2DSampler;\n#endif\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#else\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#endif\n#include<reflectionFunction>\n#endif\n#include<imageProcessingDeclaration>\n#include<imageProcessingFunctions>\n#include<bumpFragmentMainFunctions>\n#include<bumpFragmentFunctions>\n#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;\n#ifdef NORMAL\nvec3 normalW=normalize(vNormalW);\n#else\nvec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));\n#endif\n#include<bumpFragment>\n#ifdef TWOSIDEDLIGHTING\nnormalW=gl_FrontFacing ? normalW : -normalW;\n#endif\n#ifdef DIFFUSE\nbaseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);\n#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)\nif (baseColor.a<alphaCutOff)\ndiscard;\n#endif\n#ifdef ALPHAFROMDIFFUSE\nalpha*=baseColor.a;\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_ALPHA\nbaseColor.rgb*=vDiffuseInfos.y;\n#endif\n#if defined(DECAL) && !defined(DECAL_AFTER_DETAIL)\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#include<depthPrePass>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nbaseColor.rgb*=vColor.rgb;\n#endif\n#ifdef DETAIL\nbaseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);\n#endif\n#if defined(DECAL) && defined(DECAL_AFTER_DETAIL)\nvec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);\n#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)\n#endif\n#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE\nvec3 baseAmbientColor=vec3(1.,1.,1.);\n#ifdef AMBIENT\nbaseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_LIGHTS\n#ifdef SPECULARTERM\nfloat glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;\n#ifdef SPECULAR\nvec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);specularColor=specularMapColor.rgb;\n#ifdef GLOSSINESS\nglossiness=glossiness*specularMapColor.a;\n#endif\n#endif\n#else\nfloat glossiness=0.;\n#endif\nvec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;\n#ifdef SPECULARTERM\nvec3 specularBase=vec3(0.,0.,0.);\n#endif\nfloat shadow=1.;float aggShadow=0.;float numLights=0.;\n#ifdef LIGHTMAP\nvec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);\n#ifdef RGBDLIGHTMAP\nlightmapColor.rgb=fromRGBD(lightmapColor);\n#endif\nlightmapColor.rgb*=vLightmapInfos.y;\n#endif\n#include<lightFragment>[0..maxSimultaneousLights]\naggShadow=aggShadow/numLights;vec4 refractionColor=vec4(0.,0.,0.,1.);\n#ifdef REFRACTION\nvec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));\n#ifdef REFRACTIONMAP_3D\n#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC\nrefractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);\n#endif\nrefractionVector.y=refractionVector.y*vRefractionInfos.w;vec4 refractionLookup=textureCube(refractionCubeSampler,refractionVector);if (dot(refractionVector,viewDirectionW)<1.0) {refractionColor=refractionLookup;}\n#else\nvec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;refractionColor=texture2D(refraction2DSampler,refractionCoords);\n#endif\n#ifdef RGBDREFRACTION\nrefractionColor.rgb=fromRGBD(refractionColor);\n#endif\n#ifdef IS_REFRACTION_LINEAR\nrefractionColor.rgb=toGammaSpace(refractionColor.rgb);\n#endif\nrefractionColor.rgb*=vRefractionInfos.x;\n#endif\nvec4 reflectionColor=vec4(0.,0.,0.,1.);\n#ifdef REFLECTION\nvec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);\n#ifdef REFLECTIONMAP_OPPOSITEZ\nvReflectionUVW.z*=-1.0;\n#endif\n#ifdef REFLECTIONMAP_3D\n#ifdef ROUGHNESS\nfloat bias=vReflectionInfos.y;\n#ifdef SPECULARTERM\n#ifdef SPECULAR\n#ifdef GLOSSINESS\nbias*=(1.0-specularMapColor.a);\n#endif\n#endif\n#endif\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);\n#else\nreflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);\n#endif\n#else\nvec2 coords=vReflectionUVW.xy;\n#ifdef REFLECTIONMAP_PROJECTION\ncoords/=vReflectionUVW.z;\n#endif\ncoords.y=1.0-coords.y;reflectionColor=texture2D(reflection2DSampler,coords);\n#endif\n#ifdef RGBDREFLECTION\nreflectionColor.rgb=fromRGBD(reflectionColor);\n#endif\n#ifdef IS_REFLECTION_LINEAR\nreflectionColor.rgb=toGammaSpace(reflectionColor.rgb);\n#endif\nreflectionColor.rgb*=vReflectionInfos.x;\n#ifdef REFLECTIONFRESNEL\nfloat reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);\n#ifdef REFLECTIONFRESNELFROMSPECULAR\n#ifdef SPECULARTERM\nreflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#else\nreflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;\n#endif\n#endif\n#endif\n#ifdef REFRACTIONFRESNEL\nfloat refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);refractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;\n#endif\n#ifdef OPACITY\nvec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);\n#ifdef OPACITYRGB\nopacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;\n#else\nalpha*=opacityMap.a*vOpacityInfos.y;\n#endif\n#endif\n#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nalpha*=vColor.a;\n#endif\n#ifdef OPACITYFRESNEL\nfloat opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);alpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;\n#endif\n#ifdef ALPHATEST\n#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS\nif (alpha<alphaCutOff)\ndiscard;\n#endif\n#ifndef ALPHABLEND\nalpha=1.0;\n#endif\n#endif\nvec3 emissiveColor=vEmissiveColor;\n#ifdef EMISSIVE\nemissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;\n#endif\n#ifdef EMISSIVEFRESNEL\nfloat emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);emissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;\n#endif\n#ifdef DIFFUSEFRESNEL\nfloat diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);diffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\n#ifdef LINKEMISSIVEWITHDIFFUSE\nvec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#else\nvec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;\n#endif\n#endif\n#ifdef SPECULARTERM\nvec3 finalSpecular=specularBase*specularColor;\n#ifdef SPECULAROVERALPHA\nalpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#else\nvec3 finalSpecular=vec3(0.0);\n#endif\n#ifdef REFLECTIONOVERALPHA\nalpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);\n#endif\n#ifdef EMISSIVEASILLUMINATION\nvec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);\n#else\nvec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);\n#endif\n#ifdef LIGHTMAP\n#ifndef LIGHTMAPEXCLUDED\n#ifdef USELIGHTMAPASSHADOWMAP\ncolor.rgb*=lightmapColor.rgb;\n#else\ncolor.rgb+=lightmapColor.rgb;\n#endif\n#endif\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FOG\ncolor.rgb=max(color.rgb,0.);\n#include<logDepthFragment>\n#include<fogFragment>\n#ifdef IMAGEPROCESSINGPOSTPROCESS\ncolor.rgb=toLinearSpace(color.rgb);\n#else\n#ifdef IMAGEPROCESSING\ncolor.rgb=toLinearSpace(color.rgb);color=applyImageProcessing(color);\n#endif\n#endif\ncolor.a*=visibility;\n#ifdef PREMULTIPLYALPHA\ncolor.rgb*=color.a;\n#endif\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\n#ifdef PREPASS\nfloat writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;gl_FragData[0]=color; \n#ifdef PREPASS_POSITION\ngl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);\n#endif\n#ifdef PREPASS_VELOCITY\nvec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);\n#endif\n#ifdef PREPASS_IRRADIANCE\ngl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_DEPTH\ngl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_NORMAL\n#ifdef PREPASS_NORMAL_WORLDSPACE\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); \n#else\ngl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); \n#endif\n#endif\n#ifdef PREPASS_ALBEDO_SQRT\ngl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); \n#endif\n#ifdef PREPASS_REFLECTIVITY\n#if defined(SPECULARTERM)\n#if defined(SPECULAR)\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularMapColor))*writeGeometryInfo; \n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularColor),1.0)*writeGeometryInfo;\n#endif\n#else\ngl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;\n#endif\n#endif\n#endif\n#if !defined(PREPASS) || defined(WEBGL2)\ngl_FragColor=color;\n#endif\n#include<oitFragment>\n#if ORDER_INDEPENDENT_TRANSPARENCY\nif (fragDepth==nearestDepth) {frontColor.rgb+=color.rgb*color.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-color.a);} else {backColor+=color;}\n#endif\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n";
        bt.IncludesShadersStore.decalVertexDeclaration = "#ifdef DECAL\nuniform vec4 vDecalInfos;uniform mat4 decalMatrix;\n#endif\n";
        bt.IncludesShadersStore.defaultVertexDeclaration = "uniform mat4 viewProjection;uniform mat4 view;\n#ifdef DIFFUSE\nuniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;\n#endif\n#ifdef AMBIENT\nuniform mat4 ambientMatrix;uniform vec2 vAmbientInfos;\n#endif\n#ifdef OPACITY\nuniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;\n#endif\n#ifdef EMISSIVE\nuniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;\n#endif\n#ifdef LIGHTMAP\nuniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;\n#endif\n#if defined(SPECULAR) && defined(SPECULARTERM)\nuniform vec2 vSpecularInfos;uniform mat4 specularMatrix;\n#endif\n#ifdef BUMP\nuniform vec3 vBumpInfos;uniform mat4 bumpMatrix;\n#endif\n#ifdef REFLECTION\nuniform mat4 reflectionMatrix;\n#endif\n#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n#ifdef DETAIL\nuniform vec4 vDetailInfos;uniform mat4 detailMatrix;\n#endif\n#include<decalVertexDeclaration>\n#define ADDITIONAL_VERTEX_DECLARATION\n";
        bt.IncludesShadersStore.uvAttributeDeclaration = "#ifdef UV{X}\nattribute vec2 uv{X};\n#endif\n";
        bt.IncludesShadersStore.bonesDeclaration = "#if NUM_BONE_INFLUENCERS>0\nattribute vec4 matricesIndices;attribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;\n#endif\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#ifdef BONETEXTURE\nuniform highp sampler2D boneSampler;uniform float boneTextureWidth;\n#else\nuniform mat4 mBones[BonesPerMesh];\n#endif\n#ifdef BONES_VELOCITY_ENABLED\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\n{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}\n#endif\n#endif\n#endif\n";
        bt.IncludesShadersStore.bakedVertexAnimationDeclaration = "#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;\n#ifdef INSTANCES\nattribute vec4 bakedVertexAnimationSettingsInstanced;\n#endif\n#define inline\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\n{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}\n#endif\n";
        bt.IncludesShadersStore.instancesDeclaration = "#ifdef INSTANCES\nattribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;\n#ifdef INSTANCESCOLOR\nattribute vec4 instanceColor;\n#endif\n#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nattribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;\n#ifdef THIN_INSTANCES\nuniform mat4 previousWorld;\n#endif\n#endif\n#else\n#if !defined(WORLD_UBO)\nuniform mat4 world;\n#endif\n#if defined(VELOCITY) || defined(PREPASS_VELOCITY)\nuniform mat4 previousWorld;\n#endif\n#endif\n";
        bt.IncludesShadersStore.prePassVertexDeclaration = "#ifdef PREPASS\n#ifdef PREPASS_DEPTH\nvarying vec3 vViewPos;\n#endif\n#ifdef PREPASS_VELOCITY\nuniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;\n#endif\n#endif\n";
        bt.IncludesShadersStore.samplerVertexDeclaration = "#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nvarying vec2 v_VARYINGNAME_UV;\n#endif\n";
        bt.IncludesShadersStore.bumpVertexDeclaration = "#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL) \nvarying mat3 vTBN;\n#endif\n#endif\n";
        bt.IncludesShadersStore.clipPlaneVertexDeclaration = "#ifdef CLIPPLANE\nuniform vec4 vClipPlane;varying float fClipDistance;\n#endif\n#ifdef CLIPPLANE2\nuniform vec4 vClipPlane2;varying float fClipDistance2;\n#endif\n#ifdef CLIPPLANE3\nuniform vec4 vClipPlane3;varying float fClipDistance3;\n#endif\n#ifdef CLIPPLANE4\nuniform vec4 vClipPlane4;varying float fClipDistance4;\n#endif\n#ifdef CLIPPLANE5\nuniform vec4 vClipPlane5;varying float fClipDistance5;\n#endif\n#ifdef CLIPPLANE6\nuniform vec4 vClipPlane6;varying float fClipDistance6;\n#endif\n";
        bt.IncludesShadersStore.fogVertexDeclaration = "#ifdef FOG\nvarying vec3 vFogDistance;\n#endif\n";
        bt.IncludesShadersStore.lightVxFragmentDeclaration = "#ifdef LIGHT{X}\nuniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};\n#ifdef SPECULARTERM\nuniform vec4 vLightSpecular{X};\n#else\nvec4 vLightSpecular{X}=vec4(0.);\n#endif\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};\n#endif\nuniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};\n#endif\n#ifdef SPOTLIGHT{X}\nuniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};\n#elif defined(POINTLIGHT{X})\nuniform vec4 vLightFalloff{X};\n#elif defined(HEMILIGHT{X})\nuniform vec3 vLightGround{X};\n#endif\n#endif\n";
        bt.IncludesShadersStore.lightVxUboDeclaration = "#ifdef LIGHT{X}\nuniform Light{X}\n{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;\n#ifdef SPOTLIGHT{X}\nvec4 vLightDirection;vec4 vLightFalloff;\n#elif defined(POINTLIGHT{X})\nvec4 vLightFalloff;\n#elif defined(HEMILIGHT{X})\nvec3 vLightGround;\n#endif\nvec4 shadowsInfo;vec2 depthValues;} light{X};\n#ifdef SHADOW{X}\n#ifdef SHADOWCSM{X}\nuniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};\n#elif defined(SHADOWCUBE{X})\n#else\nvarying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};\n#endif\n#endif\n#endif\n";
        bt.IncludesShadersStore.morphTargetsVertexGlobalDeclaration = "#ifdef MORPHTARGETS\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\n#ifdef MORPHTARGETS_TEXTURE \nuniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)\n{ \nfloat y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}\n#endif\n#endif\n";
        bt.IncludesShadersStore.morphTargetsVertexDeclaration = "#ifdef MORPHTARGETS\n#ifndef MORPHTARGETS_TEXTURE\nattribute vec3 position{X};\n#ifdef MORPHTARGETS_NORMAL\nattribute vec3 normal{X};\n#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute vec3 tangent{X};\n#endif\n#ifdef MORPHTARGETS_UV\nattribute vec2 uv_{X};\n#endif\n#elif {X}==0\nuniform int morphTargetCount;\n#endif\n#endif\n";
        bt.IncludesShadersStore.morphTargetsVertexGlobal = "#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nfloat vertexID;\n#endif\n#endif\n";
        bt.IncludesShadersStore.morphTargetsVertex = "#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\n#if {X}==0\nfor (int i=0; i<NUM_MORPH_INFLUENCERS; i++) {if (i>=morphTargetCount) break;vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;positionUpdated+=(readVector3FromRawSampler(i,vertexID)-position)*morphTargetInfluences[i];vertexID+=1.0;\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(readVector3FromRawSampler(i,vertexID) -normal)*morphTargetInfluences[i];vertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(readVector3FromRawSampler(i,vertexID).xy-uv)*morphTargetInfluences[i];vertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(readVector3FromRawSampler(i,vertexID) -tangent.xyz)*morphTargetInfluences[i];\n#endif\n}\n#endif\n#else\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\n#endif\n#endif\n#endif\n";
        bt.IncludesShadersStore.instancesVertex = "#ifdef INSTANCES\nmat4 finalWorld=mat4(world0,world1,world2,world3);\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);\n#endif\n#ifdef THIN_INSTANCES\nfinalWorld=world*finalWorld;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nfinalPreviousWorld=previousWorld*finalPreviousWorld;\n#endif\n#endif\n#else\nmat4 finalWorld=world;\n#if defined(PREPASS_VELOCITY) || defined(VELOCITY)\nmat4 finalPreviousWorld=previousWorld;\n#endif\n#endif\n";
        bt.IncludesShadersStore.bonesVertex = "#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\n#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\n#endif\nfinalWorld=finalWorld*influence;\n#endif\n#endif\n";
        bt.IncludesShadersStore.bakedVertexAnimation = "#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\n{\n#ifdef INSTANCES\n#define BVASNAME bakedVertexAnimationSettingsInstanced\n#else\n#define BVASNAME bakedVertexAnimationSettings\n#endif\nfloat VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\n#endif\nfinalWorld=finalWorld*VATInfluence;}\n#endif\n";
        bt.IncludesShadersStore.prePassVertex = "#ifdef PREPASS_DEPTH\nvViewPos=(view*worldPos).rgb;\n#endif\n#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*worldPos;\n#if NUM_BONE_INFLUENCERS>0\nmat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\npreviousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif \n#if NUM_BONE_INFLUENCERS>2\npreviousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif \n#if NUM_BONE_INFLUENCERS>3\npreviousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif \n#if NUM_BONE_INFLUENCERS>5\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif \n#if NUM_BONE_INFLUENCERS>6\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif \n#if NUM_BONE_INFLUENCERS>7\npreviousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\nvPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);\n#else\nvPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#endif\n";
        bt.IncludesShadersStore.uvVariableDeclaration = "#if !defined(UV{X}) && defined(MAINUV{X})\nvec2 uv{X}=vec2(0.,0.);\n#endif\n#ifdef MAINUV{X}\nvMainUV{X}=uv{X};\n#endif\n";
        bt.IncludesShadersStore.samplerVertexImplementation = "#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0\nif (v_INFONAME_==0.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));}\n#ifdef UV2\nelse if (v_INFONAME_==1.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));}\n#endif\n#ifdef UV3\nelse if (v_INFONAME_==2.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));}\n#endif\n#ifdef UV4\nelse if (v_INFONAME_==3.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));}\n#endif\n#ifdef UV5\nelse if (v_INFONAME_==4.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));}\n#endif\n#ifdef UV6\nelse if (v_INFONAME_==5.)\n{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));}\n#endif\n#endif\n";
        bt.IncludesShadersStore.bumpVertex = "#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)\n#if defined(TANGENT) && defined(NORMAL)\nvec3 tbnNormal=normalize(normalUpdated);vec3 tbnTangent=normalize(tangentUpdated.xyz);vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);\n#endif\n#endif\n";
        bt.IncludesShadersStore.clipPlaneVertex = "#ifdef CLIPPLANE\nfClipDistance=dot(worldPos,vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nfClipDistance2=dot(worldPos,vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nfClipDistance3=dot(worldPos,vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nfClipDistance4=dot(worldPos,vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nfClipDistance5=dot(worldPos,vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nfClipDistance6=dot(worldPos,vClipPlane6);\n#endif\n";
        bt.IncludesShadersStore.fogVertex = "#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif\n";
        bt.IncludesShadersStore.shadowsVertex = "#ifdef SHADOWS\n#if defined(SHADOWCSM{X})\nvPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n}\n#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})\nvPositionFromLight{X}=lightMatrix{X}*worldPos;\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#else\nvDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;\n#endif\n#endif\n#endif\n";
        bt.IncludesShadersStore.vertexColorMixing = "#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvColor=vec4(1.0);\n#ifdef VERTEXCOLOR\n#ifdef VERTEXALPHA\nvColor*=color;\n#else\nvColor.rgb*=color.rgb;\n#endif\n#endif\n#ifdef INSTANCESCOLOR\nvColor*=instanceColor;\n#endif\n#endif\n";
        bt.IncludesShadersStore.pointCloudVertex = "#if defined(POINTSIZE) && !defined(WEBGPU)\ngl_PointSize=pointSize;\n#endif\n";
        bt.IncludesShadersStore.logDepthVertex = "#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif\n";
        bt.ShadersStore.defaultVertexShader = "#include<__decl__defaultVertex>\n#define CUSTOM_VERTEX_BEGIN\nattribute vec3 position;\n#ifdef NORMAL\nattribute vec3 normal;\n#endif\n#ifdef TANGENT\nattribute vec4 tangent;\n#endif\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#include<uvAttributeDeclaration>[2..7]\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<helperFunctions>\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<instancesDeclaration>\n#include<prePassVertexDeclaration>\n#include<mainUVVaryingDeclaration>[1..7]\n#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)\n#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)\n#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)\n#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)\n#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)\n#if defined(SPECULARTERM)\n#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)\n#endif\n#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)\n#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)\nvarying vec3 vPositionW;\n#ifdef NORMAL\nvarying vec3 vNormalW;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#include<bumpVertexDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<__decl__lightVxFragment>[0..maxSimultaneousLights]\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvarying vec3 vPositionUVW;\n#endif\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvarying vec3 vDirectionW;\n#endif\n#include<logDepthDeclaration>\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nvec3 positionUpdated=position;\n#ifdef NORMAL\nvec3 normalUpdated=normal;\n#endif\n#ifdef TANGENT\nvec4 tangentUpdated=tangent;\n#endif\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#ifdef REFLECTIONMAP_SKYBOX\nvPositionUVW=positionUpdated;\n#endif\n#define CUSTOM_VERTEX_UPDATE_POSITION\n#define CUSTOM_VERTEX_UPDATE_NORMAL\n#include<instancesVertex>\n#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)\nvCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);\n#endif\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#ifdef NORMAL\nmat3 normalWorld=mat3(finalWorld);\n#if defined(INSTANCES) && defined(THIN_INSTANCES)\nvNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);\n#else\n#ifdef NONUNIFORMSCALING\nnormalWorld=transposeMat3(inverseMat3(normalWorld));\n#endif\nvNormalW=normalize(normalWorld*normalUpdated);\n#endif\n#endif\n#define CUSTOM_VERTEX_UPDATE_WORLDPOS\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\nvPositionW=vec3(worldPos);\n#include<prePassVertex>\n#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)\nvDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));\n#endif\n#ifndef UV1\nvec2 uvUpdated=vec2(0.,0.);\n#endif\n#ifdef MAINUV1\nvMainUV1=uvUpdated;\n#endif\n#include<uvVariableDeclaration>[2..7]\n#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)\n#if defined(SPECULARTERM)\n#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)\n#endif\n#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)\n#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)\n#include<bumpVertex>\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<shadowsVertex>[0..maxSimultaneousLights]\n#include<vertexColorMixing>\n#include<pointCloudVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n";
        class ua {
            constructor() {
                this._defines = {},
                this._currentRank = 32,
                this._maxRank = -1,
                this._mesh = null
            }
            unBindMesh() {
                this._mesh = null
            }
            addFallback(e, t) {
                this._defines[e] || (e < this._currentRank && (this._currentRank = e),
                e > this._maxRank && (this._maxRank = e),
                this._defines[e] = new Array),
                this._defines[e].push(t)
            }
            addCPUSkinningFallback(e, t) {
                this._mesh = t,
                e < this._currentRank && (this._currentRank = e),
                e > this._maxRank && (this._maxRank = e)
            }
            get hasMoreFallbacks() {
                return this._currentRank <= this._maxRank
            }
            reduce(e, t) {
                if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
                    this._mesh.computeBonesUsingShaders = !1,
                    e = e.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0"),
                    t._bonesComputationForcedToCPU = !0;
                    const i = this._mesh.getScene();
                    for (let e = 0; e < i.meshes.length; e++) {
                        const s = i.meshes[e];
                        if (s.material) {
                            if (s.computeBonesUsingShaders && 0 !== s.numBoneInfluencers)
                                if (s.material.getEffect() === t)
                                    s.computeBonesUsingShaders = !1;
                                else if (s.subMeshes)
                                    for (const e of s.subMeshes)
                                        if (e.effect === t) {
                                            s.computeBonesUsingShaders = !1;
                                            break
                                        }
                        } else
                            !this._mesh.material && s.computeBonesUsingShaders && s.numBoneInfluencers > 0 && (s.computeBonesUsingShaders = !1)
                    }
                } else {
                    const t = this._defines[this._currentRank];
                    if (t)
                        for (let i = 0; i < t.length; i++)
                            e = e.replace("#define " + t[i], "");
                    this._currentRank++
                }
                return e
            }
        }
        class da extends ha {
            constructor() {
                super(...arguments),
                this.DETAIL = !1,
                this.DETAILDIRECTUV = 0,
                this.DETAIL_NORMALBLENDMETHOD = 0
            }
        }
        class fa extends bn {
            _markAllSubMeshesAsTexturesDirty() {
                this._enable(this._isEnabled),
                this._internalMarkAllSubMeshesAsTexturesDirty()
            }
            constructor(e, t=!0) {
                super(e, "DetailMap", 140, new da, t),
                this._texture = null,
                this.diffuseBlendLevel = 1,
                this.roughnessBlendLevel = 1,
                this.bumpLevel = 1,
                this._normalBlendMethod = Fr.MATERIAL_NORMALBLENDMETHOD_WHITEOUT,
                this._isEnabled = !1,
                this.isEnabled = !1,
                this._internalMarkAllSubMeshesAsTexturesDirty = e._dirtyCallbacks[1]
            }
            isReadyForSubMesh(e, t, i) {
                return !this._isEnabled || !(e._areTexturesDirty && t.texturesEnabled && i.getCaps().standardDerivatives && this._texture && ca.DetailTextureEnabled && !this._texture.isReady())
            }
            prepareDefines(e, t) {
                if (this._isEnabled) {
                    e.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
                    const i = t.getEngine();
                    e._areTexturesDirty && (i.getCaps().standardDerivatives && this._texture && ca.DetailTextureEnabled && this._isEnabled ? (Ar(this._texture, e, "DETAIL"),
                    e.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod) : e.DETAIL = !1)
                } else
                    e.DETAIL = !1
            }
            bindForSubMesh(e, t) {
                if (!this._isEnabled)
                    return;
                const i = this._material.isFrozen;
                e.useUbo && i && e.isSync || this._texture && ca.DetailTextureEnabled && (e.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel),
                Ir(this._texture, e, "detail")),
                t.texturesEnabled && this._texture && ca.DetailTextureEnabled && e.setTexture("detailSampler", this._texture)
            }
            hasTexture(e) {
                return this._texture === e
            }
            getActiveTextures(e) {
                this._texture && e.push(this._texture)
            }
            getAnimatables(e) {
                this._texture && this._texture.animations && this._texture.animations.length > 0 && e.push(this._texture)
            }
            dispose(e) {
                e && this._texture?.dispose()
            }
            getClassName() {
                return "DetailMapConfiguration"
            }
            getSamplers(e) {
                e.push("detailSampler")
            }
            getUniforms() {
                return {
                    ubo: [{
                        name: "vDetailInfos",
                        size: 4,
                        type: "vec4"
                    }, {
                        name: "detailMatrix",
                        size: 16,
                        type: "mat4"
                    }]
                }
            }
        }
        pi([Ti("detailTexture"), bi("_markAllSubMeshesAsTexturesDirty")], fa.prototype, "texture", void 0),
        pi([xi()], fa.prototype, "diffuseBlendLevel", void 0),
        pi([xi()], fa.prototype, "roughnessBlendLevel", void 0),
        pi([xi()], fa.prototype, "bumpLevel", void 0),
        pi([xi(), bi("_markAllSubMeshesAsTexturesDirty")], fa.prototype, "normalBlendMethod", void 0),
        pi([xi(), bi("_markAllSubMeshesAsTexturesDirty")], fa.prototype, "isEnabled", void 0);
        const _a = {
            effect: null,
            subMesh: null
        };
        class pa extends ha {
            constructor(e) {
                super(e),
                this.MAINUV1 = !1,
                this.MAINUV2 = !1,
                this.MAINUV3 = !1,
                this.MAINUV4 = !1,
                this.MAINUV5 = !1,
                this.MAINUV6 = !1,
                this.DIFFUSE = !1,
                this.DIFFUSEDIRECTUV = 0,
                this.BAKED_VERTEX_ANIMATION_TEXTURE = !1,
                this.AMBIENT = !1,
                this.AMBIENTDIRECTUV = 0,
                this.OPACITY = !1,
                this.OPACITYDIRECTUV = 0,
                this.OPACITYRGB = !1,
                this.REFLECTION = !1,
                this.EMISSIVE = !1,
                this.EMISSIVEDIRECTUV = 0,
                this.SPECULAR = !1,
                this.SPECULARDIRECTUV = 0,
                this.BUMP = !1,
                this.BUMPDIRECTUV = 0,
                this.PARALLAX = !1,
                this.PARALLAX_RHS = !1,
                this.PARALLAXOCCLUSION = !1,
                this.SPECULAROVERALPHA = !1,
                this.CLIPPLANE = !1,
                this.CLIPPLANE2 = !1,
                this.CLIPPLANE3 = !1,
                this.CLIPPLANE4 = !1,
                this.CLIPPLANE5 = !1,
                this.CLIPPLANE6 = !1,
                this.ALPHATEST = !1,
                this.DEPTHPREPASS = !1,
                this.ALPHAFROMDIFFUSE = !1,
                this.POINTSIZE = !1,
                this.FOG = !1,
                this.SPECULARTERM = !1,
                this.DIFFUSEFRESNEL = !1,
                this.OPACITYFRESNEL = !1,
                this.REFLECTIONFRESNEL = !1,
                this.REFRACTIONFRESNEL = !1,
                this.EMISSIVEFRESNEL = !1,
                this.FRESNEL = !1,
                this.NORMAL = !1,
                this.TANGENT = !1,
                this.UV1 = !1,
                this.UV2 = !1,
                this.UV3 = !1,
                this.UV4 = !1,
                this.UV5 = !1,
                this.UV6 = !1,
                this.VERTEXCOLOR = !1,
                this.VERTEXALPHA = !1,
                this.NUM_BONE_INFLUENCERS = 0,
                this.BonesPerMesh = 0,
                this.BONETEXTURE = !1,
                this.BONES_VELOCITY_ENABLED = !1,
                this.INSTANCES = !1,
                this.THIN_INSTANCES = !1,
                this.INSTANCESCOLOR = !1,
                this.GLOSSINESS = !1,
                this.ROUGHNESS = !1,
                this.EMISSIVEASILLUMINATION = !1,
                this.LINKEMISSIVEWITHDIFFUSE = !1,
                this.REFLECTIONFRESNELFROMSPECULAR = !1,
                this.LIGHTMAP = !1,
                this.LIGHTMAPDIRECTUV = 0,
                this.OBJECTSPACE_NORMALMAP = !1,
                this.USELIGHTMAPASSHADOWMAP = !1,
                this.REFLECTIONMAP_3D = !1,
                this.REFLECTIONMAP_SPHERICAL = !1,
                this.REFLECTIONMAP_PLANAR = !1,
                this.REFLECTIONMAP_CUBIC = !1,
                this.USE_LOCAL_REFLECTIONMAP_CUBIC = !1,
                this.USE_LOCAL_REFRACTIONMAP_CUBIC = !1,
                this.REFLECTIONMAP_PROJECTION = !1,
                this.REFLECTIONMAP_SKYBOX = !1,
                this.REFLECTIONMAP_EXPLICIT = !1,
                this.REFLECTIONMAP_EQUIRECTANGULAR = !1,
                this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1,
                this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1,
                this.REFLECTIONMAP_OPPOSITEZ = !1,
                this.INVERTCUBICMAP = !1,
                this.LOGARITHMICDEPTH = !1,
                this.REFRACTION = !1,
                this.REFRACTIONMAP_3D = !1,
                this.REFLECTIONOVERALPHA = !1,
                this.TWOSIDEDLIGHTING = !1,
                this.SHADOWFLOAT = !1,
                this.MORPHTARGETS = !1,
                this.MORPHTARGETS_NORMAL = !1,
                this.MORPHTARGETS_TANGENT = !1,
                this.MORPHTARGETS_UV = !1,
                this.NUM_MORPH_INFLUENCERS = 0,
                this.MORPHTARGETS_TEXTURE = !1,
                this.NONUNIFORMSCALING = !1,
                this.PREMULTIPLYALPHA = !1,
                this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = !1,
                this.ALPHABLEND = !0,
                this.PREPASS = !1,
                this.PREPASS_IRRADIANCE = !1,
                this.PREPASS_IRRADIANCE_INDEX = -1,
                this.PREPASS_ALBEDO_SQRT = !1,
                this.PREPASS_ALBEDO_SQRT_INDEX = -1,
                this.PREPASS_DEPTH = !1,
                this.PREPASS_DEPTH_INDEX = -1,
                this.PREPASS_NORMAL = !1,
                this.PREPASS_NORMAL_INDEX = -1,
                this.PREPASS_NORMAL_WORLDSPACE = !1,
                this.PREPASS_POSITION = !1,
                this.PREPASS_POSITION_INDEX = -1,
                this.PREPASS_VELOCITY = !1,
                this.PREPASS_VELOCITY_INDEX = -1,
                this.PREPASS_REFLECTIVITY = !1,
                this.PREPASS_REFLECTIVITY_INDEX = -1,
                this.SCENE_MRT_COUNT = 0,
                this.RGBDLIGHTMAP = !1,
                this.RGBDREFLECTION = !1,
                this.RGBDREFRACTION = !1,
                this.IMAGEPROCESSING = !1,
                this.VIGNETTE = !1,
                this.VIGNETTEBLENDMODEMULTIPLY = !1,
                this.VIGNETTEBLENDMODEOPAQUE = !1,
                this.TONEMAPPING = !1,
                this.TONEMAPPING_ACES = !1,
                this.CONTRAST = !1,
                this.COLORCURVES = !1,
                this.COLORGRADING = !1,
                this.COLORGRADING3D = !1,
                this.SAMPLER3DGREENDEPTH = !1,
                this.SAMPLER3DBGRMAP = !1,
                this.DITHER = !1,
                this.IMAGEPROCESSINGPOSTPROCESS = !1,
                this.SKIPFINALCOLORCLAMP = !1,
                this.MULTIVIEW = !1,
                this.ORDER_INDEPENDENT_TRANSPARENCY = !1,
                this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !1,
                this.CAMERA_ORTHOGRAPHIC = !1,
                this.CAMERA_PERSPECTIVE = !1,
                this.IS_REFLECTION_LINEAR = !1,
                this.IS_REFRACTION_LINEAR = !1,
                this.EXPOSURE = !1,
                this.DECAL_AFTER_DETAIL = !1,
                this.rebuild()
            }
            setReflectionMode(e) {
                const t = ["REFLECTIONMAP_CUBIC", "REFLECTIONMAP_EXPLICIT", "REFLECTIONMAP_PLANAR", "REFLECTIONMAP_PROJECTION", "REFLECTIONMAP_PROJECTION", "REFLECTIONMAP_SKYBOX", "REFLECTIONMAP_SPHERICAL", "REFLECTIONMAP_EQUIRECTANGULAR", "REFLECTIONMAP_EQUIRECTANGULAR_FIXED", "REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"];
                for (const i of t)
                    this[i] = i === e
            }
        }
        class ma extends la {
            get imageProcessingConfiguration() {
                return this._imageProcessingConfiguration
            }
            set imageProcessingConfiguration(e) {
                this._attachImageProcessingConfiguration(e),
                this._markAllSubMeshesAsTexturesDirty()
            }
            _attachImageProcessingConfiguration(e) {
                e !== this._imageProcessingConfiguration && (this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),
                this._imageProcessingConfiguration = e || this.getScene().imageProcessingConfiguration,
                this._imageProcessingConfiguration && (this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(( () => {
                    this._markAllSubMeshesAsImageProcessingDirty()
                }
                ))))
            }
            get isPrePassCapable() {
                return !this.disableDepthWrite
            }
            get cameraColorCurvesEnabled() {
                return this.imageProcessingConfiguration.colorCurvesEnabled
            }
            set cameraColorCurvesEnabled(e) {
                this.imageProcessingConfiguration.colorCurvesEnabled = e
            }
            get cameraColorGradingEnabled() {
                return this.imageProcessingConfiguration.colorGradingEnabled
            }
            set cameraColorGradingEnabled(e) {
                this.imageProcessingConfiguration.colorGradingEnabled = e
            }
            get cameraToneMappingEnabled() {
                return this._imageProcessingConfiguration.toneMappingEnabled
            }
            set cameraToneMappingEnabled(e) {
                this._imageProcessingConfiguration.toneMappingEnabled = e
            }
            get cameraExposure() {
                return this._imageProcessingConfiguration.exposure
            }
            set cameraExposure(e) {
                this._imageProcessingConfiguration.exposure = e
            }
            get cameraContrast() {
                return this._imageProcessingConfiguration.contrast
            }
            set cameraContrast(e) {
                this._imageProcessingConfiguration.contrast = e
            }
            get cameraColorGradingTexture() {
                return this._imageProcessingConfiguration.colorGradingTexture
            }
            set cameraColorGradingTexture(e) {
                this._imageProcessingConfiguration.colorGradingTexture = e
            }
            get cameraColorCurves() {
                return this._imageProcessingConfiguration.colorCurves
            }
            set cameraColorCurves(e) {
                this._imageProcessingConfiguration.colorCurves = e
            }
            get canRenderToMRT() {
                return !0
            }
            constructor(e, t) {
                super(e, t),
                this._diffuseTexture = null,
                this._ambientTexture = null,
                this._opacityTexture = null,
                this._reflectionTexture = null,
                this._emissiveTexture = null,
                this._specularTexture = null,
                this._bumpTexture = null,
                this._lightmapTexture = null,
                this._refractionTexture = null,
                this.ambientColor = new Fe(0,0,0),
                this.diffuseColor = new Fe(1,1,1),
                this.specularColor = new Fe(1,1,1),
                this.emissiveColor = new Fe(0,0,0),
                this.specularPower = 64,
                this._useAlphaFromDiffuseTexture = !1,
                this._useEmissiveAsIllumination = !1,
                this._linkEmissiveWithDiffuse = !1,
                this._useSpecularOverAlpha = !1,
                this._useReflectionOverAlpha = !1,
                this._disableLighting = !1,
                this._useObjectSpaceNormalMap = !1,
                this._useParallax = !1,
                this._useParallaxOcclusion = !1,
                this.parallaxScaleBias = .05,
                this._roughness = 0,
                this.indexOfRefraction = .98,
                this.invertRefractionY = !0,
                this.alphaCutOff = .4,
                this._useLightmapAsShadowmap = !1,
                this._useReflectionFresnelFromSpecular = !1,
                this._useGlossinessFromSpecularMapAlpha = !1,
                this._maxSimultaneousLights = 4,
                this._invertNormalMapX = !1,
                this._invertNormalMapY = !1,
                this._twoSidedLighting = !1,
                this._applyDecalMapAfterDetailMap = !1,
                this._renderTargets = new Ii(16),
                this._worldViewProjectionMatrix = Oi.Zero(),
                this._globalAmbientColor = new Fe(0,0,0),
                this._cacheHasRenderTargetTextures = !1,
                this.detailMap = new fa(this),
                this._attachImageProcessingConfiguration(null),
                this.prePassConfiguration = new oa,
                this.getRenderTargetTextures = () => (this._renderTargets.reset(),
                ma.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget && this._renderTargets.push(this._reflectionTexture),
                ma.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget && this._renderTargets.push(this._refractionTexture),
                this._eventInfo.renderTargets = this._renderTargets,
                this._callbackPluginEventFillRenderTargetTextures(this._eventInfo),
                this._renderTargets)
            }
            get hasRenderTargetTextures() {
                return !!(ma.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) || !!(ma.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) || this._cacheHasRenderTargetTextures
            }
            getClassName() {
                return "StandardMaterial"
            }
            needAlphaBlending() {
                return !this._disableAlphaBlending && (this.alpha < 1 || null != this._opacityTexture || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled)
            }
            needAlphaTesting() {
                return !!this._forceAlphaTest || this._hasAlphaChannel() && (null == this._transparencyMode || this._transparencyMode === Fr.MATERIAL_ALPHATEST)
            }
            _shouldUseAlphaFromDiffuseTexture() {
                return null != this._diffuseTexture && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Fr.MATERIAL_OPAQUE
            }
            _hasAlphaChannel() {
                return null != this._diffuseTexture && this._diffuseTexture.hasAlpha || null != this._opacityTexture
            }
            getAlphaTestTexture() {
                return this._diffuseTexture
            }
            isReadyForSubMesh(e, t, i=!1) {
                this._uniformBufferLayoutBuilt || this.buildUniformLayout();
                const s = t._drawWrapper;
                if (s.effect && this.isFrozen && s._wasPreviouslyReady && s._wasPreviouslyUsingInstances === i)
                    return !0;
                t.materialDefines || (this._callbackPluginEventGeneric(pr.GetDefineNames, this._eventInfo),
                t.materialDefines = new pa(this._eventInfo.defineNames));
                const r = this.getScene()
                  , n = t.materialDefines;
                if (this._isReadyForSubMesh(t))
                    return !0;
                const a = r.getEngine();
                n._needNormals = function(e, t, i, s, r=4, n=!1) {
                    if (!i._areLightsDirty)
                        return i._needNormals;
                    let a = 0;
                    const o = {
                        needNormals: i._needNormals,
                        needRebuild: !1,
                        lightmapMode: !1,
                        shadowEnabled: !1,
                        specularEnabled: !1
                    };
                    if (e.lightsEnabled && !n)
                        for (const n of t.lightSources)
                            if (Dr(e, t, n, a, i, s, o),
                            a++,
                            a === r)
                                break;
                    i.SPECULARTERM = o.specularEnabled,
                    i.SHADOWS = o.shadowEnabled;
                    for (let e = a; e < r; e++)
                        void 0 !== i["LIGHT" + e] && (i["LIGHT" + e] = !1,
                        i["HEMILIGHT" + e] = !1,
                        i["POINTLIGHT" + e] = !1,
                        i["DIRLIGHT" + e] = !1,
                        i["SPOTLIGHT" + e] = !1,
                        i["SHADOW" + e] = !1,
                        i["SHADOWCSM" + e] = !1,
                        i["SHADOWCSMDEBUG" + e] = !1,
                        i["SHADOWCSMNUM_CASCADES" + e] = !1,
                        i["SHADOWCSMUSESHADOWMAXZ" + e] = !1,
                        i["SHADOWCSMNOBLEND" + e] = !1,
                        i["SHADOWCSM_RIGHTHANDED" + e] = !1,
                        i["SHADOWPCF" + e] = !1,
                        i["SHADOWPCSS" + e] = !1,
                        i["SHADOWPOISSON" + e] = !1,
                        i["SHADOWESM" + e] = !1,
                        i["SHADOWCLOSEESM" + e] = !1,
                        i["SHADOWCUBE" + e] = !1,
                        i["SHADOWLOWQUALITY" + e] = !1,
                        i["SHADOWMEDIUMQUALITY" + e] = !1);
                    const h = e.getEngine().getCaps();
                    return void 0 === i.SHADOWFLOAT && (o.needRebuild = !0),
                    i.SHADOWFLOAT = o.shadowEnabled && (h.textureFloatRender && h.textureFloatLinearFiltering || h.textureHalfFloatRender && h.textureHalfFloatLinearFiltering),
                    i.LIGHTMAPEXCLUDED = o.lightmapMode,
                    o.needRebuild && i.rebuild(),
                    o.needNormals
                }(r, e, n, !0, this._maxSimultaneousLights, this._disableLighting),
                function(e, t) {
                    if (e.activeCamera) {
                        const i = t.MULTIVIEW;
                        t.MULTIVIEW = null !== e.activeCamera.outputRenderTarget && e.activeCamera.outputRenderTarget.getViewCount() > 1,
                        t.MULTIVIEW != i && t.markAsUnprocessed()
                    }
                }(r, n);
                const o = this.needAlphaBlendingForMesh(e) && this.getScene().useOrderIndependentTransparency;
                if (function(e, t, i) {
                    const s = t.PREPASS;
                    if (!t._arePrePassDirty)
                        return;
                    const r = [{
                        type: 1,
                        define: "PREPASS_POSITION",
                        index: "PREPASS_POSITION_INDEX"
                    }, {
                        type: 2,
                        define: "PREPASS_VELOCITY",
                        index: "PREPASS_VELOCITY_INDEX"
                    }, {
                        type: 3,
                        define: "PREPASS_REFLECTIVITY",
                        index: "PREPASS_REFLECTIVITY_INDEX"
                    }, {
                        type: 0,
                        define: "PREPASS_IRRADIANCE",
                        index: "PREPASS_IRRADIANCE_INDEX"
                    }, {
                        type: 7,
                        define: "PREPASS_ALBEDO_SQRT",
                        index: "PREPASS_ALBEDO_SQRT_INDEX"
                    }, {
                        type: 5,
                        define: "PREPASS_DEPTH",
                        index: "PREPASS_DEPTH_INDEX"
                    }, {
                        type: 6,
                        define: "PREPASS_NORMAL",
                        index: "PREPASS_NORMAL_INDEX"
                    }];
                    if (e.prePassRenderer && e.prePassRenderer.enabled && i) {
                        t.PREPASS = !0,
                        t.SCENE_MRT_COUNT = e.prePassRenderer.mrtCount,
                        t.PREPASS_NORMAL_WORLDSPACE = e.prePassRenderer.generateNormalsInWorldSpace;
                        for (let i = 0; i < r.length; i++) {
                            const s = e.prePassRenderer.getIndex(r[i].type);
                            -1 !== s ? (t[r[i].define] = !0,
                            t[r[i].index] = s) : t[r[i].define] = !1
                        }
                    } else {
                        t.PREPASS = !1;
                        for (let e = 0; e < r.length; e++)
                            t[r[e].define] = !1
                    }
                    t.PREPASS != s && (t.markAsUnprocessed(),
                    t.markAsImageProcessingDirty())
                }(r, n, this.canRenderToMRT && !o),
                function(e, t, i) {
                    const s = t.ORDER_INDEPENDENT_TRANSPARENCY
                      , r = t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;
                    t.ORDER_INDEPENDENT_TRANSPARENCY = e.useOrderIndependentTransparency && i,
                    t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !e.getEngine().getCaps().textureFloatLinearFiltering,
                    s === t.ORDER_INDEPENDENT_TRANSPARENCY && r === t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS || t.markAsUnprocessed()
                }(r, n, o),
                n._areTexturesDirty) {
                    this._eventInfo.hasRenderTargetTextures = !1,
                    this._callbackPluginEventHasRenderTargetTextures(this._eventInfo),
                    this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures,
                    n._needUVs = !1;
                    for (let e = 1; e <= 6; ++e)
                        n["MAINUV" + e] = !1;
                    if (r.texturesEnabled) {
                        if (n.DIFFUSEDIRECTUV = 0,
                        n.BUMPDIRECTUV = 0,
                        n.AMBIENTDIRECTUV = 0,
                        n.OPACITYDIRECTUV = 0,
                        n.EMISSIVEDIRECTUV = 0,
                        n.SPECULARDIRECTUV = 0,
                        n.LIGHTMAPDIRECTUV = 0,
                        this._diffuseTexture && ma.DiffuseTextureEnabled) {
                            if (!this._diffuseTexture.isReadyOrNotBlocking())
                                return !1;
                            Ar(this._diffuseTexture, n, "DIFFUSE")
                        } else
                            n.DIFFUSE = !1;
                        if (this._ambientTexture && ma.AmbientTextureEnabled) {
                            if (!this._ambientTexture.isReadyOrNotBlocking())
                                return !1;
                            Ar(this._ambientTexture, n, "AMBIENT")
                        } else
                            n.AMBIENT = !1;
                        if (this._opacityTexture && ma.OpacityTextureEnabled) {
                            if (!this._opacityTexture.isReadyOrNotBlocking())
                                return !1;
                            Ar(this._opacityTexture, n, "OPACITY"),
                            n.OPACITYRGB = this._opacityTexture.getAlphaFromRGB
                        } else
                            n.OPACITY = !1;
                        if (this._reflectionTexture && ma.ReflectionTextureEnabled) {
                            if (!this._reflectionTexture.isReadyOrNotBlocking())
                                return !1;
                            switch (n._needNormals = !0,
                            n.REFLECTION = !0,
                            n.ROUGHNESS = this._roughness > 0,
                            n.REFLECTIONOVERALPHA = this._useReflectionOverAlpha,
                            n.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === _n.INVCUBIC_MODE,
                            n.REFLECTIONMAP_3D = this._reflectionTexture.isCube,
                            n.REFLECTIONMAP_OPPOSITEZ = n.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ,
                            n.RGBDREFLECTION = this._reflectionTexture.isRGBD,
                            this._reflectionTexture.coordinatesMode) {
                            case _n.EXPLICIT_MODE:
                                n.setReflectionMode("REFLECTIONMAP_EXPLICIT");
                                break;
                            case _n.PLANAR_MODE:
                                n.setReflectionMode("REFLECTIONMAP_PLANAR");
                                break;
                            case _n.PROJECTION_MODE:
                                n.setReflectionMode("REFLECTIONMAP_PROJECTION");
                                break;
                            case _n.SKYBOX_MODE:
                                n.setReflectionMode("REFLECTIONMAP_SKYBOX");
                                break;
                            case _n.SPHERICAL_MODE:
                                n.setReflectionMode("REFLECTIONMAP_SPHERICAL");
                                break;
                            case _n.EQUIRECTANGULAR_MODE:
                                n.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");
                                break;
                            case _n.FIXED_EQUIRECTANGULAR_MODE:
                                n.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
                                break;
                            case _n.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                                n.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
                                break;
                            case _n.CUBIC_MODE:
                            case _n.INVCUBIC_MODE:
                            default:
                                n.setReflectionMode("REFLECTIONMAP_CUBIC")
                            }
                            n.USE_LOCAL_REFLECTIONMAP_CUBIC = !!this._reflectionTexture.boundingBoxSize
                        } else
                            n.REFLECTION = !1,
                            n.REFLECTIONMAP_OPPOSITEZ = !1;
                        if (this._emissiveTexture && ma.EmissiveTextureEnabled) {
                            if (!this._emissiveTexture.isReadyOrNotBlocking())
                                return !1;
                            Ar(this._emissiveTexture, n, "EMISSIVE")
                        } else
                            n.EMISSIVE = !1;
                        if (this._lightmapTexture && ma.LightmapTextureEnabled) {
                            if (!this._lightmapTexture.isReadyOrNotBlocking())
                                return !1;
                            Ar(this._lightmapTexture, n, "LIGHTMAP"),
                            n.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap,
                            n.RGBDLIGHTMAP = this._lightmapTexture.isRGBD
                        } else
                            n.LIGHTMAP = !1;
                        if (this._specularTexture && ma.SpecularTextureEnabled) {
                            if (!this._specularTexture.isReadyOrNotBlocking())
                                return !1;
                            Ar(this._specularTexture, n, "SPECULAR"),
                            n.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha
                        } else
                            n.SPECULAR = !1;
                        if (r.getEngine().getCaps().standardDerivatives && this._bumpTexture && ma.BumpTextureEnabled) {
                            if (!this._bumpTexture.isReady())
                                return !1;
                            Ar(this._bumpTexture, n, "BUMP"),
                            n.PARALLAX = this._useParallax,
                            n.PARALLAX_RHS = r.useRightHandedSystem,
                            n.PARALLAXOCCLUSION = this._useParallaxOcclusion,
                            n.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap
                        } else
                            n.BUMP = !1,
                            n.PARALLAX = !1,
                            n.PARALLAX_RHS = !1,
                            n.PARALLAXOCCLUSION = !1;
                        if (this._refractionTexture && ma.RefractionTextureEnabled) {
                            if (!this._refractionTexture.isReadyOrNotBlocking())
                                return !1;
                            n._needUVs = !0,
                            n.REFRACTION = !0,
                            n.REFRACTIONMAP_3D = this._refractionTexture.isCube,
                            n.RGBDREFRACTION = this._refractionTexture.isRGBD,
                            n.USE_LOCAL_REFRACTIONMAP_CUBIC = !!this._refractionTexture.boundingBoxSize
                        } else
                            n.REFRACTION = !1;
                        n.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting
                    } else
                        n.DIFFUSE = !1,
                        n.AMBIENT = !1,
                        n.OPACITY = !1,
                        n.REFLECTION = !1,
                        n.EMISSIVE = !1,
                        n.LIGHTMAP = !1,
                        n.BUMP = !1,
                        n.REFRACTION = !1;
                    n.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture(),
                    n.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination,
                    n.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse,
                    n.SPECULAROVERALPHA = this._useSpecularOverAlpha,
                    n.PREMULTIPLYALPHA = 7 === this.alphaMode || 8 === this.alphaMode,
                    n.ALPHATEST_AFTERALLALPHACOMPUTATIONS = null !== this.transparencyMode,
                    n.ALPHABLEND = null === this.transparencyMode || this.needAlphaBlendingForMesh(e)
                }
                if (this._eventInfo.isReadyForSubMesh = !0,
                this._eventInfo.defines = n,
                this._eventInfo.subMesh = t,
                this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),
                !this._eventInfo.isReadyForSubMesh)
                    return !1;
                if (n._areImageProcessingDirty && this._imageProcessingConfiguration) {
                    if (!this._imageProcessingConfiguration.isReady())
                        return !1;
                    this._imageProcessingConfiguration.prepareDefines(n),
                    n.IS_REFLECTION_LINEAR = null != this.reflectionTexture && !this.reflectionTexture.gammaSpace,
                    n.IS_REFRACTION_LINEAR = null != this.refractionTexture && !this.refractionTexture.gammaSpace
                }
                n._areFresnelDirty && (ma.FresnelEnabled ? (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) && (n.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled,
                n.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled,
                n.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled,
                n.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular,
                n.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled,
                n.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled,
                n._needNormals = !0,
                n.FRESNEL = !0) : n.FRESNEL = !1),
                function(e, t, i, s, r, n, a, o=!1) {
                    a._areMiscDirty && (a.LOGARITHMICDEPTH = i,
                    a.POINTSIZE = s,
                    a.FOG = r && function(e, t) {
                        return t.fogEnabled && e.applyFog && 0 !== t.fogMode
                    }(e, t),
                    a.NONUNIFORMSCALING = e.nonUniformScaling,
                    a.ALPHATEST = n,
                    a.DECAL_AFTER_DETAIL = o)
                }(e, r, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(e) || this._forceAlphaTest, n, this._applyDecalMapAfterDetailMap),
                function(e, t, i, s, r, n=null, a=!1) {
                    let o = function(e, t) {
                        let i = !1;
                        if (e.activeCamera) {
                            const s = t.CAMERA_ORTHOGRAPHIC ? 1 : 0
                              , r = t.CAMERA_PERSPECTIVE ? 1 : 0
                              , n = 1 === e.activeCamera.mode ? 1 : 0
                              , a = 0 === e.activeCamera.mode ? 1 : 0;
                            (s ^ n || r ^ a) && (t.CAMERA_ORTHOGRAPHIC = 1 === n,
                            t.CAMERA_PERSPECTIVE = 1 === a,
                            i = !0)
                        }
                        return i
                    }(e, s);
                    !1 !== n && (o = function(e, t, i) {
                        let s = !1;
                        const r = !!(e.clipPlane ?? t.clipPlane)
                          , n = !!(e.clipPlane2 ?? t.clipPlane2)
                          , a = !!(e.clipPlane3 ?? t.clipPlane3)
                          , o = !!(e.clipPlane4 ?? t.clipPlane4)
                          , h = !!(e.clipPlane5 ?? t.clipPlane5)
                          , l = !!(e.clipPlane6 ?? t.clipPlane6);
                        return i.CLIPPLANE !== r && (i.CLIPPLANE = r,
                        s = !0),
                        i.CLIPPLANE2 !== n && (i.CLIPPLANE2 = n,
                        s = !0),
                        i.CLIPPLANE3 !== a && (i.CLIPPLANE3 = a,
                        s = !0),
                        i.CLIPPLANE4 !== o && (i.CLIPPLANE4 = o,
                        s = !0),
                        i.CLIPPLANE5 !== h && (i.CLIPPLANE5 = h,
                        s = !0),
                        i.CLIPPLANE6 !== l && (i.CLIPPLANE6 = l,
                        s = !0),
                        s
                    }(i, e, s)),
                    s.DEPTHPREPASS !== !t.getColorWrite() && (s.DEPTHPREPASS = !s.DEPTHPREPASS,
                    o = !0),
                    s.INSTANCES !== r && (s.INSTANCES = r,
                    o = !0),
                    s.THIN_INSTANCES !== a && (s.THIN_INSTANCES = a,
                    o = !0),
                    o && s.markAsUnprocessed()
                }(r, a, this, n, i, null, t.getRenderingMesh().hasThinInstances),
                this._eventInfo.defines = n,
                this._eventInfo.mesh = e,
                this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo),
                function(e, t, i, s, r=!1, n=!0, a=!0) {
                    if (!t._areAttributesDirty && t._needNormals === t._normals && t._needUVs === t._uvs)
                        return !1;
                    t._normals = t._needNormals,
                    t._uvs = t._needUVs,
                    t.NORMAL = t._needNormals && e.isVerticesDataPresent("normal"),
                    t._needNormals && e.isVerticesDataPresent("tangent") && (t.TANGENT = !0);
                    for (let i = 1; i <= 6; ++i)
                        t["UV" + i] = !!t._needUVs && e.isVerticesDataPresent(`uv${1 === i ? "" : i}`);
                    if (i) {
                        const i = e.useVertexColors && e.isVerticesDataPresent("color");
                        t.VERTEXCOLOR = i,
                        t.VERTEXALPHA = e.hasVertexAlpha && i && n
                    }
                    e.isVerticesDataPresent("instanceColor") && (e.hasInstances || e.hasThinInstances) && (t.INSTANCESCOLOR = !0),
                    s && function(e, t) {
                        if (e.useBones && e.computeBonesUsingShaders && e.skeleton) {
                            t.NUM_BONE_INFLUENCERS = e.numBoneInfluencers;
                            const i = void 0 !== t.BONETEXTURE;
                            if (e.skeleton.isUsingTextureForMatrices && i)
                                t.BONETEXTURE = !0;
                            else {
                                t.BonesPerMesh = e.skeleton.bones.length + 1,
                                t.BONETEXTURE = !i && void 0;
                                const s = e.getScene().prePassRenderer;
                                if (s && s.enabled) {
                                    const i = -1 === s.excludedSkinnedMesh.indexOf(e);
                                    t.BONES_VELOCITY_ENABLED = i
                                }
                            }
                        } else
                            t.NUM_BONE_INFLUENCERS = 0,
                            t.BonesPerMesh = 0,
                            void 0 !== t.BONETEXTURE && (t.BONETEXTURE = !1)
                    }(e, t),
                    r && function(e, t) {
                        const i = e.morphTargetManager;
                        i ? (t.MORPHTARGETS_UV = i.supportsUVs && t.UV1,
                        t.MORPHTARGETS_TANGENT = i.supportsTangents && t.TANGENT,
                        t.MORPHTARGETS_NORMAL = i.supportsNormals && t.NORMAL,
                        t.NUM_MORPH_INFLUENCERS = i.numMaxInfluencers || i.numInfluencers,
                        t.MORPHTARGETS = t.NUM_MORPH_INFLUENCERS > 0,
                        t.MORPHTARGETS_TEXTURE = i.isUsingTextureForTargets) : (t.MORPHTARGETS_UV = !1,
                        t.MORPHTARGETS_TANGENT = !1,
                        t.MORPHTARGETS_NORMAL = !1,
                        t.MORPHTARGETS = !1,
                        t.NUM_MORPH_INFLUENCERS = 0)
                    }(e, t),
                    a && function(e, t) {
                        const i = e.bakedVertexAnimationManager;
                        t.BAKED_VERTEX_ANIMATION_TEXTURE = !(!i || !i.isEnabled)
                    }(e, t)
                }(e, n, !0, !0, !0),
                this._callbackPluginEventPrepareDefines(this._eventInfo);
                let h = !1;
                if (n.isDirty) {
                    const i = n._areLightsDisposed;
                    n.markAsProcessed();
                    const s = new ua;
                    n.REFLECTION && s.addFallback(0, "REFLECTION"),
                    n.SPECULAR && s.addFallback(0, "SPECULAR"),
                    n.BUMP && s.addFallback(0, "BUMP"),
                    n.PARALLAX && s.addFallback(1, "PARALLAX"),
                    n.PARALLAX_RHS && s.addFallback(1, "PARALLAX_RHS"),
                    n.PARALLAXOCCLUSION && s.addFallback(0, "PARALLAXOCCLUSION"),
                    n.SPECULAROVERALPHA && s.addFallback(0, "SPECULAROVERALPHA"),
                    n.FOG && s.addFallback(1, "FOG"),
                    n.POINTSIZE && s.addFallback(0, "POINTSIZE"),
                    n.LOGARITHMICDEPTH && s.addFallback(0, "LOGARITHMICDEPTH"),
                    function(e, t, i=4, s=0) {
                        let r = 0;
                        for (let n = 0; n < i && e["LIGHT" + n]; n++)
                            n > 0 && (r = s + n,
                            t.addFallback(r, "LIGHT" + n)),
                            e.SHADOWS || (e["SHADOW" + n] && t.addFallback(s, "SHADOW" + n),
                            e["SHADOWPCF" + n] && t.addFallback(s, "SHADOWPCF" + n),
                            e["SHADOWPCSS" + n] && t.addFallback(s, "SHADOWPCSS" + n),
                            e["SHADOWPOISSON" + n] && t.addFallback(s, "SHADOWPOISSON" + n),
                            e["SHADOWESM" + n] && t.addFallback(s, "SHADOWESM" + n),
                            e["SHADOWCLOSEESM" + n] && t.addFallback(s, "SHADOWCLOSEESM" + n));
                        r++
                    }(n, s, this._maxSimultaneousLights),
                    n.SPECULARTERM && s.addFallback(0, "SPECULARTERM"),
                    n.DIFFUSEFRESNEL && s.addFallback(1, "DIFFUSEFRESNEL"),
                    n.OPACITYFRESNEL && s.addFallback(2, "OPACITYFRESNEL"),
                    n.REFLECTIONFRESNEL && s.addFallback(3, "REFLECTIONFRESNEL"),
                    n.EMISSIVEFRESNEL && s.addFallback(4, "EMISSIVEFRESNEL"),
                    n.FRESNEL && s.addFallback(4, "FRESNEL"),
                    n.MULTIVIEW && s.addFallback(0, "MULTIVIEW");
                    const o = [os.PositionKind];
                    n.NORMAL && o.push(os.NormalKind),
                    n.TANGENT && o.push(os.TangentKind);
                    for (let e = 1; e <= 6; ++e)
                        n["UV" + e] && o.push(`uv${1 === e ? "" : e}`);
                    n.VERTEXCOLOR && o.push(os.ColorKind),
                    function(e, t, i, s) {
                        i.NUM_BONE_INFLUENCERS > 0 && (s.addCPUSkinningFallback(0, t),
                        e.push("matricesIndices"),
                        e.push("matricesWeights"),
                        i.NUM_BONE_INFLUENCERS > 4 && (e.push("matricesIndicesExtra"),
                        e.push("matricesWeightsExtra")))
                    }(o, e, n, s),
                    function(e, t) {
                        (t.INSTANCES || t.THIN_INSTANCES) && Er(e, !!t.PREPASS_VELOCITY),
                        t.INSTANCESCOLOR && e.push("instanceColor")
                    }(o, n),
                    function(e, t, i) {
                        const s = i.NUM_MORPH_INFLUENCERS;
                        if (s > 0 && Ze.LastCreatedEngine) {
                            const r = Ze.LastCreatedEngine.getCaps().maxVertexAttribs
                              , n = t.morphTargetManager;
                            if (n?.isUsingTextureForTargets)
                                return;
                            const a = n && n.supportsNormals && i.NORMAL
                              , o = n && n.supportsTangents && i.TANGENT
                              , h = n && n.supportsUVs && i.UV1;
                            for (let i = 0; i < s; i++)
                                e.push("position" + i),
                                a && e.push("normal" + i),
                                o && e.push("tangent" + i),
                                h && e.push("uv_" + i),
                                e.length > r && We.Error("Cannot add more vertex attributes for mesh " + t.name)
                        }
                    }(o, e, n),
                    Rr(o, 0, n);
                    let l = "default";
                    const c = ["world", "view", "viewProjection", "vEyePosition", "vLightsType", "vAmbientColor", "vDiffuseColor", "vSpecularColor", "vEmissiveColor", "visibility", "vFogInfos", "vFogColor", "pointSize", "vDiffuseInfos", "vAmbientInfos", "vOpacityInfos", "vReflectionInfos", "vEmissiveInfos", "vSpecularInfos", "vBumpInfos", "vLightmapInfos", "vRefractionInfos", "mBones", "diffuseMatrix", "ambientMatrix", "opacityMatrix", "reflectionMatrix", "emissiveMatrix", "specularMatrix", "bumpMatrix", "normalMatrix", "lightmapMatrix", "refractionMatrix", "diffuseLeftColor", "diffuseRightColor", "opacityParts", "reflectionLeftColor", "reflectionRightColor", "emissiveLeftColor", "emissiveRightColor", "refractionLeftColor", "refractionRightColor", "vReflectionPosition", "vReflectionSize", "vRefractionPosition", "vRefractionSize", "logarithmicDepthConstant", "vTangentSpaceParams", "alphaCutOff", "boneTextureWidth", "morphTargetTextureInfo", "morphTargetTextureIndices"]
                      , u = ["diffuseSampler", "ambientSampler", "opacitySampler", "reflectionCubeSampler", "reflection2DSampler", "emissiveSampler", "specularSampler", "bumpSampler", "lightmapSampler", "refractionCubeSampler", "refraction2DSampler", "boneSampler", "morphTargets", "oitDepthSampler", "oitFrontColorSampler"]
                      , d = ["Material", "Scene", "Mesh"]
                      , f = {
                        maxSimultaneousLights: this._maxSimultaneousLights,
                        maxSimultaneousMorphTargets: n.NUM_MORPH_INFLUENCERS
                    };
                    this._eventInfo.fallbacks = s,
                    this._eventInfo.fallbackRank = 0,
                    this._eventInfo.defines = n,
                    this._eventInfo.uniforms = c,
                    this._eventInfo.attributes = o,
                    this._eventInfo.samplers = u,
                    this._eventInfo.uniformBuffersNames = d,
                    this._eventInfo.customCode = void 0,
                    this._eventInfo.mesh = e,
                    this._eventInfo.indexParameters = f,
                    this._callbackPluginEventGeneric(pr.PrepareEffect, this._eventInfo),
                    oa.AddUniforms(c),
                    oa.AddSamplers(u),
                    Zi && (Zi.PrepareUniforms(c, n),
                    Zi.PrepareSamplers(u, n)),
                    function(e, t, i, s=4) {
                        let r, n = null;
                        if (e.uniformsNames) {
                            const a = e;
                            r = a.uniformsNames,
                            n = a.uniformBuffersNames,
                            t = a.samplers,
                            i = a.defines,
                            s = a.maxSimultaneousLights || 0
                        } else
                            r = e,
                            t || (t = []);
                        for (let e = 0; e < s && i["LIGHT" + e]; e++)
                            wr(e, r, t, i["PROJECTEDLIGHTTEXTURE" + e], n);
                        i.NUM_MORPH_INFLUENCERS && (r.push("morphTargetInfluences"),
                        r.push("morphTargetCount")),
                        i.BAKED_VERTEX_ANIMATION_TEXTURE && (r.push("bakedVertexAnimationSettings"),
                        r.push("bakedVertexAnimationTextureSizeInverted"),
                        r.push("bakedVertexAnimationTime"),
                        t.push("bakedVertexAnimationTexture"))
                    }({
                        uniformsNames: c,
                        uniformBuffersNames: d,
                        samplers: u,
                        defines: n,
                        maxSimultaneousLights: this._maxSimultaneousLights
                    }),
                    gr(c);
                    const _ = {};
                    this.customShaderNameResolve && (l = this.customShaderNameResolve(l, c, d, u, n, o, _));
                    const p = n.toString()
                      , m = t.effect;
                    let g = r.getEngine().createEffect(l, {
                        attributes: o,
                        uniformsNames: c,
                        uniformBuffersNames: d,
                        samplers: u,
                        defines: p,
                        fallbacks: s,
                        onCompiled: this.onCompiled,
                        onError: this.onError,
                        indexParameters: f,
                        processFinalCode: _.processFinalCode,
                        processCodeAfterIncludes: this._eventInfo.customCode,
                        multiTarget: n.PREPASS
                    }, a);
                    if (this._eventInfo.customCode = void 0,
                    g)
                        if (this._onEffectCreatedObservable && (_a.effect = g,
                        _a.subMesh = t,
                        this._onEffectCreatedObservable.notifyObservers(_a)),
                        this.allowShaderHotSwapping && m && !g.isReady()) {
                            if (g = m,
                            n.markAsUnprocessed(),
                            h = this.isFrozen,
                            i)
                                return n._areLightsDisposed = !0,
                                !1
                        } else
                            r.resetCachedMaterial(),
                            t.setEffect(g, n, this._materialContext)
                }
                return !(!t.effect || !t.effect.isReady() || (n._renderId = r.getRenderId(),
                s._wasPreviouslyReady = !h,
                s._wasPreviouslyUsingInstances = i,
                this._checkScenePerformancePriority(),
                0))
            }
            buildUniformLayout() {
                const e = this._uniformBuffer;
                e.addUniform("diffuseLeftColor", 4),
                e.addUniform("diffuseRightColor", 4),
                e.addUniform("opacityParts", 4),
                e.addUniform("reflectionLeftColor", 4),
                e.addUniform("reflectionRightColor", 4),
                e.addUniform("refractionLeftColor", 4),
                e.addUniform("refractionRightColor", 4),
                e.addUniform("emissiveLeftColor", 4),
                e.addUniform("emissiveRightColor", 4),
                e.addUniform("vDiffuseInfos", 2),
                e.addUniform("vAmbientInfos", 2),
                e.addUniform("vOpacityInfos", 2),
                e.addUniform("vReflectionInfos", 2),
                e.addUniform("vReflectionPosition", 3),
                e.addUniform("vReflectionSize", 3),
                e.addUniform("vEmissiveInfos", 2),
                e.addUniform("vLightmapInfos", 2),
                e.addUniform("vSpecularInfos", 2),
                e.addUniform("vBumpInfos", 3),
                e.addUniform("diffuseMatrix", 16),
                e.addUniform("ambientMatrix", 16),
                e.addUniform("opacityMatrix", 16),
                e.addUniform("reflectionMatrix", 16),
                e.addUniform("emissiveMatrix", 16),
                e.addUniform("lightmapMatrix", 16),
                e.addUniform("specularMatrix", 16),
                e.addUniform("bumpMatrix", 16),
                e.addUniform("vTangentSpaceParams", 2),
                e.addUniform("pointSize", 1),
                e.addUniform("alphaCutOff", 1),
                e.addUniform("refractionMatrix", 16),
                e.addUniform("vRefractionInfos", 4),
                e.addUniform("vRefractionPosition", 3),
                e.addUniform("vRefractionSize", 3),
                e.addUniform("vSpecularColor", 4),
                e.addUniform("vEmissiveColor", 3),
                e.addUniform("vDiffuseColor", 4),
                e.addUniform("vAmbientColor", 3),
                super.buildUniformLayout()
            }
            bindForSubMesh(e, t, i) {
                const s = this.getScene()
                  , r = i.materialDefines;
                if (!r)
                    return;
                const n = i.effect;
                if (!n)
                    return;
                this._activeEffect = n,
                t.getMeshUniformBuffer().bindToEffect(n, "Mesh"),
                t.transferToEffect(e),
                this._uniformBuffer.bindToEffect(n, "Material"),
                this.prePassConfiguration.bindForSubMesh(this._activeEffect, s, t, e, this.isFrozen),
                this._eventInfo.subMesh = i,
                this._callbackPluginEventHardBindForSubMesh(this._eventInfo),
                r.OBJECTSPACE_NORMALMAP && (e.toNormalMatrix(this._normalMatrix),
                this.bindOnlyNormalMatrix(this._normalMatrix));
                const a = this._mustRebind(s, n, i, t.visibility);
                Cr(t, n);
                const o = this._uniformBuffer;
                if (a) {
                    if (this.bindViewProjection(n),
                    !o.useUbo || !this.isFrozen || !o.isSync || i._drawWrapper._forceRebindOnNextCall) {
                        if (ma.FresnelEnabled && r.FRESNEL && (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled && (o.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power),
                        o.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias)),
                        this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled && o.updateColor4("opacityParts", new Fe(this.opacityFresnelParameters.leftColor.toLuminance(),this.opacityFresnelParameters.rightColor.toLuminance(),this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power),
                        this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled && (o.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power),
                        o.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias)),
                        this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled && (o.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power),
                        o.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias)),
                        this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled && (o.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power),
                        o.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias))),
                        s.texturesEnabled) {
                            if (this._diffuseTexture && ma.DiffuseTextureEnabled && (o.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level),
                            Ir(this._diffuseTexture, o, "diffuse")),
                            this._ambientTexture && ma.AmbientTextureEnabled && (o.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level),
                            Ir(this._ambientTexture, o, "ambient")),
                            this._opacityTexture && ma.OpacityTextureEnabled && (o.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level),
                            Ir(this._opacityTexture, o, "opacity")),
                            this._hasAlphaChannel() && o.updateFloat("alphaCutOff", this.alphaCutOff),
                            this._reflectionTexture && ma.ReflectionTextureEnabled && (o.updateFloat2("vReflectionInfos", this._reflectionTexture.level, this.roughness),
                            o.updateMatrix("reflectionMatrix", this._reflectionTexture.getReflectionTextureMatrix()),
                            this._reflectionTexture.boundingBoxSize)) {
                                const e = this._reflectionTexture;
                                o.updateVector3("vReflectionPosition", e.boundingBoxPosition),
                                o.updateVector3("vReflectionSize", e.boundingBoxSize)
                            }
                            if (this._emissiveTexture && ma.EmissiveTextureEnabled && (o.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level),
                            Ir(this._emissiveTexture, o, "emissive")),
                            this._lightmapTexture && ma.LightmapTextureEnabled && (o.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level),
                            Ir(this._lightmapTexture, o, "lightmap")),
                            this._specularTexture && ma.SpecularTextureEnabled && (o.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level),
                            Ir(this._specularTexture, o, "specular")),
                            this._bumpTexture && s.getEngine().getCaps().standardDerivatives && ma.BumpTextureEnabled && (o.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias),
                            Ir(this._bumpTexture, o, "bump"),
                            s._mirroredCameraPosition ? o.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1) : o.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1)),
                            this._refractionTexture && ma.RefractionTextureEnabled) {
                                let e = 1;
                                if (this._refractionTexture.isCube || (o.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix()),
                                this._refractionTexture.depth && (e = this._refractionTexture.depth)),
                                o.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, e, this.invertRefractionY ? -1 : 1),
                                this._refractionTexture.boundingBoxSize) {
                                    const e = this._refractionTexture;
                                    o.updateVector3("vRefractionPosition", e.boundingBoxPosition),
                                    o.updateVector3("vRefractionSize", e.boundingBoxSize)
                                }
                            }
                        }
                        this.pointsCloud && o.updateFloat("pointSize", this.pointSize),
                        r.SPECULARTERM && o.updateColor4("vSpecularColor", this.specularColor, this.specularPower),
                        o.updateColor3("vEmissiveColor", ma.EmissiveTextureEnabled ? this.emissiveColor : Fe.BlackReadOnly),
                        o.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha),
                        s.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor),
                        o.updateColor3("vAmbientColor", this._globalAmbientColor)
                    }
                    s.texturesEnabled && (this._diffuseTexture && ma.DiffuseTextureEnabled && n.setTexture("diffuseSampler", this._diffuseTexture),
                    this._ambientTexture && ma.AmbientTextureEnabled && n.setTexture("ambientSampler", this._ambientTexture),
                    this._opacityTexture && ma.OpacityTextureEnabled && n.setTexture("opacitySampler", this._opacityTexture),
                    this._reflectionTexture && ma.ReflectionTextureEnabled && (this._reflectionTexture.isCube ? n.setTexture("reflectionCubeSampler", this._reflectionTexture) : n.setTexture("reflection2DSampler", this._reflectionTexture)),
                    this._emissiveTexture && ma.EmissiveTextureEnabled && n.setTexture("emissiveSampler", this._emissiveTexture),
                    this._lightmapTexture && ma.LightmapTextureEnabled && n.setTexture("lightmapSampler", this._lightmapTexture),
                    this._specularTexture && ma.SpecularTextureEnabled && n.setTexture("specularSampler", this._specularTexture),
                    this._bumpTexture && s.getEngine().getCaps().standardDerivatives && ma.BumpTextureEnabled && n.setTexture("bumpSampler", this._bumpTexture),
                    this._refractionTexture && ma.RefractionTextureEnabled && (this._refractionTexture.isCube ? n.setTexture("refractionCubeSampler", this._refractionTexture) : n.setTexture("refraction2DSampler", this._refractionTexture))),
                    this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(t) && this.getScene().depthPeelingRenderer.bind(n),
                    this._eventInfo.subMesh = i,
                    this._callbackPluginEventBindForSubMesh(this._eventInfo),
                    vr(n, this, s),
                    this.bindEyePosition(n)
                } else
                    s.getEngine()._features.needToAlwaysBindUniformBuffers && (this._needToBindSceneUbo = !0);
                !a && this.isFrozen || (s.lightsEnabled && !this._disableLighting && function(e, t, i, s, r=4) {
                    const n = Math.min(t.lightSources.length, r);
                    for (let r = 0; r < n; r++)
                        Pr(t.lightSources[r], r, e, i, "boolean" == typeof s ? s : s.SPECULARTERM, t.receiveShadows)
                }(s, t, n, r, this._maxSimultaneousLights),
                (s.fogEnabled && t.applyFog && s.fogMode !== ks.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture || t.receiveShadows || r.PREPASS) && this.bindView(n),
                Tr(s, t, n),
                r.NUM_MORPH_INFLUENCERS && Mr(t, n),
                r.BAKED_VERTEX_ANIMATION_TEXTURE && t.bakedVertexAnimationManager?.bind(n, r.INSTANCES),
                this.useLogarithmicDepth && xr(r, n, s),
                this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess && this._imageProcessingConfiguration.bind(this._activeEffect)),
                this._afterBind(t, this._activeEffect, i),
                o.update()
            }
            getAnimatables() {
                const e = super.getAnimatables();
                return this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0 && e.push(this._diffuseTexture),
                this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0 && e.push(this._ambientTexture),
                this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0 && e.push(this._opacityTexture),
                this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0 && e.push(this._reflectionTexture),
                this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0 && e.push(this._emissiveTexture),
                this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0 && e.push(this._specularTexture),
                this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0 && e.push(this._bumpTexture),
                this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0 && e.push(this._lightmapTexture),
                this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0 && e.push(this._refractionTexture),
                e
            }
            getActiveTextures() {
                const e = super.getActiveTextures();
                return this._diffuseTexture && e.push(this._diffuseTexture),
                this._ambientTexture && e.push(this._ambientTexture),
                this._opacityTexture && e.push(this._opacityTexture),
                this._reflectionTexture && e.push(this._reflectionTexture),
                this._emissiveTexture && e.push(this._emissiveTexture),
                this._specularTexture && e.push(this._specularTexture),
                this._bumpTexture && e.push(this._bumpTexture),
                this._lightmapTexture && e.push(this._lightmapTexture),
                this._refractionTexture && e.push(this._refractionTexture),
                e
            }
            hasTexture(e) {
                return !!super.hasTexture(e) || this._diffuseTexture === e || this._ambientTexture === e || this._opacityTexture === e || this._reflectionTexture === e || this._emissiveTexture === e || this._specularTexture === e || this._bumpTexture === e || this._lightmapTexture === e || this._refractionTexture === e
            }
            dispose(e, t) {
                t && (this._diffuseTexture?.dispose(),
                this._ambientTexture?.dispose(),
                this._opacityTexture?.dispose(),
                this._reflectionTexture?.dispose(),
                this._emissiveTexture?.dispose(),
                this._specularTexture?.dispose(),
                this._bumpTexture?.dispose(),
                this._lightmapTexture?.dispose(),
                this._refractionTexture?.dispose()),
                this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver),
                super.dispose(e, t)
            }
            clone(e, t=!0, i="") {
                const s = ki.Clone(( () => new ma(e,this.getScene())), this, {
                    cloneTexturesOnlyOnce: t
                });
                return s.name = e,
                s.id = e,
                this.stencil.copyTo(s.stencil),
                this._clonePlugins(s, i),
                s
            }
            static Parse(e, t, i) {
                const s = ki.Parse(( () => new ma(e.name,t)), e, t, i);
                return e.stencil && s.stencil.parse(e.stencil, t, i),
                Fr._ParsePlugins(e, s, t, i),
                s
            }
            static get DiffuseTextureEnabled() {
                return ca.DiffuseTextureEnabled
            }
            static set DiffuseTextureEnabled(e) {
                ca.DiffuseTextureEnabled = e
            }
            static get DetailTextureEnabled() {
                return ca.DetailTextureEnabled
            }
            static set DetailTextureEnabled(e) {
                ca.DetailTextureEnabled = e
            }
            static get AmbientTextureEnabled() {
                return ca.AmbientTextureEnabled
            }
            static set AmbientTextureEnabled(e) {
                ca.AmbientTextureEnabled = e
            }
            static get OpacityTextureEnabled() {
                return ca.OpacityTextureEnabled
            }
            static set OpacityTextureEnabled(e) {
                ca.OpacityTextureEnabled = e
            }
            static get ReflectionTextureEnabled() {
                return ca.ReflectionTextureEnabled
            }
            static set ReflectionTextureEnabled(e) {
                ca.ReflectionTextureEnabled = e
            }
            static get EmissiveTextureEnabled() {
                return ca.EmissiveTextureEnabled
            }
            static set EmissiveTextureEnabled(e) {
                ca.EmissiveTextureEnabled = e
            }
            static get SpecularTextureEnabled() {
                return ca.SpecularTextureEnabled
            }
            static set SpecularTextureEnabled(e) {
                ca.SpecularTextureEnabled = e
            }
            static get BumpTextureEnabled() {
                return ca.BumpTextureEnabled
            }
            static set BumpTextureEnabled(e) {
                ca.BumpTextureEnabled = e
            }
            static get LightmapTextureEnabled() {
                return ca.LightmapTextureEnabled
            }
            static set LightmapTextureEnabled(e) {
                ca.LightmapTextureEnabled = e
            }
            static get RefractionTextureEnabled() {
                return ca.RefractionTextureEnabled
            }
            static set RefractionTextureEnabled(e) {
                ca.RefractionTextureEnabled = e
            }
            static get ColorGradingTextureEnabled() {
                return ca.ColorGradingTextureEnabled
            }
            static set ColorGradingTextureEnabled(e) {
                ca.ColorGradingTextureEnabled = e
            }
            static get FresnelEnabled() {
                return ca.FresnelEnabled
            }
            static set FresnelEnabled(e) {
                ca.FresnelEnabled = e
            }
        }
        pi([Ti("diffuseTexture")], ma.prototype, "_diffuseTexture", void 0),
        pi([bi("_markAllSubMeshesAsTexturesAndMiscDirty")], ma.prototype, "diffuseTexture", void 0),
        pi([Ti("ambientTexture")], ma.prototype, "_ambientTexture", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "ambientTexture", void 0),
        pi([Ti("opacityTexture")], ma.prototype, "_opacityTexture", void 0),
        pi([bi("_markAllSubMeshesAsTexturesAndMiscDirty")], ma.prototype, "opacityTexture", void 0),
        pi([Ti("reflectionTexture")], ma.prototype, "_reflectionTexture", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "reflectionTexture", void 0),
        pi([Ti("emissiveTexture")], ma.prototype, "_emissiveTexture", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "emissiveTexture", void 0),
        pi([Ti("specularTexture")], ma.prototype, "_specularTexture", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "specularTexture", void 0),
        pi([Ti("bumpTexture")], ma.prototype, "_bumpTexture", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "bumpTexture", void 0),
        pi([Ti("lightmapTexture")], ma.prototype, "_lightmapTexture", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "lightmapTexture", void 0),
        pi([Ti("refractionTexture")], ma.prototype, "_refractionTexture", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "refractionTexture", void 0),
        pi([Ei("ambient")], ma.prototype, "ambientColor", void 0),
        pi([Ei("diffuse")], ma.prototype, "diffuseColor", void 0),
        pi([Ei("specular")], ma.prototype, "specularColor", void 0),
        pi([Ei("emissive")], ma.prototype, "emissiveColor", void 0),
        pi([xi()], ma.prototype, "specularPower", void 0),
        pi([xi("useAlphaFromDiffuseTexture")], ma.prototype, "_useAlphaFromDiffuseTexture", void 0),
        pi([bi("_markAllSubMeshesAsTexturesAndMiscDirty")], ma.prototype, "useAlphaFromDiffuseTexture", void 0),
        pi([xi("useEmissiveAsIllumination")], ma.prototype, "_useEmissiveAsIllumination", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "useEmissiveAsIllumination", void 0),
        pi([xi("linkEmissiveWithDiffuse")], ma.prototype, "_linkEmissiveWithDiffuse", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "linkEmissiveWithDiffuse", void 0),
        pi([xi("useSpecularOverAlpha")], ma.prototype, "_useSpecularOverAlpha", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "useSpecularOverAlpha", void 0),
        pi([xi("useReflectionOverAlpha")], ma.prototype, "_useReflectionOverAlpha", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "useReflectionOverAlpha", void 0),
        pi([xi("disableLighting")], ma.prototype, "_disableLighting", void 0),
        pi([bi("_markAllSubMeshesAsLightsDirty")], ma.prototype, "disableLighting", void 0),
        pi([xi("useObjectSpaceNormalMap")], ma.prototype, "_useObjectSpaceNormalMap", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "useObjectSpaceNormalMap", void 0),
        pi([xi("useParallax")], ma.prototype, "_useParallax", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "useParallax", void 0),
        pi([xi("useParallaxOcclusion")], ma.prototype, "_useParallaxOcclusion", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "useParallaxOcclusion", void 0),
        pi([xi()], ma.prototype, "parallaxScaleBias", void 0),
        pi([xi("roughness")], ma.prototype, "_roughness", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "roughness", void 0),
        pi([xi()], ma.prototype, "indexOfRefraction", void 0),
        pi([xi()], ma.prototype, "invertRefractionY", void 0),
        pi([xi()], ma.prototype, "alphaCutOff", void 0),
        pi([xi("useLightmapAsShadowmap")], ma.prototype, "_useLightmapAsShadowmap", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "useLightmapAsShadowmap", void 0),
        pi([Mi("diffuseFresnelParameters")], ma.prototype, "_diffuseFresnelParameters", void 0),
        pi([bi("_markAllSubMeshesAsFresnelDirty")], ma.prototype, "diffuseFresnelParameters", void 0),
        pi([Mi("opacityFresnelParameters")], ma.prototype, "_opacityFresnelParameters", void 0),
        pi([bi("_markAllSubMeshesAsFresnelAndMiscDirty")], ma.prototype, "opacityFresnelParameters", void 0),
        pi([Mi("reflectionFresnelParameters")], ma.prototype, "_reflectionFresnelParameters", void 0),
        pi([bi("_markAllSubMeshesAsFresnelDirty")], ma.prototype, "reflectionFresnelParameters", void 0),
        pi([Mi("refractionFresnelParameters")], ma.prototype, "_refractionFresnelParameters", void 0),
        pi([bi("_markAllSubMeshesAsFresnelDirty")], ma.prototype, "refractionFresnelParameters", void 0),
        pi([Mi("emissiveFresnelParameters")], ma.prototype, "_emissiveFresnelParameters", void 0),
        pi([bi("_markAllSubMeshesAsFresnelDirty")], ma.prototype, "emissiveFresnelParameters", void 0),
        pi([xi("useReflectionFresnelFromSpecular")], ma.prototype, "_useReflectionFresnelFromSpecular", void 0),
        pi([bi("_markAllSubMeshesAsFresnelDirty")], ma.prototype, "useReflectionFresnelFromSpecular", void 0),
        pi([xi("useGlossinessFromSpecularMapAlpha")], ma.prototype, "_useGlossinessFromSpecularMapAlpha", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "useGlossinessFromSpecularMapAlpha", void 0),
        pi([xi("maxSimultaneousLights")], ma.prototype, "_maxSimultaneousLights", void 0),
        pi([bi("_markAllSubMeshesAsLightsDirty")], ma.prototype, "maxSimultaneousLights", void 0),
        pi([xi("invertNormalMapX")], ma.prototype, "_invertNormalMapX", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "invertNormalMapX", void 0),
        pi([xi("invertNormalMapY")], ma.prototype, "_invertNormalMapY", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "invertNormalMapY", void 0),
        pi([xi("twoSidedLighting")], ma.prototype, "_twoSidedLighting", void 0),
        pi([bi("_markAllSubMeshesAsTexturesDirty")], ma.prototype, "twoSidedLighting", void 0),
        pi([xi("applyDecalMapAfterDetailMap")], ma.prototype, "_applyDecalMapAfterDetailMap", void 0),
        pi([bi("_markAllSubMeshesAsMiscDirty")], ma.prototype, "applyDecalMapAfterDetailMap", void 0),
        Ie("BABYLON.StandardMaterial", ma),
        ks.DefaultMaterialFactory = e => new ma("default material",e);
        const ga = {
            effect: null,
            subMesh: null
        };
        class va extends la {
            constructor(e, t, i, s={}, r=!0) {
                super(e, t, r),
                this._textures = {},
                this._textureArrays = {},
                this._externalTextures = {},
                this._floats = {},
                this._ints = {},
                this._uints = {},
                this._floatsArrays = {},
                this._colors3 = {},
                this._colors3Arrays = {},
                this._colors4 = {},
                this._colors4Arrays = {},
                this._vectors2 = {},
                this._vectors3 = {},
                this._vectors4 = {},
                this._quaternions = {},
                this._quaternionsArrays = {},
                this._matrices = {},
                this._matrixArrays = {},
                this._matrices3x3 = {},
                this._matrices2x2 = {},
                this._vectors2Arrays = {},
                this._vectors3Arrays = {},
                this._vectors4Arrays = {},
                this._uniformBuffers = {},
                this._textureSamplers = {},
                this._storageBuffers = {},
                this._cachedWorldViewMatrix = new Oi,
                this._cachedWorldViewProjectionMatrix = new Oi,
                this._multiview = !1,
                this._materialHelperNeedsPreviousMatrices = !1,
                this._shaderPath = i,
                this._options = {
                    needAlphaBlending: !1,
                    needAlphaTesting: !1,
                    attributes: ["position", "normal", "uv"],
                    uniforms: ["worldViewProjection"],
                    uniformBuffers: [],
                    samplers: [],
                    externalTextures: [],
                    samplerObjects: [],
                    storageBuffers: [],
                    defines: [],
                    useClipPlane: !1,
                    ...s
                }
            }
            get shaderPath() {
                return this._shaderPath
            }
            set shaderPath(e) {
                this._shaderPath = e
            }
            get options() {
                return this._options
            }
            get isMultiview() {
                return this._multiview
            }
            getClassName() {
                return "ShaderMaterial"
            }
            needAlphaBlending() {
                return this.alpha < 1 || this._options.needAlphaBlending
            }
            needAlphaTesting() {
                return this._options.needAlphaTesting
            }
            _checkUniform(e) {
                -1 === this._options.uniforms.indexOf(e) && this._options.uniforms.push(e)
            }
            setTexture(e, t) {
                return -1 === this._options.samplers.indexOf(e) && this._options.samplers.push(e),
                this._textures[e] = t,
                this
            }
            setTextureArray(e, t) {
                return -1 === this._options.samplers.indexOf(e) && this._options.samplers.push(e),
                this._checkUniform(e),
                this._textureArrays[e] = t,
                this
            }
            setExternalTexture(e, t) {
                return -1 === this._options.externalTextures.indexOf(e) && this._options.externalTextures.push(e),
                this._externalTextures[e] = t,
                this
            }
            setFloat(e, t) {
                return this._checkUniform(e),
                this._floats[e] = t,
                this
            }
            setInt(e, t) {
                return this._checkUniform(e),
                this._ints[e] = t,
                this
            }
            setUInt(e, t) {
                return this._checkUniform(e),
                this._uints[e] = t,
                this
            }
            setFloats(e, t) {
                return this._checkUniform(e),
                this._floatsArrays[e] = t,
                this
            }
            setColor3(e, t) {
                return this._checkUniform(e),
                this._colors3[e] = t,
                this
            }
            setColor3Array(e, t) {
                return this._checkUniform(e),
                this._colors3Arrays[e] = t.reduce(( (e, t) => (t.toArray(e, e.length),
                e)), []),
                this
            }
            setColor4(e, t) {
                return this._checkUniform(e),
                this._colors4[e] = t,
                this
            }
            setColor4Array(e, t) {
                return this._checkUniform(e),
                this._colors4Arrays[e] = t.reduce(( (e, t) => (t.toArray(e, e.length),
                e)), []),
                this
            }
            setVector2(e, t) {
                return this._checkUniform(e),
                this._vectors2[e] = t,
                this
            }
            setVector3(e, t) {
                return this._checkUniform(e),
                this._vectors3[e] = t,
                this
            }
            setVector4(e, t) {
                return this._checkUniform(e),
                this._vectors4[e] = t,
                this
            }
            setQuaternion(e, t) {
                return this._checkUniform(e),
                this._quaternions[e] = t,
                this
            }
            setQuaternionArray(e, t) {
                return this._checkUniform(e),
                this._quaternionsArrays[e] = t.reduce(( (e, t) => (t.toArray(e, e.length),
                e)), []),
                this
            }
            setMatrix(e, t) {
                return this._checkUniform(e),
                this._matrices[e] = t,
                this
            }
            setMatrices(e, t) {
                this._checkUniform(e);
                const i = new Float32Array(16 * t.length);
                for (let e = 0; e < t.length; e++)
                    t[e].copyToArray(i, 16 * e);
                return this._matrixArrays[e] = i,
                this
            }
            setMatrix3x3(e, t) {
                return this._checkUniform(e),
                this._matrices3x3[e] = t,
                this
            }
            setMatrix2x2(e, t) {
                return this._checkUniform(e),
                this._matrices2x2[e] = t,
                this
            }
            setArray2(e, t) {
                return this._checkUniform(e),
                this._vectors2Arrays[e] = t,
                this
            }
            setArray3(e, t) {
                return this._checkUniform(e),
                this._vectors3Arrays[e] = t,
                this
            }
            setArray4(e, t) {
                return this._checkUniform(e),
                this._vectors4Arrays[e] = t,
                this
            }
            setUniformBuffer(e, t) {
                return -1 === this._options.uniformBuffers.indexOf(e) && this._options.uniformBuffers.push(e),
                this._uniformBuffers[e] = t,
                this
            }
            setTextureSampler(e, t) {
                return -1 === this._options.samplerObjects.indexOf(e) && this._options.samplerObjects.push(e),
                this._textureSamplers[e] = t,
                this
            }
            setStorageBuffer(e, t) {
                return -1 === this._options.storageBuffers.indexOf(e) && this._options.storageBuffers.push(e),
                this._storageBuffers[e] = t,
                this
            }
            setDefine(e, t) {
                const i = e.trimEnd() + " "
                  , s = this.options.defines.findIndex((t => t === e || t.startsWith(i)));
                return s >= 0 && this.options.defines.splice(s, 1),
                ("boolean" != typeof t || t) && this.options.defines.push(i + t),
                this
            }
            isReadyForSubMesh(e, t, i) {
                return this.isReady(e, i, t)
            }
            isReady(e, t, i) {
                const s = i && this._storeEffectOnSubMeshes;
                if (this.isFrozen) {
                    const e = s ? i._drawWrapper : this._drawWrapper;
                    if (e.effect && e._wasPreviouslyReady && e._wasPreviouslyUsingInstances === t)
                        return !0
                }
                const r = this.getScene()
                  , n = r.getEngine()
                  , a = []
                  , o = []
                  , h = new ua;
                let l = this._shaderPath
                  , c = this._options.uniforms
                  , u = this._options.uniformBuffers
                  , d = this._options.samplers;
                n.getCaps().multiview && r.activeCamera && r.activeCamera.outputRenderTarget && r.activeCamera.outputRenderTarget.getViewCount() > 1 && (this._multiview = !0,
                a.push("#define MULTIVIEW"),
                -1 !== c.indexOf("viewProjection") && -1 === c.indexOf("viewProjectionR") && c.push("viewProjectionR"));
                for (let e = 0; e < this._options.defines.length; e++) {
                    const t = 0 === this._options.defines[e].indexOf("#define") ? this._options.defines[e] : `#define ${this._options.defines[e]}`;
                    a.push(t)
                }
                for (let e = 0; e < this._options.attributes.length; e++)
                    o.push(this._options.attributes[e]);
                if (e && e.isVerticesDataPresent(os.ColorKind) && (-1 === o.indexOf(os.ColorKind) && o.push(os.ColorKind),
                a.push("#define VERTEXCOLOR")),
                t && (a.push("#define INSTANCES"),
                Er(o, this._materialHelperNeedsPreviousMatrices),
                e?.hasThinInstances && (a.push("#define THIN_INSTANCES"),
                e && e.isVerticesDataPresent(os.ColorInstanceKind) && (o.push(os.ColorInstanceKind),
                a.push("#define INSTANCESCOLOR")))),
                e && e.useBones && e.computeBonesUsingShaders && e.skeleton) {
                    o.push(os.MatricesIndicesKind),
                    o.push(os.MatricesWeightsKind),
                    e.numBoneInfluencers > 4 && (o.push(os.MatricesIndicesExtraKind),
                    o.push(os.MatricesWeightsExtraKind));
                    const t = e.skeleton;
                    a.push("#define NUM_BONE_INFLUENCERS " + e.numBoneInfluencers),
                    h.addCPUSkinningFallback(0, e),
                    t.isUsingTextureForMatrices ? (a.push("#define BONETEXTURE"),
                    -1 === c.indexOf("boneTextureWidth") && c.push("boneTextureWidth"),
                    -1 === this._options.samplers.indexOf("boneSampler") && this._options.samplers.push("boneSampler")) : (a.push("#define BonesPerMesh " + (t.bones.length + 1)),
                    -1 === c.indexOf("mBones") && c.push("mBones"))
                } else
                    a.push("#define NUM_BONE_INFLUENCERS 0");
                let f = 0;
                const _ = e ? e.morphTargetManager : null;
                if (_) {
                    const e = _.supportsUVs && -1 !== a.indexOf("#define UV1")
                      , t = _.supportsTangents && -1 !== a.indexOf("#define TANGENT")
                      , i = _.supportsNormals && -1 !== a.indexOf("#define NORMAL");
                    f = _.numMaxInfluencers || _.numInfluencers,
                    e && a.push("#define MORPHTARGETS_UV"),
                    t && a.push("#define MORPHTARGETS_TANGENT"),
                    i && a.push("#define MORPHTARGETS_NORMAL"),
                    f > 0 && a.push("#define MORPHTARGETS"),
                    _.isUsingTextureForTargets && (a.push("#define MORPHTARGETS_TEXTURE"),
                    -1 === c.indexOf("morphTargetTextureIndices") && c.push("morphTargetTextureIndices"),
                    -1 === this._options.samplers.indexOf("morphTargets") && this._options.samplers.push("morphTargets")),
                    a.push("#define NUM_MORPH_INFLUENCERS " + f);
                    for (let s = 0; s < f; s++)
                        o.push(os.PositionKind + s),
                        i && o.push(os.NormalKind + s),
                        t && o.push(os.TangentKind + s),
                        e && o.push(os.UVKind + "_" + s);
                    f > 0 && (c = c.slice(),
                    c.push("morphTargetInfluences"),
                    c.push("morphTargetCount"),
                    c.push("morphTargetTextureInfo"),
                    c.push("morphTargetTextureIndices"))
                } else
                    a.push("#define NUM_MORPH_INFLUENCERS 0");
                if (e) {
                    const t = e.bakedVertexAnimationManager;
                    t && t.isEnabled && (a.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),
                    -1 === c.indexOf("bakedVertexAnimationSettings") && c.push("bakedVertexAnimationSettings"),
                    -1 === c.indexOf("bakedVertexAnimationTextureSizeInverted") && c.push("bakedVertexAnimationTextureSizeInverted"),
                    -1 === c.indexOf("bakedVertexAnimationTime") && c.push("bakedVertexAnimationTime"),
                    -1 === this._options.samplers.indexOf("bakedVertexAnimationTexture") && this._options.samplers.push("bakedVertexAnimationTexture")),
                    Rr(o, 0, a)
                }
                for (const e in this._textures)
                    if (!this._textures[e].isReady())
                        return !1;
                e && this._shouldTurnAlphaTestOn(e) && a.push("#define ALPHATEST"),
                !1 !== this._options.useClipPlane && (gr(c),
                function(e, t, i) {
                    const s = !!(e.clipPlane ?? t.clipPlane)
                      , r = !!(e.clipPlane2 ?? t.clipPlane2)
                      , n = !!(e.clipPlane3 ?? t.clipPlane3)
                      , a = !!(e.clipPlane4 ?? t.clipPlane4)
                      , o = !!(e.clipPlane5 ?? t.clipPlane5)
                      , h = !!(e.clipPlane6 ?? t.clipPlane6);
                    s && i.push("#define CLIPPLANE"),
                    r && i.push("#define CLIPPLANE2"),
                    n && i.push("#define CLIPPLANE3"),
                    a && i.push("#define CLIPPLANE4"),
                    o && i.push("#define CLIPPLANE5"),
                    h && i.push("#define CLIPPLANE6")
                }(this, r, a)),
                r.fogEnabled && e?.applyFog && r.fogMode !== ks.FOGMODE_NONE && (a.push("#define FOG"),
                -1 === c.indexOf("view") && c.push("view"),
                -1 === c.indexOf("vFogInfos") && c.push("vFogInfos"),
                -1 === c.indexOf("vFogColor") && c.push("vFogColor")),
                this._useLogarithmicDepth && (a.push("#define LOGARITHMICDEPTH"),
                -1 === c.indexOf("logarithmicDepthConstant") && c.push("logarithmicDepthConstant")),
                this.customShaderNameResolve && (c = c.slice(),
                u = u.slice(),
                d = d.slice(),
                l = this.customShaderNameResolve(l, c, u, d, a, o));
                const p = s ? i._getDrawWrapper(void 0, !0) : this._drawWrapper
                  , m = p?.effect ?? null
                  , g = p?.defines ?? null
                  , v = a.join("\n");
                let y = m;
                return g !== v && (y = n.createEffect(l, {
                    attributes: o,
                    uniformsNames: c,
                    uniformBuffersNames: u,
                    samplers: d,
                    defines: v,
                    fallbacks: h,
                    onCompiled: this.onCompiled,
                    onError: this.onError,
                    indexParameters: {
                        maxSimultaneousMorphTargets: f
                    },
                    shaderLanguage: this._options.shaderLanguage
                }, n),
                s ? i.setEffect(y, v, this._materialContext) : p && p.setEffect(y, v),
                this._onEffectCreatedObservable && (ga.effect = y,
                ga.subMesh = i ?? e?.subMeshes[0] ?? null,
                this._onEffectCreatedObservable.notifyObservers(ga))),
                p._wasPreviouslyUsingInstances = !!t,
                !(!y?.isReady() ?? 1) && (m !== y && r.resetCachedMaterial(),
                p._wasPreviouslyReady = !0,
                !0)
            }
            bindOnlyWorldMatrix(e, t) {
                const i = this.getScene()
                  , s = t ?? this.getEffect();
                s && (-1 !== this._options.uniforms.indexOf("world") && s.setMatrix("world", e),
                -1 !== this._options.uniforms.indexOf("worldView") && (e.multiplyToRef(i.getViewMatrix(), this._cachedWorldViewMatrix),
                s.setMatrix("worldView", this._cachedWorldViewMatrix)),
                -1 !== this._options.uniforms.indexOf("worldViewProjection") && (e.multiplyToRef(i.getTransformMatrix(), this._cachedWorldViewProjectionMatrix),
                s.setMatrix("worldViewProjection", this._cachedWorldViewProjectionMatrix)),
                -1 !== this._options.uniforms.indexOf("view") && s.setMatrix("view", i.getViewMatrix()))
            }
            bindForSubMesh(e, t, i) {
                this.bind(e, t, i._drawWrapperOverride?.effect, i)
            }
            bind(e, t, i, s) {
                const r = s && this._storeEffectOnSubMeshes
                  , n = i ?? (r ? s.effect : this.getEffect());
                if (!n)
                    return;
                const a = this.getScene();
                this._activeEffect = n,
                this.bindOnlyWorldMatrix(e, i);
                const o = this._options.uniformBuffers;
                let h = !1;
                if (n && o && o.length > 0 && a.getEngine().supportsUniformBuffers)
                    for (let i = 0; i < o.length; ++i)
                        switch (o[i]) {
                        case "Mesh":
                            t && (t.getMeshUniformBuffer().bindToEffect(n, "Mesh"),
                            t.transferToEffect(e));
                            break;
                        case "Scene":
                            Sr(n, a.getSceneUniformBuffer()),
                            a.finalizeSceneUbo(),
                            h = !0
                        }
                const l = t && r ? this._mustRebind(a, n, s, t.visibility) : a.getCachedMaterial() !== this;
                if (n && l) {
                    let e;
                    for (e in h || -1 === this._options.uniforms.indexOf("view") || n.setMatrix("view", a.getViewMatrix()),
                    h || -1 === this._options.uniforms.indexOf("projection") || n.setMatrix("projection", a.getProjectionMatrix()),
                    h || -1 === this._options.uniforms.indexOf("viewProjection") || (n.setMatrix("viewProjection", a.getTransformMatrix()),
                    this._multiview && n.setMatrix("viewProjectionR", a._transformMatrixR)),
                    a.activeCamera && -1 !== this._options.uniforms.indexOf("cameraPosition") && n.setVector3("cameraPosition", a.activeCamera.globalPosition),
                    Cr(t, n),
                    vr(n, this, a),
                    this._useLogarithmicDepth && xr(r ? s.materialDefines : n.defines, n, a),
                    t && Tr(a, t, n),
                    this._textures)
                        n.setTexture(e, this._textures[e]);
                    for (e in this._textureArrays)
                        n.setTextureArray(e, this._textureArrays[e]);
                    for (e in this._externalTextures)
                        n.setExternalTexture(e, this._externalTextures[e]);
                    for (e in this._ints)
                        n.setInt(e, this._ints[e]);
                    for (e in this._uints)
                        n.setUInt(e, this._uints[e]);
                    for (e in this._floats)
                        n.setFloat(e, this._floats[e]);
                    for (e in this._floatsArrays)
                        n.setArray(e, this._floatsArrays[e]);
                    for (e in this._colors3)
                        n.setColor3(e, this._colors3[e]);
                    for (e in this._colors3Arrays)
                        n.setArray3(e, this._colors3Arrays[e]);
                    for (e in this._colors4) {
                        const t = this._colors4[e];
                        n.setFloat4(e, t.r, t.g, t.b, t.a)
                    }
                    for (e in this._colors4Arrays)
                        n.setArray4(e, this._colors4Arrays[e]);
                    for (e in this._vectors2)
                        n.setVector2(e, this._vectors2[e]);
                    for (e in this._vectors3)
                        n.setVector3(e, this._vectors3[e]);
                    for (e in this._vectors4)
                        n.setVector4(e, this._vectors4[e]);
                    for (e in this._quaternions)
                        n.setQuaternion(e, this._quaternions[e]);
                    for (e in this._matrices)
                        n.setMatrix(e, this._matrices[e]);
                    for (e in this._matrixArrays)
                        n.setMatrices(e, this._matrixArrays[e]);
                    for (e in this._matrices3x3)
                        n.setMatrix3x3(e, this._matrices3x3[e]);
                    for (e in this._matrices2x2)
                        n.setMatrix2x2(e, this._matrices2x2[e]);
                    for (e in this._vectors2Arrays)
                        n.setArray2(e, this._vectors2Arrays[e]);
                    for (e in this._vectors3Arrays)
                        n.setArray3(e, this._vectors3Arrays[e]);
                    for (e in this._vectors4Arrays)
                        n.setArray4(e, this._vectors4Arrays[e]);
                    for (e in this._quaternionsArrays)
                        n.setArray4(e, this._quaternionsArrays[e]);
                    for (e in this._uniformBuffers) {
                        const t = this._uniformBuffers[e].getBuffer();
                        t && n.bindUniformBuffer(t, e)
                    }
                    for (e in this._textureSamplers)
                        n.setTextureSampler(e, this._textureSamplers[e]);
                    for (e in this._storageBuffers)
                        n.setStorageBuffer(e, this._storageBuffers[e])
                }
                if (n && t && (l || !this.isFrozen)) {
                    const e = t.morphTargetManager;
                    e && e.numInfluencers > 0 && Mr(t, n);
                    const i = t.bakedVertexAnimationManager;
                    if (i && i.isEnabled) {
                        const e = r ? s._drawWrapper : this._drawWrapper;
                        t.bakedVertexAnimationManager?.bind(n, !!e._wasPreviouslyUsingInstances)
                    }
                }
                this._afterBind(t, n, s)
            }
            getActiveTextures() {
                const e = super.getActiveTextures();
                for (const t in this._textures)
                    e.push(this._textures[t]);
                for (const t in this._textureArrays) {
                    const i = this._textureArrays[t];
                    for (let t = 0; t < i.length; t++)
                        e.push(i[t])
                }
                return e
            }
            hasTexture(e) {
                if (super.hasTexture(e))
                    return !0;
                for (const t in this._textures)
                    if (this._textures[t] === e)
                        return !0;
                for (const t in this._textureArrays) {
                    const i = this._textureArrays[t];
                    for (let t = 0; t < i.length; t++)
                        if (i[t] === e)
                            return !0
                }
                return !1
            }
            clone(e) {
                const t = ki.Clone(( () => new va(e,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)), this);
                t.name = e,
                t.id = e,
                "object" == typeof t._shaderPath && (t._shaderPath = {
                    ...t._shaderPath
                }),
                this._options = {
                    ...this._options
                },
                Object.keys(this._options).forEach((e => {
                    const t = this._options[e];
                    Array.isArray(t) && (this._options[e] = t.slice(0))
                }
                )),
                this.stencil.copyTo(t.stencil);
                for (const e in this._textures)
                    t.setTexture(e, this._textures[e]);
                for (const e in this._textureArrays)
                    t.setTextureArray(e, this._textureArrays[e]);
                for (const e in this._externalTextures)
                    t.setExternalTexture(e, this._externalTextures[e]);
                for (const e in this._ints)
                    t.setInt(e, this._ints[e]);
                for (const e in this._uints)
                    t.setUInt(e, this._uints[e]);
                for (const e in this._floats)
                    t.setFloat(e, this._floats[e]);
                for (const e in this._floatsArrays)
                    t.setFloats(e, this._floatsArrays[e]);
                for (const e in this._colors3)
                    t.setColor3(e, this._colors3[e]);
                for (const e in this._colors3Arrays)
                    t._colors3Arrays[e] = this._colors3Arrays[e];
                for (const e in this._colors4)
                    t.setColor4(e, this._colors4[e]);
                for (const e in this._colors4Arrays)
                    t._colors4Arrays[e] = this._colors4Arrays[e];
                for (const e in this._vectors2)
                    t.setVector2(e, this._vectors2[e]);
                for (const e in this._vectors3)
                    t.setVector3(e, this._vectors3[e]);
                for (const e in this._vectors4)
                    t.setVector4(e, this._vectors4[e]);
                for (const e in this._quaternions)
                    t.setQuaternion(e, this._quaternions[e]);
                for (const e in this._quaternionsArrays)
                    t._quaternionsArrays[e] = this._quaternionsArrays[e];
                for (const e in this._matrices)
                    t.setMatrix(e, this._matrices[e]);
                for (const e in this._matrixArrays)
                    t._matrixArrays[e] = this._matrixArrays[e].slice();
                for (const e in this._matrices3x3)
                    t.setMatrix3x3(e, this._matrices3x3[e]);
                for (const e in this._matrices2x2)
                    t.setMatrix2x2(e, this._matrices2x2[e]);
                for (const e in this._vectors2Arrays)
                    t.setArray2(e, this._vectors2Arrays[e]);
                for (const e in this._vectors3Arrays)
                    t.setArray3(e, this._vectors3Arrays[e]);
                for (const e in this._vectors4Arrays)
                    t.setArray4(e, this._vectors4Arrays[e]);
                for (const e in this._uniformBuffers)
                    t.setUniformBuffer(e, this._uniformBuffers[e]);
                for (const e in this._textureSamplers)
                    t.setTextureSampler(e, this._textureSamplers[e]);
                for (const e in this._storageBuffers)
                    t.setStorageBuffer(e, this._storageBuffers[e]);
                return t
            }
            dispose(e, t, i) {
                if (t) {
                    let e;
                    for (e in this._textures)
                        this._textures[e].dispose();
                    for (e in this._textureArrays) {
                        const t = this._textureArrays[e];
                        for (let e = 0; e < t.length; e++)
                            t[e].dispose()
                    }
                }
                this._textures = {},
                super.dispose(e, t, i)
            }
            serialize() {
                const e = ki.Serialize(this);
                let t;
                for (t in e.customType = "BABYLON.ShaderMaterial",
                e.uniqueId = this.uniqueId,
                e.options = this._options,
                e.shaderPath = this._shaderPath,
                e.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes,
                e.stencil = this.stencil.serialize(),
                e.textures = {},
                this._textures)
                    e.textures[t] = this._textures[t].serialize();
                for (t in e.textureArrays = {},
                this._textureArrays) {
                    e.textureArrays[t] = [];
                    const i = this._textureArrays[t];
                    for (let s = 0; s < i.length; s++)
                        e.textureArrays[t].push(i[s].serialize())
                }
                for (t in e.ints = {},
                this._ints)
                    e.ints[t] = this._ints[t];
                for (t in e.uints = {},
                this._uints)
                    e.uints[t] = this._uints[t];
                for (t in e.floats = {},
                this._floats)
                    e.floats[t] = this._floats[t];
                for (t in e.floatsArrays = {},
                this._floatsArrays)
                    e.floatsArrays[t] = this._floatsArrays[t];
                for (t in e.colors3 = {},
                this._colors3)
                    e.colors3[t] = this._colors3[t].asArray();
                for (t in e.colors3Arrays = {},
                this._colors3Arrays)
                    e.colors3Arrays[t] = this._colors3Arrays[t];
                for (t in e.colors4 = {},
                this._colors4)
                    e.colors4[t] = this._colors4[t].asArray();
                for (t in e.colors4Arrays = {},
                this._colors4Arrays)
                    e.colors4Arrays[t] = this._colors4Arrays[t];
                for (t in e.vectors2 = {},
                this._vectors2)
                    e.vectors2[t] = this._vectors2[t].asArray();
                for (t in e.vectors3 = {},
                this._vectors3)
                    e.vectors3[t] = this._vectors3[t].asArray();
                for (t in e.vectors4 = {},
                this._vectors4)
                    e.vectors4[t] = this._vectors4[t].asArray();
                for (t in e.quaternions = {},
                this._quaternions)
                    e.quaternions[t] = this._quaternions[t].asArray();
                for (t in e.matrices = {},
                this._matrices)
                    e.matrices[t] = this._matrices[t].asArray();
                for (t in e.matrixArray = {},
                this._matrixArrays)
                    e.matrixArray[t] = this._matrixArrays[t];
                for (t in e.matrices3x3 = {},
                this._matrices3x3)
                    e.matrices3x3[t] = this._matrices3x3[t];
                for (t in e.matrices2x2 = {},
                this._matrices2x2)
                    e.matrices2x2[t] = this._matrices2x2[t];
                for (t in e.vectors2Arrays = {},
                this._vectors2Arrays)
                    e.vectors2Arrays[t] = this._vectors2Arrays[t];
                for (t in e.vectors3Arrays = {},
                this._vectors3Arrays)
                    e.vectors3Arrays[t] = this._vectors3Arrays[t];
                for (t in e.vectors4Arrays = {},
                this._vectors4Arrays)
                    e.vectors4Arrays[t] = this._vectors4Arrays[t];
                for (t in e.quaternionsArrays = {},
                this._quaternionsArrays)
                    e.quaternionsArrays[t] = this._quaternionsArrays[t];
                return e
            }
            static Parse(e, t, i) {
                const s = ki.Parse(( () => new va(e.name,t,e.shaderPath,e.options,e.storeEffectOnSubMeshes)), e, t, i);
                let r;
                for (r in e.stencil && s.stencil.parse(e.stencil, t, i),
                e.textures)
                    s.setTexture(r, _n.Parse(e.textures[r], t, i));
                for (r in e.textureArrays) {
                    const n = e.textureArrays[r]
                      , a = [];
                    for (let e = 0; e < n.length; e++)
                        a.push(_n.Parse(n[e], t, i));
                    s.setTextureArray(r, a)
                }
                for (r in e.ints)
                    s.setInt(r, e.ints[r]);
                for (r in e.uints)
                    s.setUInt(r, e.uints[r]);
                for (r in e.floats)
                    s.setFloat(r, e.floats[r]);
                for (r in e.floatsArrays)
                    s.setFloats(r, e.floatsArrays[r]);
                for (r in e.colors3)
                    s.setColor3(r, Fe.FromArray(e.colors3[r]));
                for (r in e.colors3Arrays) {
                    const t = e.colors3Arrays[r].reduce(( (e, t, i) => (i % 3 == 0 ? e.push([t]) : e[e.length - 1].push(t),
                    e)), []).map((e => Fe.FromArray(e)));
                    s.setColor3Array(r, t)
                }
                for (r in e.colors4)
                    s.setColor4(r, Oe.FromArray(e.colors4[r]));
                for (r in e.colors4Arrays) {
                    const t = e.colors4Arrays[r].reduce(( (e, t, i) => (i % 4 == 0 ? e.push([t]) : e[e.length - 1].push(t),
                    e)), []).map((e => Oe.FromArray(e)));
                    s.setColor4Array(r, t)
                }
                for (r in e.vectors2)
                    s.setVector2(r, Pi.FromArray(e.vectors2[r]));
                for (r in e.vectors3)
                    s.setVector3(r, Di.FromArray(e.vectors3[r]));
                for (r in e.vectors4)
                    s.setVector4(r, wi.FromArray(e.vectors4[r]));
                for (r in e.quaternions)
                    s.setQuaternion(r, Fi.FromArray(e.quaternions[r]));
                for (r in e.matrices)
                    s.setMatrix(r, Oi.FromArray(e.matrices[r]));
                for (r in e.matrixArray)
                    s._matrixArrays[r] = new Float32Array(e.matrixArray[r]);
                for (r in e.matrices3x3)
                    s.setMatrix3x3(r, e.matrices3x3[r]);
                for (r in e.matrices2x2)
                    s.setMatrix2x2(r, e.matrices2x2[r]);
                for (r in e.vectors2Arrays)
                    s.setArray2(r, e.vectors2Arrays[r]);
                for (r in e.vectors3Arrays)
                    s.setArray3(r, e.vectors3Arrays[r]);
                for (r in e.vectors4Arrays)
                    s.setArray4(r, e.vectors4Arrays[r]);
                for (r in e.quaternionsArrays)
                    s.setArray4(r, e.quaternionsArrays[r]);
                return s
            }
            static ParseFromFileAsync(e, t, i, s="") {
                return new Promise(( (r, n) => {
                    const a = new qe;
                    a.addEventListener("readystatechange", ( () => {
                        if (4 == a.readyState)
                            if (200 == a.status) {
                                const t = JSON.parse(a.responseText)
                                  , n = this.Parse(t, i || Ze.LastCreatedScene, s);
                                e && (n.name = e),
                                r(n)
                            } else
                                n("Unable to load the ShaderMaterial")
                    }
                    )),
                    a.open("GET", t),
                    a.send()
                }
                ))
            }
            static ParseFromSnippetAsync(e, t, i="") {
                return new Promise(( (s, r) => {
                    const n = new qe;
                    n.addEventListener("readystatechange", ( () => {
                        if (4 == n.readyState)
                            if (200 == n.status) {
                                const r = JSON.parse(JSON.parse(n.responseText).jsonPayload)
                                  , a = JSON.parse(r.shaderMaterial)
                                  , o = this.Parse(a, t || Ze.LastCreatedScene, i);
                                o.snippetId = e,
                                s(o)
                            } else
                                r("Unable to load the snippet " + e)
                    }
                    )),
                    n.open("GET", this.SnippetUrl + "/" + e.replace(/#/g, "/")),
                    n.send()
                }
                ))
            }
        }
        va.SnippetUrl = "https://snippet.babylonjs.com",
        va.CreateFromSnippetAsync = va.ParseFromSnippetAsync,
        Ie("BABYLON.ShaderMaterial", va);
        bt.ShadersStore.colorPixelShader = "#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\n#define VERTEXCOLOR\nvarying vec4 vColor;\n#else\nuniform vec4 color;\n#endif\n#include<clipPlaneFragmentDeclaration>\n#include<fogFragmentDeclaration>\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\ngl_FragColor=vColor;\n#else\ngl_FragColor=color;\n#endif\n#include<fogFragment>(color,gl_FragColor)\n#define CUSTOM_FRAGMENT_MAIN_END\n}";
        bt.ShadersStore.colorVertexShader = "attribute vec3 position;\n#ifdef VERTEXCOLOR\nattribute vec4 color;\n#endif\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#ifdef FOG\nuniform mat4 view;\n#endif\n#include<instancesDeclaration>\nuniform mat4 viewProjection;\n#ifdef MULTIVIEW\nuniform mat4 viewProjectionR;\n#endif\n#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)\nvarying vec4 vColor;\n#endif\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void) {\n#define CUSTOM_VERTEX_MAIN_BEGIN\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(position,1.0);\n#ifdef MULTIVIEW\nif (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}\n#else\ngl_Position=viewProjection*worldPos;\n#endif\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<vertexColorMixing>\n#define CUSTOM_VERTEX_MAIN_END\n}",
        Gr._LinesMeshParser = (e, t) => ya.Parse(e, t);
        class ya extends Gr {
            _isShaderMaterial(e) {
                return "ShaderMaterial" === e.getClassName()
            }
            constructor(e, t=null, i=null, s=null, r, n, a, o) {
                super(e, t, i, s, r),
                this.useVertexColor = n,
                this.useVertexAlpha = a,
                this.color = new Fe(1,1,1),
                this.alpha = 1,
                s && (this.color = s.color.clone(),
                this.alpha = s.alpha,
                this.useVertexColor = s.useVertexColor,
                this.useVertexAlpha = s.useVertexAlpha),
                this.intersectionThreshold = .1;
                const h = {
                    attributes: [os.PositionKind],
                    uniforms: ["world", "viewProjection"],
                    needAlphaBlending: !0,
                    defines: [],
                    useClipPlane: null
                };
                !1 === a ? h.needAlphaBlending = !1 : h.defines.push("#define VERTEXALPHA"),
                n ? (h.defines.push("#define VERTEXCOLOR"),
                h.attributes.push(os.ColorKind)) : (h.uniforms.push("color"),
                this._color4 = new Oe),
                o ? this.material = o : (this.material = new va("colorShader",this.getScene(),"color",h,!1),
                this.material.doNotSerialize = !0)
            }
            isReady() {
                return !!this._lineMaterial.isReady(this, !!this._userInstancedBuffersStorage || this.hasThinInstances) && super.isReady()
            }
            getClassName() {
                return "LinesMesh"
            }
            get material() {
                return this._lineMaterial
            }
            set material(e) {
                this._lineMaterial = e,
                this._lineMaterial.fillMode = Fr.LineListDrawMode
            }
            get checkCollisions() {
                return !1
            }
            set checkCollisions(e) {}
            _bind(e, t) {
                if (!this._geometry)
                    return this;
                const i = this.isUnIndexed ? null : this._geometry.getIndexBuffer();
                if (!this._userInstancedBuffersStorage || this.hasThinInstances ? this._geometry._bind(t, i) : this._geometry._bind(t, i, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects),
                !this.useVertexColor && this._isShaderMaterial(this._lineMaterial)) {
                    const {r: e, g: t, b: i} = this.color;
                    this._color4.set(e, t, i, this.alpha),
                    this._lineMaterial.setColor4("color", this._color4)
                }
                return this
            }
            _draw(e, t, i) {
                if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer())
                    return this;
                const s = this.getScene().getEngine();
                return this._unIndexed ? s.drawArraysType(Fr.LineListDrawMode, e.verticesStart, e.verticesCount, i) : s.drawElementsType(Fr.LineListDrawMode, e.indexStart, e.indexCount, i),
                this
            }
            dispose(e, t=!1, i) {
                i || this._lineMaterial.dispose(!1, !1, !0),
                super.dispose(e)
            }
            clone(e, t=null, i) {
                return new ya(e,this.getScene(),t,this,i)
            }
            createInstance(e) {
                const t = new ba(e,this);
                if (this.instancedBuffers) {
                    t.instancedBuffers = {};
                    for (const e in this.instancedBuffers)
                        t.instancedBuffers[e] = this.instancedBuffers[e]
                }
                return t
            }
            serialize(e) {
                super.serialize(e),
                e.color = this.color.asArray(),
                e.alpha = this.alpha
            }
            static Parse(e, t) {
                const i = new ya(e.name,t);
                return i.color = Fe.FromArray(e.color),
                i.alpha = e.alpha,
                i
            }
        }
        class ba extends Xr {
            constructor(e, t) {
                super(e, t),
                this.intersectionThreshold = t.intersectionThreshold
            }
            getClassName() {
                return "InstancedLinesMesh"
            }
        }
        function xa(e) {
            const t = []
              , i = []
              , s = e.lines
              , r = e.colors
              , n = [];
            let a = 0;
            for (let e = 0; e < s.length; e++) {
                const o = s[e];
                for (let s = 0; s < o.length; s++) {
                    const {x: h, y: l, z: c} = o[s];
                    if (i.push(h, l, c),
                    r) {
                        const t = r[e]
                          , {r: i, g: a, b: o, a: h} = t[s];
                        n.push(i, a, o, h)
                    }
                    s > 0 && (t.push(a - 1),
                    t.push(a)),
                    a++
                }
            }
            const o = new $s;
            return o.indices = t,
            o.positions = i,
            r && (o.colors = n),
            o
        }
        function Ta(e) {
            const t = e.dashSize || 3
              , i = e.gapSize || 1
              , s = e.dashNb || 200
              , r = e.points
              , n = []
              , a = []
              , o = Di.Zero();
            let h = 0
              , l = 0
              , c = 0
              , u = 0
              , d = 0
              , f = 0
              , _ = 0;
            for (_ = 0; _ < r.length - 1; _++)
                r[_ + 1].subtractToRef(r[_], o),
                h += o.length();
            for (c = h / s,
            u = t * c / (t + i),
            _ = 0; _ < r.length - 1; _++) {
                r[_ + 1].subtractToRef(r[_], o),
                l = Math.floor(o.length() / c),
                o.normalize();
                for (let e = 0; e < l; e++)
                    d = c * e,
                    n.push(r[_].x + d * o.x, r[_].y + d * o.y, r[_].z + d * o.z),
                    n.push(r[_].x + (d + u) * o.x, r[_].y + (d + u) * o.y, r[_].z + (d + u) * o.z),
                    a.push(f, f + 1),
                    f += 2
            }
            const p = new $s;
            return p.positions = n,
            p.indices = a,
            p
        }
        function Ea(e, t, i=null) {
            const s = t.colors ? [t.colors] : null;
            return function(e, t, i=null) {
                const s = t.instance
                  , r = t.lines
                  , n = t.colors;
                if (s) {
                    const e = s.getVerticesData(os.PositionKind);
                    let t, i;
                    n && (t = s.getVerticesData(os.ColorKind));
                    let a = 0
                      , o = 0;
                    for (let s = 0; s < r.length; s++) {
                        const h = r[s];
                        for (let r = 0; r < h.length; r++)
                            e[a] = h[r].x,
                            e[a + 1] = h[r].y,
                            e[a + 2] = h[r].z,
                            n && t && (i = n[s],
                            t[o] = i[r].r,
                            t[o + 1] = i[r].g,
                            t[o + 2] = i[r].b,
                            t[o + 3] = i[r].a,
                            o += 4),
                            a += 3
                    }
                    return s.updateVerticesData(os.PositionKind, e, !1, !1),
                    n && t && s.updateVerticesData(os.ColorKind, t, !1, !1),
                    s
                }
                const a = new ya(e,i,null,void 0,void 0,!!n,t.useVertexAlpha,t.material);
                return xa(t).applyToMesh(a, t.updatable),
                a
            }(e, {
                lines: [t.points],
                updatable: t.updatable,
                instance: t.instance,
                colors: s,
                useVertexAlpha: t.useVertexAlpha,
                material: t.material
            }, i)
        }
        function Ma(e) {
            const t = []
              , i = []
              , s = []
              , r = []
              , n = e.width || e.size || 1
              , a = e.height || e.size || 1
              , o = 0 === e.sideOrientation ? 0 : e.sideOrientation || $s.DEFAULTSIDE
              , h = n / 2
              , l = a / 2;
            i.push(-h, -l, 0),
            s.push(0, 0, -1),
            r.push(0, er.UseOpenGLOrientationForUV ? 1 : 0),
            i.push(h, -l, 0),
            s.push(0, 0, -1),
            r.push(1, er.UseOpenGLOrientationForUV ? 1 : 0),
            i.push(h, l, 0),
            s.push(0, 0, -1),
            r.push(1, er.UseOpenGLOrientationForUV ? 0 : 1),
            i.push(-h, l, 0),
            s.push(0, 0, -1),
            r.push(0, er.UseOpenGLOrientationForUV ? 0 : 1),
            t.push(0),
            t.push(1),
            t.push(2),
            t.push(0),
            t.push(2),
            t.push(3),
            $s._ComputeSides(o, i, t, s, r, e.frontUVs, e.backUVs);
            const c = new $s;
            return c.indices = t,
            c.positions = i,
            c.normals = s,
            c.uvs = r,
            c
        }
        function Sa(e, t={}, i=null) {
            const s = new Gr(e,i);
            return t.sideOrientation = Gr._GetDefaultSideOrientation(t.sideOrientation),
            s._originalBuilderSideOrientation = t.sideOrientation,
            Ma(t).applyToMesh(s, t.updatable),
            t.sourcePlane && (s.translate(t.sourcePlane.normal, -t.sourcePlane.d),
            s.setDirection(t.sourcePlane.normal.scale(-1))),
            s
        }
        $s.CreateLineSystem = xa,
        $s.CreateDashedLines = Ta,
        Gr.CreateLines = (e, t, i=null, s=!1, r=null) => Ea(e, {
            points: t,
            updatable: s,
            instance: r
        }, i),
        Gr.CreateDashedLines = (e, t, i, s, r, n=null, a, o) => function(e, t, i=null) {
            const s = t.points
              , r = t.instance
              , n = t.gapSize || 1
              , a = t.dashSize || 3;
            if (r) {
                const e = e => {
                    const t = Di.Zero()
                      , i = e.length / 6;
                    let n = 0
                      , a = 0
                      , o = 0
                      , h = 0
                      , l = 0
                      , c = 0
                      , u = 0
                      , d = 0;
                    for (u = 0; u < s.length - 1; u++)
                        s[u + 1].subtractToRef(s[u], t),
                        n += t.length();
                    o = n / i;
                    const f = r._creationDataStorage.dashSize;
                    for (h = f * o / (f + r._creationDataStorage.gapSize),
                    u = 0; u < s.length - 1; u++)
                        for (s[u + 1].subtractToRef(s[u], t),
                        a = Math.floor(t.length() / o),
                        t.normalize(),
                        d = 0; d < a && c < e.length; )
                            l = o * d,
                            e[c] = s[u].x + l * t.x,
                            e[c + 1] = s[u].y + l * t.y,
                            e[c + 2] = s[u].z + l * t.z,
                            e[c + 3] = s[u].x + (l + h) * t.x,
                            e[c + 4] = s[u].y + (l + h) * t.y,
                            e[c + 5] = s[u].z + (l + h) * t.z,
                            c += 6,
                            d++;
                    for (; c < e.length; )
                        e[c] = s[u].x,
                        e[c + 1] = s[u].y,
                        e[c + 2] = s[u].z,
                        c += 3
                }
                ;
                return (t.dashNb || t.dashSize || t.gapSize || t.useVertexAlpha || t.material) && We.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."),
                r.updateMeshPositions(e, !1),
                r
            }
            const o = new ya(e,i,null,void 0,void 0,void 0,t.useVertexAlpha,t.material);
            return Ta(t).applyToMesh(o, t.updatable),
            o._creationDataStorage = new Br,
            o._creationDataStorage.dashSize = a,
            o._creationDataStorage.gapSize = n,
            o
        }(e, {
            points: t,
            dashSize: i,
            gapSize: s,
            dashNb: r,
            updatable: a,
            instance: o
        }, n),
        $s.CreatePlane = Ma,
        Gr.CreatePlane = (e, t, i, s, r) => Sa(e, {
            size: t,
            width: t,
            height: t,
            sideOrientation: r,
            updatable: s
        }, i);
        var Aa = {
            showFPS: !1,
            antiAlias: !0,
            clearColor: [.8, .9, 1],
            ambientColor: [.5, .5, .5],
            lightDiffuse: [1, 1, 1],
            lightSpecular: [1, 1, 1],
            lightVector: [1, -1, .5],
            useAO: !0,
            AOmultipliers: [.93, .8, .5],
            reverseAOmultiplier: 1,
            preserveDrawingBuffer: !0,
            octreeBlockSize: 2,
            renderOnResize: !0
        };
        class Ia {
            constructor(e, t, i) {
                t = Object.assign({}, Aa, t),
                this.noa = e,
                this.renderOnResize = !!t.renderOnResize,
                this.useAO = !!t.useAO,
                this.aoVals = t.AOmultipliers,
                this.revAoVal = t.reverseAOmultiplier,
                this.meshingCutoffTime = 6,
                this.engine = null,
                this.scene = null,
                this.light = null,
                this.camera = null,
                this._initScene(i, t),
                t.showFPS && function() {
                    var e = document.createElement("div");
                    e.id = "noa_fps",
                    e.style.position = "absolute",
                    e.style.top = "0",
                    e.style.right = "0",
                    e.style.zIndex = "0",
                    e.style.color = "white",
                    e.style.backgroundColor = "rgba(0,0,0,0.5)",
                    e.style.font = "14px monospace",
                    e.style.textAlign = "center",
                    e.style.minWidth = "2em",
                    e.style.margin = "4px",
                    document.body.appendChild(e);
                    var t = 0
                      , i = 0
                      , s = performance.now()
                      , r = s;
                    Da = function() {
                        t++;
                        var n = performance.now();
                        if (n - r > i && (i = n - r),
                        r = n,
                        !(n - s < 1e3)) {
                            var a = Math.round(t / (n - s) * 1e3)
                              , o = Math.round(1 / i * 1e3);
                            e.innerHTML = a + "<br>" + o,
                            t = 0,
                            i = 0,
                            s = n
                        }
                    }
                }()
            }
            _initScene(e, t) {
                this.engine = new rr(e,t.antiAlias,{
                    preserveDrawingBuffer: t.preserveDrawingBuffer
                });
                var i = new ks(this.engine);
                this.scene = i,
                i.detachControl(),
                i.performancePriority = Us.Intermediate,
                i.autoClear = !0;
                var s = Math.round(t.octreeBlockSize);
                this._octreeManager = new Kn(this,s),
                this._cameraHolder = new lr("camHolder",i),
                this.camera = new sa("camera",new Di(0,0,0),i),
                this.camera.parent = this._cameraHolder,
                this.camera.minZ = .01,
                this._camScreen = Sa("camScreen", {
                    size: 10
                }, i),
                this.addMeshToScene(this._camScreen),
                this._camScreen.position.z = .1,
                this._camScreen.parent = this.camera,
                this._camScreenMat = this.makeStandardMaterial("camera_screen_mat"),
                this._camScreen.material = this._camScreenMat,
                this._camScreen.setEnabled(!1),
                this._camScreenMat.freeze(),
                this._camLocBlock = 0,
                i.clearColor = Oe.FromArray(t.clearColor),
                i.ambientColor = Fe.FromArray(t.ambientColor);
                var r = Di.FromArray(t.lightVector);
                this.light = new aa("light",r,i),
                this.light.diffuse = Fe.FromArray(t.lightDiffuse),
                this.light.specular = Fe.FromArray(t.lightSpecular),
                i.skipPointerMovePicking = !0
            }
        }
        Ia.prototype.getScene = function() {
            return this.scene
        }
        ,
        Ia.prototype.tick = function(e) {}
        ,
        Ia.prototype.render = function() {
            Pa("start"),
            function(e) {
                var t = e.noa.camera
                  , i = t._localGetTargetPosition();
                e._cameraHolder.position.copyFromFloats(i[0], i[1], i[2]),
                e._cameraHolder.rotation.x = t.pitch,
                e._cameraHolder.rotation.y = t.heading,
                e.camera.position.z = -t.currentZoom;
                var s = t._localGetPosition()
                  , r = e.noa.worldOriginOffset
                  , n = Math.floor(s[0] + r[0])
                  , a = Math.floor(s[1] + r[1])
                  , o = Math.floor(s[2] + r[2])
                  , h = e.noa.getBlock(n, a, o);
                !function(e, t) {
                    if (t !== e._camLocBlock) {
                        if (0 === t)
                            e._camScreen.setEnabled(!1);
                        else {
                            var i = e.noa.registry.getBlockFaceMaterial(t, 0);
                            if (i) {
                                var s = e.noa.registry.getMaterialData(i)
                                  , r = s.color
                                  , n = s.alpha;
                                r && n && n < 1 && (e._camScreenMat.diffuseColor.set(0, 0, 0),
                                e._camScreenMat.ambientColor.set(r[0], r[1], r[2]),
                                e._camScreenMat.alpha = n,
                                e._camScreen.setEnabled(!0))
                            }
                        }
                        e._camLocBlock = t
                    }
                }(e, h)
            }(this),
            Pa("updateCamera"),
            this.engine.beginFrame(),
            Pa("beginFrame"),
            this.scene.render(),
            Pa("render"),
            Da(),
            this.engine.endFrame(),
            Pa("endFrame"),
            Pa("end")
        }
        ,
        Ia.prototype.postRender = function() {}
        ,
        Ia.prototype.resize = function() {
            this.engine.resize(),
            this.noa._paused && this.renderOnResize && this.scene.render()
        }
        ,
        Ia.prototype.highlightBlockFace = function(e, t, i) {
            var s = function(e) {
                var t = e._highlightMesh;
                if (!t) {
                    t = Sa("highlight", {
                        size: 1
                    }, e.scene);
                    var i = e.makeStandardMaterial("block_highlight_mat");
                    i.backFaceCulling = !1,
                    i.emissiveColor = new Fe(1,1,1),
                    i.alpha = .2,
                    i.freeze(),
                    t.material = i;
                    var s = .5
                      , r = Ea("hightlightLines", {
                        points: [new Di(s,s,0), new Di(s,-s,0), new Di(-s,-s,0), new Di(-s,s,0), new Di(s,s,0)]
                    }, e.scene);
                    r.color = new Fe(1,1,1),
                    r.parent = t,
                    e.addMeshToScene(t),
                    e.addMeshToScene(r),
                    e._highlightMesh = t
                }
                return t
            }(this);
            if (e) {
                this.noa.globalToLocal(t, null, Ra);
                for (var n = .001 + .001 * r().dist(this.noa.camera._localGetPosition(), Ra), a = 0; a < 3; a++)
                    0 === i[a] ? Ra[a] += .5 : Ra[a] += i[a] > 0 ? 1 + n : -n;
                s.position.copyFromFloats(Ra[0], Ra[1], Ra[2]),
                s.rotation.x = i[1] ? Math.PI / 2 : 0,
                s.rotation.y = i[0] ? Math.PI / 2 : 0
            }
            s.setEnabled(e)
        }
        ;
        var Ra = [];
        Ia.prototype.addMeshToScene = function(e, t=!1, i=null, s=null) {
            if (e.metadata || (e.metadata = {}),
            e.metadata[Ca])
                this._octreeManager.setMeshVisibility(e, !0);
            else {
                if (e.metadata[Ca] = !0,
                !e.parent) {
                    i || (i = e.position.asArray());
                    var r = this.noa.globalToLocal(i, null, []);
                    e.position.fromArray(r)
                }
                this._octreeManager.addMesh(e, t, i, s),
                e.onDisposeObservable.add(( () => {
                    this._octreeManager.removeMesh(e),
                    e.metadata[Ca] = !1
                }
                ))
            }
        }
        ;
        var Ca = "noa_added_to_scene";
        Ia.prototype.setMeshVisibility = function(e, t=!1) {
            e.metadata || (e.metadata = {}),
            e.metadata[Ca] ? this._octreeManager.setMeshVisibility(e, t) : t && this.addMeshToScene(e)
        }
        ,
        Ia.prototype.makeStandardMaterial = function(e) {
            var t = new ma(e,this.scene);
            return t.specularColor.copyFromFloats(0, 0, 0),
            t.ambientColor.copyFromFloats(1, 1, 1),
            t.diffuseColor.copyFromFloats(1, 1, 1),
            t
        }
        ,
        Ia.prototype.prepareChunkForRendering = function(e) {}
        ,
        Ia.prototype.disposeChunkForRendering = function(e) {}
        ,
        Ia.prototype._rebaseOrigin = function(e) {
            var t = new Di(e[0],e[1],e[2]);
            this.scene.meshes.forEach((e => {
                e.parent || (e.position.subtractInPlace(t),
                e.isWorldMatrixFrozen && e.freezeWorldMatrix())
            }
            )),
            this._octreeManager.rebase(t)
        }
        ,
        Ia.prototype.debug_SceneCheck = function() {
            var e = this.scene.meshes
              , t = this.scene._selectionOctree
              , i = t.dynamicContent
              , s = []
              , r = 0
              , n = 0
              , a = this.scene.materials
              , o = [];
            a.forEach((e => {
                e.subMaterials ? e.subMaterials.forEach((e => o.push(e))) : o.push(e)
            }
            )),
            t.blocks.forEach((function(e) {
                r++,
                e.entries.forEach((e => s.push(e)))
            }
            )),
            e.forEach((function(e) {
                if (e.isDisposed() && c(e, "disposed mesh in scene"),
                !function(e) {
                    return 0 === e.getIndices().length
                }(e))
                    if (u(e, i, s) && c(e, "non-empty mesh missing from octree"),
                    e.material) {
                        n += e.subMeshes ? e.subMeshes.length : 1;
                        var t = e.material.subMaterials || [e.material];
                        t.forEach((function(e) {
                            u(e, t) && c(e, "mesh material not in scene")
                        }
                        ))
                    } else
                        c(e, "non-empty scene mesh with no material")
            }
            ));
            var h = [];
            o.forEach((t => {
                var i = !1;
                e.forEach((e => {
                    e.material === t && (i = !0),
                    e.material && (e.material.subMaterials || [e.material]).includes(t) && (i = !0)
                }
                )),
                i || h.push(t.name)
            }
            )),
            h.length && console.warn("Materials unused by any mesh: ", h.join(", ")),
            i.forEach((function(t) {
                u(t, e) && c(t, "octree/dynamic mesh not in scene")
            }
            )),
            s.forEach((function(t) {
                u(t, e) && c(t, "octree block mesh not in scene")
            }
            ));
            var l = Math.round(10 * s.length / r) / 10;
            function c(e, t) {
                console.warn(e.name + " --- " + t)
            }
            function u(e, t, i) {
                return !(!e || t.includes(e) || i && i.includes(e))
            }
            return console.log("meshes - octree:", s.length, "  dynamic:", i.length, "   subMeshes:", n, "   avg meshes/octreeBlock:", l),
            "done."
        }
        ,
        Ia.prototype.debug_MeshCount = function() {
            var e = {};
            for (var t in this.scene.meshes.forEach((t => {
                var i = t.name || "";
                i = (i = (i = (i = i.replace(/-\d+.*/, "#")).replace(/\d+.*/, "#")).replace(/(rotHolder|camHolder|camScreen)/, "rendering use")).replace(/atlas sprite .*/, "atlas sprites"),
                e[i] = e[i] || 0,
                e[i]++
            }
            )),
            e)
                console.log("   " + (e[t] + "       ").substr(0, 7) + t)
        }
        ;
        var Pa = () => {}
          , Da = function() {};
        class wa {
            constructor(e, t, i, s, n, a, o) {
                this.aabb = new F(e.base,e.vec),
                this.mass = t,
                this.friction = i,
                this.restitution = s,
                this.gravityMultiplier = n,
                this.onCollide = a,
                this.autoStep = !!o,
                this.airDrag = -1,
                this.fluidDrag = -1,
                this.onStep = null,
                this.velocity = r().create(),
                this.resting = [0, 0, 0],
                this.inFluid = !1,
                this._ratioInFluid = 0,
                this._forces = r().create(),
                this._impulses = r().create(),
                this._sleepFrameCount = 10
            }
            setPosition(e) {
                Fa(e),
                r().subtract(e, e, this.aabb.base),
                this.aabb.translate(e),
                this._markActive()
            }
            getPosition() {
                return r().clone(this.aabb.base)
            }
            applyForce(e) {
                Fa(e),
                r().add(this._forces, this._forces, e),
                this._markActive()
            }
            applyImpulse(e) {
                Fa(e),
                r().add(this._impulses, this._impulses, e),
                this._markActive()
            }
            _markActive() {
                this._sleepFrameCount = 10
            }
            atRestX() {
                return this.resting[0]
            }
            atRestY() {
                return this.resting[1]
            }
            atRestZ() {
                return this.resting[2]
            }
        }
        var Fa = e => {}
        ;
        function Oa() {
            this.airDrag = .1,
            this.fluidDrag = .4,
            this.fluidDensity = 2,
            this.gravity = [0, -10, 0],
            this.minBounceImpulse = .5
        }
        function La(e, t, i) {
            e = Object.assign(new Oa, e),
            this.gravity = e.gravity || [0, -10, 0],
            this.airDrag = e.airDrag || .1,
            this.fluidDensity = e.fluidDensity || 2,
            this.fluidDrag = e.fluidDrag || .4,
            this.minBounceImpulse = e.minBounceImpulse,
            this.bodies = [],
            this.testSolid = t,
            this.testFluid = i
        }
        La.prototype.addBody = function(e, t, i, s, r, n) {
            e = e || new F([0, 0, 0],[1, 1, 1]),
            void 0 === t && (t = 1),
            void 0 === i && (i = 1),
            void 0 === s && (s = 0),
            void 0 === r && (r = 1);
            var a = new wa(e,t,i,s,r,n);
            return this.bodies.push(a),
            a
        }
        ,
        La.prototype.removeBody = function(e) {
            var t = this.bodies.indexOf(e);
            t < 0 || (this.bodies.splice(t, 1),
            e.aabb = e.onCollide = null)
        }
        ;
        var Ba = r().create()
          , Na = r().create()
          , Ua = r().create()
          , ka = r().create()
          , Va = r().create();
        La.prototype.tick = function(e) {
            e /= 1e3;
            var t = Qa(0, r().squaredLength(this.gravity));
            this.bodies.forEach((i => function(e, t, i, s) {
                if (r().copy(Va, t.resting),
                t.mass <= 0)
                    return r().set(t.velocity, 0, 0, 0),
                    r().set(t._forces, 0, 0, 0),
                    void r().set(t._impulses, 0, 0, 0);
                if (!function(e, t, i, s) {
                    if (t._sleepFrameCount > 0)
                        return !1;
                    if (s)
                        return !0;
                    var n = !1
                      , a = .5 * i * i * t.gravityMultiplier;
                    return r().scale(Za, e.gravity, a),
                    L()(e.testSolid, t.aabb, Za, (function() {
                        return n = !0,
                        !0
                    }
                    ), !0),
                    n
                }(e, t, i, s || 0 === t.gravityMultiplier)) {
                    t._sleepFrameCount--,
                    function(e, t) {
                        var i = t.aabb
                          , s = Math.floor(i.base[0])
                          , n = Math.floor(i.base[2])
                          , a = Math.floor(i.base[1])
                          , o = Math.floor(i.max[1]);
                        if (!e.testFluid(s, a, n))
                            return t.inFluid = !1,
                            void (t.ratioInFluid = 0);
                        for (var h = 1, l = a + 1; l <= o && e.testFluid(s, l, n); )
                            h++,
                            l++;
                        var c = (a + h - i.base[1]) / i.vec[1];
                        c > 1 && (c = 1);
                        var u = i.vec[0] * i.vec[1] * i.vec[2] * c
                          , d = Ga;
                        r().scale(d, e.gravity, -e.fluidDensity * u),
                        t.applyForce(d),
                        t.inFluid = !0,
                        t.ratioInFluid = c
                    }(e, t),
                    Ja(t._forces),
                    Ja(t._impulses),
                    Ja(t.velocity),
                    Ja(t.resting),
                    r().scale(Ba, t._forces, 1 / t.mass),
                    r().scaleAndAdd(Ba, Ba, e.gravity, t.gravityMultiplier),
                    r().scale(Na, t._impulses, 1 / t.mass),
                    r().scaleAndAdd(Na, Na, Ba, i),
                    r().add(t.velocity, t.velocity, Na),
                    t.friction && (za(0, t, Na),
                    za(1, t, Na),
                    za(2, t, Na));
                    var n = t.airDrag >= 0 ? t.airDrag : e.airDrag;
                    t.inFluid && (n = t.fluidDrag >= 0 ? t.fluidDrag : e.fluidDrag,
                    n *= 1 - (1 - t.ratioInFluid) ** 2);
                    var a = Math.max(1 - n * i / t.mass, 0);
                    r().scale(t.velocity, t.velocity, a),
                    r().scale(Ua, t.velocity, i),
                    r().set(t._forces, 0, 0, 0),
                    r().set(t._impulses, 0, 0, 0),
                    t.autoStep && $a(Ha, t.aabb),
                    Xa(e, t.aabb, Ua, t.resting),
                    t.autoStep && function(e, t, i, s) {
                        if (!(t.resting[1] >= 0) || t.inFluid) {
                            var n = 0 !== t.resting[0]
                              , a = 0 !== t.resting[2];
                            if (n || a) {
                                var o = Math.abs(s[0] / s[2]);
                                if ((n || !(o > 4)) && (a || !(o < 1 / 4))) {
                                    r().add(Ya, i.base, s);
                                    var h = e.testSolid;
                                    L()(h, i, s, (function(e, t, i, s) {
                                        if (1 !== t)
                                            return !0;
                                        s[t] = 0
                                    }
                                    ));
                                    var l = t.aabb.base[1]
                                      , c = Math.floor(l + 1.001) - l;
                                    r().set(ja, 0, c, 0);
                                    var u = !1;
                                    L()(h, i, ja, (function(e, t, i, s) {
                                        return u = !0,
                                        !0
                                    }
                                    )),
                                    u || (r().subtract(qa, Ya, i.base),
                                    qa[1] = 0,
                                    Xa(e, i, qa, Ka),
                                    (!n || Qa(i.base[0], Ya[0])) && (a && !Qa(i.base[2], Ya[2]) || ($a(t.aabb, i),
                                    t.resting[0] = Ka[0],
                                    t.resting[2] = Ka[2],
                                    t.onStep && t.onStep())))
                                }
                            }
                        }
                    }(e, t, Ha, Ua);
                    for (var o = 0; o < 3; ++o)
                        ka[o] = 0,
                        t.resting[o] && (Va[o] || (ka[o] = -t.velocity[o]),
                        t.velocity[o] = 0);
                    var h = r().length(ka);
                    h > .001 && (r().scale(ka, ka, t.mass),
                    t.onCollide && t.onCollide(ka),
                    t.restitution > 0 && h > e.minBounceImpulse && (r().scale(ka, ka, t.restitution),
                    t.applyImpulse(ka))),
                    r().squaredLength(t.velocity) > 1e-5 && t._markActive()
                }
            }(this, i, e, t)))
        }
        ;
        var Ga = r().create();
        function za(e, t, i) {
            var s = t.resting[e]
              , n = i[e];
            if (0 !== s && !(s * n <= 0)) {
                r().copy(Wa, t.velocity),
                Wa[e] = 0;
                var a = r().length(Wa);
                if (!Qa(a, 0)) {
                    var o = Math.abs(t.friction * n)
                      , h = a > o ? (a - o) / a : 0;
                    t.velocity[(e + 1) % 3] *= h,
                    t.velocity[(e + 2) % 3] *= h
                }
            }
        }
        var Wa = r().create();
        function Xa(e, t, i, s) {
            return r().set(s, 0, 0, 0),
            L()(e.testSolid, t, i, (function(e, t, i, r) {
                s[t] = i,
                r[t] = 0
            }
            ))
        }
        var Ha = new F([],[])
          , Ka = r().create()
          , Ya = r().create()
          , ja = r().create()
          , qa = r().create()
          , Za = r().create();
        function Qa(e, t) {
            return Math.abs(e - t) < 1e-5
        }
        function $a(e, t) {
            for (var i = 0; i < 3; i++)
                e.base[i] = t.base[i],
                e.max[i] = t.max[i],
                e.vec[i] = t.vec[i]
        }
        var Ja = function(e) {}
          , eo = {
            gravity: [0, -10, 0],
            airDrag: .1
        };
        class to extends La {
            constructor(e, t) {
                t = Object.assign({}, eo, t);
                var i = e.world
                  , s = e.registry._solidityLookup
                  , r = e.registry._fluidityLookup
                  , n = e.worldOriginOffset;
                super(t, ( (e, t, r) => {
                    var a = i.getBlockID(e + n[0], t + n[1], r + n[2]);
                    return s[a]
                }
                ), ( (e, t, s) => {
                    var a = i.getBlockID(e + n[0], t + n[1], s + n[2]);
                    return r[a]
                }
                ))
            }
        }
        function io(e, t, i, s, r, n, o, h=-1) {
            this.noa = e,
            this.isDisposed = !1,
            this.userData = null,
            this.requestID = t,
            this.voxels = o,
            this.i = i,
            this.j = s,
            this.k = r,
            this.size = n,
            this.x = i * n,
            this.y = s * n,
            this.z = r * n,
            this.pos = [this.x, this.y, this.z],
            this._terrainDirty = !1,
            this._objectsDirty = !1,
            this._terrainMeshes = [],
            e._terrainMesher.initChunk(this),
            e._objectMesher.initChunk(this),
            this._isFull = !1,
            this._isEmpty = !1,
            this._wholeLayerVoxel = Array(n).fill(-1),
            h >= 0 && (this.voxels.data.fill(h, 0, this.voxels.size),
            this._wholeLayerVoxel.fill(h));
            var l = Array.from(Array(27), ( () => null));
            this._neighbors = a()(l, [3, 3, 3]).lo(1, 1, 1),
            this._neighbors.set(0, 0, 0, this),
            this._neighborCount = 0,
            this._timesMeshed = 0,
            this._blockHandlerLocs = new rn,
            ro(this)
        }
        function so(e, t, i, s, r, n) {
            var a = t[i];
            a && a(e.x + s, e.y + r, e.z + n)
        }
        function ro(e) {
            for (var t = e.voxels, i = t.data, s = t.shape[0], r = e.noa.registry._opacityLookup, n = e.noa.registry._blockHandlerLookup, a = e.noa.registry._objectLookup, o = e.noa.registry._blockIsPlainLookup, h = e.noa._objectMesher, l = !0, c = !0, u = 0; u < s; ++u) {
                var d = e._wholeLayerVoxel[u];
                if (d >= 0 && !h[d] && !n[d])
                    r[d] || (l = !1),
                    0 !== d && (c = !1);
                else {
                    for (var f = t.get(0, u, 0), _ = 0; _ < s; ++_)
                        for (var p = t.index(_, u, 0), m = 0; m < s; ++m,
                        ++p) {
                            var g = i[p];
                            if (f >= 0 && g !== f && (f = -1),
                            0 !== g)
                                if (o[g])
                                    c = !1;
                                else {
                                    l = l && r[g],
                                    c = !1,
                                    a[g] && (h.setObjectBlock(e, g, _, u, m),
                                    e._objectsDirty = !0);
                                    var v = n[g];
                                    v && (e._blockHandlerLocs.add(_, u, m),
                                    so(e, v, "onLoad", _, u, m))
                                }
                            else
                                l = !1
                        }
                    f >= 0 && (e._wholeLayerVoxel[u] = f)
                }
            }
            e._isFull = l,
            e._isEmpty = c,
            e._terrainDirty = !e._isEmpty
        }
        function no(e, t) {
            var i = e.voxels
              , s = e.noa.registry._blockHandlerLookup;
            e._blockHandlerLocs.arr.forEach(( ([r,n,a]) => {
                var o = i.get(r, n, a);
                so(e, s[o], t, r, n, a)
            }
            ))
        }
        io._createVoxelArray = function(e) {
            var t = new Uint16Array(e * e * e);
            return a()(t, [e, e, e])
        }
        ,
        io.prototype._updateVoxelArray = function(e, t=-1) {
            no(this, "onUnload"),
            this.noa._objectMesher.disposeChunk(this),
            this.noa._terrainMesher.disposeChunk(this),
            this.voxels = e,
            this._terrainDirty = !1,
            this._objectsDirty = !1,
            this._blockHandlerLocs.empty(),
            this.noa._objectMesher.initChunk(this),
            this.noa._terrainMesher.initChunk(this),
            t >= 0 ? this._wholeLayerVoxel.fill(t) : this._wholeLayerVoxel.fill(-1),
            ro(this)
        }
        ,
        io.prototype.get = function(e, t, i) {
            return this.voxels.get(e, t, i)
        }
        ,
        io.prototype.getSolidityAt = function(e, t, i) {
            return this.noa.registry._solidityLookup[this.voxels.get(e, t, i)]
        }
        ,
        io.prototype.set = function(e, t, i, s) {
            var r = this.voxels.get(e, t, i);
            if (s !== r) {
                this.voxels.set(e, t, i, s);
                var n = this.noa.registry._solidityLookup
                  , a = this.noa.registry._objectLookup
                  , o = this.noa.registry._opacityLookup
                  , h = this.noa.registry._blockHandlerLookup;
                o[s] || (this._isFull = !1),
                0 !== s && (this._isEmpty = !1),
                this._wholeLayerVoxel[t] !== s && (this._wholeLayerVoxel[t] = -1);
                var l = h[r]
                  , c = h[s];
                l && so(this, l, "onUnset", e, t, i),
                c ? (so(this, c, "onSet", e, t, i),
                this._blockHandlerLocs.add(e, t, i)) : this._blockHandlerLocs.remove(e, t, i);
                var u = this.noa._objectMesher
                  , d = a[r]
                  , f = a[s];
                d && u.setObjectBlock(this, 0, e, t, i),
                f && u.setObjectBlock(this, s, e, t, i);
                var _ = n[r] !== n[s]
                  , p = o[r] !== o[s]
                  , m = !d && 0 !== r
                  , g = !f && 0 !== s;
                if ((d || f) && (this._objectsDirty = !0),
                (_ || p || m || g) && (this._terrainDirty = !0),
                (this._terrainDirty || this._objectsDirty) && this.noa.world._queueChunkForRemesh(this),
                _ || p)
                    for (var v = this.size - 1, y = 0 === t ? -1 : 0, b = 0 === i ? -1 : 0, x = e === v ? 1 : 0, T = t === v ? 1 : 0, E = i === v ? 1 : 0, M = 0 === e ? -1 : 0; M <= x; M++)
                        for (var S = y; S <= T; S++)
                            for (var A = b; A <= E; A++)
                                if (M | S | A) {
                                    var I = this._neighbors.get(M, S, A);
                                    I && (I._terrainDirty = !0,
                                    this.noa.world._queueChunkForRemesh(I))
                                }
            }
        }
        ,
        io.prototype.updateMeshes = function() {
            this._terrainDirty && (this.noa._terrainMesher.meshChunk(this),
            this._timesMeshed++,
            this._terrainDirty = !1),
            this._objectsDirty && (this.noa._objectMesher.buildObjectMeshes(),
            this._objectsDirty = !1)
        }
        ,
        io.prototype.dispose = function() {
            no(this, "onUnload"),
            this._blockHandlerLocs.empty(),
            this.noa._objectMesher.disposeChunk(this),
            this.noa._terrainMesher.disposeChunk(this),
            this.voxels.data = null,
            this.voxels = null,
            this._neighbors.data = null,
            this._neighbors = null,
            this.isDisposed = !0
        }
        ;
        var ao = {
            chunkSize: 24,
            chunkAddDistance: [2, 2],
            chunkRemoveDistance: [3, 3],
            worldGenWhilePaused: !1,
            manuallyControlChunkLoading: !1
        };
        class oo extends (t()) {
            constructor(e, t) {
                super(),
                t = Object.assign({}, ao, t),
                this.noa = e,
                this.playerChunkLoaded = !1,
                this.Chunk = io,
                this.manuallyControlChunkLoading = !!t.manuallyControlChunkLoading,
                this.chunkSortingDistFn = Mo,
                this.minNeighborsToMesh = 6,
                this.worldGenWhilePaused = !!t.worldGenWhilePaused,
                this.maxChunksPendingCreation = 50,
                this.maxChunksPendingMeshing = 50,
                this.maxProcessingPerTick = 5,
                this.maxProcessingPerRender = 3,
                this._chunkSize = t.chunkSize,
                this._chunkAddDistance = [2, 2],
                this._chunkRemoveDistance = [3, 3],
                this._addDistanceFn = null,
                this._remDistanceFn = null,
                this._prevWorldName = "",
                this._prevPlayerChunkHash = 0,
                this._chunkAddSearchFrom = 0,
                this._prevSortingFn = null,
                this._sortMeshQueueEvery = 0,
                this._chunksKnown = new rn,
                this._chunksToRequest = new rn,
                this._chunksInvalidated = new rn,
                this._chunksToRemove = new rn,
                this._chunksPending = new rn,
                this._chunksToMesh = new rn,
                this._chunksToMeshFirst = new rn,
                this._chunksSortedLocs = new rn,
                this.setAddRemoveDistance(t.chunkAddDistance, t.chunkRemoveDistance),
                this._storage = new sn;
                var i = this._chunkSize;
                this._coordsToChunkIndexes = yo,
                this._coordsToChunkLocals = bo,
                !(i & i - 1) && (this._coordShiftBits = 0 | Math.log2(i),
                this._coordMask = i - 1 | 0,
                this._coordsToChunkIndexes = xo,
                this._coordsToChunkLocals = To)
            }
        }
        oo.prototype.getBlockID = function(e=0, t=0, i=0) {
            var [s,r,n] = this._coordsToChunkIndexes(e, t, i)
              , a = this._storage.getChunkByIndexes(s, r, n);
            if (!a)
                return 0;
            var [o,h,l] = this._coordsToChunkLocals(e, t, i);
            return a.voxels.get(o, h, l)
        }
        ,
        oo.prototype.getBlockSolidity = function(e=0, t=0, i=0) {
            var [s,r,n] = this._coordsToChunkIndexes(e, t, i)
              , a = this._storage.getChunkByIndexes(s, r, n);
            if (!a)
                return !1;
            var [o,h,l] = this._coordsToChunkLocals(e, t, i);
            return !!a.getSolidityAt(o, h, l)
        }
        ,
        oo.prototype.getBlockOpacity = function(e=0, t=0, i=0) {
            var s = this.getBlockID(e, t, i);
            return this.noa.registry.getBlockOpacity(s)
        }
        ,
        oo.prototype.getBlockFluidity = function(e=0, t=0, i=0) {
            var s = this.getBlockID(e, t, i);
            return this.noa.registry.getBlockFluidity(s)
        }
        ,
        oo.prototype.getBlockProperties = function(e=0, t=0, i=0) {
            var s = this.getBlockID(e, t, i);
            return this.noa.registry.getBlockProps(s)
        }
        ,
        oo.prototype.setBlockID = function(e=0, t=0, i=0, s=0) {
            var [r,n,a] = this._coordsToChunkIndexes(t, i, s)
              , o = this._storage.getChunkByIndexes(r, n, a);
            if (o) {
                var [h,l,c] = this._coordsToChunkLocals(t, i, s);
                return o.set(h, l, c, e)
            }
        }
        ,
        oo.prototype.isBoxUnobstructed = function(e) {
            for (var t = e.base, i = e.max, s = Math.floor(t[0]); s < i[0] + 1; s++)
                for (var r = Math.floor(t[1]); r < i[1] + 1; r++)
                    for (var n = Math.floor(t[2]); n < i[2] + 1; n++)
                        if (this.getBlockSolidity(s, r, n))
                            return !1;
            return !0
        }
        ,
        oo.prototype.setChunkData = function(e, t, i=null, s=-1) {
            !function(e, t, i, s, r) {
                var n = t.split("|")
                  , a = parseInt(n.shift())
                  , o = parseInt(n.shift())
                  , h = parseInt(n.shift())
                  , l = n.join("|");
                if (e._chunksPending.remove(a, o, h),
                l === e.noa.worldName && e._chunksKnown.includes(a, o, h) && !e._chunksToRemove.includes(a, o, h)) {
                    var c = e._storage.getChunkByIndexes(a, o, h);
                    if (c)
                        c._updateVoxelArray(i, r);
                    else {
                        var u = e._chunkSize;
                        c = new io(e.noa,t,a,o,h,u,i,r),
                        e._storage.storeChunkByIndexes(a, o, h, c),
                        c.userData = s,
                        e.noa.rendering.prepareChunkForRendering(c),
                        e.emit("chunkAdded", c)
                    }
                    vo(e, c),
                    So(e, a, o, h, c),
                    Co("receive")
                }
            }(this, e, t, i, s)
        }
        ,
        oo.prototype.setAddRemoveDistance = function(e=2, t=3) {
            var i = Array.isArray(e) ? e : [e, e]
              , s = Array.isArray(t) ? t : [t, t];
            s[0] < i[0] + 1 && (s[0] = i[0] + 1),
            s[1] < i[1] + 1 && (s[1] = i[1] + 1),
            this._chunkAddDistance = i,
            this._chunkRemoveDistance = s,
            this._addDistanceFn = Ao(i[0], i[1]),
            this._remDistanceFn = Ao(s[0], s[1]),
            this._chunksSortedLocs.empty();
            for (var r = 0; r <= i[0]; r++)
                for (var n = 0; n <= r; n++)
                    for (var a = 0; a <= i[1]; a++)
                        this._addDistanceFn(r, a, n) && this._chunksSortedLocs.add(r, a, n);
            this._prevSortingFn = null,
            this._chunkAddSearchFrom = 0
        }
        ,
        oo.prototype.invalidateVoxelsInAABB = function(e) {
            !function(e, t) {
                for (var i = e._coordsToChunkIndexes(t.base[0], t.base[1], t.base[2]), s = e._coordsToChunkIndexes(t.max[0], t.max[1], t.max[2]), r = 0; r < 3; r++)
                    Number.isFinite(t.base[r]) || (i[r] = t.base[r]),
                    Number.isFinite(t.max[r]) || (s[r] = t.max[r]);
                e._chunksKnown.forEach((t => {
                    var [r,n,a] = t;
                    r < i[0] || r >= s[0] || n < i[1] || n >= s[1] || a < i[2] || a >= s[2] || (e._chunksInvalidated.add(r, n, a),
                    e._chunksToRemove.remove(r, n, a),
                    e._chunksToRequest.remove(r, n, a),
                    e._chunksToMesh.remove(r, n, a),
                    e._chunksToMeshFirst.remove(r, n, a))
                }
                ))
            }(this, e)
        }
        ,
        oo.prototype.manuallyLoadChunk = function(e=0, t=0, i=0) {
            if (!this.manuallyControlChunkLoading)
                throw ho;
            var [s,r,n] = this._coordsToChunkIndexes(e, t, i);
            this._chunksKnown.add(s, r, n),
            this._chunksToRequest.add(s, r, n)
        }
        ,
        oo.prototype.manuallyUnloadChunk = function(e=0, t=0, i=0) {
            if (!this.manuallyControlChunkLoading)
                throw ho;
            var [s,r,n] = this._coordsToChunkIndexes(e, t, i);
            this._chunksToRemove.add(s, r, n),
            this._chunksToMesh.remove(s, r, n),
            this._chunksToRequest.remove(s, r, n),
            this._chunksToMeshFirst.remove(s, r, n)
        }
        ;
        var ho = "Set `noa.world.manuallyControlChunkLoading` if you need this API";
        function lo(e) {
            var [t,i,s] = e.noa.entities.getPosition(e.noa.playerEntity);
            return e._coordsToChunkIndexes(t, i, s)
        }
        oo.prototype.tick = function() {
            var e, t = performance.now(), [i,s,r] = lo(this), n = tn(i, s, r);
            n !== this._prevPlayerChunkHash && (this.emit("playerEnteredChunk", i, s, r),
            this._prevPlayerChunkHash = n,
            this._chunkAddSearchFrom = 0),
            this._prevWorldName !== this.noa.worldName && (this.manuallyControlChunkLoading || ((e = this)._chunksInvalidated.copyFrom(e._chunksKnown),
            e._chunksToRemove.empty(),
            e._chunksToRequest.empty(),
            e._chunksToMesh.empty(),
            e._chunksToMeshFirst.empty(),
            Eo(e, e._chunksInvalidated),
            this._chunkAddSearchFrom = 0,
            mo(this)),
            this._prevWorldName = this.noa.worldName),
            Ro("start"),
            Co("start"),
            this.manuallyControlChunkLoading || (function(e, t, i, s) {
                var r = e._remDistanceFn
                  , n = e._chunksToRemove
                  , a = n.count() + e._chunksInvalidated.count();
                if (!(a >= 50)) {
                    var o = e._chunksKnown.arr;
                    if (0 !== o.length) {
                        for (var h = Math.min(100, o.length / 10), l = !1, c = 0; c < h; c++) {
                            var [u,d,f] = o[fo++ % o.length];
                            if (!n.includes(u, d, f) && !r(u - t, d - i, f - s) && (e._chunksToRemove.add(u, d, f),
                            e._chunksToRequest.remove(u, d, f),
                            e._chunksToMesh.remove(u, d, f),
                            e._chunksToMeshFirst.remove(u, d, f),
                            l = !0,
                            ++a > 50))
                                break
                        }
                        fo %= o.length,
                        l && Eo(e, n, t, i, s)
                    }
                }
            }(this, i, s, r),
            Ro("remQueue"),
            function(e, t, i, s) {
                var r = e._chunksToRequest;
                if (!(r.count() >= 50)) {
                    var n = e.chunkSortingDistFn || Mo;
                    n !== e._prevSortingFn && (Eo(e, e._chunksSortedLocs, 0, 0, 0, !0),
                    e._prevSortingFn = n);
                    for (var a = e._chunksSortedLocs.arr, o = e._chunkAddSearchFrom, h = Math.min(20, a.length / 10), l = 0; l < h; l++) {
                        var [c,u,d] = a[o++ % a.length];
                        if (co(e, t, i, s, c, u, d),
                        r.count() >= 50)
                            break
                    }
                    e._chunksInvalidated.isEmpty() && (e._chunkAddSearchFrom = o % a.length),
                    Eo(e, r, t, i, s, !1)
                }
            }(this, i, s, r),
            Ro("addQueue")),
            function(e) {
                var t = e._chunksToMesh.count() + e._chunksToMeshFirst.count();
                if (!(t > 10)) {
                    for (var i = e._chunksKnown.arr, s = Math.min(50, i.length / 10), r = 0; r < s; r++) {
                        var [n,a,o] = i[_o++ % i.length]
                          , h = e._storage.getChunkByIndexes(n, a, o);
                        if (h && (vo(e, h) && t++,
                        t > 10))
                            break
                    }
                    _o %= i.length
                }
            }(this);
            var a = performance.now()
              , o = t + (this.maxProcessingPerTick || 0);
            a < o && (o = a + 1);
            for (var h = !1, l = !1, c = !1; a < o && (h || (h = mo(this) || mo(this),
            Ro("removes")),
            l || (l = po(this),
            Ro("requests")),
            c || (c = go(this, !1),
            Ro("meshes")),
            !(h && l && c)); )
                a = performance.now();
            var u = this._storage.getChunkByIndexes(i, s, r);
            this.playerChunkLoaded = !!u,
            Co("end", this),
            Ro("end")
        }
        ,
        oo.prototype.render = function() {
            for (var e = performance.now(), t = e + this.maxProcessingPerRender; e < t && !go(this, !0); )
                e = performance.now()
        }
        ,
        oo.prototype._getChunkByCoords = function(e=0, t=0, i=0) {
            var [s,r,n] = this._coordsToChunkIndexes(e, t, i);
            return this._storage.getChunkByIndexes(s, r, n)
        }
        ,
        oo.prototype._queueChunkForRemesh = function(e) {
            vo(this, e)
        }
        ;
        var co = (e, t, i, s, r, n, a) => {
            uo(e, t + r, i + n, s + a),
            r !== a && uo(e, t + a, i + n, s + r),
            r > 0 && co(e, t, i, s, -r, n, a),
            n > 0 && co(e, t, i, s, r, -n, a),
            a > 0 && co(e, t, i, s, r, n, -a)
        }
          , uo = (e, t, i, s) => {
            e._chunksKnown.includes(t, i, s) || (e._chunksKnown.add(t, i, s),
            e._chunksToRequest.add(t, i, s, !0))
        }
          , fo = 0
          , _o = 0;
        function po(e) {
            var t = e._chunksToRequest;
            if (t.isEmpty())
                return !0;
            var i = e._chunksPending.count()
              , s = e._chunksToMesh.count();
            if (i >= e.maxChunksPendingCreation)
                return !0;
            if (s >= e.maxChunksPendingMeshing)
                return !0;
            var [r,n,a] = t.pop();
            return function(e, t, i, s) {
                var r = e._chunkSize
                  , n = io._createVoxelArray(e._chunkSize)
                  , a = e.noa.worldName
                  , o = [t, i, s, a].join("|")
                  , h = t * r
                  , l = i * r
                  , c = s * r;
                e._chunksPending.add(t, i, s),
                e.emit("worldDataNeeded", o, n, h, l, c, a),
                Co("request")
            }(e, r, n, a),
            t.isEmpty()
        }
        function mo(e) {
            var t = e._chunksInvalidated;
            if (t.isEmpty() && (t = e._chunksToRemove),
            t.isEmpty())
                return !0;
            var [i,s,r] = t.pop();
            return function(e, t, i, s) {
                var r = e._storage.getChunkByIndexes(t, i, s);
                r && (e.emit("chunkBeingRemoved", r.requestID, r.voxels, r.userData),
                e.noa.rendering.disposeChunkForRendering(r),
                r.dispose(),
                Co("dispose"),
                So(e, t, i, s, null)),
                e._storage.removeChunkByIndexes(t, i, s),
                e._chunksKnown.remove(t, i, s),
                e._chunksToMesh.remove(t, i, s),
                e._chunksToRemove.remove(t, i, s),
                e._chunksToMeshFirst.remove(t, i, s)
            }(e, i, s, r),
            t.isEmpty()
        }
        function go(e, t) {
            var i = e._chunksToMeshFirst;
            if (i.isEmpty() && !t && (i = e._chunksToMesh),
            i.isEmpty())
                return !0;
            var [s,r,n] = i.pop();
            if (!e._chunksToRemove.includes(s, r, n)) {
                var a = e._storage.getChunkByIndexes(s, r, n);
                a && function(e, t) {
                    e._chunksToMesh.remove(t.i, t.j, t.k),
                    e._chunksToMeshFirst.remove(t.i, t.j, t.k),
                    t.updateMeshes(),
                    Co("mesh")
                }(e, a)
            }
        }
        function vo(e, t) {
            if (!t._terrainDirty && !t._objectsDirty)
                return !1;
            if (t._neighborCount < t.minNeighborsToMesh)
                return !1;
            if (e._chunksToMesh.includes(t.i, t.j, t.k))
                return !1;
            if (e._chunksToMeshFirst.includes(t.i, t.j, t.k))
                return !1;
            var i = 26 === t._neighborCount ? e._chunksToMeshFirst : e._chunksToMesh;
            return i.add(t.i, t.j, t.k),
            e._sortMeshQueueEvery++,
            e._sortMeshQueueEvery > 20 && (Eo(e, i),
            e._sortMeshQueueEvery = 0),
            !0
        }
        function yo(e, t, i) {
            var s = this._chunkSize;
            return [0 | Math.floor(e / s), 0 | Math.floor(t / s), 0 | Math.floor(i / s)]
        }
        function bo(e, t, i) {
            var s = this._chunkSize
              , r = e % s | 0;
            r < 0 && (r += s);
            var n = t % s | 0;
            n < 0 && (n += s);
            var a = i % s | 0;
            return a < 0 && (a += s),
            [r, n, a]
        }
        function xo(e, t, i) {
            var s = this._coordShiftBits;
            return [e >> s, t >> s, i >> s]
        }
        function To(e, t, i) {
            var s = this._coordMask;
            return [e & s, t & s, i & s]
        }
        function Eo(e, t, i, s, r, n=!1) {
            var a = e.chunkSortingDistFn || Mo;
            void 0 === i && ([i,s,r] = lo(e)),
            t.sortByDistance(( (e, t, n) => a(i - e, s - t, r - n)), n)
        }
        var Mo = (e, t, i) => e * e + t * t + i * i;
        function So(e, t, i, s, r) {
            for (var n = !r || r && !r.isEmpty, a = -1; a <= 1; a++)
                for (var o = -1; o <= 1; o++)
                    for (var h = -1; h <= 1; h++)
                        if (a | o | h) {
                            var l = e._storage.getChunkByIndexes(t + a, i + o, s + h);
                            if (l) {
                                n && (l._terrainDirty = !0),
                                r && !r._neighbors.get(a, o, h) && (r._neighborCount++,
                                r._neighbors.set(a, o, h, l));
                                var c = l._neighbors.get(-a, -o, -h);
                                r && !c && (l._neighborCount++,
                                l._neighbors.set(-a, -o, -h, r),
                                26 === l._neighborCount && vo(e, l)),
                                !r && c && (l._neighborCount--,
                                l._neighbors.set(-a, -o, -h, null))
                            }
                        }
        }
        function Ao(e, t) {
            var i = e * e
              , s = t * t;
            return e === t ? (e, t, s) => e * e + t * t + s * s <= i : e > t ? (e, s, r) => !(Math.abs(s) > t) && e * e + s * s + r * r <= i : (e, t, r) => {
                var n = e * e + r * r;
                return !(n > i) && n + t * t <= s
            }
        }
        function Io(e, t, i, s) {
            var r = 0
              , n = 0
              , a = 0
              , o = 0
              , h = [];
            i.forEach((t => {
                var i = e._storage.getChunkByIndexes(t[0], t[1], t[2]);
                i && (a++,
                h.push(i._timesMeshed),
                i._isFull && r++,
                i._isEmpty && n++,
                26 === i._neighborCount && o++)
            }
            ));
            var l = i.length.toString().padEnd(8);
            if (l += ("exist: " + a).padEnd(12),
            l += ("full: " + r).padEnd(12),
            l += ("empty: " + n).padEnd(12),
            l += ("surr: " + o).padEnd(12),
            s) {
                var c = h.reduce(( (e, t) => e + t), 0)
                  , u = h.reduce(( (e, t) => Math.max(e, t)), 0)
                  , d = h.reduce(( (e, t) => Math.min(e, t)), 0);
                l += "times meshed: avg " + (c / a).toFixed(2),
                l += "  max " + u,
                l += "  min " + d
            }
            console.log(t, l)
        }
        oo.prototype.report = function() {
            console.log("World report - playerChunkLoaded: ", this.playerChunkLoaded),
            Io(this, "  known:     ", this._chunksKnown.arr, !0),
            Io(this, "  to request:", this._chunksToRequest.arr, 0),
            Io(this, "  to remove: ", this._chunksToRemove.arr, 0),
            Io(this, "  invalid:   ", this._chunksInvalidated.arr, 0),
            Io(this, "  creating:  ", this._chunksPending.arr, 0),
            Io(this, "  to mesh:   ", this._chunksToMesh.arr, 0),
            Io(this, "  mesh 1st:  ", this._chunksToMeshFirst.arr, 0)
        }
        ;
        var Ro = function(e, t="", i) {
            if (!(e > 0))
                return () => {}
                ;
            var s = {}
              , r = 0
              , n = 0
              , a = 0
              , o = 0;
            return h => {
                var l, c;
                "start" === h ? (r = n = performance.now(),
                a++) : "end" === h ? ( () => {
                    if (o += performance.now() - r,
                    !(a < e)) {
                        var n = `${t}: ${(o / e).toFixed(2)}ms  --  `;
                        n += Object.keys(s).map((e => i && s[e] / o < .05 ? "" : `${e}: ${(s[e] / a).toFixed(2)}ms`)).join("  "),
                        console.log(n + `    (avg over ${e} runs)`),
                        s = {},
                        a = o = 0
                    }
                }
                )() : (l = h,
                c = performance.now(),
                s[l] = (s[l] || 0) + (c - n),
                n = c)
            }
        }(0, "world ticks:", 1)
          , Co = () => {}
          , Po = {
            debug: !1,
            silent: !1,
            silentBabylon: !1,
            playerHeight: 1.8,
            playerWidth: .6,
            playerStart: [0, 10, 0],
            playerAutoStep: !1,
            playerShadowComponent: !0,
            tickRate: 30,
            maxRenderRate: 0,
            blockTestDistance: 10,
            stickyPointerLock: !0,
            dragCameraOutsidePointerLock: !0,
            stickyFullscreen: !1,
            skipDefaultHighlighting: !1,
            originRebaseDistance: 25
        };
        class Do extends e.EventEmitter {
            constructor(e={}) {
                if (super(),
                e = Object.assign({}, Po, e),
                this.version = "0.33.0",
                !e.silent) {
                    var t = e.debug ? " (debug)" : "";
                    console.log(`noa-engine v${this.version}${t}`)
                }
                this._paused = !1,
                this._originRebaseDistance = e.originRebaseDistance,
                this.worldOriginOffset = [0, 0, 0],
                this.positionInCurrentTick = 0,
                this.worldName = "default",
                this.timeScale = 1,
                this.container = new I(this,e),
                this.tickRate = this.container._shell.tickRate,
                Object.defineProperty(this, "tickRate", {
                    get: () => this.container._shell.tickRate
                }),
                this.maxRenderRate = this.container._shell.maxRenderRate,
                Object.defineProperty(this, "maxRenderRate", {
                    get: () => this.container._shell.maxRenderRate,
                    set: e => {
                        this.container._shell.maxRenderRate = e || 0
                    }
                }),
                this.inputs = new E(this,e,this.container.element),
                this.registry = new Nn(this,e),
                this.world = new oo(this,e);
                var i = console.log;
                e.silentBabylon && (console.log = () => {}
                ),
                this.rendering = new Ia(this,e,this.container.canvas),
                e.silentBabylon && (console.log = i),
                this.physics = new to(this,e),
                this.entities = new Qr(this,e),
                this.ents = this.entities;
                var s = this.entities;
                this.playerEntity = s.add(e.playerStart, e.playerWidth, e.playerHeight, null, null, !0, e.playerShadowComponent),
                s.addComponent(this.playerEntity, s.names.collideTerrain),
                s.addComponent(this.playerEntity, s.names.collideEntities);
                var n = s.getPhysics(this.playerEntity).body;
                if (n.gravityMultiplier = 2,
                n.autoStep = e.playerAutoStep,
                s.addComponent(this.playerEntity, s.names.receivesInputs),
                s.addComponent(this.playerEntity, s.names.fadeOnZoom),
                s.addComponent(this.playerEntity, s.names.movement, {
                    airJumps: 1
                }),
                this.camera = new k(this,e),
                this.blockTestDistance = e.blockTestDistance,
                this.blockTargetIdCheck = this.registry.getBlockSolidity,
                this.targetedBlock = null,
                e.skipDefaultHighlighting || (this.defaultBlockHighlightFunction = e => {
                    e ? this.rendering.highlightBlockFace(!0, e.position, e.normal) : this.rendering.highlightBlockFace(!1)
                }
                ,
                this.on("targetBlockChanged", this.defaultBlockHighlightFunction)),
                this._terrainMesher = new In(this),
                this._objectMesher = new nn(this),
                this._targetedBlockDat = {
                    blockID: 0,
                    position: r().create(),
                    normal: r().create(),
                    adjacent: r().create()
                },
                this._prevTargetHash = 0,
                this._pickPos = r().create(),
                this._pickResult = {
                    _localPosition: r().create(),
                    position: [0, 0, 0],
                    normal: [0, 0, 0]
                },
                e.debug) {
                    this.vec3 = r(),
                    this.ndarray = a(),
                    s.getMovement(1).airJumps = 999;
                    var o = window;
                    o.noa = this,
                    o.vec3 = r(),
                    o.ndarray = a(),
                    o.scene = this.rendering.scene
                }
                !function(e) {
                    var t = "0.27"
                      , i = (e, i, s) => {
                        var r = () => {
                            throw `This property changed in ${t} - ${s}`
                        }
                        ;
                        Object.defineProperty(e, i, {
                            get: r,
                            set: r
                        })
                    }
                    ;
                    i(e, "getPlayerEyePosition", "to get the camera/player offset see API docs for `noa.camera.cameraTarget`"),
                    i(e, "setPlayerEyePosition", "to set the camera/player offset see API docs for `noa.camera.cameraTarget`"),
                    i(e, "getPlayerPosition", "use `noa.ents.getPosition(noa.playerEntity)` or similar"),
                    i(e, "getCameraVector", "use `noa.camera.getDirection`"),
                    i(e, "getPlayerMesh", "use `noa.ents.getMeshData(noa.playerEntity).mesh` or similar"),
                    i(e, "playerBody", "use `noa.ents.getPhysicsBody(noa.playerEntity)`"),
                    i(e.rendering, "zoomDistance", "use `noa.camera.zoomDistance`"),
                    i(e.rendering, "_currentZoom", "use `noa.camera.currentZoom`"),
                    i(e.rendering, "_cameraZoomSpeed", "use `noa.camera.zoomSpeed`"),
                    i(e.rendering, "getCameraVector", "use `noa.camera.getDirection`"),
                    i(e.rendering, "getCameraPosition", "use `noa.camera.getLocalPosition`"),
                    i(e.rendering, "getCameraRotation", "use `noa.camera.heading` and `noa.camera.pitch`"),
                    i(e.rendering, "setCameraRotation", "to customize camera behavior see API docs for `noa.camera`"),
                    t = "0.28",
                    i(e.rendering, "makeMeshInstance", "removed, use Babylon's `mesh.createInstance`"),
                    i(e.world, "_maxChunksPendingCreation", 'use `maxChunksPendingCreation` (no "_")'),
                    i(e.world, "_maxChunksPendingMeshing", 'use `maxChunksPendingMeshing` (no "_")'),
                    i(e.world, "_maxProcessingPerTick", 'use `maxProcessingPerTick` (no "_")'),
                    i(e.world, "_maxProcessingPerRender", 'use `maxProcessingPerRender` (no "_")'),
                    t = "0.29",
                    i(e, "_constants", "removed, voxel IDs are no longer packed with bit flags"),
                    t = "0.30",
                    i(e, "_tickRate", "tickRate is now at `noa.tickRate`"),
                    i(e.container, "_tickRate", "tickRate is now at `noa.tickRate`"),
                    t = "0.31",
                    i(e.world, "chunkSize", "effectively an internal, so changed to `_chunkSize`"),
                    i(e.world, "chunkAddDistance", "set this with `noa.world.setAddRemoveDistance`"),
                    i(e.world, "chunkRemoveDistance", "set this with `noa.world.setAddRemoveDistance`"),
                    t = "0.33",
                    i(e.rendering, "postMaterialCreationHook", "Removed - use mesh post-creation hook instead`")
                }(this)
            }
            tick(e) {
                if (e *= this.timeScale || 1,
                this._paused)
                    this.world.worldGenWhilePaused && this.world.tick();
                else if (wo("start"),
                function(e) {
                    var t = e.ents.getPositionData(e.playerEntity)._localPosition
                      , i = e._originRebaseDistance;
                    if (!(r().sqrLen(t) < i * i)) {
                        for (var s = [], n = 0; n < 3; n++)
                            s[n] = Math.floor(t[n]),
                            e.worldOriginOffset[n] += s[n];
                        e.rendering._rebaseOrigin(s),
                        e.entities._rebaseOrigin(s),
                        e._objectMesher._rebaseOrigin(s)
                    }
                }(this),
                this.world.tick(),
                wo("world"),
                this.world.playerChunkLoaded) {
                    this.physics.tick(e),
                    wo("physics"),
                    this._objectMesher.tick(),
                    this.rendering.tick(e),
                    wo("rendering"),
                    function(e) {
                        var t = 0
                          , i = e.blockTargetIdCheck || e.registry.getBlockSolidity
                          , s = e._localPick(null, null, null, i);
                        if (s) {
                            var n = e._targetedBlockDat;
                            r().floor(n.adjacent, s.position),
                            r().copy(n.normal, s.normal),
                            r().subtract(n.position, n.adjacent, n.normal),
                            n.blockID = e.world.getBlockID(n.position[0], n.position[1], n.position[2]),
                            e.targetedBlock = n;
                            var a = n.position
                              , o = n.normal
                              , h = tn(a[0] + n.blockID, a[1], a[2]);
                            t = h ^= tn(o[0], o[1] + n.blockID, o[2])
                        } else
                            e.targetedBlock = null;
                        t != e._prevTargetHash && (e.emit("targetBlockChanged", e.targetedBlock),
                        e._prevTargetHash = t)
                    }(this),
                    wo("targets"),
                    this.entities.tick(e),
                    wo("entities"),
                    this.emit("tick", e),
                    wo("tick event"),
                    wo("end");
                    var t = this.inputs.pointerState;
                    t.scrollx = t.scrolly = t.scrollz = 0
                } else
                    this.rendering.tick(e)
            }
            render(e, t) {
                e *= this.timeScale || 1,
                this.positionInCurrentTick = t,
                this._paused ? this.world.worldGenWhilePaused && this.world.render() : (Fo("start"),
                this.camera.applyInputsToCamera(),
                Fo("init"),
                this.world.render(),
                Fo("meshing"),
                this.camera.updateBeforeEntityRenderSystems(),
                this.entities.render(e),
                this.camera.updateAfterEntityRenderSystems(),
                Fo("entities"),
                this.emit("beforeRender", e),
                Fo("before render"),
                this.rendering.render(),
                this.rendering.postRender(),
                Fo("render"),
                this.emit("afterRender", e),
                Fo("after render"),
                Fo("end"),
                this.inputs.pointerState.dx = this.inputs.pointerState.dy = 0)
            }
            setPaused(e=!1) {
                this._paused = !!e,
                e || (this.inputs.pointerState.dx = this.inputs.pointerState.dy = 0)
            }
            getBlock(e, t=0, i=0) {
                return e.length ? this.world.getBlockID(e[0], e[1], e[2]) : this.world.getBlockID(e, t, i)
            }
            setBlock(e, t, i=0, s=0) {
                return t.length ? this.world.setBlockID(e, t[0], t[1], t[2]) : this.world.setBlockID(e, t, i, s)
            }
            addBlock(e, t, i=0, s=0) {
                if (t.length) {
                    if (this.entities.isTerrainBlocked(t[0], t[1], t[2]))
                        return;
                    return this.world.setBlockID(e, t[0], t[1], t[2]),
                    e
                }
                if (!this.entities.isTerrainBlocked(t, i, s))
                    return this.world.setBlockID(e, t, i, s),
                    e
            }
            globalToLocal(e, t, i) {
                var s = this.worldOriginOffset;
                if (t) {
                    for (var n = 0; n < 3; n++) {
                        var a = e[n] - s[n];
                        a += t[n],
                        i[n] = a
                    }
                    return i
                }
                return r().subtract(i, e, s)
            }
            localToGlobal(e, t, i=null) {
                var s = this.worldOriginOffset;
                if (i) {
                    for (var n = 0; n < 3; n++) {
                        var a = Math.floor(e[n]);
                        t[n] = a + s[n],
                        i[n] = e[n] - a
                    }
                    return t
                }
                return r().add(t, e, s)
            }
            pick(e=null, t=null, i=-1, s=null) {
                if (0 === i)
                    return null;
                var r = this._pickPos;
                return e && (this.globalToLocal(e, null, r),
                e = r),
                this._localPick(e, t, i, s)
            }
            _localPick(e=null, t=null, i=-1, s=null) {
                if (0 === i)
                    return null;
                var n = s || this.registry.getBlockSolidity
                  , a = this.world
                  , o = this.worldOriginOffset;
                e || (e = this.camera._localGetTargetPosition()),
                t = t || this.camera.getDirection(),
                (i = i || -1) < 0 && (i = this.blockTestDistance);
                var l = this._pickResult
                  , c = l._localPosition
                  , u = l.normal;
                return h()((function(e, t, i) {
                    var s = a.getBlockID(e + o[0], t + o[1], i + o[2]);
                    return n(s)
                }
                ), e, t, i, c, u) ? (r().scaleAndAdd(c, c, u, .01),
                this.localToGlobal(c, l.position),
                l) : null
            }
        }
        var wo = () => {}
          , Fo = () => {}
        ;
  window.NoaEngine=Do;
  _init();
    }
    )()
}
)();
function dataURLToBlob(dataURL) {
    const byteString = atob(dataURL.split(',')[1]);
    const mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
    const ab = new ArrayBuffer(byteString.length);
    const ia = new Uint8Array(ab);
    for (let i = 0; i < byteString.length; i++) {
        ia[i] = byteString.charCodeAt(i);
    }
    return new Blob([ab], { type: mimeString });
}
function _init(){
    const blob = dataURLToBlob($textures$[0]);
    const fileURL = URL.createObjectURL(blob);

    const noa = new NoaEngine({  // Anzeigeoptionen
  showFPS: true,

  // Eingabeverhalten
  pointerLock: true,
  inverseY: false,
  blockTestDistance: 8,

  // Weltkonfiguration
  chunkSize: 32,
  chunkAddDistance: 4,
  chunkRemoveDistance: 4.5,

  // Rendering
  texturePath: '',
  maxCameraZoom: 15,

  // Spieler-Einstellungen
  playerStart: [1.5, 15, 1.5],
  playerHeight: 2,
  playerWidth: 0.7,
  playerAutoStep: true,});

noa.rendering.camera.fov=1.9;

window.noa=noa;
// Base64-Textur (Meerschweinchen)
// Base64-Textur (Meerschweinchen) - Ersetze YOUR_BASE64_HERE durch deinen Base64-String
var grassT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAPUlEQVQoFWNIX+j7P39d8H8QjQ0zgCRhGKsCgiZg04UsxoDMgbGR3YShAOYemCIMBSBTYJIgNlYFMKtANABKYZYPlInzUQAAAABJRU5ErkJggg=="
var dirtT = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAAXNSR0IArs4c6QAAAD9JREFUGJVjbIxw+8/Lw8HAwMDA8PnLDwZ0wASTZGBgYEBmwxVgiKArQDYWmxUs2CSQ3YRhBbqbCLsBXQDdTQDFuxcPiAREygAAAABJRU5ErkJggg=="




// Engine-Instanz (angenommen, sie heit 'noa')
// var noa = new NOA.Engine(opts);

// Deine Base64 Data-URL

// Registriere das Material
// Der erste Parameter ist ein Name fr das Material (frei whlbar)
// Der zweite Parameter ist ein Options-Objekt
const materialName = 'dirt';
noa.registry.registerMaterial(materialName, { textureURL: dirtT });

noa.registry.registerMaterial("grass", { textureURL: grassT });
// Wenn deine Textur Teil eines Atlas ist (eine vertikale Bildleiste),
// und du nur einen bestimmten Bereich davon nutzen mchtest,
// kannst du zustzlich atlasIndex angeben:
// noa.registry.registerMaterial('meinAtlasMaterial', {
//   textureURL: 'data:image/png;base64,...dein_atlas_base64...',
//   atlasIndex: 0 // Der Index des Bildes im Atlas (beginnend bei 0)
// });

// ID fr den neuen Block (muss eine positive Ganzzahl sein, die noch nicht verwendet wird)
const newBlockID = 101; // Whle eine ID, die noch nicht von noa.js oder anderen Blcken belegt ist.

// Definiere die Eigenschaften des Blocks
const blockProperties = {
    // material: materialName // Der Name des Materials, das du oben registriert hast
    // Du kannst hier auch mehrere Materialien fr verschiedene Seiten angeben:
    // material: ['topMaterial', 'bottomMaterial', 'sideMaterial']
    // oder
 material: [
     'dirt',
     'dirt',
     'grass',
    'dirt',
    'dirt',
     'dirt'
]
    // Weitere Blockeigenschaften wie Undurchsichtigkeit, Festigkeit etc.
    // opaque: true,
    // solid: true,
};

// Registriere den Block
noa.registry.registerBlock(newBlockID, blockProperties);

// Jetzt kannst du Blcke dieses Typs in der Welt setzen:
// noa.setBlock(newBlockID, x, y, z);






// Block platzieren

// Debugging

grassID=101;

  // Welt generieren
  noa.world.on('worldDataNeeded', (id, data, x, y, z) => {
      console.log(data);
    for (let i = 0; i < data.shape[0]; i++) {
      for (let k = 0; k < data.shape[2]; k++) {
        data.set(i, 0, k, grassID)
      }
    }
            console.log(id,data);

    noa.world.setChunkData(id, data)
  })

  // Abbauen
  window.addEventListener('mousedown', (e) => {
    console.log(e)
    if(e.button==0){
    const block = noa.targetedBlock
    if (block) noa.setBlock(0, block.position)
    }
    if(e.button==2){
        console.log(
        "Spielerposition: ",Array.from(noa.entities.getState(noa.playerEntity,"position").position),
        "\n Blockposition: ",Array.from(noa.targetedBlock.adjacent)
    )
        var blockPos = noa.targetedBlock.adjacent;
noa.setBlock(101,blockPos[0],blockPos[1],blockPos[2]);
    }
  })

    const block = noa.targetedBlock
    if (block) noa.setBlock(grassID, block.adjacent)

    const base64String = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAIxUExURUgwH0owIFI0JFAzI00xIEcvH0EsHEowIUMrHEguHlQ2I00zITsnGUAqGj8qHEUtHkEqGzsnGkQrHUIrHEQsHkMsHkEpGzwoGj4qGz0nGT8oGkArG0UsHUkwH0kvIE0yIkoxIEcuHkMqHEErHUApG0AqHEQrHkcvHj4oGjwnGkMrHTknGTYjFzklGTwoGUIqHUQsHT8qG0ErHEArHD8pGkYuHkkvH0cuH1I1IjYkFzQiFjglGDsmGTgmGD0oGjclGDUjFzgmGT4oG0wxIE8yIUYuH0gwIEAqGzQhFjQjFjonGUMsHEQrHD0oGzomGTQjFzwpGkIqGz0pGkguH0EqHEUuHkUsHDkmGTsoGT8pGzUkFzsoGkMsHUIrHTEhFTwmGUUtHTckGDolGEYvHk4yIU4zIjwnGT0oGU8zIUgvHkgvH0gvHT4pGlU4JFE1I0kxIEsxIFM1JE0yIU4yIE80IVQ2JVEzIksxIU8zIk0xITgkGEcvIEQsHE0xI0swH0wxIUUsHjklGEUuHUYsHkIrHjslGTIhFTckF0kvHjkmGDglFz4pG0YtHUMqGzooGTMiFjIiFkYuHTomGkoxH0wyIUkwIFA0IUQtHkUrHEErGzslGEwwIDomGEQtHTcjF1EzIz4nGlI0I0wwIT0nGkwyIFQ1Iz8qGk4yIkcsHkctHkIsHjIiF0AoGj8rG1I1JDAgFUgvIDUiF0ovIFAzIj8oGzsmGEUuH0ovHzwmGDglGT4qGu2UlbUAAAAJcEhZcwAADr8AAA6/ATgFUyQAAAPgSURBVDhPDdCLQxplAADw78o7zyCPhw6FEzjk5iFk30GHsYPTOE/0ZDf5QAQ8gnCgI9rQHjBZgfaas7Zl1spZtt7r3VrPv679/oQfANhjj/fhOIH1kwNPGPqNTw5SJrPFOjQ0fMY2Mmp3AHrM6cLcLsYz7mXPTnB2Hztp8geemnoah3wwyIbAM0I47J52PuuNnBPFaEwymrwzs4HnQnBAsJhM8QjgSHlOUeYTvoVFNbSUDHLntQvacgqlnSSxlBAXgMZlVrKepF2MrOYgJAbyBXHNyjv0ou7R4WDgeZCLmH2lqCkmIRIKEJbZFyrrQiqJh6ACL1Z1G6gpFmJDm4lasE2MvuQOE2ymDh0TJEEr2RerVQrIA7Ieaqij9ZcuzwtXmlvbXgudTqc9enoerL/8yjZ49bUWThDI0tc2CCn3fPsq2hlMK50kxK9h9a3X3wBXu3j2mlD09kZIZQwwQbS7EAsRHvd8dq/e3w4HASxnJ+gyW4oWRPTmW2+/U3jX10iGEVyi6fJ1hq+ABst0E2pFDCwu+uJxTcutsd5hQUWWViJ/He6LgIv2UjcCZyTN6i+IBxA63rOWeHskInE+n0DZ3gdItXtXb9axEMsmahsdvbpJ7Bntt25HUyP8B80rGOAGfYfLiJQN0BRCCFa3upsyJs4WYiSBkP7hCtCWI6s2q2Bo5akGX0tl5Wp3jrwxYyMlCY08ugdJqqFt0K2jIYsyMe2AzSYmCFNxNs+oUY6GLAFa+HkbL38Ei3S7+XEyjGUdKV7l43c6kkPBMPgJYO2SZP/Ufjwl4N27NMHnanmOsJ0keKRUx8gJHthOxFLMWKlUGp91KLaDJ6caHbzyea6GnbYHBDIH8mhG/KJHBWPGfNGj0p1quUakuBNR3d6692U9y4PdyIJKQ6ec+Srm272dc359z2qOFQqF46WLp+1vGAJwfIL/dhhO0/lY42RnNlkfOoyWrDoyavb+776HZgAoSmhwBCYzk+D+D6s/7vh/orpyOG9N7Gt+uzUDDNjRHfho8NL4z/gv/WLk1xiqnrpdfWxeLUSKSTf4bT04xCTr3eHQSsvQvRb9HfHh1lxTkVwPpNLdP44ADRMZ5iEjnO3Vne05974IIdRlheDlJu/tnrZBXhp9yEX+zHhpmCbwv45tAkkIskMiikU1VpTrYMbfyNe0GkqYMzq/Hyis8Yj/O1uUOuvCzVv+sg58LD+l1ho2znxQEnf+4ayr/64VQ0pzZQ+yxgv7ByDOo7DbDWtopQwp6n66l1j/Tw87nQ/CYcgunuMBu3nZ1Wy7EDU4yRhaXUOrZ06oTHPOVRWY8UMt9z/y1Q0A9oKoBAAAAABJRU5ErkJggg=='; // dein Bild hier

const img = new Image()
img.src = base64String

img.onload = () => {
    // Jetzt ist das Bild geladen, wir knnen es registrieren
    const tileName = 'custom_tile'

    // Fge es dem Textur-Atlas hinzu
    noa.registry.registerMaterial(tileName, {
        texture: img
    })

    // Registriere den Block mit dieser Textur
    const customBlockId = noa.registry.registerBlock(100, {
        solid: true,
        opaque: true,
        texture: tileName
    })

    // Platziere den Block in der Welt (z.B. bei 0, 10, 0)
    noa.setBlock(customBlockId, -24, 1, 125)
}

};
(() => {
  const cross = document.createElement('div');
  cross.id = 'crosshair';
  document.body.appendChild(cross);

  Object.assign(cross.style, {
    position: 'fixed',
    top: '50%',
    left: '50%',
    width: '20px',
    height: '20px',
    transform: 'translate(-50%, -50%)',
    pointerEvents: 'none',
    zIndex: 999999,
    mixBlendMode: 'difference'
  });

  cross.innerHTML = `
    <div style="position:absolute;top:0;left:9px;width:2px;height:20px;background:white;"></div>
    <div style="position:absolute;top:9px;left:0;width:20px;height:2px;background:white;"></div>
  `;
})();



</script>
</head>
<style>
    
</style>
